<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"sniffer.site","root":"/","images":"/images","scheme":"Gemini","version":"8.7.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"1POSCBVZ02","apiKey":"bf09f0197d475fa69488099407011316","indexName":"getstarted_actors","hits":{"per_page":10}}}</script><script src="/js/config.js"></script>
<meta name="description" content="最近抽空学习下Linux网络协议栈, 读源码时总会前一天梳理完, 等两天再来看却发现又忘记的差不多, 只能又过一遍, 前后理几遍才完全的把整个逻辑弄清楚. 于是有时间想着要把看过的代码逻辑整理下来, 算是对这段时间学习的总结, 也方便后面的查阅.  在之前的一篇有关网络协议的文章从NAPI说一说Linux内核数据的接收流程简单的讲到了Linux的数据接收流程, 但主要是集中在数据链路层与设备驱动之">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux网络协议之数据发送流程">
<meta property="og:url" content="https://sniffer.site/2021/04/08/Linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="JasonWang&#39;s Blog">
<meta property="og:description" content="最近抽空学习下Linux网络协议栈, 读源码时总会前一天梳理完, 等两天再来看却发现又忘记的差不多, 只能又过一遍, 前后理几遍才完全的把整个逻辑弄清楚. 于是有时间想着要把看过的代码逻辑整理下来, 算是对这段时间学习的总结, 也方便后面的查阅.  在之前的一篇有关网络协议的文章从NAPI说一说Linux内核数据的接收流程简单的讲到了Linux的数据接收流程, 但主要是集中在数据链路层与设备驱动之">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/linux_network_stack_flow.png">
<meta property="og:image" content="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/network_stack_tcp_flow.png">
<meta property="og:image" content="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/network_stack_ip_flow.png">
<meta property="article:published_time" content="2021-04-08T08:20:29.000Z">
<meta property="article:modified_time" content="2021-09-17T02:19:00.440Z">
<meta property="article:author" content="Jason Wang">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="TCP&#x2F;IP">
<meta property="article:tag" content="网络协议栈">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/linux_network_stack_flow.png">


<link rel="canonical" href="https://sniffer.site/2021/04/08/Linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://sniffer.site/2021/04/08/Linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B/","path":"2021/04/08/Linux网络协议之数据发送流程/","title":"Linux网络协议之数据发送流程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Linux网络协议之数据发送流程 | JasonWang's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">JasonWang's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">本色做人，角色做事</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.</span> <span class="nav-text">内核协议栈的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">数据发送流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E4%BC%A0%E8%BE%93%E5%B1%82%E6%B5%81%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">TCP传输层流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%AF%BB%E5%9D%80"><span class="nav-number">2.2.</span> <span class="nav-text">IP网络层数据路由与寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%E7%9A%84%E6%97%85%E7%A8%8B-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97QoS%E4%B8%8E%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="nav-number">2.3.</span> <span class="nav-text">最后的旅程: 优先级队列QoS与软中断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-number">3.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jason Wang"
      src="/images/gallaxy.jpg">
  <p class="site-author-name" itemprop="name">Jason Wang</p>
  <div class="site-description" itemprop="description">关于编程,生活,工作</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">175</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/runningforlife" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;runningforlife" rel="noopener" target="_blank">GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/u/2573460570" title="微博 → http:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;2573460570" rel="noopener" target="_blank">微博</a>
      </span>
  </div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/runningforlife" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sniffer.site/2021/04/08/Linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gallaxy.jpg">
      <meta itemprop="name" content="Jason Wang">
      <meta itemprop="description" content="关于编程,生活,工作">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JasonWang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux网络协议之数据发送流程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-08 16:20:29" itemprop="dateCreated datePublished" datetime="2021-04-08T16:20:29+08:00">2021-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">网络协议</span></a>
        </span>
    </span>

  
    <span id="/2021/04/08/Linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="Linux网络协议之数据发送流程" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>最近抽空学习下Linux网络协议栈, 读源码时总会前一天梳理完, 等两天再来看却发现又忘记的差不多, 只能又过一遍, 前后理几遍才完全的把整个逻辑弄清楚. 于是有时间想着要把看过的代码逻辑整理下来, 算是对这段时间学习的总结, 也方便后面的查阅. </p>
<p>在之前的一篇有关网络协议的文章<a href="http://sniffer.site/2020/05/12/%E4%BB%8ENAPI%E8%AF%B4%E4%B8%80%E8%AF%B4Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/">从NAPI说一说Linux内核数据的接收流程</a>简单的讲到了Linux的数据接收流程, 但主要是集中在数据链路层与设备驱动之间的交互, 并没有涉及到IP网络层以及TCP传输层的逻辑.这篇文章, 着重看下数据的发送流程, 并梳理下Linux协议栈大致的结构与初始化流程, 主要分为如下两个部分:</p>
<ul>
<li>Linux内核协议栈的初始化流程</li>
<li>数据是如何从TCP传输层发送到设备驱动的</li>
</ul>
<span id="more"></span>

<blockquote>
<p>本文基于Linux 4.14版本的ipv4, 没有关注ipv6部分的实现</p>
</blockquote>
<h2 id="内核协议栈的初始化"><a href="#内核协议栈的初始化" class="headerlink" title="内核协议栈的初始化"></a><strong>内核协议栈的初始化</strong></h2><p>Linux内核的初始化的逻辑都放在了<code>af_inet.c</code>(<code>kernel/net/ipv4</code>)这个文件, 系统启动的时候, 会调用初始化的函数<code>inet_init</code>, 由这个函数负责注册socket层的接口,初始化TCP/IP层以及注册IP层与数据链路层的接口.</p>
<ul>
<li><code>proto_register</code>注册TCP/UDP/ICMP相关的协议, 并分配相应的slab空间； 这些传输层协议负责与socket层进行交互, 比如用户写入到socket数据后会发送到这些协议; 并接收来自网络层的数据后将数据写入到用户空间的缓冲区</li>
<li><code>sock_register</code>注册接口用于创建socket对象</li>
<li>接着把通过<code>inet_add_protocol</code>把传输层的各个协议如TCP/UDP/ICMP等的接口注册到网络层, 这样网络层数据回来之后就可以通过这些注册的回调接口进行处理, 并将数据写到对应应用的socket缓冲区</li>
<li><code>inet_register_protosw</code>注册socket层的接口, linux内核提供了三种形式的<code>SOCK_STREAM</code>/<code>SOCK_DGRAM</code>/<code>SOCK_RAW</code> socket, 一般来说TCP使用的是<code>SOCK_STREAM</code>字节流形式的socket, 而UDP/ICMP使用的是<code>SOCK_DGRAM</code>数据报文形式的socket</li>
<li><code>xxx_init</code>函数会依次初始化ARP/IP/TCP等各个模块, 为其分配相应的slab内存空间</li>
<li>最后<code>dev_add_pack</code>向链路层添加一个数据接收的接口<code>ip_packet_type</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// af_inet.c</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">inet_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">q</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">r</span>;</span></span><br><span class="line">    <span class="keyword">int</span> rc = -EINVAL;</span><br><span class="line"></span><br><span class="line">    sock_skb_cb_check_size(<span class="keyword">sizeof</span>(struct inet_skb_parm));</span><br><span class="line"></span><br><span class="line">    rc = proto_register(&amp;tcp_prot, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc)</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    rc = proto_register(&amp;udp_prot, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc)</span><br><span class="line">      <span class="keyword">goto</span> out_unregister_tcp_proto;</span><br><span class="line"></span><br><span class="line">    rc = proto_register(&amp;raw_prot, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc)</span><br><span class="line">      <span class="keyword">goto</span> out_unregister_udp_proto;</span><br><span class="line"></span><br><span class="line">    rc = proto_register(&amp;ping_prot, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc)</span><br><span class="line">      <span class="keyword">goto</span> out_unregister_raw_proto;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *	Tell SOCKET that we are alive...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    (<span class="keyword">void</span>)sock_register(&amp;inet_family_ops);</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSCTL</span></span><br><span class="line">    ip_static_sysctl_init();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *	Add all the base protocols.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inet_add_protocol(&amp;icmp_protocol, IPPROTO_ICMP) &lt; <span class="number">0</span>)</span><br><span class="line">      pr_crit(<span class="string">&quot;%s: Cannot add ICMP protocol\n&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">if</span> (inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &lt; <span class="number">0</span>)</span><br><span class="line">      pr_crit(<span class="string">&quot;%s: Cannot add UDP protocol\n&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">if</span> (inet_add_protocol(&amp;tcp_protocol, IPPROTO_TCP) &lt; <span class="number">0</span>)</span><br><span class="line">      pr_crit(<span class="string">&quot;%s: Cannot add TCP protocol\n&quot;</span>, __func__);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IP_MULTICAST</span></span><br><span class="line">    <span class="keyword">if</span> (inet_add_protocol(&amp;igmp_protocol, IPPROTO_IGMP) &lt; <span class="number">0</span>)</span><br><span class="line">      pr_crit(<span class="string">&quot;%s: Cannot add IGMP protocol\n&quot;</span>, __func__);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Register the socket-side information for inet_create. */</span></span><br><span class="line">    <span class="keyword">for</span> (r = &amp;inetsw[<span class="number">0</span>]; r &lt; &amp;inetsw[SOCK_MAX]; ++r)</span><br><span class="line">      INIT_LIST_HEAD(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)</span><br><span class="line">      inet_register_protosw(q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *	Set the ARP module up</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    arp_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *	Set the IP module up</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    ip_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup TCP slab cache for open requests. */</span></span><br><span class="line">    tcp_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup UDP memory threshold */</span></span><br><span class="line">    udp_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add UDP-Lite (RFC 3828) */</span></span><br><span class="line">    udplite4_register();</span><br><span class="line"></span><br><span class="line">    ping_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *	Set the ICMP layer up</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (icmp_init() &lt; <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;Failed to create the ICMP control socket.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *	Initialise the multicast router</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_IP_MROUTE)</span></span><br><span class="line">    <span class="keyword">if</span> (ip_mr_init())</span><br><span class="line">      pr_crit(<span class="string">&quot;%s: Cannot init ipv4 mroute\n&quot;</span>, __func__);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (init_inet_pernet_ops())</span><br><span class="line">      pr_crit(<span class="string">&quot;%s: Cannot init ipv4 inet pernet ops\n&quot;</span>, __func__);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *	Initialise per-cpu ipv4 mibs</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (init_ipv4_mibs())</span><br><span class="line">      pr_crit(<span class="string">&quot;%s: Cannot init ipv4 mibs\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">    ipv4_proc_init();</span><br><span class="line"></span><br><span class="line">    ipfrag_init();</span><br><span class="line"></span><br><span class="line">    dev_add_pack(&amp;ip_packet_type);</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fs_initcall(inet_init);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总的说来, Linux内核把网络协议栈的实现大致分为了四个层级:</p>
<ul>
<li>socket层: 为用户空间提供系统调用的接口, 并负责与下一层TCP传输层进行交互</li>
<li>TCP传输层: 就是通常所说的TCP/IP协议栈对应的数据传输层, 传输层一方面要为socket层提供接口, 另一方面要为网络层的数据接收提供接口</li>
<li>IP网络层: 对应TCP/IP协议栈的网络层, 负责将传输层的数据分片/路由, 并发送到对应的网络设备; 接收到数据后发送给对应的传输层协议</li>
<li>数据链路层: 需要负责物理设备与IP地址之间的转换, 将数据发送给物理设备, 接收来自物理设备的数据</li>
</ul>
<p>对协议栈有了这个大致的框架层级图, 梳理整个协议栈的代码就会清晰很多.在讲具体的代码细节之前, 我们先来看一个大致的数据收发流程图:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/linux_network_stack_flow.png" alt="Linux Network stack flow"></p>
<p>沿着这个流程简图, 我们就来仔细看下数据的发送流程(基于TCP协议).</p>
<h2 id="数据发送流程"><a href="#数据发送流程" class="headerlink" title="数据发送流程"></a><strong>数据发送流程</strong></h2><p>这里把整个发送流程按照TCP/IP协议栈分为三个部分来分析:</p>
<ul>
<li>TCP传输层</li>
<li>IP网络层</li>
<li>数据链路层</li>
</ul>
<h3 id="TCP传输层流程"><a href="#TCP传输层流程" class="headerlink" title="TCP传输层流程"></a><strong>TCP传输层流程</strong></h3><p>在分析具体流程之前, 可以看下TCP层数据传输的具体流程简图, 方便跟踪代码:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/network_stack_tcp_flow.png" alt="TCP data flow"></p>
<p>简单起见, 这里跳过了TCP socket创建与连接建立的过程(感兴趣的可以参看<code>kernel/net/socket.c</code>), 只着重于数据的发送过程. 在第一部分初始化的时候, 我们看到, socket层与TCP传输层的接口是<code>tcp_prot</code>, 这个结构体在<code>tcp_ipv4.c</code>中定义, 其接口包含了socket连接(<code>connect</code>), 连接断开(<code>disconnect</code>), 接受连接(<code>accept</code>), 接收消息(<code>recvmsg</code>), 发送消息<code>sendmsg</code>等.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//tcp_ipv4.c</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">tcp_prot</span> =</span> &#123;</span><br><span class="line">    .name			= <span class="string">&quot;TCP&quot;</span>,</span><br><span class="line">    .owner			= THIS_MODULE,</span><br><span class="line">    .close			= tcp_close,</span><br><span class="line">    .connect		= tcp_v4_connect,</span><br><span class="line">    .disconnect		= tcp_disconnect,</span><br><span class="line">    .accept			= inet_csk_accept,</span><br><span class="line">    .ioctl			= tcp_ioctl,</span><br><span class="line">    .init			= tcp_v4_init_sock,</span><br><span class="line">    .destroy		= tcp_v4_destroy_sock,</span><br><span class="line">    .shutdown		= tcp_shutdown,</span><br><span class="line">    .setsockopt		= tcp_setsockopt,</span><br><span class="line">    .getsockopt		= tcp_getsockopt,</span><br><span class="line">    .keepalive		= tcp_set_keepalive,</span><br><span class="line">    .recvmsg		= tcp_recvmsg,</span><br><span class="line">    .sendmsg		= tcp_sendmsg,</span><br><span class="line">    .sendpage		= tcp_sendpage,</span><br><span class="line">    .backlog_rcv		= tcp_v4_do_rcv,</span><br><span class="line">    .release_cb		= tcp_release_cb,</span><br><span class="line">    .hash			= inet_hash,</span><br><span class="line">    .unhash			= inet_unhash,</span><br><span class="line">    .get_port		= inet_csk_get_port,</span><br><span class="line">    .enter_memory_pressure	= tcp_enter_memory_pressure,</span><br><span class="line">    .leave_memory_pressure	= tcp_leave_memory_pressure,</span><br><span class="line">    .stream_memory_free	= tcp_stream_memory_free,</span><br><span class="line">    .sockets_allocated	= &amp;tcp_sockets_allocated,</span><br><span class="line">    .orphan_count		= &amp;tcp_orphan_count,</span><br><span class="line">    .memory_allocated	= &amp;tcp_memory_allocated,</span><br><span class="line">    .memory_pressure	= &amp;tcp_memory_pressure,</span><br><span class="line">    .sysctl_mem		= sysctl_tcp_mem,</span><br><span class="line">    .sysctl_wmem		= sysctl_tcp_wmem,</span><br><span class="line">    .sysctl_rmem		= sysctl_tcp_rmem,</span><br><span class="line">    .max_header		= MAX_TCP_HEADER,</span><br><span class="line">    .obj_size		= <span class="built_in"><span class="keyword">sizeof</span></span>(struct tcp_sock),</span><br><span class="line">    .slab_flags		= SLAB_TYPESAFE_BY_RCU,</span><br><span class="line">    .twsk_prot		= &amp;tcp_timewait_sock_ops,</span><br><span class="line">    .rsk_prot		= &amp;tcp_request_sock_ops,</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">EXPORT_SYMBOL</span>(tcp_prot);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>socket层接收到用户进程的数据发送请求后, <code>inet_sendmsg</code>就是调用了<code>tcp_prot</code>的<code>sendmsg</code>来传输数据的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//af_inet.c</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">inet_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">sock_rps_record_flow</span>(sk);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* We may need to bind the socket. */</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">inet_sk</span>(sk)-&gt;inet_num &amp;&amp; !sk-&gt;sk_prot-&gt;no_autobind &amp;&amp;</span><br><span class="line">		    <span class="built_in">inet_autobind</span>(sk))</span><br><span class="line">			<span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> sk-&gt;sk_prot-&gt;<span class="built_in">sendmsg</span>(sk, msg, size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	  ###<span class="meta"># tcp.c  ####</span></span><br><span class="line">	  <span class="function"><span class="keyword">int</span> <span class="title">tcp_sendmsg</span><span class="params">(struct sock *sk, struct msghdr *msg, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">	  </span>&#123;</span><br><span class="line">		    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">		    <span class="built_in">lock_sock</span>(sk);</span><br><span class="line">		    ret = <span class="built_in">tcp_sendmsg_locked</span>(sk, msg, size);</span><br><span class="line">		    <span class="built_in">release_sock</span>(sk);</span><br><span class="line"></span><br><span class="line">		    <span class="keyword">return</span> ret;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在发送数据之前, 先通过<code>lock_sock</code>获取到锁后, 然后调用<code>tcp_sendmsg_locked</code>发送数据, 这里主要做如下几个事情:</p>
<ul>
<li>查看socket标志位是否有<code>MSG_ZEROCOPY</code>以及<code>MSG_FASTOPEN</code>(在三次握手时即开始传输数据)</li>
<li>判断当前TCP是否处于<code>TCPF_ESTABLISHED</code>连接状态, 否则需要等待连接成功后再发送数据</li>
<li>如果发生了数据拷贝, 则调用<code>tcp_push</code>执行数据的发送</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// tcp.c</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">tcp_sendmsg_locked</span><span class="params">(struct sock *sk, struct msghdr *msg, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> <span class="built_in">tcp_sk</span>(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ubuf_info</span> *<span class="title">uarg</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockcm_cookie</span> <span class="title">sockc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> flags, err, copied = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mss_now = <span class="number">0</span>, size_goal, copied_syn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> process_backlog = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> sg;</span><br><span class="line">    <span class="keyword">long</span> timeo;</span><br><span class="line"></span><br><span class="line">    flags = msg-&gt;msg_flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MSG_ZEROCOPY &amp;&amp; size &amp;&amp; <span class="built_in">sock_flag</span>(sk, SOCK_ZEROCOPY)) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)) &#123;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> out_err;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      skb = <span class="built_in">tcp_send_head</span>(sk) ? <span class="built_in">tcp_write_queue_tail</span>(sk) : <span class="literal">NULL</span>;</span><br><span class="line">      uarg = <span class="built_in">sock_zerocopy_realloc</span>(sk, size, <span class="built_in">skb_zcopy</span>(skb));</span><br><span class="line">      <span class="keyword">if</span> (!uarg) &#123;</span><br><span class="line">        err = -ENOBUFS;</span><br><span class="line">        <span class="keyword">goto</span> out_err;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!(<span class="built_in">sk_check_csum_caps</span>(sk) &amp;&amp; sk-&gt;sk_route_caps &amp; NETIF_F_SG))</span><br><span class="line">        uarg-&gt;zerocopy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(flags &amp; MSG_FASTOPEN || <span class="built_in">inet_sk</span>(sk)-&gt;defer_connect) &amp;&amp;</span><br><span class="line">        !tp-&gt;repair) &#123;</span><br><span class="line">      err = <span class="built_in">tcp_sendmsg_fastopen</span>(sk, msg, &amp;copied_syn, size);</span><br><span class="line">      <span class="keyword">if</span> (err == -EINPROGRESS &amp;&amp; copied_syn &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> out_err;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for a connection to finish. One exception is TCP Fast Open</span></span><br><span class="line"><span class="comment">    * (passive side) where data is allowed to be sent before a connection</span></span><br><span class="line"><span class="comment">    * is fully established.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)) &amp;&amp;</span><br><span class="line">        !<span class="built_in">tcp_passive_fastopen</span>(sk)) &#123;</span><br><span class="line">      err = <span class="built_in">sk_stream_wait_connect</span>(sk, &amp;timeo);</span><br><span class="line">      <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> do_error;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ok commence sending. */</span></span><br><span class="line">    copied = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  restart:</span><br><span class="line">    mss_now = <span class="built_in">tcp_send_mss</span>(sk, &amp;size_goal, flags);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断发送msg消息中的数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">msg_data_left</span>(msg)) &#123;</span><br><span class="line">      <span class="keyword">int</span> copy = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> max = size_goal;</span><br><span class="line"></span><br><span class="line">      skb = <span class="built_in">tcp_write_queue_tail</span>(sk);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">tcp_send_head</span>(sk)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_NONE)</span><br><span class="line">          max = mss_now;</span><br><span class="line">        copy = max - skb-&gt;len;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (copy &lt;= <span class="number">0</span> || !<span class="built_in">tcp_skb_can_collapse_to</span>(skb)) &#123;</span><br><span class="line">        <span class="keyword">bool</span> first_skb;</span><br><span class="line"></span><br><span class="line">  new_segment:</span><br><span class="line">        <span class="comment">/* Allocate new segment. If the interface is SG,</span></span><br><span class="line"><span class="comment">        * allocate skb fitting to single page.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">sk_stream_memory_free</span>(sk))</span><br><span class="line">          <span class="keyword">goto</span> wait_for_sndbuf;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (process_backlog &amp;&amp; <span class="built_in">sk_flush_backlog</span>(sk)) &#123;</span><br><span class="line">          process_backlog = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">goto</span> restart;</span><br><span class="line">        &#125;</span><br><span class="line">        first_skb = <span class="built_in">skb_queue_empty</span>(&amp;sk-&gt;sk_write_queue);</span><br><span class="line">        skb = <span class="built_in">sk_stream_alloc_skb</span>(sk,</span><br><span class="line">                <span class="built_in">select_size</span>(sk, sg, first_skb),</span><br><span class="line">                sk-&gt;sk_allocation,</span><br><span class="line">                first_skb);</span><br><span class="line">        <span class="keyword">if</span> (!skb)</span><br><span class="line">          <span class="keyword">goto</span> wait_for_memory;</span><br><span class="line"></span><br><span class="line">        process_backlog = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Check whether we can use HW checksum.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sk_check_csum_caps</span>(sk))</span><br><span class="line">          skb-&gt;ip_summed = CHECKSUM_PARTIAL;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">skb_entail</span>(sk, skb);</span><br><span class="line">        copy = size_goal;</span><br><span class="line">        max = size_goal;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">/* Try to append data to the end of skb. */</span></span><br><span class="line">      <span class="keyword">if</span> (copy &gt; <span class="built_in">msg_data_left</span>(msg))</span><br><span class="line">        copy = <span class="built_in">msg_data_left</span>(msg);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Where to copy to? */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">skb_availroom</span>(skb) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* We have some space in skb head. Superb! */</span></span><br><span class="line">        copy = <span class="built_in">min_t</span>(<span class="keyword">int</span>, copy, <span class="built_in">skb_availroom</span>(skb));</span><br><span class="line">        err = <span class="built_in">skb_add_data_nocache</span>(sk, skb, &amp;msg-&gt;msg_iter, copy);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">          <span class="keyword">goto</span> do_fault;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!uarg || !uarg-&gt;zerocopy) &#123;</span><br><span class="line">        <span class="keyword">bool</span> merge = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">skb_shinfo</span>(skb)-&gt;nr_frags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page_frag</span> *<span class="title">pfrag</span> =</span> <span class="built_in">sk_page_frag</span>(sk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">sk_page_frag_refill</span>(sk, pfrag))</span><br><span class="line">          <span class="keyword">goto</span> wait_for_memory;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">skb_can_coalesce</span>(skb, i, pfrag-&gt;page,</span><br><span class="line">                  pfrag-&gt;offset)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i &gt;= sysctl_max_skb_frags || !sg) &#123;</span><br><span class="line">            <span class="built_in">tcp_mark_push</span>(tp, skb);</span><br><span class="line">            <span class="keyword">goto</span> new_segment;</span><br><span class="line">          &#125;</span><br><span class="line">          merge = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        copy = <span class="built_in">min_t</span>(<span class="keyword">int</span>, copy, pfrag-&gt;size - pfrag-&gt;offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">sk_wmem_schedule</span>(sk, copy))</span><br><span class="line">          <span class="keyword">goto</span> wait_for_memory;</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">skb_copy_to_page_nocache</span>(sk, &amp;msg-&gt;msg_iter, skb,</span><br><span class="line">                    pfrag-&gt;page,</span><br><span class="line">                    pfrag-&gt;offset,</span><br><span class="line">                    copy);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">          <span class="keyword">goto</span> do_error;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update the skb. */</span></span><br><span class="line">        <span class="keyword">if</span> (merge) &#123;</span><br><span class="line">          <span class="built_in">skb_frag_size_add</span>(&amp;<span class="built_in">skb_shinfo</span>(skb)-&gt;frags[i - <span class="number">1</span>], copy);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">skb_fill_page_desc</span>(skb, i, pfrag-&gt;page,</span><br><span class="line">                pfrag-&gt;offset, copy);</span><br><span class="line">          <span class="built_in">page_ref_inc</span>(pfrag-&gt;page);</span><br><span class="line">        &#125;</span><br><span class="line">        pfrag-&gt;offset += copy;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = <span class="built_in">skb_zerocopy_iter_stream</span>(sk, skb, msg, copy, uarg);</span><br><span class="line">        <span class="keyword">if</span> (err == -EMSGSIZE || err == -EEXIST)</span><br><span class="line">          <span class="keyword">goto</span> new_segment;</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">goto</span> do_error;</span><br><span class="line">        copy = err;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!copied)</span><br><span class="line">        <span class="built_in">TCP_SKB_CB</span>(skb)-&gt;tcp_flags &amp;= ~TCPHDR_PSH;</span><br><span class="line"></span><br><span class="line">      tp-&gt;write_seq += copy;</span><br><span class="line">      <span class="built_in">TCP_SKB_CB</span>(skb)-&gt;end_seq += copy;</span><br><span class="line">      <span class="built_in">tcp_skb_pcount_set</span>(skb, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      copied += copy;</span><br><span class="line">      <span class="comment">// 没有数据, 则中断拷贝</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">msg_data_left</span>(msg)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">unlikely</span>(flags &amp; MSG_EOR))</span><br><span class="line">          <span class="built_in">TCP_SKB_CB</span>(skb)-&gt;eor = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (skb-&gt;len &lt; max || (flags &amp; MSG_OOB) || <span class="built_in">unlikely</span>(tp-&gt;repair))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前写入的数据超过了最大window的2倍, 就直接发送</span></span><br><span class="line">      <span class="keyword">if</span> (forced_push(tp)) &#123;</span><br><span class="line">        <span class="built_in">tcp_mark_push</span>(tp, skb);</span><br><span class="line">        __tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skb == <span class="built_in">tcp_send_head</span>(sk))</span><br><span class="line">        <span class="built_in">tcp_push_one</span>(sk, mss_now);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  wait_for_sndbuf:</span><br><span class="line">      <span class="built_in">set_bit</span>(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);</span><br><span class="line">  wait_for_memory:</span><br><span class="line">      <span class="keyword">if</span> (copied)</span><br><span class="line">        <span class="built_in">tcp_push</span>(sk, flags &amp; ~MSG_MORE, mss_now,</span><br><span class="line">          TCP_NAGLE_PUSH, size_goal);</span><br><span class="line"></span><br><span class="line">      err = <span class="built_in">sk_stream_wait_memory</span>(sk, &amp;timeo);</span><br><span class="line">      <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> do_error;</span><br><span class="line"></span><br><span class="line">      mss_now = <span class="built_in">tcp_send_mss</span>(sk, &amp;size_goal, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  out:</span><br><span class="line">    <span class="comment">// 当前有数据需要发送</span></span><br><span class="line">    <span class="keyword">if</span> (copied) &#123;</span><br><span class="line">      <span class="built_in">tcp_tx_timestamp</span>(sk, sockc.tsflags, <span class="built_in">tcp_write_queue_tail</span>(sk));</span><br><span class="line">      <span class="built_in">tcp_push</span>(sk, flags, mss_now, tp-&gt;nonagle, size_goal);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tcp_push</code>首先检查发送队列是否为空, 为空则直接返回, 接着会检查标志位<code>flags</code>是否包含有<code>MSG_MORE/MSG_OOB</code>;另外, 还会判断是否满足<code>auto cork</code>的条件(简单来说, <code>auto corking</code>是TCP针对小包发送的一种优化, 详细可以参考<a target="_blank" rel="noopener" href="https://lwn.net/Articles/576263/">https://lwn.net/Articles/576263/</a>). 最后通过<code>__tcp_push_pending_frames</code>传送对应的数据.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// tcp.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tcp_push</span><span class="params">(struct sock *sk, <span class="keyword">int</span> flags, <span class="keyword">int</span> mss_now,</span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="keyword">int</span> nonagle, <span class="keyword">int</span> size_goal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tcp_send_head(sk))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	skb = tcp_write_queue_tail(sk);</span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; MSG_MORE) || forced_push(tp))</span><br><span class="line">		tcp_mark_push(tp, skb);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 是否属于OOB(out of band)紧急数据</span></span><br><span class="line">	tcp_mark_urg(tp, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcp_should_autocork(sk, skb, size_goal)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* avoid atomic op if TSQ_THROTTLED bit is already set */</span></span><br><span class="line">		<span class="keyword">if</span> (!test_bit(TSQ_THROTTLED, &amp;sk-&gt;sk_tsq_flags)) &#123;</span><br><span class="line">			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPAUTOCORKING);</span><br><span class="line">			set_bit(TSQ_THROTTLED, &amp;sk-&gt;sk_tsq_flags);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* It is possible TX completion already happened</span></span><br><span class="line"><span class="comment">		 * before we set TSQ_THROTTLED.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (refcount_read(&amp;sk-&gt;sk_wmem_alloc) &gt; skb-&gt;truesize)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MSG_MORE)</span><br><span class="line">		nonagle = TCP_NAGLE_CORK;</span><br><span class="line"></span><br><span class="line">	__tcp_push_pending_frames(sk, mss_now, nonagle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>__tcp_push_pending_frames</code>首先会判断当前socket是否close, 非close状态则调用<code>tcp_write_xmit</code>继续发送数据:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// tcp_output.c</span></span><br><span class="line">	<span class="keyword">void</span> __tcp_push_pending_frames(struct sock *sk, <span class="keyword">unsigned</span> <span class="keyword">int</span> cur_mss,</span><br><span class="line">				       <span class="keyword">int</span> nonagle)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* If we are closed, the bytes will have to remain here.</span></span><br><span class="line"><span class="comment">		 * In time closedown will finish, we empty the write queue and</span></span><br><span class="line"><span class="comment">		 * all will be happy.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(sk-&gt;sk_state == TCP_CLOSE))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tcp_write_xmit(sk, cur_mss, nonagle, <span class="number">0</span>,</span><br><span class="line">				   sk_gfp_mask(sk, GFP_ATOMIC)))</span><br><span class="line">			tcp_check_probe_timer(sk);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tcp_write_xmit</code>的函数的核心逻辑就是不断取出socket发送队列中的skb_buff, 然后通过<code>tcp_transmit_skb</code>发送出去, 而<code>tcp_transmit_skb</code>实际只是调用了<code>__tcp_transmit_skb</code>而已:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// tcp_output.c</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">tcp_write_xmit</span><span class="params">(struct sock *sk, <span class="keyword">unsigned</span> <span class="keyword">int</span> mss_now, <span class="keyword">int</span> nonagle,</span></span></span><br><span class="line"><span class="params"><span class="function">				   <span class="keyword">int</span> push_one, <span class="keyword">gfp_t</span> gfp)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> tso_segs, sent_pkts;</span><br><span class="line">		<span class="keyword">int</span> cwnd_quota;</span><br><span class="line">		<span class="keyword">int</span> result;</span><br><span class="line">		<span class="keyword">bool</span> is_cwnd_limited = <span class="literal">false</span>, is_rwnd_limited = <span class="literal">false</span>;</span><br><span class="line">		u32 max_segs;</span><br><span class="line"></span><br><span class="line">		sent_pkts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		tcp_mstamp_refresh(tp);</span><br><span class="line">		<span class="comment">// 如果不是发送一个段的包, 则执行PMTU</span></span><br><span class="line">		<span class="keyword">if</span> (!push_one) &#123;</span><br><span class="line">			<span class="comment">/* Do MTU probing. */</span></span><br><span class="line">			result = tcp_mtu_probe(sk);</span><br><span class="line">			<span class="keyword">if</span> (!result) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				sent_pkts = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		max_segs = tcp_tso_segs(sk, mss_now);</span><br><span class="line">		<span class="keyword">while</span> ((skb = tcp_send_head(sk))) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (tcp_pacing_check(sk))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			tso_segs = tcp_init_tso_segs(skb, mss_now);</span><br><span class="line">			BUG_ON(!tso_segs);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (unlikely(tp-&gt;repair) &amp;&amp; tp-&gt;repair_queue == TCP_SEND_QUEUE) &#123;</span><br><span class="line">				<span class="comment">/* &quot;skb_mstamp&quot; is used as a start point for the retransmit timer */</span></span><br><span class="line">				skb-&gt;skb_mstamp = tp-&gt;tcp_mstamp;</span><br><span class="line">				<span class="keyword">goto</span> repair; <span class="comment">/* Skip network transmission */</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			cwnd_quota = tcp_cwnd_test(tp, skb);</span><br><span class="line">			<span class="keyword">if</span> (!cwnd_quota) &#123;</span><br><span class="line">				<span class="keyword">if</span> (push_one == <span class="number">2</span>)</span><br><span class="line">					<span class="comment">/* Force out a loss probe pkt. */</span></span><br><span class="line">					cwnd_quota = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (unlikely(!tcp_snd_wnd_test(tp, skb, mss_now))) &#123;</span><br><span class="line">				is_rwnd_limited = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (tso_segs == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (unlikely(!tcp_nagle_test(tp, skb, mss_now,</span><br><span class="line">							     (tcp_skb_is_last(sk, skb) ?</span><br><span class="line">							      nonagle : TCP_NAGLE_PUSH))))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (!push_one &amp;&amp;</span><br><span class="line">				    tcp_tso_should_defer(sk, skb, &amp;is_cwnd_limited,</span><br><span class="line">							 &amp;is_rwnd_limited, max_segs))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			limit = mss_now;</span><br><span class="line">			<span class="keyword">if</span> (tso_segs &gt; <span class="number">1</span> &amp;&amp; !tcp_urg_mode(tp))</span><br><span class="line">				limit = tcp_mss_split_point(sk, skb, mss_now,</span><br><span class="line">							    <span class="keyword">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>,</span><br><span class="line">								  cwnd_quota,</span><br><span class="line">								  max_segs),</span><br><span class="line">							    nonagle);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (skb-&gt;len &gt; limit &amp;&amp;</span><br><span class="line">			    unlikely(tso_fragment(sk, skb, limit, mss_now, gfp)))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (test_bit(TCP_TSQ_DEFERRED, &amp;sk-&gt;sk_tsq_flags))</span><br><span class="line">				clear_bit(TCP_TSQ_DEFERRED, &amp;sk-&gt;sk_tsq_flags);</span><br><span class="line">			<span class="keyword">if</span> (tcp_small_queue_check(sk, skb, <span class="number">0</span>))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Argh, we hit an empty skb(), presumably a thread</span></span><br><span class="line"><span class="comment">			 * is sleeping in sendmsg()/sk_stream_wait_memory().</span></span><br><span class="line"><span class="comment">			 * We do not want to send a pure-ack packet and have</span></span><br><span class="line"><span class="comment">			 * a strange looking rtx queue with empty packet(s).</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;end_seq == TCP_SKB_CB(skb)-&gt;seq)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 发送数据</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(tcp_transmit_skb(sk, skb, <span class="number">1</span>, gfp)))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	repair:</span><br><span class="line">			<span class="comment">/* Advance the send_head.  This one is sent out.</span></span><br><span class="line"><span class="comment">			 * This call will increment packets_out.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			tcp_event_new_data_sent(sk, skb);</span><br><span class="line"></span><br><span class="line">			tcp_minshall_update(tp, mss_now, skb);</span><br><span class="line">			sent_pkts += tcp_skb_pcount(skb);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (push_one)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (is_rwnd_limited)</span><br><span class="line">			tcp_chrono_start(sk, TCP_CHRONO_RWND_LIMITED);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tcp_chrono_stop(sk, TCP_CHRONO_RWND_LIMITED);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(sent_pkts)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tcp_in_cwnd_reduction(sk))</span><br><span class="line">				tp-&gt;prr_out += sent_pkts;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Send one loss probe per tail loss episode. */</span></span><br><span class="line">			<span class="keyword">if</span> (push_one != <span class="number">2</span>)</span><br><span class="line">				tcp_schedule_loss_probe(sk, <span class="literal">false</span>);</span><br><span class="line">			is_cwnd_limited |= (tcp_packets_in_flight(tp) &gt;= tp-&gt;snd_cwnd);</span><br><span class="line">			tcp_cwnd_validate(sk, is_cwnd_limited);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> !tp-&gt;packets_out &amp;&amp; tcp_send_head(sk);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>__tcp_transmit_skb</code>是TCP传输层与IP网络层的分界函数, 在组装完TCP头后, 就调用IP层的接口<code>queue_xmit</code>往网络层继续发送数据:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// tcp_output.c </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> __tcp_transmit_skb(struct sock *sk, struct sk_buff *skb,</span><br><span class="line">				      <span class="keyword">int</span> clone_it, <span class="keyword">gfp_t</span> gfp_mask, u32 rcv_nxt)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcp_skb_cb</span> *<span class="title">tcb</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcp_out_options</span> <span class="title">opts</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> tcp_options_size, tcp_header_size;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">oskb</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcp_md5sig_key</span> *<span class="title">md5</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">		<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">		BUG_ON(!skb || !tcp_skb_pcount(skb));</span><br><span class="line">		tp = tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (clone_it) &#123;</span><br><span class="line">			TCP_SKB_CB(skb)-&gt;tx.in_flight = TCP_SKB_CB(skb)-&gt;end_seq</span><br><span class="line">				- tp-&gt;snd_una;</span><br><span class="line">			oskb = skb;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(skb_cloned(skb)))</span><br><span class="line">				skb = pskb_copy(skb, gfp_mask);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				skb = skb_clone(skb, gfp_mask);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">				<span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">		&#125;</span><br><span class="line">		skb-&gt;skb_mstamp = tp-&gt;tcp_mstamp;</span><br><span class="line"></span><br><span class="line">		inet = inet_sk(sk);</span><br><span class="line">		tcb = TCP_SKB_CB(skb);</span><br><span class="line">		<span class="built_in">memset</span>(&amp;opts, <span class="number">0</span>, <span class="keyword">sizeof</span>(opts));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(tcb-&gt;tcp_flags &amp; TCPHDR_SYN))</span><br><span class="line">			tcp_options_size = tcp_syn_options(sk, skb, &amp;opts, &amp;md5);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tcp_options_size = tcp_established_options(sk, skb, &amp;opts,</span><br><span class="line">								   &amp;md5);</span><br><span class="line">		tcp_header_size = tcp_options_size + <span class="keyword">sizeof</span>(struct tcphdr);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* if no packet is in qdisc/device queue, then allow XPS to select</span></span><br><span class="line"><span class="comment">		 * another queue. We can be called from tcp_tsq_handler()</span></span><br><span class="line"><span class="comment">		 * which holds one reference to sk_wmem_alloc.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">TODO:</span> Ideally, in-flight pure ACK packets should not matter here.</span></span><br><span class="line"><span class="comment">		 * One way to get this would be to set skb-&gt;truesize = 2 on them.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		skb-&gt;ooo_okay = sk_wmem_alloc_get(sk) &lt; SKB_TRUESIZE(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If we had to use memory reserve to allocate this skb,</span></span><br><span class="line"><span class="comment">		 * this might cause drops if packet is looped back :</span></span><br><span class="line"><span class="comment">		 * Other socket might not have SOCK_MEMALLOC.</span></span><br><span class="line"><span class="comment">		 * Packets not looped back do not care about pfmemalloc.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		skb-&gt;pfmemalloc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		skb_push(skb, tcp_header_size);</span><br><span class="line">		skb_reset_transport_header(skb);</span><br><span class="line"></span><br><span class="line">		skb_orphan(skb);</span><br><span class="line">		skb-&gt;sk = sk;</span><br><span class="line">		skb-&gt;destructor = skb_is_tcp_pure_ack(skb) ? __sock_wfree : tcp_wfree;</span><br><span class="line">		skb_set_hash_from_sk(skb, sk);</span><br><span class="line">		refcount_add(skb-&gt;truesize, &amp;sk-&gt;sk_wmem_alloc);</span><br><span class="line"></span><br><span class="line">		skb_set_dst_pending_confirm(skb, sk-&gt;sk_dst_pending_confirm);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Build TCP header and checksum it. */</span></span><br><span class="line">		th = (struct tcphdr *)skb-&gt;data;</span><br><span class="line">		th-&gt;source		= inet-&gt;inet_sport;</span><br><span class="line">		th-&gt;dest		= inet-&gt;inet_dport;</span><br><span class="line">		th-&gt;seq			= htonl(tcb-&gt;seq);</span><br><span class="line">		th-&gt;ack_seq		= htonl(rcv_nxt);</span><br><span class="line">		*(((__be16 *)th) + <span class="number">6</span>)	= htons(((tcp_header_size &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">						tcb-&gt;tcp_flags);</span><br><span class="line"></span><br><span class="line">		th-&gt;check		= <span class="number">0</span>;</span><br><span class="line">		th-&gt;urg_ptr		= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* The urg_mode check is necessary during a below snd_una win probe */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(tcp_urg_mode(tp) &amp;&amp; before(tcb-&gt;seq, tp-&gt;snd_up))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (before(tp-&gt;snd_up, tcb-&gt;seq + <span class="number">0x10000</span>)) &#123;</span><br><span class="line">				th-&gt;urg_ptr = htons(tp-&gt;snd_up - tcb-&gt;seq);</span><br><span class="line">				th-&gt;urg = <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (after(tcb-&gt;seq + <span class="number">0xFFFF</span>, tp-&gt;snd_nxt)) &#123;</span><br><span class="line">				th-&gt;urg_ptr = htons(<span class="number">0xFFFF</span>);</span><br><span class="line">				th-&gt;urg = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tcp_options_write((__be32 *)(th + <span class="number">1</span>), tp, &amp;opts);</span><br><span class="line">		skb_shinfo(skb)-&gt;gso_type = sk-&gt;sk_gso_type;</span><br><span class="line">		<span class="keyword">if</span> (likely(!(tcb-&gt;tcp_flags &amp; TCPHDR_SYN))) &#123;</span><br><span class="line">			th-&gt;window      = htons(tcp_select_window(sk));</span><br><span class="line">			tcp_ecn_send(sk, skb, th, tcp_header_size);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* RFC1323: The window in SYN &amp; SYN/ACK segments</span></span><br><span class="line"><span class="comment">			 * is never scaled.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			th-&gt;window	= htons(min(tp-&gt;rcv_wnd, <span class="number">65535U</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		....</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 计算checksum</span></span><br><span class="line">		icsk-&gt;icsk_af_ops-&gt;send_check(sk, skb);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(tcb-&gt;tcp_flags &amp; TCPHDR_ACK))</span><br><span class="line">			tcp_event_ack_sent(sk, tcp_skb_pcount(skb), rcv_nxt);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;len != tcp_header_size) &#123;</span><br><span class="line">			tcp_event_data_sent(tp, sk);</span><br><span class="line">			tp-&gt;data_segs_out += tcp_skb_pcount(skb);</span><br><span class="line">			tcp_internal_pacing(sk, skb);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (after(tcb-&gt;end_seq, tp-&gt;snd_nxt) || tcb-&gt;seq == tcb-&gt;end_seq)</span><br><span class="line">			TCP_ADD_STATS(sock_net(sk), TCP_MIB_OUTSEGS,</span><br><span class="line">				      tcp_skb_pcount(skb));</span><br><span class="line"></span><br><span class="line">		tp-&gt;segs_out += tcp_skb_pcount(skb);</span><br><span class="line">		<span class="comment">/* OK, its time to fill skb_shinfo(skb)-&gt;gso_&#123;segs|size&#125; */</span></span><br><span class="line">		skb_shinfo(skb)-&gt;gso_segs = tcp_skb_pcount(skb);</span><br><span class="line">		skb_shinfo(skb)-&gt;gso_size = tcp_skb_mss(skb);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Our usage of tstamp should remain private */</span></span><br><span class="line">		skb-&gt;tstamp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Cleanup our debris for IP stacks */</span></span><br><span class="line">		<span class="built_in">memset</span>(skb-&gt;cb, <span class="number">0</span>, max(<span class="keyword">sizeof</span>(struct inet_skb_parm),</span><br><span class="line">				       <span class="keyword">sizeof</span>(struct inet6_skb_parm)));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将当前数据发送给IP网络层</span></span><br><span class="line">		err = icsk-&gt;icsk_af_ops-&gt;queue_xmit(sk, skb, &amp;inet-&gt;cork.fl);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(err &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">			tcp_enter_cwr(sk);</span><br><span class="line">			err = net_xmit_eval(err);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!err &amp;&amp; oskb) &#123;</span><br><span class="line">			oskb-&gt;skb_mstamp = tp-&gt;tcp_mstamp;</span><br><span class="line">			tcp_rate_skb_sent(sk, oskb);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么, <code>queue_xmit</code>这个接口又是在何时赋值的? 实际在socket创建时初始化TCP部分时, 在<code>tcp_v4_init_sock</code>这个函数传入了网络层的接口:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// tcp_ipv4.c</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_v4_init_sock</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> =</span> inet_csk(sk);</span><br><span class="line"></span><br><span class="line">		tcp_init_sock(sk);</span><br><span class="line"></span><br><span class="line">		icsk-&gt;icsk_af_ops = &amp;ipv4_specific;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock_af_ops</span> <span class="title">ipv4_specific</span> =</span> &#123;</span><br><span class="line">	.queue_xmit	   = ip_queue_xmit,</span><br><span class="line">	.send_check	   = tcp_v4_send_check,</span><br><span class="line">	.rebuild_header	   = inet_sk_rebuild_header,</span><br><span class="line">	.sk_rx_dst_set	   = inet_sk_rx_dst_set,</span><br><span class="line">	.conn_request	   = tcp_v4_conn_request,</span><br><span class="line">	.syn_recv_sock	   = tcp_v4_syn_recv_sock,</span><br><span class="line">	.net_header_len	   = <span class="keyword">sizeof</span>(struct iphdr),</span><br><span class="line">	.setsockopt	   = ip_setsockopt,</span><br><span class="line">	.getsockopt	   = ip_getsockopt,</span><br><span class="line">	.addr2sockaddr	   = inet_csk_addr2sockaddr,</span><br><span class="line">	.sockaddr_len	   = <span class="keyword">sizeof</span>(struct sockaddr_in),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	.compat_setsockopt = compat_ip_setsockopt,</span><br><span class="line">	.compat_getsockopt = compat_ip_getsockopt,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	.mtu_reduced	   = tcp_v4_mtu_reduced,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(ipv4_specific);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="IP网络层数据路由与寻址"><a href="#IP网络层数据路由与寻址" class="headerlink" title="IP网络层数据路由与寻址"></a><strong>IP网络层数据路由与寻址</strong></h3><p>IP层主要负责数据的路由,寻址, 同时还会对数据报文基于设定的iptables规则进行过滤. 函数<code>ip_queue_xmit</code>首先要做的就是找到需要发送数据的路由出口<code>struct rtable</code>, 如果没有找到路由,则直接返回<code>EHOSTUNREACH</code>的错误; 有了路由信息之后, 接着会构造IP协议头, 然后尝试通过本地的NETFILETER模块<code>ip_local_out</code>对包进行过滤处理. 下图是对应的流程简图:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/network_stack_ip_flow.png" alt="IP data flow"></p>
<blockquote>
<p>Linux内核路由实现原理的可以参考<a target="_blank" rel="noopener" href="http://kernelspec.blogspot.com/2014/10/zoom-into-packet-routing-in-linux-kernel.html">Linux路由实现原理</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ip_output.c</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ip_queue_xmit</span><span class="params">(struct sock *sk, struct sk_buff *skb, struct flowi *fl)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ip_options_rcu</span> *<span class="title">inet_opt</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">flowi4</span> *<span class="title">fl4</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">		<span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Skip all of this if the packet is already routed,</span></span><br><span class="line"><span class="comment">		 * f.e. by something like SCTP.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		inet_opt = rcu_dereference(inet-&gt;inet_opt);</span><br><span class="line">		fl4 = &amp;fl-&gt;u.ip4;</span><br><span class="line">		rt = skb_rtable(skb);</span><br><span class="line">		<span class="keyword">if</span> (rt)</span><br><span class="line">			<span class="keyword">goto</span> packet_routed;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Make sure we can route this packet. */</span></span><br><span class="line">		rt = (struct rtable *)__sk_dst_check(sk, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (!rt) &#123;</span><br><span class="line">			__be32 daddr;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Use correct destination address if we have options. */</span></span><br><span class="line">			daddr = inet-&gt;inet_daddr;</span><br><span class="line">			<span class="keyword">if</span> (inet_opt &amp;&amp; inet_opt-&gt;opt.srr)</span><br><span class="line">				daddr = inet_opt-&gt;opt.faddr;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* If this fails, retransmit mechanism of transport layer will</span></span><br><span class="line"><span class="comment">			 * keep trying until route appears or the connection times</span></span><br><span class="line"><span class="comment">			 * itself out.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			rt = ip_route_output_ports(net, fl4, sk,</span><br><span class="line">						   daddr, inet-&gt;inet_saddr,</span><br><span class="line">						   inet-&gt;inet_dport,</span><br><span class="line">						   inet-&gt;inet_sport,</span><br><span class="line">						   sk-&gt;sk_protocol,</span><br><span class="line">						   RT_CONN_FLAGS(sk),</span><br><span class="line">						   sk-&gt;sk_bound_dev_if);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(rt))</span><br><span class="line">				<span class="keyword">goto</span> no_route;</span><br><span class="line">			sk_setup_caps(sk, &amp;rt-&gt;dst);</span><br><span class="line">		&#125;</span><br><span class="line">		skb_dst_set_noref(skb, &amp;rt-&gt;dst);</span><br><span class="line"></span><br><span class="line">	packet_routed:</span><br><span class="line">		<span class="keyword">if</span> (inet_opt &amp;&amp; inet_opt-&gt;opt.is_strictroute &amp;&amp; rt-&gt;rt_uses_gateway)</span><br><span class="line">			<span class="keyword">goto</span> no_route;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* OK, we know where to send it, allocate and build IP header. */</span></span><br><span class="line">		skb_push(skb, <span class="keyword">sizeof</span>(struct iphdr) + (inet_opt ? inet_opt-&gt;opt.optlen : <span class="number">0</span>));</span><br><span class="line">		skb_reset_network_header(skb);</span><br><span class="line">		iph = ip_hdr(skb);</span><br><span class="line">		*((__be16 *)iph) = htons((<span class="number">4</span> &lt;&lt; <span class="number">12</span>) | (<span class="number">5</span> &lt;&lt; <span class="number">8</span>) | (inet-&gt;tos &amp; <span class="number">0xff</span>));</span><br><span class="line">		<span class="keyword">if</span> (ip_dont_fragment(sk, &amp;rt-&gt;dst) &amp;&amp; !skb-&gt;ignore_df)</span><br><span class="line">			iph-&gt;frag_off = htons(IP_DF);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			iph-&gt;frag_off = <span class="number">0</span>;</span><br><span class="line">		iph-&gt;ttl      = ip_select_ttl(inet, &amp;rt-&gt;dst);</span><br><span class="line">		iph-&gt;protocol = sk-&gt;sk_protocol;</span><br><span class="line">		ip_copy_addrs(iph, fl4);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Transport layer set skb-&gt;h.foo itself. */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (inet_opt &amp;&amp; inet_opt-&gt;opt.optlen) &#123;</span><br><span class="line">			iph-&gt;ihl += inet_opt-&gt;opt.optlen &gt;&gt; <span class="number">2</span>;</span><br><span class="line">			ip_options_build(skb, &amp;inet_opt-&gt;opt, inet-&gt;inet_daddr, rt, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ip_select_ident_segs(net, skb, sk,</span><br><span class="line">				     skb_shinfo(skb)-&gt;gso_segs ?: <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* TODO : should we use skb-&gt;sk here instead of sk ? */</span></span><br><span class="line">		skb-&gt;priority = sk-&gt;sk_priority;</span><br><span class="line">		skb-&gt;mark = sk-&gt;sk_mark;</span><br><span class="line"></span><br><span class="line">		res = ip_local_out(net, sk, skb);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	no_route:</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		IP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES);</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		<span class="keyword">return</span> -EHOSTUNREACH;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ip_local_out</code>首先要通过<code>LOCAL_OUT</code>的模块进行包过滤, 如果可以通过, 则会调直接通过<code>dst_out</code>将数据发送出去</p>
<blockquote>
<p>有关Linux Netfilter框架的介绍可以参考Wiki百科的文章<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Netfilter">https://en.wikipedia.org/wiki/Netfilter</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ip_output.c</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ip_local_out</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">		err = __ip_local_out(net, sk, skb);</span><br><span class="line">		<span class="keyword">if</span> (likely(err == <span class="number">1</span>))</span><br><span class="line">			err = dst_output(net, sk, skb);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> __ip_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)</span><br><span class="line">      &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> =</span> ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">		iph-&gt;tot_len = htons(skb-&gt;len);</span><br><span class="line">		ip_send_check(iph);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* if egress device is enslaved to an L3 master device pass the</span></span><br><span class="line"><span class="comment">		 * skb to its handler for processing</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		skb = l3mdev_ip_out(sk, skb);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		skb-&gt;protocol = htons(ETH_P_IP);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// nf_hook如果返回1, 则表示包可以正常通过, 否则被拒绝, 无法发送出去</span></span><br><span class="line">		<span class="keyword">return</span> nf_hook(NFPROTO_IPV4, NF_INET_LOCAL_OUT,</span><br><span class="line">			       net, sk, skb, <span class="literal">NULL</span>, skb_dst(skb)-&gt;dev,</span><br><span class="line">			       dst_output);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>dst_output</code>实际调用了<code>skb-&gt;dst_entry</code>的<code>output</code>函数把包发出去而已, 那么, <code>struct dst_entry</code>这个接口又是在何时初始化的? 从<code>struct dst_entry</code>的定义来看, 我们知道这个是表示<code>struct skb_buff</code>的出去的路由信息, 因此可以推断出<code>dst_entry-&gt;output</code>这个接口应该是在路由查找的过程中赋值的.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// dst.h</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dst_output</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> skb_dst(skb)-&gt;output(net, sk, skb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>继续看下<code>route.c</code>中的<code>rt_dst_alloc</code>函数, 可以看到这个<code>output</code>函数就是在路由初始化的时候根据目标地址的类型来赋值的, 如果是本地的数据, 则赋值为<code>ip_local_deliver</code>; 如果是是广播数据, 则是<code>ip_mc_output</code>, 其他的则为<code>ip_output</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// route.c</span></span><br><span class="line">	<span class="function">struct rtable *<span class="title">rt_dst_alloc</span><span class="params">(struct net_device *dev,</span></span></span><br><span class="line"><span class="params"><span class="function">				    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, u16 type,</span></span></span><br><span class="line"><span class="params"><span class="function">				    <span class="keyword">bool</span> nopolicy, <span class="keyword">bool</span> noxfrm, <span class="keyword">bool</span> will_cache)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span>;</span></span><br><span class="line"></span><br><span class="line">		rt = dst_alloc(&amp;ipv4_dst_ops, dev, <span class="number">1</span>, DST_OBSOLETE_FORCE_CHK,</span><br><span class="line">			       (will_cache ? <span class="number">0</span> : DST_HOST) |</span><br><span class="line">			       (nopolicy ? DST_NOPOLICY : <span class="number">0</span>) |</span><br><span class="line">			       (noxfrm ? DST_NOXFRM : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rt) &#123;</span><br><span class="line">			rt-&gt;rt_genid = rt_genid_ipv4(dev_net(dev));</span><br><span class="line">			rt-&gt;rt_flags = flags;</span><br><span class="line">			rt-&gt;rt_type = type;</span><br><span class="line">			rt-&gt;rt_is_input = <span class="number">0</span>;</span><br><span class="line">			rt-&gt;rt_iif = <span class="number">0</span>;</span><br><span class="line">			rt-&gt;rt_pmtu = <span class="number">0</span>;</span><br><span class="line">			rt-&gt;rt_mtu_locked = <span class="number">0</span>;</span><br><span class="line">			rt-&gt;rt_gateway = <span class="number">0</span>;</span><br><span class="line">			rt-&gt;rt_uses_gateway = <span class="number">0</span>;</span><br><span class="line">			rt-&gt;rt_table_id = <span class="number">0</span>;</span><br><span class="line">			INIT_LIST_HEAD(&amp;rt-&gt;rt_uncached);</span><br><span class="line"></span><br><span class="line">			rt-&gt;dst.output = ip_output;</span><br><span class="line">			<span class="keyword">if</span> (flags &amp; RTCF_LOCAL)</span><br><span class="line">				rt-&gt;dst.input = ip_local_deliver;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> rt;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ip_output</code>在确定好链路层的协议<code>ETH_P_IP</code>后, 通过<code>NF_HOOK_COND</code>进入<code>POSTROUTING</code>的NETFILETER模块, 如果包可以正常通过过滤, 则会调用<code>ip_finish_output</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ip_output.c</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ip_output</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> skb_dst(skb)-&gt;dev;</span><br><span class="line"></span><br><span class="line">		IP_UPD_PO_STATS(net, IPSTATS_MIB_OUT, skb-&gt;len);</span><br><span class="line"></span><br><span class="line">		skb-&gt;dev = dev;</span><br><span class="line">		skb-&gt;protocol = htons(ETH_P_IP);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING,</span><br><span class="line">				    net, sk, skb, <span class="literal">NULL</span>, dev,</span><br><span class="line">				    ip_finish_output,</span><br><span class="line">				    !(IPCB(skb)-&gt;flags &amp; IPSKB_REROUTED));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ip_finish_output</code>主要做两个事情:</p>
<ul>
<li>确认是否有<code>SNAT</code>, 如果有就进行调用<code>dst_output</code>进行处理(SNAT一般在POSTROUTING过滤阶段完成)</li>
<li>skb的长度是否超过了当前网络的MTU, 如果是则需要进行分片处理, 否则通过<code>ip_finish_output2</code>将包发送出去</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ip_output.c </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ip_finish_output</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mtu;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = BPF_CGROUP_RUN_PROG_INET_EGRESS(sk, skb);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_NETFILTER) &amp;&amp; defined(CONFIG_XFRM)</span></span><br><span class="line">	<span class="comment">/* Policy lookup after SNAT yielded a new policy */</span></span><br><span class="line">	<span class="keyword">if</span> (skb_dst(skb)-&gt;xfrm) &#123;</span><br><span class="line">		IPCB(skb)-&gt;flags |= IPSKB_REROUTED;</span><br><span class="line">		<span class="keyword">return</span> dst_output(net, sk, skb);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	mtu = ip_skb_dst_mtu(sk, skb);</span><br><span class="line">	<span class="keyword">if</span> (skb_is_gso(skb))</span><br><span class="line">		<span class="keyword">return</span> ip_finish_output_gso(net, sk, skb, mtu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;len &gt; mtu || (IPCB(skb)-&gt;flags &amp; IPSKB_FRAG_PMTU))</span><br><span class="line">		<span class="keyword">return</span> ip_fragment(net, sk, skb, mtu, ip_finish_output2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ip_finish_output2(net, sk, skb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到<code>ip_finish_output2</code>这里实际已经到了数据链路层了, 其主要的作用是找到数据需要发送的下一个<code>邻居</code>: 简单来说就是要根据下一跳的路由信息找到数据包发送下一个目标节点的MAC地址, 比如默认网关, 路由器等MAC地址; 对于IPv4协议来说, IP地址与MAC的对应关系是通过ARP(Address Resolution Protocol)来实现的; 而IPv6则是通过NDP(Neighbour Discovery Protocol)协议来实现的. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">// ip_output.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ip_finish_output2</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dst_entry</span> *<span class="title">dst</span> =</span> skb_dst(skb);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span> =</span> (struct rtable *)dst;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> dst-&gt;dev;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hh_len = LL_RESERVED_SPACE(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">neighbour</span> *<span class="title">neigh</span>;</span></span><br><span class="line">	u32 nexthop;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rt-&gt;rt_type == RTN_MULTICAST) &#123;</span><br><span class="line">		IP_UPD_PO_STATS(net, IPSTATS_MIB_OUTMCAST, skb-&gt;len);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rt-&gt;rt_type == RTN_BROADCAST)</span><br><span class="line">		IP_UPD_PO_STATS(net, IPSTATS_MIB_OUTBCAST, skb-&gt;len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Be paranoid, rather than too clever. */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(skb_headroom(skb) &lt; hh_len &amp;&amp; dev-&gt;header_ops)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb2</span>;</span></span><br><span class="line"></span><br><span class="line">		skb2 = skb_realloc_headroom(skb, LL_RESERVED_SPACE(dev));</span><br><span class="line">		<span class="keyword">if</span> (!skb2) &#123;</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;sk)</span><br><span class="line">			skb_set_owner_w(skb2, skb-&gt;sk);</span><br><span class="line">		consume_skb(skb);</span><br><span class="line">		skb = skb2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lwtunnel_xmit_redirect(dst-&gt;lwtstate)) &#123;</span><br><span class="line">		<span class="keyword">int</span> res = lwtunnel_xmit(skb);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (res &lt; <span class="number">0</span> || res == LWTUNNEL_XMIT_DONE)</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock_bh();</span><br><span class="line">	<span class="comment">// 通过nexthop来找到对应的neighbour, 如果没有则创建一个新的, 并发起ARP请求</span></span><br><span class="line">	nexthop = (__force u32) rt_nexthop(rt, ip_hdr(skb)-&gt;daddr);</span><br><span class="line">	neigh = __ipv4_neigh_lookup_noref(dev, nexthop);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!neigh))</span><br><span class="line">		neigh = __neigh_create(&amp;arp_tbl, &amp;nexthop, dev, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(neigh)) &#123;</span><br><span class="line">		<span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">		sock_confirm_neigh(skb, neigh);</span><br><span class="line">		res = neigh_output(neigh, skb);</span><br><span class="line"></span><br><span class="line">		rcu_read_unlock_bh();</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_read_unlock_bh();</span><br><span class="line"></span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果<code>struct neighbour</code>已经做了ARP解析, 并且是可用状态, 则通过<code>neigh_hh_output</code>直接把数据发送给对应的网络设备, 如果不可用, 则先要通过<code>n-&gt;output</code>执行ARP解析后才能发送. 有关<code>struct neighbour</code>中的接口初始化可以参考<code>arp.c</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// neighbour.h</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">neigh_output</span><span class="params">(struct neighbour *n, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">hh_cache</span> *<span class="title">hh</span> =</span> &amp;n-&gt;hh;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((n-&gt;nud_state &amp; NUD_CONNECTED) &amp;&amp; hh-&gt;hh_len)</span><br><span class="line">			<span class="keyword">return</span> neigh_hh_output(hh, skb);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> n-&gt;output(n, skb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数<code>neigh_hh_output</code>只是把网络设备的MAC地址保存到链路层协议头上, 然后通过<code>dev_queue_xmit</code>把数据发送给驱动层. 至此数据还需要经过队列优先级(QoS)处理, 然后就可以通过驱动发送出去了.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// neighbour.h</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">neigh_hh_output</span><span class="params">(<span class="keyword">const</span> struct hh_cache *hh, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> hh_alen = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> seq;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> hh_len;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			seq = read_seqbegin(&amp;hh-&gt;hh_lock);</span><br><span class="line">			hh_len = READ_ONCE(hh-&gt;hh_len);</span><br><span class="line">			<span class="keyword">if</span> (likely(hh_len &lt;= HH_DATA_MOD)) &#123;</span><br><span class="line">				hh_alen = HH_DATA_MOD;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* skb_push() would proceed silently if we have room for</span></span><br><span class="line"><span class="comment">				 * the unaligned size but not for the aligned size:</span></span><br><span class="line"><span class="comment">				 * check headroom explicitly.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">if</span> (likely(skb_headroom(skb) &gt;= HH_DATA_MOD)) &#123;</span><br><span class="line">					<span class="comment">/* this is inlined by gcc */</span></span><br><span class="line">					<span class="built_in">memcpy</span>(skb-&gt;data - HH_DATA_MOD, hh-&gt;hh_data,</span><br><span class="line">					       HH_DATA_MOD);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				hh_alen = HH_DATA_ALIGN(hh_len);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (likely(skb_headroom(skb) &gt;= hh_alen)) &#123;</span><br><span class="line">					<span class="built_in">memcpy</span>(skb-&gt;data - hh_alen, hh-&gt;hh_data,</span><br><span class="line">					       hh_alen);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (read_seqretry(&amp;hh-&gt;hh_lock, seq));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(skb_headroom(skb) &lt; hh_alen)) &#123;</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			<span class="keyword">return</span> NET_XMIT_DROP;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		__skb_push(skb, hh_len);</span><br><span class="line">		<span class="keyword">return</span> dev_queue_xmit(skb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="最后的旅程-优先级队列QoS与软中断"><a href="#最后的旅程-优先级队列QoS与软中断" class="headerlink" title="最后的旅程: 优先级队列QoS与软中断"></a><strong>最后的旅程: 优先级队列QoS与软中断</strong></h3><p>发送的数据包在达到网络设备之前, 还需要经过一个优先级队列进行流量控制与调度, 然后再通过触发软中断才会最终发送出去.优先级队列的作用是对发送数据包进行流量整形, 调度, 确保数据包可以更优先地发送出去. 有关Linux中的流量控制可以参考:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://tldp.org/HOWTO/Traffic-Control-HOWTO/overview.html">Linux Traffic Control -HOWTO</a></li>
<li><a target="_blank" rel="noopener" href="https://netbeez.net/blog/how-to-use-the-linux-traffic-control/">How to use Linux Traffic Contro</a></li>
</ul>
<p>Linux内核默认使用了pfifo队列来实现流量控制, pfifo类似与fifo(先进先出), 只是在此基础上把队列根据数据包的优先级(这个优先级就是根据IP协议头中的TOS映射过来的)将包分别放到三个优先级队列中, 然后再根据对应的优先级进行出队的操作. </p>
<p>函数<code>dev_queue_xmit</code>实际调用了另外一个函数<code>__dev_queue_xmit</code>进行数据的发送; <code>__dev_queue_xmit</code>首先确认<code>Qdisc</code>是否有定义了入队<code>enqueue</code>函数, 如果有定义则通过<code>__dev_xmit_skb</code>压入队列；如果没有, 则直接发送到网络设备驱动<code>dev_hard_start_xmit</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">// dev.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dev_queue_xmit</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __dev_queue_xmit(skb, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __dev_queue_xmit(struct sk_buff *skb, <span class="keyword">void</span> *accel_priv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> skb-&gt;dev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netdev_queue</span> *<span class="title">txq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span> *<span class="title">q</span>;</span></span><br><span class="line">	<span class="keyword">int</span> rc = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	skb_reset_mac_header(skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(skb_shinfo(skb)-&gt;tx_flags &amp; SKBTX_SCHED_TSTAMP))</span><br><span class="line">		__skb_tstamp_tx(skb, <span class="literal">NULL</span>, skb-&gt;sk, SCM_TSTAMP_SCHED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Disable soft irqs for various locks below. Also</span></span><br><span class="line"><span class="comment">	 * stops preemption for RCU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rcu_read_lock_bh();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 更新skbuff的优先级(根据cgroup定义的优先级)</span></span><br><span class="line">	skb_update_prio(skb);</span><br><span class="line"></span><br><span class="line">	qdisc_pkt_len_init(skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If device/qdisc don&#x27;t need skb-&gt;dst, release it right now while</span></span><br><span class="line"><span class="comment">	 * its hot in this cpu cache.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;priv_flags &amp; IFF_XMIT_DST_RELEASE)</span><br><span class="line">		skb_dst_drop(skb);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		skb_dst_force(skb);</span><br><span class="line"></span><br><span class="line">	txq = netdev_pick_tx(dev, skb, accel_priv);</span><br><span class="line">	q = rcu_dereference_bh(txq-&gt;qdisc);</span><br><span class="line"></span><br><span class="line">	trace_net_dev_queue(skb);</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;enqueue) &#123;</span><br><span class="line">		rc = __dev_xmit_skb(skb, q, dev, txq);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The device has no queue. Common case for software devices:</span></span><br><span class="line"><span class="comment">	 * loopback, all the sorts of tunnels...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 * Really, it is unlikely that netif_tx_lock protection is necessary</span></span><br><span class="line"><span class="comment">	 * here.  (f.e. loopback and IP tunnels are clean ignoring statistics</span></span><br><span class="line"><span class="comment">	 * counters.)</span></span><br><span class="line"><span class="comment">	 * However, it is possible, that they rely on protection</span></span><br><span class="line"><span class="comment">	 * made by us here.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 * Check this and shot the lock. It is not prone from deadlocks.</span></span><br><span class="line"><span class="comment">	 *Either shot noqueue qdisc, it is even simpler 8)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;flags &amp; IFF_UP) &#123;</span><br><span class="line">		<span class="keyword">int</span> cpu = smp_processor_id(); <span class="comment">/* ok because BHs are off */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (txq-&gt;xmit_lock_owner != cpu) &#123;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(__this_cpu_read(xmit_recursion) &gt;</span><br><span class="line">				     XMIT_RECURSION_LIMIT))</span><br><span class="line">				<span class="keyword">goto</span> recursion_alert;</span><br><span class="line"></span><br><span class="line">			skb = validate_xmit_skb(skb, dev);</span><br><span class="line">			<span class="keyword">if</span> (!skb)</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">			HARD_TX_LOCK(dev, txq, cpu);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!netif_xmit_stopped(txq)) &#123;</span><br><span class="line">				__this_cpu_inc(xmit_recursion);</span><br><span class="line">				skb = dev_hard_start_xmit(skb, dev, txq, &amp;rc);</span><br><span class="line">				__this_cpu_dec(xmit_recursion);</span><br><span class="line">				<span class="keyword">if</span> (dev_xmit_complete(rc)) &#123;</span><br><span class="line">					HARD_TX_UNLOCK(dev, txq);</span><br><span class="line">					<span class="keyword">goto</span> out;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			HARD_TX_UNLOCK(dev, txq);</span><br><span class="line">			net_crit_ratelimited(<span class="string">&quot;Virtual device %s asks to queue packet!\n&quot;</span>,</span><br><span class="line">					     dev-&gt;name);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Recursion is detected! It is possible,</span></span><br><span class="line"><span class="comment">			 * unfortunately</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">recursion_alert:</span><br><span class="line">			net_crit_ratelimited(<span class="string">&quot;Dead loop on virtual device %s, fix it urgently!\n&quot;</span>,</span><br><span class="line">					     dev-&gt;name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rc = -ENETDOWN;</span><br><span class="line">	rcu_read_unlock_bh();</span><br><span class="line"></span><br><span class="line">	atomic_long_inc(&amp;dev-&gt;tx_dropped);</span><br><span class="line">	kfree_skb_list(skb);</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">out:</span><br><span class="line">	rcu_read_unlock_bh();</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>__dev_xmit_skb</code>根据队列的状态来执行数据的发送:</p>
<ul>
<li>如果队列处于非激活状态, 比如网卡处于down状态, 则直接丢弃数据</li>
<li>如果当前队列为空且没有在执行状态, 则选择直接发送数据到网卡驱动</li>
<li>否则先将数据入队, 然后执行<code>__qdisc_run</code>, 把数据从队列中一一取出, 触发软中断数据发送流程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// dev.c</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,</span><br><span class="line">					 struct net_device *dev,</span><br><span class="line">					 struct netdev_queue *txq)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">spinlock_t</span> *root_lock = qdisc_lock(q);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">to_free</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">bool</span> contended;</span><br><span class="line">		<span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">		qdisc_calculate_pkt_len(skb, q);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Heuristic to force contended enqueues to serialize on a</span></span><br><span class="line"><span class="comment">		 * separate lock before trying to get qdisc main lock.</span></span><br><span class="line"><span class="comment">		 * This permits qdisc-&gt;running owner to get the lock more</span></span><br><span class="line"><span class="comment">		 * often and dequeue packets faster.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		contended = qdisc_is_running(q);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(contended))</span><br><span class="line">			spin_lock(&amp;q-&gt;busylock);</span><br><span class="line"></span><br><span class="line">		spin_lock(root_lock);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(test_bit(__QDISC_STATE_DEACTIVATED, &amp;q-&gt;state))) &#123;</span><br><span class="line">			__qdisc_drop(skb, &amp;to_free);</span><br><span class="line">			rc = NET_XMIT_DROP;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((q-&gt;flags &amp; TCQ_F_CAN_BYPASS) &amp;&amp; !qdisc_qlen(q) &amp;&amp;</span><br><span class="line">			   qdisc_run_begin(q)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * This is a work-conserving queue; there are no old skbs</span></span><br><span class="line"><span class="comment">			 * waiting to be sent out; and the qdisc is not running -</span></span><br><span class="line"><span class="comment">			 * xmit the skb directly.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"></span><br><span class="line">			qdisc_bstats_update(q, skb);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (sch_direct_xmit(skb, q, dev, txq, root_lock, <span class="literal">true</span>)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (unlikely(contended)) &#123;</span><br><span class="line">					spin_unlock(&amp;q-&gt;busylock);</span><br><span class="line">					contended = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				__qdisc_run(q);</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">				qdisc_run_end(q);</span><br><span class="line"></span><br><span class="line">			rc = NET_XMIT_SUCCESS;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			rc = q-&gt;enqueue(skb, q, &amp;to_free) &amp; NET_XMIT_MASK;</span><br><span class="line">			<span class="keyword">if</span> (qdisc_run_begin(q)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (unlikely(contended)) &#123;</span><br><span class="line">					spin_unlock(&amp;q-&gt;busylock);</span><br><span class="line">					contended = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				__qdisc_run(q);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		spin_unlock(root_lock);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(to_free))</span><br><span class="line">			kfree_skb_list(to_free);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(contended))</span><br><span class="line">			spin_unlock(&amp;q-&gt;busylock);</span><br><span class="line">		<span class="keyword">return</span> rc;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数<code>__qdisc_run</code>需要做的就是不断从优先级队列中取出包, 然后通过<code>sch_direct_xmit</code>直接发送到驱动(这里不再贴出具体代码, 有兴趣的可以参考<code>dev.c</code>/<code>sch_generic.c</code>两个文件的实现. 如果发送的数据达到了设备设定的配额(Linux默认网卡数据发送配额为64), 或者其他CPU被其他优先级高的任务抢占后, 则调用<code>__netif_schedule</code>执行软中断任务.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// sch_generic.c</span></span><br><span class="line">	<span class="keyword">void</span> __qdisc_run(struct Qdisc *q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> quota = dev_tx_weight;</span><br><span class="line">		<span class="keyword">int</span> packets;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (qdisc_restart(q, &amp;packets)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Ordered by possible occurrence: Postpone processing if</span></span><br><span class="line"><span class="comment">			 * 1. we&#x27;ve exceeded packet quota</span></span><br><span class="line"><span class="comment">			 * 2. another process needs the CPU;</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			quota -= packets;</span><br><span class="line">			<span class="keyword">if</span> (quota &lt;= <span class="number">0</span> || need_resched()) &#123;</span><br><span class="line">				__netif_schedule(q);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		qdisc_run_end(q);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>__netif_schedule</code>首先检查到优先级队列<code>Qdisc</code>是否处于非调度状态, 然后就通过<code>__netif_reschedule</code>执行软中触发调度:</p>
<ul>
<li>保存并禁止本地中断<code>local_irq_save</code></li>
<li>获取当前CPU的<code>struct softnet_data</code>数据, 把需要调度的<code>Qdisc</code>优先级队列放到发送队列末尾</li>
<li>发送一个软中断信号<code>raise_softirq_irqoff(NET_TX_SOFTIRQ)</code>, 恢复本地中断</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// dev.c</span></span><br><span class="line">	<span class="keyword">void</span> __netif_schedule(struct Qdisc *q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!test_and_set_bit(__QDISC_STATE_SCHED, &amp;q-&gt;state))</span><br><span class="line">			__netif_reschedule(q);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> __netif_reschedule(struct Qdisc *q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">		local_irq_save(flags);</span><br><span class="line">		sd = this_cpu_ptr(&amp;softnet_data);</span><br><span class="line">		q-&gt;next_sched = <span class="literal">NULL</span>;</span><br><span class="line">		*sd-&gt;output_queue_tailp = q;</span><br><span class="line">		sd-&gt;output_queue_tailp = &amp;q-&gt;next_sched;</span><br><span class="line">		raise_softirq_irqoff(NET_TX_SOFTIRQ);</span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>软中断的初始化在内核启动的时候初始化完成的, 可以参考<code>dev.c</code>; <code>net_tx_action</code>对应发送软中断的处理函数, 其主要做两件事情:</p>
<ul>
<li>检查发送完成队列<code>completion_queue</code>是否有需要释放的<code>skb_buf</code>, 如果有就释放掉对应的内存</li>
<li>从本地CPU<code>struct softnet_data</code>中获取对应的发送队列<code>output_queue</code>数据, 不断通过<code>qdisc_run</code>发送到驱动中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// dev.c</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> __latent_entropy <span class="keyword">void</span> <span class="title">net_tx_action</span><span class="params">(struct softirq_action *h)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> =</span> this_cpu_ptr(&amp;softnet_data);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (sd-&gt;completion_queue) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">clist</span>;</span></span><br><span class="line"></span><br><span class="line">			local_irq_disable();</span><br><span class="line">			clist = sd-&gt;completion_queue;</span><br><span class="line">			sd-&gt;completion_queue = <span class="literal">NULL</span>;</span><br><span class="line">			local_irq_enable();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (clist) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> =</span> clist;</span><br><span class="line"></span><br><span class="line">				clist = clist-&gt;next;</span><br><span class="line"></span><br><span class="line">				WARN_ON(refcount_read(&amp;skb-&gt;users));</span><br><span class="line">				<span class="keyword">if</span> (likely(get_kfree_skb_cb(skb)-&gt;reason == SKB_REASON_CONSUMED))</span><br><span class="line">					trace_consume_skb(skb);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					trace_kfree_skb(skb, net_tx_action);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (skb-&gt;fclone != SKB_FCLONE_UNAVAILABLE)</span><br><span class="line">					__kfree_skb(skb);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					__kfree_skb_defer(skb);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			__kfree_skb_flush();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (sd-&gt;output_queue) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span> *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line">			local_irq_disable();</span><br><span class="line">			head = sd-&gt;output_queue;</span><br><span class="line">			sd-&gt;output_queue = <span class="literal">NULL</span>;</span><br><span class="line">			sd-&gt;output_queue_tailp = &amp;sd-&gt;output_queue;</span><br><span class="line">			local_irq_enable();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (head) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span> *<span class="title">q</span> =</span> head;</span><br><span class="line">				<span class="keyword">spinlock_t</span> *root_lock;</span><br><span class="line"></span><br><span class="line">				head = head-&gt;next_sched;</span><br><span class="line"></span><br><span class="line">				root_lock = qdisc_lock(q);</span><br><span class="line">				spin_lock(root_lock);</span><br><span class="line">				<span class="comment">/* We need to make sure head-&gt;next_sched is read</span></span><br><span class="line"><span class="comment">				 * before clearing __QDISC_STATE_SCHED</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				smp_mb__before_atomic();</span><br><span class="line">				clear_bit(__QDISC_STATE_SCHED, &amp;q-&gt;state);</span><br><span class="line">				qdisc_run(q);</span><br><span class="line">				spin_unlock(root_lock);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此, 数据的发送就完成了. 感兴趣的话,可以选择某个特定设备的驱动看下驱动层是如何处理数据的发送的. 相信跟着Linux源代码流程, 我们对Linux内核协议栈也有了大致的了解, 如果想要深入某个模块进行了解, 读源码的同时结合相关协议的文档, 相信会有更多的收获.</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.embeddedlinux.org.cn/linux_net/">Understanding Linux Network Internals</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html">里边有很多源码的分析, 值得参考</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/">Linux 内核数据发送流程解析</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Jason Wang
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://sniffer.site/2021/04/08/Linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B/" title="Linux网络协议之数据发送流程">https://sniffer.site/2021/04/08/Linux网络协议之数据发送流程/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/TCP-IP/" rel="tag"># TCP/IP</a>
              <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/" rel="tag"># 网络协议栈</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/02/20/ADB%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/" rel="prev" title="一个ADB无法识别设备的问题">
                  <i class="fa fa-chevron-left"></i> 一个ADB无法识别设备的问题
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/04/29/%E4%BB%8EWifi%E7%83%AD%E7%82%B9%E5%8A%9F%E8%83%BD%E8%AF%B4%E4%B8%80%E8%AF%B4Android-Wifi%E6%A1%86%E6%9E%B6/" rel="next" title="从Wifi热点功能说一说Android Wifi框架">
                  从Wifi热点功能说一说Android Wifi框架 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC8yOTM5NS81OTYz"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason Wang</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
  <script src="https://embed.widgetpack.com/widget.js" async></script>
  <script class="next-config" data-name="rating" type="application/json">{"enable":true,"id":32167,"color":"#fc6423"}</script>
  <script src="/js/third-party/rating.js"></script>
<script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.10.3/dist/algoliasearch-lite.umd.js" integrity="sha256-G3d8uGe8RUBl42fj30KOUgKMV2LpwsJUI3fzfEiuHsY=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.25.2/dist/instantsearch.production.min.js" integrity="sha256-h8iRwCCyeIDuVWtR9WwIJ+XJ8Z37SunCvilg+pnImD4=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script>




  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"rVKgtmJD3PpeVCLXgI3MrnXk-gzGzoHsz","app_key":"nj66qROg1RNBE9qxvn1yTFMg","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
