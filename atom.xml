<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasonWang&#39;s Blog</title>
  
  <subtitle>本色做人，角色做事</subtitle>
  <link href="https://sniffer.site/atom.xml" rel="self"/>
  
  <link href="https://sniffer.site/"/>
  <updated>2023-04-18T06:07:52.377Z</updated>
  <id>https://sniffer.site/</id>
  
  <author>
    <name>Jason Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android如何进行DNS解析</title>
    <link href="https://sniffer.site/2023/04/17/Android%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8CDNS%E8%A7%A3%E6%9E%90/"/>
    <id>https://sniffer.site/2023/04/17/Android%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8CDNS%E8%A7%A3%E6%9E%90/</id>
    <published>2023-04-17T08:54:27.000Z</published>
    <updated>2023-04-18T06:07:52.377Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Domain_Name_System"><code>DNS(Domain Name System)</code></a>即域名解析系统，是网络访问时用于将域名解析成对应IP地址的一种分布式网络服务。比如，要访问<code>www.google.com</code>这个域名，<code>Android</code>系统会首先发送一个<code>UDP</code>请求到标准的<code>53</code>端口系统的域名解析服务器，拿到对应的IP地址后才会与服务端建立连接。除了标准的<code>DNS</code>服务外，目前还有<code>HttpDNS</code>(<a href="https://en.wikipedia.org/wiki/DNS_over_HTTPS"><code>DNS over Https, DoH</code></a>)以及基于<code>TSL</code>的<code>DNS</code>服务(<a href="https://datatracker.ietf.org/doc/html/rfc7858"><code>DNS over TLS， DoT</code></a>)。</p><p>那么，<code>Android</code>中<code>DNS</code>解析的大致框架是怎么的？整个<code>DNS</code>解析的流程又是怎么样的？ 在看具体实现细节之前，我们不妨思考一下几个问题，想一想，如果我们自己从零开始为<code>Android</code>设计一个<code>DNS</code>系统，应该怎么做？</p><span id="more"></span><ul><li><code>DNS</code>服务应该何时启动初始化，以何种形式为应用提供服务？</li><li><code>Android</code>中每个应用访问网络都会进行域名解析，如何对解析结果进行缓存，确保同样的域名不会被重复解析？</li><li>不同网络切换时，比如从<code>WIFI</code>切换到<code>4G</code>网络时，<code>DNS</code>解析的缓存应该如何清除？</li></ul><p>带着这几个问题，本文将从三个方面详细阐述下<code>Android</code>中<code>DNS</code>解析的具体原理与实现细节:</p><ul><li><code>DNS</code>服务的初始化</li><li>应用是如何执行域名解析的</li><li>网络变化时，<code>DNS</code>域名解析缓存是如何变化的</li></ul><blockquote><p>本文参考的源码是<code>Android S(12)</code></p></blockquote><h2 id="DNS系统服务的初始化"><a href="#DNS系统服务的初始化" class="headerlink" title="DNS系统服务的初始化"></a><strong>DNS系统服务的初始化</strong></h2><p><code>Android</code>中网络管理的核心服务都是在<a href="https://sniffer.site/2018/12/18/android-netd%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"><code>NETD</code></a>进程中实现的，<code>DNS</code>也不例外。在<code>netd</code>进程初始化时，系统会对<code>DNS</code>服务进行初始化<code>initDnsResolver</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stopwatch s;</span><br><span class="line">    gLog.<span class="built_in">info</span>(<span class="string">&quot;netd 1.0 starting&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Make sure BPF programs are loaded before doing anything</span></span><br><span class="line">    android::bpf::<span class="built_in">waitForProgsLoaded</span>();</span><br><span class="line">    gLog.<span class="built_in">info</span>(<span class="string">&quot;BPF programs are loaded&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Set local DNS mode, to prevent bionic from proxying</span></span><br><span class="line">    <span class="comment">// back to this service, recursively.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Check if we could remove it since resolver cache no loger</span></span><br><span class="line">    <span class="comment">// checks this environment variable after aosp/838050.</span></span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;ANDROID_DNS_MODE&quot;</span>, <span class="string">&quot;local&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Note that only call initDnsResolver after gCtls initializing.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">initDnsResolver</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to init resolver&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MDnsSdListener mdnsl;</span><br><span class="line">    <span class="keyword">if</span> (mdnsl.<span class="built_in">startListener</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to start MDnsSdListener (%s)&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">FwmarkServer <span class="title">fwmarkServer</span><span class="params">(&amp;gCtls-&gt;netCtrl, &amp;gCtls-&gt;eventReporter, &amp;gCtls-&gt;trafficCtrl)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (fwmarkServer.<span class="built_in">startListener</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to start FwmarkServer (%s)&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stopwatch subTime;</span><br><span class="line">    <span class="type">status_t</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = NetdNativeService::<span class="built_in">start</span>()) != android::OK) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to start NetdNativeService: %d&quot;</span>, ret);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    gLog.<span class="built_in">info</span>(<span class="string">&quot;Registering NetdNativeService: %&quot;</span> PRId64 <span class="string">&quot;us&quot;</span>, subTime.<span class="built_in">getTimeAndResetUs</span>());</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    gLog.<span class="built_in">info</span>(<span class="string">&quot;netd exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>initDnsResolver</code>调用<code>resolv_init</code>执行<code>DNS</code>服务的初始化，并注册一个回调函数，用于<code>DNS</code>服务调用时权限检查、获取当前网络ID以及打印日志等:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">initDnsResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResolverNetdCallbacks callbacks = &#123;</span><br><span class="line">            .check_calling_permission = &amp;checkCallingPermissionCallback,</span><br><span class="line">            .get_network_context = &amp;getNetworkContextCallback,</span><br><span class="line">            .log = &amp;logCallback,</span><br><span class="line">            .tagSocket = &amp;tagSocketCallback,</span><br><span class="line">            .evaluate_domain_name = &amp;evaluateDomainNameCallback,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">resolv_init</span>(&amp;callbacks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Android S</code>中<code>DNS</code>服务的代码放在了一个单独的模块<code>packages/modules/DnsResolver</code>中，函数<code>resolv_init</code>就是在模块的<code>DnsResolver.cpp</code>中实现的, 主要是设置日志标记以及打印等级，核心逻辑是创建一个<code>DnsResolver</code>对象，并启动<code>DNS</code>服务:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">resolv_init</span><span class="params">(<span class="type">const</span> ResolverNetdCallbacks* callbacks)</span> </span>&#123;</span><br><span class="line">    android::base::<span class="built_in">InitLogging</span>(<span class="comment">/*argv=*/</span><span class="literal">nullptr</span>);</span><br><span class="line">    android::base::<span class="built_in">SetDefaultTag</span>(<span class="string">&quot;libnetd_resolv&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: Initializing resolver&quot;</span>;</span><br><span class="line">    <span class="comment">// TODO(b/170539625): restore log level to WARNING after clarifying flaky tests.</span></span><br><span class="line">    <span class="built_in">resolv_set_log_severity</span>(<span class="built_in">isUserDebugBuild</span>() ? android::base::DEBUG : android::base::WARNING);</span><br><span class="line">    <span class="keyword">using</span> android::net::gApiLevel;</span><br><span class="line">    gApiLevel = <span class="built_in">getApiLevel</span>();</span><br><span class="line">    <span class="keyword">using</span> android::net::gResNetdCallbacks;</span><br><span class="line">    gResNetdCallbacks.check_calling_permission = callbacks-&gt;check_calling_permission;</span><br><span class="line">    gResNetdCallbacks.get_network_context = callbacks-&gt;get_network_context;</span><br><span class="line">    gResNetdCallbacks.log = callbacks-&gt;log;</span><br><span class="line">    <span class="keyword">if</span> (gApiLevel &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">        gResNetdCallbacks.tagSocket = callbacks-&gt;tagSocket;</span><br><span class="line">        gResNetdCallbacks.evaluate_domain_name = callbacks-&gt;evaluate_domain_name;</span><br><span class="line">    &#125;</span><br><span class="line">    android::net::gDnsResolv = android::net::DnsResolver::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">return</span> android::net::gDnsResolv-&gt;<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>DNS</code>服务的启动主要完成了三件事情: </p><ul><li>初始化私有DNS功能<code>DnsTlsDispatcher::getInstance()</code></li><li>启动<code>DNS</code>代理服务，启动一个名为<code>dnsproxyd</code>的<code>Unix Socket</code>服务，用于监听应用的域名解析请求</li><li>启动<code>IDnsResolver.aidl</code>的<code>HAL binder</code>服务，主要提供网络切换时设置<code>DNS</code>，创建缓存、清理缓存等接口</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DnsResolver::<span class="built_in">DnsResolver</span>() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> make them member variables after fixing the circular dependency:</span></span><br><span class="line">    <span class="comment">//   DnsTlsDispatcher.h -&gt; resolv_private.h -&gt; DnsResolver.h -&gt; DnsTlsDispatcher.h</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; dnsTlsDispatcher = DnsTlsDispatcher::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">auto</span>&amp; privateDnsConfiguration = PrivateDnsConfiguration::<span class="built_in">getInstance</span>();</span><br><span class="line">    privateDnsConfiguration.<span class="built_in">setObserver</span>(&amp;dnsTlsDispatcher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DnsResolver::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">verifyCallbacks</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: Callback verification failed&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDnsProxyListener.<span class="built_in">startListener</span>()) &#123;</span><br><span class="line">        <span class="built_in">PLOG</span>(ERROR) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: Unable to start DnsProxyListener&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">binder_status_t</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = DnsResolverService::<span class="built_in">start</span>()) != STATUS_OK) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: Unable to start DnsResolverService: &quot;</span> &lt;&lt; ret;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，<code>DNS</code>相关的功能完成了初始化。接下来，我们继续看第二部分: 应用是如何获取到域名的IP地址的。</p><h2 id="应用是如何解析域名的"><a href="#应用是如何解析域名的" class="headerlink" title="应用是如何解析域名的"></a><strong>应用是如何解析域名的</strong></h2><p>在深入细节之前，不妨看下<code>Android</code>中的<code>DNS</code>服务的大致框架。应用通过标准的JAVA接口<code>getAllByName</code>尝试解析域名，然后通过JNI调用<code>libc</code>中的接口，<code>libc</code>负责将域名解析请求通过名为<code>dnsproxyd</code>的<code>Unix Socket</code>发送给<code>DNS</code>代理服务，<code>DNS</code>服务查询到对应域名的IP地址列表再通过<code>socket</code>接口返回给应用。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/how_android_dns_works.png" alt="Android DNS服务框架"></p><ul><li>应用调用<code>InetAddress.getAllByName</code>获取域名对应的IP列表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* The implementation is always dual stack IPv6/IPv4 on android */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">InetAddressImpl</span> <span class="variable">impl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inet6AddressImpl</span>();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress[] getAllByName(String host)</span><br><span class="line">    <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">    <span class="comment">// Android-changed: Resolves a hostname using Libcore.os.</span></span><br><span class="line">    <span class="comment">// Also, returns both the Inet4 and Inet6 loopback for null/empty host</span></span><br><span class="line">    <span class="keyword">return</span> impl.lookupAllHostAddr(host, NETID_UNSET).clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>尝试从JAVA中的缓存中获取IP地址，如果没有缓存，则尝试解析域名, 并将结果保存到缓存中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resolves a hostname to its IP addresses using a cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InetAddress[] lookupHostByName(String host, <span class="type">int</span> netId)</span><br><span class="line">        <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">    BlockGuard.getThreadPolicy().onNetwork();</span><br><span class="line">    <span class="comment">// Do we have a result cached?</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cachedResult</span> <span class="operator">=</span> addressCache.get(host, netId);</span><br><span class="line">    <span class="keyword">if</span> (cachedResult != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedResult <span class="keyword">instanceof</span> InetAddress[]) &#123;</span><br><span class="line">            <span class="comment">// A cached positive result.</span></span><br><span class="line">            <span class="keyword">return</span> (InetAddress[]) cachedResult;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// A cached negative result.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnknownHostException</span>((String) cachedResult);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">StructAddrinfo</span> <span class="variable">hints</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StructAddrinfo</span>();</span><br><span class="line">        hints.ai_flags = AI_ADDRCONFIG;</span><br><span class="line">        hints.ai_family = AF_UNSPEC;</span><br><span class="line">        <span class="comment">// If we don&#x27;t specify a socket type, every address will appear twice, once</span></span><br><span class="line">        <span class="comment">// for SOCK_STREAM and one for SOCK_DGRAM. Since we do not return the family</span></span><br><span class="line">        <span class="comment">// anyway, just pick one.</span></span><br><span class="line">        hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">        InetAddress[] addresses = Libcore.os.android_getaddrinfo(host, hints, netId);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> should getaddrinfo set the hostname of the InetAddresses it returns?</span></span><br><span class="line">        <span class="keyword">for</span> (InetAddress address : addresses) &#123;</span><br><span class="line">            address.holder().hostName = host;</span><br><span class="line">            address.holder().originalHostName = host;</span><br><span class="line">        &#125;</span><br><span class="line">        addressCache.put(host, netId, addresses);</span><br><span class="line">        <span class="keyword">return</span> addresses;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (GaiException gaiException) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>Libcore.os.android_getaddrinfo</code>调用<code>libc</code>中的<code>DNS</code>接口<code>android_getaddrinfofornet</code>尝试解析域名:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> jobjectArray <span class="title">Linux_android_getaddrinfo</span><span class="params">(JNIEnv* env, jobject, jstring javaNode,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject javaHints, jint netId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    addrinfo hints;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="built_in">sizeof</span>(hints));</span><br><span class="line">    hints.ai_flags = env-&gt;<span class="built_in">GetIntField</span>(javaHints, flagsFid);</span><br><span class="line">    hints.ai_family = env-&gt;<span class="built_in">GetIntField</span>(javaHints, familyFid);</span><br><span class="line">    hints.ai_socktype = env-&gt;<span class="built_in">GetIntField</span>(javaHints, socktypeFid);</span><br><span class="line">    hints.ai_protocol = env-&gt;<span class="built_in">GetIntField</span>(javaHints, protocolFid);</span><br><span class="line"></span><br><span class="line">    addrinfo* addressList = <span class="literal">NULL</span>;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rc = <span class="built_in">android_getaddrinfofornet</span>(node.<span class="built_in">c_str</span>(), <span class="literal">NULL</span>, &amp;hints, netId, <span class="number">0</span>, &amp;addressList);</span><br><span class="line">    <span class="function">std::unique_ptr&lt;addrinfo, addrinfo_deleter&gt; <span class="title">addressListDeleter</span><span class="params">(addressList)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">throwGaiException</span>(env, <span class="string">&quot;android_getaddrinfo&quot;</span>, rc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count results so we know how to size the output array.</span></span><br><span class="line">    <span class="type">int</span> addressCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (addrinfo* ai = addressList; ai != <span class="literal">NULL</span>; ai = ai-&gt;ai_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ai-&gt;ai_family == AF_INET || ai-&gt;ai_family == AF_INET6) &#123;</span><br><span class="line">            ++addressCount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;android_getaddrinfo unexpected ai_family %i&quot;</span>, ai-&gt;ai_family);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Prepare output array.</span></span><br><span class="line">    jobjectArray result = env-&gt;<span class="built_in">NewObjectArray</span>(addressCount, JniConstants::<span class="built_in">GetInetAddressClass</span>(env), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Examine returned addresses one by one, save them in the output array.</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (addrinfo* ai = addressList; ai != <span class="literal">NULL</span>; ai = ai-&gt;ai_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ai-&gt;ai_family != AF_INET &amp;&amp; ai-&gt;ai_family != AF_INET6) &#123;</span><br><span class="line">            <span class="comment">// Unknown address family. Skip this address.</span></span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;android_getaddrinfo unexpected ai_family %i&quot;</span>, ai-&gt;ai_family);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert each IP address into a Java byte array.</span></span><br><span class="line">        sockaddr_storage&amp; address = *<span class="built_in">reinterpret_cast</span>&lt;sockaddr_storage*&gt;(ai-&gt;ai_addr);</span><br><span class="line">        <span class="function">ScopedLocalRef&lt;jobject&gt; <span class="title">inetAddress</span><span class="params">(env, sockaddrToInetAddress(env, address, <span class="literal">NULL</span>))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (inetAddress.<span class="built_in">get</span>() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        env-&gt;<span class="built_in">SetObjectArrayElement</span>(result, index, inetAddress.<span class="built_in">get</span>());</span><br><span class="line">        ++index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>继续调用<code>android_getaddrinfofornetcontext</code>:该函数实际通过<code>android_getaddrinfo_proxy</code>将域名解析请求通过<code>dnsproxyd</code>的<code>Unix Socket</code>发送给<code>netd</code>的<code>DNS</code>解析服务:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">__BIONIC_WEAK_FOR_NATIVE_BRIDGE</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">android_getaddrinfofornetcontext</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hostname, <span class="type">const</span> <span class="type">char</span> *servname,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="type">const</span> <span class="keyword">struct</span> android_net_context *netcontext,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> addrinfo **res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">addrinfo</span> *pai;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">explore</span> *ex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* hostname is allowed to be NULL */</span></span><br><span class="line">  <span class="comment">/* servname is allowed to be NULL */</span></span><br><span class="line">  <span class="comment">/* hints is allowed to be NULL */</span></span><br><span class="line">  <span class="built_in">assert</span>(res != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">assert</span>(netcontext != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;sentinel, <span class="number">0</span>, <span class="built_in">sizeof</span>(sentinel));</span><br><span class="line">  cur = &amp;sentinel;</span><br><span class="line">  pai = &amp;ai;</span><br><span class="line">  pai-&gt;ai_flags = <span class="number">0</span>;</span><br><span class="line">  pai-&gt;ai_family = PF_UNSPEC;</span><br><span class="line">  pai-&gt;ai_socktype = ANY;</span><br><span class="line">  pai-&gt;ai_protocol = ANY;</span><br><span class="line">  pai-&gt;ai_addrlen = <span class="number">0</span>;</span><br><span class="line">  pai-&gt;ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">  pai-&gt;ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">  pai-&gt;ai_next = <span class="literal">NULL</span>;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏变量`__ANDROID__`是在`libc`库编译的时候设置的</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">  <span class="type">int</span> gai_error = <span class="built_in">android_getaddrinfo_proxy</span>(</span><br><span class="line">    hostname, servname, hints, res, netcontext-&gt;app_netid);</span><br><span class="line">  <span class="keyword">if</span> (gai_error != EAI_SYSTEM) &#123;</span><br><span class="line">    <span class="keyword">return</span> gai_error;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>函数<code>android_getaddrinfo_proxy</code>首先通过<code>NetdClient</code>中的函数<code>dns_open_proxy</code>创建与<code>DNS</code>服务的<code>socket</code>接口，然后向服务端发送一个<code>getaddrinfo www.google.com x x x x x</code>的指令, 然后尝试读取服务端返回的结果:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// Returns 0 on success, else returns on error.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">android_getaddrinfo_proxy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="type">char</span> *hostname, <span class="type">const</span> <span class="type">char</span> *servname,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **res, <span class="type">unsigned</span> netid)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear this at start, as we use its non-NULLness later (in the</span></span><br><span class="line">    <span class="comment">// error path) to decide if we have to free up any memory we</span></span><br><span class="line">    <span class="comment">// allocated in the process (before failing).</span></span><br><span class="line">    *res = <span class="literal">NULL</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    FILE* proxy = <span class="built_in">fdopen</span>(__netdClientDispatch.<span class="built_in">dnsOpenProxy</span>(), <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (proxy == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> EAI_SYSTEM;</span><br><span class="line">    &#125;</span><br><span class="line">    netid = __netdClientDispatch.<span class="built_in">netIdForResolv</span>(netid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send the request.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fprintf</span>(proxy, <span class="string">&quot;getaddrinfo %s %s %d %d %d %d %u&quot;</span>,</span><br><span class="line">          hostname == <span class="literal">NULL</span> ? <span class="string">&quot;^&quot;</span> : hostname,</span><br><span class="line">          servname == <span class="literal">NULL</span> ? <span class="string">&quot;^&quot;</span> : servname,</span><br><span class="line">          hints == <span class="literal">NULL</span> ? <span class="number">-1</span> : hints-&gt;ai_flags,</span><br><span class="line">          hints == <span class="literal">NULL</span> ? <span class="number">-1</span> : hints-&gt;ai_family,</span><br><span class="line">          hints == <span class="literal">NULL</span> ? <span class="number">-1</span> : hints-&gt;ai_socktype,</span><br><span class="line">          hints == <span class="literal">NULL</span> ? <span class="number">-1</span> : hints-&gt;ai_protocol,</span><br><span class="line">          netid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">// read result code for gethostbyaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="built_in">sizeof</span>(buf), proxy) != <span class="built_in">sizeof</span>(buf)) &#123;</span><br><span class="line">      <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result_code = (<span class="type">int</span>)<span class="built_in">strtol</span>(buf, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// verify the code itself</span></span><br><span class="line">    <span class="keyword">if</span> (result_code != DnsProxyQueryResult) &#123;</span><br><span class="line">      <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="built_in">sizeof</span>(buf), proxy);</span><br><span class="line">      <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span>* ai = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span>** nextres = res;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">int32_t</span> have_more;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">readBE32</span>(proxy, &amp;have_more)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (have_more == <span class="number">0</span>) &#123;</span><br><span class="line">        success = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ai = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> addrinfo) + <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage));</span><br><span class="line">      <span class="keyword">if</span> (ai == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ai-&gt;ai_addr = (<span class="keyword">struct</span> sockaddr*)(ai + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// struct addrinfo &#123;</span></span><br><span class="line">      <span class="comment">//intai_flags;/* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */</span></span><br><span class="line">      <span class="comment">//intai_family;/* PF_xxx */</span></span><br><span class="line">      <span class="comment">//intai_socktype;/* SOCK_xxx */</span></span><br><span class="line">      <span class="comment">//intai_protocol;/* 0 or IPPROTO_xxx for IPv4 and IPv6 */</span></span><br><span class="line">      <span class="comment">//socklen_t ai_addrlen;/* length of ai_addr */</span></span><br><span class="line">      <span class="comment">//char*ai_canonname;/* canonical name for hostname */</span></span><br><span class="line">      <span class="comment">//structsockaddr *ai_addr;/* binary address */</span></span><br><span class="line">      <span class="comment">//structaddrinfo *ai_next;/* next structure in linked list */</span></span><br><span class="line">      <span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Read the struct piece by piece because we might be a 32-bit process</span></span><br><span class="line">      <span class="comment">// talking to a 64-bit netd.</span></span><br><span class="line">      <span class="type">int32_t</span> addr_len;</span><br><span class="line">      <span class="type">bool</span> success =</span><br><span class="line">          <span class="built_in">readBE32</span>(proxy, &amp;ai-&gt;ai_flags) &amp;&amp;</span><br><span class="line">          <span class="built_in">readBE32</span>(proxy, &amp;ai-&gt;ai_family) &amp;&amp;</span><br><span class="line">          <span class="built_in">readBE32</span>(proxy, &amp;ai-&gt;ai_socktype) &amp;&amp;</span><br><span class="line">          <span class="built_in">readBE32</span>(proxy, &amp;ai-&gt;ai_protocol) &amp;&amp;</span><br><span class="line">          <span class="built_in">readBE32</span>(proxy, &amp;addr_len);</span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set ai_addrlen and read the ai_addr data.</span></span><br><span class="line">      ai-&gt;ai_addrlen = addr_len;</span><br><span class="line">      <span class="keyword">if</span> (addr_len != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">size_t</span>) addr_len &gt; <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage)) &#123;</span><br><span class="line">          <span class="comment">// Bogus; too big.</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fread</span>(ai-&gt;ai_addr, addr_len, <span class="number">1</span>, proxy) != <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ai != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">// Clean up partially-built addrinfo that we never ended up</span></span><br><span class="line">      <span class="comment">// attaching to the response.</span></span><br><span class="line">      <span class="built_in">freeaddrinfo</span>(ai);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>服务端的代理<code>DnsProxyListener</code>收到域名解析指令<code>getaddrinfo</code>后，启动一个新的线程处理该请求:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DnsProxyListener::GetAddrInfoCmd::<span class="built_in">GetAddrInfoCmd</span>() : <span class="built_in">FrameworkCommand</span>(<span class="string">&quot;getaddrinfo&quot;</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> DnsProxyListener::GetAddrInfoCmd::<span class="built_in">runCommand</span>(SocketClient* cli, <span class="type">int</span> argc, <span class="type">char</span>** argv) &#123;</span><br><span class="line">    <span class="built_in">logArguments</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* msg = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">asprintf</span>(&amp;msg, <span class="string">&quot;Invalid number of arguments to getaddrinfo: %i&quot;</span>, argc);</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;GetAddrInfoCmd::runCommand: &quot;</span> &lt;&lt; (msg ? msg : <span class="string">&quot;null&quot;</span>);</span><br><span class="line">        cli-&gt;<span class="built_in">sendMsg</span>(ResponseCode::CommandParameterError, msg, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">free</span>(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string name = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">const</span> std::string service = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ai_flags = <span class="built_in">strtol</span>(argv[<span class="number">3</span>], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> ai_family = <span class="built_in">strtol</span>(argv[<span class="number">4</span>], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> ai_socktype = <span class="built_in">strtol</span>(argv[<span class="number">5</span>], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> ai_protocol = <span class="built_in">strtol</span>(argv[<span class="number">6</span>], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">unsigned</span> netId = <span class="built_in">strtoul</span>(argv[<span class="number">7</span>], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> useLocalNameservers = <span class="built_in">checkAndClearUseLocalNameserversFlag</span>(&amp;netId);</span><br><span class="line">    <span class="type">const</span> <span class="type">uid_t</span> uid = cli-&gt;<span class="built_in">getUid</span>();</span><br><span class="line"></span><br><span class="line">    android_net_context netcontext;</span><br><span class="line">    gResNetdCallbacks.<span class="built_in">get_network_context</span>(netId, uid, &amp;netcontext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useLocalNameservers) &#123;</span><br><span class="line">        netcontext.flags |= NET_CONTEXT_FLAG_USE_LOCAL_NAMESERVERS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;addrinfo&gt; hints;</span><br><span class="line">    <span class="keyword">if</span> (ai_flags != <span class="number">-1</span> || ai_family != <span class="number">-1</span> || ai_socktype != <span class="number">-1</span> || ai_protocol != <span class="number">-1</span>) &#123;</span><br><span class="line">        hints.<span class="built_in">reset</span>((addrinfo*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(addrinfo)));</span><br><span class="line">        hints-&gt;ai_flags = ai_flags;</span><br><span class="line">        hints-&gt;ai_family = ai_family;</span><br><span class="line">        hints-&gt;ai_socktype = ai_socktype;</span><br><span class="line">        hints-&gt;ai_protocol = ai_protocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">new</span> <span class="built_in">GetAddrInfoHandler</span>(cli, name, service, <span class="built_in">move</span>(hints), netcontext))-&gt;<span class="built_in">spawn</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>处理域名解析请求的线程执行，首先会通过<code>resolv_getaddrinfo</code>尝试域名解析(如果没有cache，则会向域名解析服务器发送解析请求，这里默认是<code>53</code>的UDP端口)，拿到解析后的IP地址后，通过<code>socket</code>发送地址列表给客户端。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> DnsProxyListener::GetAddrInfoHandler::<span class="built_in">run</span>() &#123;</span><br><span class="line">    addrinfo* result = <span class="literal">nullptr</span>;</span><br><span class="line">    Stopwatch s;</span><br><span class="line">    <span class="built_in">maybeFixupNetContext</span>(&amp;mNetContext, mClient-&gt;<span class="built_in">getPid</span>());</span><br><span class="line">    <span class="type">const</span> <span class="type">uid_t</span> uid = mClient-&gt;<span class="built_in">getUid</span>();</span><br><span class="line">    <span class="type">int32_t</span> rv = <span class="number">0</span>;</span><br><span class="line">    NetworkDnsEventReported event;</span><br><span class="line">    <span class="built_in">initDnsEvent</span>(&amp;event, mNetContext);</span><br><span class="line">    <span class="keyword">if</span> (queryLimiter.<span class="built_in">start</span>(uid)) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* host = mHost.<span class="built_in">starts_with</span>(<span class="string">&#x27;^&#x27;</span>) ? <span class="literal">nullptr</span> : mHost.<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* service = mService.<span class="built_in">starts_with</span>(<span class="string">&#x27;^&#x27;</span>) ? <span class="literal">nullptr</span> : mService.<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">evaluate_domain_name</span>(mNetContext, host)) &#123;</span><br><span class="line">            rv = <span class="built_in">resolv_getaddrinfo</span>(host, service, mHints.<span class="built_in">get</span>(), &amp;mNetContext, &amp;result, &amp;event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rv = EAI_SYSTEM;</span><br><span class="line">        &#125;</span><br><span class="line">        queryLimiter.<span class="built_in">finish</span>(uid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Note that this error code is currently not passed down to the client.</span></span><br><span class="line">        <span class="comment">// android_getaddrinfo_proxy() returns EAI_NODATA on any error.</span></span><br><span class="line">        rv = EAI_MEMORY;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;GetAddrInfoHandler::run: from UID &quot;</span> &lt;&lt; uid</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, max concurrent queries reached&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">doDns64Synthesis</span>(&amp;rv, &amp;result, &amp;event);</span><br><span class="line">    <span class="type">const</span> <span class="type">int32_t</span> latencyUs = <span class="built_in">saturate_cast</span>&lt;<span class="type">int32_t</span>&gt;(s.<span class="built_in">timeTakenUs</span>());</span><br><span class="line">    event.<span class="built_in">set_latency_micros</span>(latencyUs);</span><br><span class="line">    event.<span class="built_in">set_event_type</span>(EVENT_GETADDRINFO);</span><br><span class="line">    event.<span class="built_in">set_hints_ai_flags</span>((mHints ? mHints-&gt;ai_flags : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">        <span class="comment">// getaddrinfo failed</span></span><br><span class="line">        success = !mClient-&gt;<span class="built_in">sendBinaryMsg</span>(ResponseCode::DnsProxyOperationFailed, &amp;rv, <span class="built_in">sizeof</span>(rv));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        success = !mClient-&gt;<span class="built_in">sendCode</span>(ResponseCode::DnsProxyQueryResult);</span><br><span class="line">        addrinfo* ai = result;</span><br><span class="line">        <span class="keyword">while</span> (ai &amp;&amp; success) &#123;</span><br><span class="line">            success = <span class="built_in">sendBE32</span>(mClient, <span class="number">1</span>) &amp;&amp; <span class="built_in">sendaddrinfo</span>(mClient, ai);</span><br><span class="line">            ai = ai-&gt;ai_next;</span><br><span class="line">        &#125;</span><br><span class="line">        success = success &amp;&amp; <span class="built_in">sendBE32</span>(mClient, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">freeaddrinfo</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有关域名解析的具体实现<code>resolv_getaddrinfo</code>可以参考<code>packages/modules/DnsResolver</code>中的代码，这里就不具体展开分析了。</p><h2 id="网络切换时DNS缓存时如何清除的"><a href="#网络切换时DNS缓存时如何清除的" class="headerlink" title="网络切换时DNS缓存时如何清除的"></a><strong>网络切换时DNS缓存时如何清除的</strong></h2><p>发生网络切换时，<code>Android</code>需要确保<code>DNS</code>服务使用了正确的服务器进行域名解析，另外要清除掉之前网络域名解析的缓存，确保两个网络的解析结果是独立的。<code>Android</code>的网络管理都是由<code>ConnectivityService</code>系统服务来完成的，当两个网络发生切换时，<code>ConnectivityService</code>会更新网络的<code>DNS</code>配置, 并清除<code>DNS</code>服务中对应的缓存:</p><ul><li><code>updateLinkProperties</code>时网络状态切换: 设置<code>DNS</code>解析服务器，清除应用自身的缓存</li><li><code>destroyNetwork</code>: 断开网络时，会完全清除系统对应的<code>DNS</code>缓存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateLinkProperties</span><span class="params">(NetworkAgentInfo networkAgent, <span class="meta">@NonNull</span> LinkProperties newLp,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> LinkProperties oldLp)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">netId</span> <span class="operator">=</span> networkAgent.network.getNetId();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (isDefaultNetwork(networkAgent)) &#123;</span><br><span class="line">        updateTcpBufferSizes(newLp.getTcpBufferSizes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateRoutes(newLp, oldLp, netId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新DNS配置</span></span><br><span class="line">    updateDnses(newLp, oldLp, netId);</span><br><span class="line">    <span class="comment">// Make sure LinkProperties represents the latest private DNS status.</span></span><br><span class="line">    <span class="comment">// This does not need to be done before updateDnses because the</span></span><br><span class="line">    <span class="comment">// LinkProperties are not the source of the private DNS configuration.</span></span><br><span class="line">    <span class="comment">// updateDnses will fetch the private DNS configuration from DnsManager.</span></span><br><span class="line">    mDnsManager.updatePrivateDnsStatus(netId, newLp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDefaultNetwork(networkAgent)) &#123;</span><br><span class="line">        handleApplyDefaultProxy(newLp.getHttpProxy());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        updateProxy(newLp, oldLp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateWakeOnLan(newLp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Captive portal data is obtained from NetworkMonitor and stored in NetworkAgentInfo.</span></span><br><span class="line">    <span class="comment">// It is not always contained in the LinkProperties sent from NetworkAgents, and if it</span></span><br><span class="line">    <span class="comment">// does, it needs to be merged here.</span></span><br><span class="line">    newLp.setCaptivePortalData(mergeCaptivePortalData(networkAgent.networkAgentPortalData,</span><br><span class="line">            networkAgent.capportApiData));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法<code>updateDnses</code>主要做两件事情:</p><ul><li>设置当前网络的<code>DNS</code>服务器, 调用<code>IDnsResolver</code>的接口<code>setResolverConfiguration</code>设置当前系统的DNS服务的配置</li><li>清除当前系统的<code>DNS</code>解析缓存, 发送<code>ACTION_CLEAR_DNS_CACHE</code>来清除缓存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateDnses</span><span class="params">(LinkProperties newLp, LinkProperties oldLp, <span class="type">int</span> netId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldLp != <span class="literal">null</span> &amp;&amp; newLp.isIdenticalDnses(oldLp)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// no updating necessary</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mDnsManager.noteDnsServersForNetwork(netId, newLp);</span><br><span class="line">        mDnsManager.flushVmDnsCache();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        loge(<span class="string">&quot;Exception in setDnsConfigurationForNetwork: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于如何设置<code>DNS</code>配置，大家可以查看<code>DnsResolverService.cpp</code>的代码；这里，我们重点看下缓存清理的大致流程。清理系统<code>DNS</code>缓存时，向<code>ActivityManager</code>发送一个<code>ACTION_CLEAR_DNS_CACHE</code>广播：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flush DNS caches and events work before boot has completed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flushVmDnsCache</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Tell the VMs to toss their DNS caches</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(ConnectivityManager.ACTION_CLEAR_DNS_CACHE);</span><br><span class="line">    intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Connectivity events can happen before boot has completed ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(ident);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ActivityManager</code>收到清除的广播后，调用<code>IApplicationThread.clearDnsCache</code>清理所有进程的<code>DNS</code>缓存:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (mProcLock) &#123;</span><br><span class="line">    mProcessList.clearAllDnsCacheLOSP();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy(anyOf = &#123;&quot;mService&quot;, &quot;mProcLock&quot;&#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clearAllDnsCacheLOSP</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mLruProcesses.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">ProcessRecord</span> <span class="variable">r</span> <span class="operator">=</span> mLruProcesses.get(i);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">IApplicationThread</span> <span class="variable">thread</span> <span class="operator">=</span> r.getThread();</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.clearDnsCache();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Failed to clear dns cache for: &quot;</span> + r.info.processName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>IApplicationThread</code>的实现在<code>ActivityThread</code>中， 接口<code>clearDnsCache</code>清除的是应用自身的解析缓存:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearDnsCache</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// a non-standard API to get this to libcore</span></span><br><span class="line">    InetAddress.clearDnsCache();</span><br><span class="line">    <span class="comment">// Allow libcore to perform the necessary actions as it sees fit upon a network</span></span><br><span class="line">    <span class="comment">// configuration change.</span></span><br><span class="line">    NetworkEventDispatcher.getInstance().dispatchNetworkConfigurationChange();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>网络切换完成后，会断开之前的网络，清除系统中对应的解析缓存:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">destroyNetwork</span><span class="params">(NetworkAgentInfo nai)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nai.created) &#123;</span><br><span class="line">        <span class="comment">// Tell netd to clean up the configuration for this network</span></span><br><span class="line">        <span class="comment">// (routing rules, DNS, etc).</span></span><br><span class="line">        <span class="comment">// This may be slow as it requires a lot of netd shelling out to ip and</span></span><br><span class="line">        <span class="comment">// ip[6]tables to flush routes and remove the incoming packet mark rule, so do it</span></span><br><span class="line">        <span class="comment">// after we&#x27;ve rematched networks with requests (which might change the default</span></span><br><span class="line">        <span class="comment">// network or service a new request from an app), so network traffic isn&#x27;t interrupted</span></span><br><span class="line">        <span class="comment">// for an unnecessarily long time.</span></span><br><span class="line">        destroyNativeNetwork(nai);</span><br><span class="line">        mDnsManager.removeNetwork(nai.network);</span><br><span class="line">    &#125;</span><br><span class="line">    mNetIdManager.releaseNetId(nai.network.getNetId());</span><br><span class="line">    nai.onNetworkDestroyed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理系统缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">destroyNativeNetwork</span><span class="params">(<span class="meta">@NonNull</span> NetworkAgentInfo nai)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mNetd.networkDestroy(nai.network.getNetId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException | ServiceSpecificException e) &#123;</span><br><span class="line">        loge(<span class="string">&quot;Exception destroying network(networkDestroy): &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mDnsResolver.destroyNetworkCache(nai.network.getNetId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException | ServiceSpecificException e) &#123;</span><br><span class="line">        loge(<span class="string">&quot;Exception destroying network: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>本文阐述了Android中DNS解析的原理和实现细节，重点关注了三个方面：</p><ul><li>DNS服务的初始化</li><li>应用程序如何执行域名解析</li><li>网络变化时DNS域名解析缓存的变化</li></ul><p>在Android中，DNS服务是在NETD进程中实现的，系统在进程初始化时对DNS服务进行初始化。文章还讨论了应用程序如何执行域名解析以及网络从Wi-Fi切换到4G时DNS域名解析缓存是如何清除的。理清这些流程，一方面是为了更好的定位遇到的网络问题，也可以更深入的理解Android中系统架构设计的思路以及代码的整体框架。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://datatracker.ietf.org/doc/html/rfc7858">DNS over TLS</a></li><li><a href="https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/">什么是DNS</a></li><li><a href="https://en.wikipedia.org/wiki/Domain_Name_System">Wikipedia DNS</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_Name_System&quot;&gt;&lt;code&gt;DNS(Domain Name System)&lt;/code&gt;&lt;/a&gt;即域名解析系统，是网络访问时用于将域名解析成对应IP地址的一种分布式网络服务。比如，要访问&lt;code&gt;www.google.com&lt;/code&gt;这个域名，&lt;code&gt;Android&lt;/code&gt;系统会首先发送一个&lt;code&gt;UDP&lt;/code&gt;请求到标准的&lt;code&gt;53&lt;/code&gt;端口系统的域名解析服务器，拿到对应的IP地址后才会与服务端建立连接。除了标准的&lt;code&gt;DNS&lt;/code&gt;服务外，目前还有&lt;code&gt;HttpDNS&lt;/code&gt;(&lt;a href=&quot;https://en.wikipedia.org/wiki/DNS_over_HTTPS&quot;&gt;&lt;code&gt;DNS over Https, DoH&lt;/code&gt;&lt;/a&gt;)以及基于&lt;code&gt;TSL&lt;/code&gt;的&lt;code&gt;DNS&lt;/code&gt;服务(&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7858&quot;&gt;&lt;code&gt;DNS over TLS， DoT&lt;/code&gt;&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;那么，&lt;code&gt;Android&lt;/code&gt;中&lt;code&gt;DNS&lt;/code&gt;解析的大致框架是怎么的？整个&lt;code&gt;DNS&lt;/code&gt;解析的流程又是怎么样的？ 在看具体实现细节之前，我们不妨思考一下几个问题，想一想，如果我们自己从零开始为&lt;code&gt;Android&lt;/code&gt;设计一个&lt;code&gt;DNS&lt;/code&gt;系统，应该怎么做？&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://sniffer.site/categories/Android/"/>
    
    
    <category term="DNS" scheme="https://sniffer.site/tags/DNS/"/>
    
    <category term="TCP/IP" scheme="https://sniffer.site/tags/TCP-IP/"/>
    
    <category term="域名解析" scheme="https://sniffer.site/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    
    <category term="Private DNS" scheme="https://sniffer.site/tags/Private-DNS/"/>
    
  </entry>
  
  <entry>
    <title>chatGPT之后，我们还能做什么?</title>
    <link href="https://sniffer.site/2023/03/23/chatGPT%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88/"/>
    <id>https://sniffer.site/2023/03/23/chatGPT%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88/</id>
    <published>2023-03-23T01:37:05.000Z</published>
    <updated>2023-04-18T12:17:43.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Those who cannot remember the past are condemned to repeat it</p><p><strong>George Santayana</strong></p></blockquote><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/JasonW_a_young_chinese_girl_ride_on_a_chinese_dragon.png" alt="龙女儿"></p><span id="more"></span><p>最近铺天盖地都是<code>chatGpt</code>的新闻，各种基于<code>GPT</code>的工具与应用不断涌现，十分热闹。这种狂热的情绪不禁让人浮想联翩。前几年热火朝天的比特币以及区块链技术，当时的人们也一度兴奋异常，说一场颠覆金融与银行的技术变革已然到来，结果在资本逐利与人性的贪婪之下，比特币与区块链在无数的涨涨跌跌中归于平淡。如今，人们谈及比特币没有了最初的热情，也没多少人聊区块链金融了。</p><p>可是，体验过<code>chatGPT</code>以及<code>AIGC(AI Gernerated Content)</code>相关的工具以后(开头的图片就是使用<a href="https://discord.com/"><code>midjourney</code></a>自动生成的,几分钟时间生成的图片效果不错)，还是觉得这次应该不一样了，这是人工智能历史上一次具有革命意义的变化，是人类自有了计算机以来，生产力工具的一次重大转折与突破。就好比从前我们使用的是镰刀与斧头，如今直接用上推土机与坦克了；<code>chatGPT</code>完成了从<code>深度学习</code>到<code>通用智能</code>的转变，可以把信息与知识的呈现完全以新的形式展现给用户,把人从简单繁琐的任务中解脱出来，让人可以有更多精力与时间做更多有价值的事情。比如，用开源的<a href="https://www.cursor.so/"><code>cursor编辑器</code></a>，可以查找函数的使用示例；写代码的单元测试；查看语言的特性等等，这能提升开发的效率。<code>chatGPT</code>让人跟机器的界限慢慢被打破，机器为人类的决策提供了更多的帮助，让生产效率成倍的增长。就像人类从石器时代一下到了铁器时代，新的生产力工具让人类社会有了更多的想象空间。</p><p>或许，<code>chatGPT</code>这种大语言模型(LLM)展现出来对自然语言上下文惊人的理解能力才是真正让人惊讶与恐怖的事情。<code>GPT-4</code>模型俨然是一个百科全书的知识库，具备了很好的推理能力，能把各种知识与信息组织的条理井然。这是通用智能的前奏，几十年前阿兰图灵设想的图灵测试恐怕就要被超越了，而一旦模型或算法本身进化成了具备自我意识的一个实体，人与机器的关系到底该如何界定？我们如何看到一个具备智能的机器？这个机器又如何看待人类？这不仅是技术的变革，而是人类社会伦理与存在的一次挑战。我们是否做好了充分准备来迎接这样的变革？</p><p>从技术角度来看，不论是<code>chatGPT</code>大语言模型还是如<code>midjourney</code>这样的<code>AIGC</code>工具，无非都是一个个简单的人工神经元组成的巨大网络，里面有上千亿的模型参数，通过复杂的网络布局以及适当的反馈回路，这种深度神经网络竟然会拥有如此强大的推理与泛化能力，不得不让人赞叹，就像一个个大脑细胞通过突触相互链接让人拥有了智能，拥有了自我意识一样，或许在某一天， 大规模的机器模型也会来到这个智慧的临界点-产生自我意识。人创造了一个智慧体，上帝是喜还是忧？</p><p>从人类现有历史来看，技术的发展与进化对社会的影响是深刻而不可逆的(这种不可逆可能也让人类常常想回到最初的那种原始自然的状态，就好像我们从乡村来到城市，却会时常想回到乡村去一样):</p><ul><li>人有了数字的概念，并发明了数字0，然后人类在数学方面完成了革新，重塑人类对自然的理解，奠定了科学进步的基础</li><li>人类学会利用火，不用再像其他动物一样生吃肉或者蔬菜了，饮食成了一种美味的享受，让人在数千年的进化中逐步蜕变，并利用各种能源如煤炭、石油、自然能源等让社会生产力得以提升</li><li>牛顿发现了万有引力，完成了认识宇宙的第一步，把人类文明提升到新的高度；爱因斯坦的相对论再一次扩展了人类对于宇宙与自身存在的认识，让我们对宇宙的历史不再望而却步</li></ul><p>今天，以<a href="https://openai.com/"><code>OpenAI</code></a>公司的<code>chatGPT</code>在通用智能上完成突破，其意义非凡，但也让人在深思熟虑之后产生些许忧虑与不安。对于一名软件开发人员，能使用这种生产力倍增的工具自然感到兴奋，但在整个人类社会，还有很多的人没有能力去获取或者接触到任何智能相关的技术与工具，这是一个鸿沟，短期内无法填平的数字鸿沟。这也就势必会给有技术领先优势的公司或者组织更多的掌控力与控制权，渐渐的形成<code>AI霸权</code>，带来更多的数字鸿沟:那些掌控了<code>AI</code>能力的群体自然而然有更多的话语权与影响力，从而得以维护自己的利益。这很难说不是现状，但恐怕未来随着<code>AI</code>技术的发展只会愈加明显。</p><p>随着<code>chatGPT</code>这种具备通用智能模型的不断进步与发展，很多没有太多原创性的工作可能被替代，比如秘书，文案写作者，但是不是就像许多耸人听闻的标题说的那样，人快成了完美的废物:35岁卷不动，只好吃喝等死了。从历史上来看，任何技术的进步都是一把双刃剑，让某些行业受益的同时，也会给其他行业造成冲击，但对社会总体而言是利大于弊，是有价值的。与其回避技术可能带来的变化，不如主动拥抱这种变化。作为一名技术人员，在这种快速变化的智能时代，我们应该怎么做？</p><ul><li>保持开放的心态，努力学习。如果不能成为这股技术变革中的一员，那么努力想想自己所在行业可以如何跟AI进行结合，是否可以在AI的帮助下做的更好</li><li>提升创新与创造的能力，主动寻求变化，跳出舒适区，让自己更具韧性与适应能力</li><li>做更多有价值的事情。为用户创造价值，为组织创造价值，为社会创造价值，让自己活的更有价值</li><li>学会从更大的视角看待事物，更高的维度思考问题。不满足于已有的答案，要有系统性的思维能力</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>二百多年前，英国数学家<code>Charles Babbage</code>便有了利用机器来计算的想法，并尝试制造了第一台差分机。而人工智能概念的出现到如今的<code>chatGPT</code>多模态的通用智能模型，也不过八十来年的历史。技术进步正在加速，我们该如何应对这种技术的变革，如何面对通用智能带来的挑战？需要改变的不仅仅是个人，而是教育体系。我们的下一代将生活在智能主导的世界，他们需要有新的思维与认知方式，需要创造与创新的能力去解决面临的问题。未来的教育不能再想如今一样只是教授知识，更多的应该要培养人的原创力。</p><p>而如今，在新的时代起点上，如何去选择？我们需要重新思考自身的价值，思考存在的意义，思考如何利用智能的工具创造更多的价值。人类在地球上生存了千百年，很多东西变了，很多仍然没有变化。那些让人类不断进化，不断创造的源动力并没有变。我们可以欣赏自然的美，可以感受爱与温情，可以体验快乐与幸福，可以创造与构建，可以思考这个世界一切的奥秘。而这正是每一个人存在的价值。</p><p>有关更多<code>GPT</code>哲学上的探讨，可以看下<a href="https://mp.weixin.qq.com/s/AnlhmRHoSJM-O9bLBlxOVw">赵汀阳：GPT在哪些问题上逼得思想无路可走？</a>这篇文章。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;Those who cannot remember the past are condemned to repeat it&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;George Santayana&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/JasonW_a_young_chinese_girl_ride_on_a_chinese_dragon.png&quot; alt=&quot;龙女儿&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="人工智能" scheme="https://sniffer.site/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="人工智能" scheme="https://sniffer.site/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="AI" scheme="https://sniffer.site/tags/AI/"/>
    
    <category term="chatGPT" scheme="https://sniffer.site/tags/chatGPT/"/>
    
    <category term="LLM" scheme="https://sniffer.site/tags/LLM/"/>
    
    <category term="AIGC" scheme="https://sniffer.site/tags/AIGC/"/>
    
  </entry>
  
  <entry>
    <title>Android中HAL服务无法使用网络的问题</title>
    <link href="https://sniffer.site/2023/03/09/Android%E4%B8%ADHAL%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://sniffer.site/2023/03/09/Android%E4%B8%ADHAL%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-09T06:19:09.000Z</published>
    <updated>2023-03-13T12:03:38.848Z</updated>
    
    <content type="html"><![CDATA[<p>最近有同学在<code>Android S(12)</code>上遇到了一个奇怪的网络问题，说自己的<code>audio HAL</code>服务尝试通过以太网创建<code>socket</code>与其他局域网的节点通讯时，总是提示<code>Operation Not Permitted</code>。原先怀疑是<code>Selinux</code>的问题，但是目前在开发版本中<code>selinux</code>是完全关闭的；从问题发生的现象看，只有属于<code>audioserver</code>这个<code>UID</code>的进程才有问题，其他的如<code>system/root</code>的进程则没有问题。</p><p>据此，我们可以推断，<code>audioserver</code>这个<code>UID</code>的进程没有相关权限，所以导致无法使用局域网的网络。记得在早前的<code>Android</code>版本中，很多网络系统调用会通过<code>netd</code>代理进行权限检查，比如<code>socket/connect/bind</code>等系统调用都会先通过<code>netdClient</code>这个库的接口进行权限检查，而后才真正进行系统调用。<span id="more"></span>查看了<code>Android S</code>中<code>netd/client</code>中的代码，果真有一个<code>socket</code>的代理接口会检查权限:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">netdClientSocket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Block creating AF_INET/AF_INET6 socket if networking is not allowed.</span></span><br><span class="line">    <span class="keyword">if</span> (FwmarkCommand::<span class="built_in">isSupportedFamily</span>(domain) &amp;&amp; !allowNetworkingForProcess.<span class="built_in">load</span>()) &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> socketFd = <span class="built_in">libcSocket</span>(domain, type, protocol);</span><br><span class="line">    <span class="keyword">if</span> (socketFd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> netId = netIdForProcess &amp; ~NETID_USE_LOCAL_NAMESERVERS;</span><br><span class="line">    <span class="keyword">if</span> (netId != NETID_UNSET &amp;&amp; FwmarkClient::<span class="built_in">shouldSetFwmark</span>(domain)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">int</span> error = <span class="built_in">setNetworkForSocket</span>(netId, socketFd)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">closeFdAndSetErrno</span>(socketFd, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> socketFd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>有关<code>netd</code>的详细介绍可以参考<a href="https://sniffer.site/2018/12/18/android-netd%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">Android Netd工作原理详解</a></p></blockquote><p>继续跟踪这个代码路径，发现<code>Android</code>的<code>Zygote</code>进程创建应用进程的时候会调用<code>setAllowNetworkingForProcess</code>接口，根据进程是否在一个<code>INET_GID</code>用户组来设置该进程是否有权限访问网络:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 进程是否包含了在INET对应的用户组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">containsInetGid</span><span class="params">(<span class="type">int</span>[] gids)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gids.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gids[i] == android.os.Process.INET_GID) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">forkAndSpecialize</span><span class="params">(<span class="type">int</span> uid, <span class="type">int</span> gid, <span class="type">int</span>[] gids, <span class="type">int</span> runtimeFlags,</span></span><br><span class="line"><span class="params">        <span class="type">int</span>[][] rlimits, <span class="type">int</span> mountExternal, String seInfo, String niceName, <span class="type">int</span>[] fdsToClose,</span></span><br><span class="line"><span class="params">        <span class="type">int</span>[] fdsToIgnore, <span class="type">boolean</span> startChildZygote, String instructionSet, String appDataDir,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> isTopApp, String[] pkgDataInfoList, String[] allowlistedDataInfoList,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> bindMountAppDataDirs, <span class="type">boolean</span> bindMountAppStorageDirs)</span> &#123;</span><br><span class="line">    ZygoteHooks.preFork();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> nativeForkAndSpecialize(</span><br><span class="line">            uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">            fdsToIgnore, startChildZygote, instructionSet, appDataDir, isTopApp,</span><br><span class="line">            pkgDataInfoList, allowlistedDataInfoList, bindMountAppDataDirs,</span><br><span class="line">            bindMountAppStorageDirs);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Note that this event ends at the end of handleChildProc,</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;PostFork&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If no GIDs were specified, don&#x27;t make any permissions changes based on groups.</span></span><br><span class="line">        <span class="keyword">if</span> (gids != <span class="literal">null</span> &amp;&amp; gids.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            NetworkUtilsInternal.setAllowNetworkingForProcess(containsInetGid(gids));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the Java Language thread priority to the default value for new apps.</span></span><br><span class="line">    Thread.currentThread().setPriority(Thread.NORM_PRIORITY);</span><br><span class="line"></span><br><span class="line">    ZygoteHooks.postForkCommon();</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次检查<code>HAL</code>服务的<code>rc</code>配置，发现<code>group</code>用户组中已经包含了<code>inet</code>了。而且，从问题的现象来看，是跟进程的<code>UID</code>有关，与<code>GID</code>的关系不大。那么，到底是哪里设置了<code>UID</code>相关的权限了？ 跟同事一起确认发现，只要在<code>/system/etc/permission/platform.xml</code>中为<code>audioserver</code>添加一个<code>INTERNET</code>权限网络就可以正常访问了:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;assign-permission name=<span class="string">&quot;android.permission.INTERNET&quot;</span> uid=<span class="string">&quot;audioserver&quot;</span> /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>问题好像比较清晰了，应该是系统启动时，对于那些无法通过<code>AndroidManifest.xml</code>声明权限的服务，比如<code>native</code>的服务，包管理服务<code>PMS</code>会去解析对应<code>UID</code>的权限，然后再通过某种方式设置到系统，确保其在创建<code>socket</code>时相关的权限会被检查。查看<code>frameworks/base/services/../pm/permission</code>代码可以大概知道，<code>Android</code>中的所有权限都统一由系统服务<code>PermissionManagerService</code>来管理，系统启动时，就会通过这个服务解析<code>platform.xml</code>文件中各个<code>UID</code>的权限声明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">SystemConfig</span> <span class="variable">systemConfig</span> <span class="operator">=</span> SystemConfig.getInstance();</span><br><span class="line">mSystemPermissions = systemConfig.getSystemPermissions();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但继续跟踪代码，却没有看到是这个权限配置是如何与<code>socket</code>的创建控制关联在一起的。这个想来十分奇怪，按照实现逻辑来说，这种权限控制不会放在内核实现，而是应该在用户空间的某个地方设置。过了两天再来看这个问题，突然想起之前做流量统计功能时，<code>Android</code>中使用了<code>BPF</code>，很有可能这个网络权限的控制也是在<code>netd</code>对应的<code>BPF</code>中实现的。查看了下<code>/system/netd/bpf_progs/netd.c</code>的代码，确实有一个<code>bpf map</code>来控制<code>socket</code>的创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_BPF_PROG_KVER</span>(<span class="string">&quot;cgroupsock/inet/create&quot;</span>, AID_ROOT, AID_ROOT, inet_socket_create,</span><br><span class="line">                     <span class="built_in">KVER</span>(<span class="number">4</span>, <span class="number">14</span>, <span class="number">0</span>))</span><br><span class="line">(<span class="keyword">struct</span> bpf_sock* sk) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> gid_uid = <span class="built_in">bpf_get_current_uid_gid</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A given app is guaranteed to have the same app ID in all the profiles in</span></span><br><span class="line"><span class="comment">     * which it is installed, and install permission is granted to app for all</span></span><br><span class="line"><span class="comment">     * user at install time so we only check the appId part of a request uid at</span></span><br><span class="line"><span class="comment">     * run time. See UserHandle#isSameApp for detail.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> appId = (gid_uid &amp; <span class="number">0xffffffff</span>) % PER_USER_RANGE;</span><br><span class="line">    <span class="type">uint8_t</span>* permissions = <span class="built_in">bpf_uid_permission_map_lookup_elem</span>(&amp;appId);</span><br><span class="line">    <span class="keyword">if</span> (!permissions) &#123;</span><br><span class="line">        <span class="comment">// UID not in map. Default to just INTERNET permission.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A return value of 1 means allow, everything else means deny.</span></span><br><span class="line">    <span class="keyword">return</span> (*permissions &amp; BPF_PERMISSION_INTERNET) == BPF_PERMISSION_INTERNET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个<code>UID</code>权限<code>map</code>对象正是通过<code>Netd</code>的接口进行设置的，大致的路径如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PermissionMonitor.startMoniotr -&gt; (SystemServer)</span><br><span class="line">    NetdNativeService.trafficSetNetPermForUids --&gt; (Netd)</span><br><span class="line">    TrafficeController.setPermissionForUids</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是说<code>ConnectivityService</code>在启动过程中，通过<code>PermissionMonitor</code>读取到<code>SystemConfig</code>的用户权限配置后，会调用<code>NETD</code>的接口设置对应的<code>UID</code>的网络权限:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">startMonitoring</span><span class="params">()</span> &#123;</span><br><span class="line">    log(<span class="string">&quot;Monitoring&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">userAllContext</span> <span class="operator">=</span> mContext.createContextAsUser(UserHandle.ALL, <span class="number">0</span> <span class="comment">/* flags */</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">IntentFilter</span> <span class="variable">intentFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>();</span><br><span class="line">    intentFilter.addAction(Intent.ACTION_PACKAGE_ADDED);</span><br><span class="line">    intentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);</span><br><span class="line">    intentFilter.addDataScheme(<span class="string">&quot;package&quot;</span>);</span><br><span class="line">    userAllContext.registerReceiver(</span><br><span class="line">            mIntentReceiver, intentFilter, <span class="literal">null</span> <span class="comment">/* broadcastPermission */</span>,</span><br><span class="line">            <span class="literal">null</span> <span class="comment">/* scheduler */</span>);</span><br><span class="line">    ...</span><br><span class="line">    List&lt;PackageInfo&gt; apps = mPackageManager.getInstalledPackages(GET_PERMISSIONS</span><br><span class="line">            | MATCH_ANY_USER);</span><br><span class="line">    <span class="keyword">if</span> (apps == <span class="literal">null</span>) &#123;</span><br><span class="line">        loge(<span class="string">&quot;No apps&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">SparseIntArray</span> <span class="variable">netdPermsUids</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SparseIntArray</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (PackageInfo app : apps) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">uid</span> <span class="operator">=</span> app.applicationInfo != <span class="literal">null</span> ? app.applicationInfo.uid : INVALID_UID;</span><br><span class="line">        <span class="keyword">if</span> (uid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mAllApps.add(UserHandle.getAppId(uid));</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNetwork</span> <span class="operator">=</span> hasNetworkPermission(app);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasRestrictedPermission</span> <span class="operator">=</span> hasRestrictedNetworkPermission(app);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isNetwork || hasRestrictedPermission) &#123;</span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">permission</span> <span class="operator">=</span> mApps.get(UserHandle.getAppId(uid));</span><br><span class="line">            <span class="comment">// If multiple packages share a UID (cf: android:sharedUserId) and ask for different</span></span><br><span class="line">            <span class="comment">// permissions, don&#x27;t downgrade (i.e., if it&#x27;s already SYSTEM, leave it as is).</span></span><br><span class="line">            <span class="keyword">if</span> (permission == <span class="literal">null</span> || permission == NETWORK) &#123;</span><br><span class="line">                mApps.put(UserHandle.getAppId(uid), hasRestrictedPermission);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> unify the management of the permissions into one codepath.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">otherNetdPerms</span> <span class="operator">=</span> getNetdPermissionMask(app.requestedPermissions,</span><br><span class="line">                app.requestedPermissionsFlags);</span><br><span class="line">        netdPermsUids.put(uid, netdPermsUids.get(uid) | otherNetdPerms);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mUsers.addAll(mUserManager.getUserHandles(<span class="literal">true</span> <span class="comment">/* excludeDying */</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> SparseArray&lt;String&gt; netdPermToSystemPerm = <span class="keyword">new</span> <span class="title class_">SparseArray</span>&lt;&gt;();</span><br><span class="line">    netdPermToSystemPerm.put(INetd.PERMISSION_INTERNET, INTERNET);</span><br><span class="line">    netdPermToSystemPerm.put(INetd.PERMISSION_UPDATE_DEVICE_STATS, UPDATE_DEVICE_STATS);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; netdPermToSystemPerm.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">netdPermission</span> <span class="operator">=</span> netdPermToSystemPerm.keyAt(i);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">systemPermission</span> <span class="operator">=</span> netdPermToSystemPerm.valueAt(i);</span><br><span class="line">        <span class="comment">//获取有INTERNET权限的UID</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span>[] hasPermissionUids =</span><br><span class="line">                mSystemConfigManager.getSystemPermissionUids(systemPermission);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; hasPermissionUids.length; j++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">uid</span> <span class="operator">=</span> hasPermissionUids[j];</span><br><span class="line">            netdPermsUids.put(uid, netdPermsUids.get(uid) | netdPermission);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;Users: &quot;</span> + mUsers.size() + <span class="string">&quot;, Apps: &quot;</span> + mApps.size());</span><br><span class="line">    update(mUsers, mApps, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置UID的网络权限</span></span><br><span class="line">    sendPackagePermissionsToNetd(netdPermsUids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，谜底终于解开了。感兴趣的可以查看<code>packages/modules/Connectivity/</code>下<code>PermissionMonitor.java</code>的代码。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近有同学在&lt;code&gt;Android S(12)&lt;/code&gt;上遇到了一个奇怪的网络问题，说自己的&lt;code&gt;audio HAL&lt;/code&gt;服务尝试通过以太网创建&lt;code&gt;socket&lt;/code&gt;与其他局域网的节点通讯时，总是提示&lt;code&gt;Operation Not Permitted&lt;/code&gt;。原先怀疑是&lt;code&gt;Selinux&lt;/code&gt;的问题，但是目前在开发版本中&lt;code&gt;selinux&lt;/code&gt;是完全关闭的；从问题发生的现象看，只有属于&lt;code&gt;audioserver&lt;/code&gt;这个&lt;code&gt;UID&lt;/code&gt;的进程才有问题，其他的如&lt;code&gt;system/root&lt;/code&gt;的进程则没有问题。&lt;/p&gt;
&lt;p&gt;据此，我们可以推断，&lt;code&gt;audioserver&lt;/code&gt;这个&lt;code&gt;UID&lt;/code&gt;的进程没有相关权限，所以导致无法使用局域网的网络。记得在早前的&lt;code&gt;Android&lt;/code&gt;版本中，很多网络系统调用会通过&lt;code&gt;netd&lt;/code&gt;代理进行权限检查，比如&lt;code&gt;socket/connect/bind&lt;/code&gt;等系统调用都会先通过&lt;code&gt;netdClient&lt;/code&gt;这个库的接口进行权限检查，而后才真正进行系统调用。</summary>
    
    
    
    <category term="Android" scheme="https://sniffer.site/categories/Android/"/>
    
    
    <category term="Android" scheme="https://sniffer.site/tags/Android/"/>
    
    <category term="网络使用权限" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>说说系统开发中的康威定律</title>
    <link href="https://sniffer.site/2023/02/27/%E8%AF%B4%E8%AF%B4%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B/"/>
    <id>https://sniffer.site/2023/02/27/%E8%AF%B4%E8%AF%B4%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B/</id>
    <published>2023-02-27T10:30:16.000Z</published>
    <updated>2023-03-23T01:10:55.496Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Work on stuff that matters: </p><ul><li>work on something that matters to you more than money</li><li>create more value than you capture</li><li>take the long view.</li></ul><p> <strong>Tim O’Reilly</strong></p></blockquote><p><img src="https://images.unsplash.com/photo-1487958449943-2429e8be8625?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80" alt="system design board"></p><span id="more"></span><p>最近在跟车载座舱中的紧急通话<code>ECALL</code>功能时，发现最开始的设计方案完全没有考虑到硬件与软件的复用。由于这个方案跨了两个中心的部门，<code>ECALL</code>的初始方案设计中竟然为<code>ECALL</code>增加了额外的一套录音与播放系统，不仅增加了硬件成本，也加大了软件开发的投入，而这样音频系统在座舱<code>SoC</code>上早就已经有一套了。如今，团队又不得不重新提出一个所谓降本的方案，以减少成本。这种系统设计的方案不禁让我联想到软件设计中著名的<a href="https://en.wikipedia.org/wiki/Conway%27s_law">康威定律(<code>Conway&#39;s law</code>)</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization&#x27;s communication structure</span><br><span class="line"></span><br><span class="line">— Melvin E. Conway， 1968</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>翻译过来，康威定律是说，在任何一个组织中诞生的系统, 在很大程度上会被设计成一个跟这个组织(沟通)结构类似的架构，就是说在系统设计的时候，我们自觉或不自觉的构建出了一个跟自己所在团队结构类似的系统框架了。关于康威定律，有一个更为直观的说法来自<a href="https://en.wikipedia.org/wiki/Eric_S._Raymond"><code>Eric Steven Raymond</code></a>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">If you have four groups working on a compiler, you&#x27;ll get a 4-pass compiler</span><br><span class="line"></span><br><span class="line">&lt;如果有四个团队开发一个编译器，最后会得到一个4阶段的编译器&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于汽车这样一个由诸多复杂零部件构成的系统来说，实际开发中涉及到主机厂、各级供应商，跨团队的合作与开发会特别多，所以容易出现这类系统设计的<code>事故</code>，举几个我知道的例子吧:</p><ul><li>自动驾驶团队在选摄像头型号时，只考虑方便训练机器学习模型的类型，没有考虑其他系统，比如座舱控制器也有可能需要行车数据，导致后期在车型上开展类似功能时十分痛苦，做出来的效果跟其他厂商比也差强人意</li><li>同属一个业务的功能，如<code>CarService</code>，由于应用端与系统开发分属在两个团队， 应用的开发在需要提供接口给第三方业务调用时，基于系统的API做了第二次封装，与现有的封装业务属性上基本重合了</li><li>不同团队在同一个平台上、同一个系统上同时进行开发，大家在同样的事情上重复的投入</li></ul><p>那么，我们不禁要问，为什么人们在跨团队合作时会出现这种事后看起来啼笑皆非的情况，做出让人难以置信的决策了？想了想，大致有如下两个原因:</p><ul><li>团队中经常出现屁股决定脑袋的事情，不同部门之间协作容易变成抢业务的情况，尤其是业务存在重叠时更是如此</li><li>做技术决策或者方案设计时，相关的专业人员没有深度参与其中，导致很多声音被埋没了，没有被听见</li></ul><p>从这两点上，我们不妨来推演下，如何避免跨团队设计方案时出现康威定律中的诅咒。一个公司在发展初期，人员比较少，很多业务在大公司都是几十个人承担的，在这里可能就一个人忙前忙后。这样大家做沟通与决策的成本相对而言比较少的。等到公司规模不断扩展，团队人员快速增加，沟通成本增加的同时，也带来了业务分配的问题，最后发现可能有多个团队在做类似或者相同的事情。</p><p>这类问题初期还容易比较根治，到了后期涉及到的人员多时就很难了。业务的重叠或者人员的冗余，说到底是公司技术体系的构建不合理，没有充分做到复用：人员的复用，团队能力的复用，系统设计的复用。所以，理想汽车的<code>CEO</code>李想在讲到公司的组织架构时(视频可以在哔哩哔哩上搜索到，值得看看)，就特别提到了公司体系的建设与构建-我想这大概就是尽可能去做到组织中各个团队不同业务的解耦，尽量避免重复造轮子，增加系统复用的程度，从而提高组织效率，从根源上减少开发成本。又或者，公司初期在组织体系上做的不够完善，欠了债务，那么等到团队初具规模时，一定要下定决心做重构，重新梳理不同业务部门的职能与负责的事情，尽量避免这种团队与业务的耦合扩散到无法收拾的程度。</p><p>关于第二点，在做系统方案设计时，专业声音被淹没的问题，由于涉及到不同专业背景的人，所以可能更难处理。对于一个想要在激烈市场竞争中获得胜利的团队，要想做出更好的产品，做出更明智的决策，让团队成员都有机会发声，强调高效、平等的沟通，打造专业、追求极致的文化氛围之外似乎没有更好的选择了。这是一个系统工程，也是一个想要长期取得领先定位的团队必须要思考面对的问题。只有从方方面面去构建高效、专业、极致的组织文化，才有可能避免这种专业声音石沉大海的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这里借这康威定律讲了自己在系统设计与组织构建中的遇到一些问题，实际上这些问题的原因可能比我看到的要更为复杂多样。系统设计涉及到公司组织架构、技术能力、团队管理、产品定义等多个维度，要想做好其实是一个非常有难度而有挑战的事情。每个想要做好产品，为用户创造价值的团队都需要认真考虑康威定律可能带来的影响。有关康威定律，<code>Martin Fowler</code>写了一篇文章介绍了如何在软件开发如何应对，值得参考下<a href="https://martinfowler.com/bliki/ConwaysLaw.html">Conway’s law</a>。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;Work on stuff that matters: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;work on something that matters to you more than money&lt;/li&gt;
&lt;li&gt;create more value than you capture&lt;/li&gt;
&lt;li&gt;take the long view.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;strong&gt;Tim O’Reilly&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1487958449943-2429e8be8625?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1170&amp;q=80&quot; alt=&quot;system design board&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="软件工程" scheme="https://sniffer.site/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="软件开发" scheme="https://sniffer.site/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="Conway&#39;s Law" scheme="https://sniffer.site/tags/Conway-s-Law/"/>
    
    <category term="康威定律" scheme="https://sniffer.site/tags/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>为什么iperf测试时UDP会出现高丢包率</title>
    <link href="https://sniffer.site/2023/01/10/%E4%B8%BA%E4%BB%80%E4%B9%88iperf%E6%B5%8B%E8%AF%95%E6%97%B6UDP%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%AB%98%E4%B8%A2%E5%8C%85%E7%8E%87/"/>
    <id>https://sniffer.site/2023/01/10/%E4%B8%BA%E4%BB%80%E4%B9%88iperf%E6%B5%8B%E8%AF%95%E6%97%B6UDP%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%AB%98%E4%B8%A2%E5%8C%85%E7%8E%87/</id>
    <published>2023-01-10T07:13:25.000Z</published>
    <updated>2023-01-10T09:23:40.137Z</updated>
    
    <content type="html"><![CDATA[<p>这两天质量的同学反馈说<code>iperf</code>测试时结果很差，跟实际的千兆带宽差别很大。确认了半天，发现内核的各项参数都已经完全按照千兆的目标速率进行配置了，那为什么还是会出现<code>TCP/UDP</code>带宽不足的问题？ 记得当时优化参数时，自己摸底测试的<code>TCP</code>结果挺好的，都达到了预期的<code>900Mbps</code>以上，看起来最近有什么修改导致了这个测试结果差异。</p><p>偶然的一个机会查看内核配置时，发现最近有人打开了<code>trace</code>功能，看起来很可能是这个修改导致了网络性能的下降了。拿早前未开启<code>trace</code>功能的版本一对比，果真是<code>trace</code>功能影响了<code>TCP</code>的带宽。<span id="more"></span>但是测试<code>UDP</code>还是会出现如下结果，看起來好像网络很差(注意对<code>UDP</code>测试需要通过设置<code>-b</code>参数来限制可能的带宽，否则也可能出现测试结果偏差)：</p><ul><li>使用<code>iperf</code>默认的的包大小测试(看源码，对<code>UDP</code>来说，默认的包大小为<code>1024</code>， 最大为<code>65507</code>)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务端: iperf3 -s -p <span class="number">8989</span> -f m</span><br><span class="line">客户端: iperf3 -c <span class="number">172.20</span><span class="number">.2</span><span class="number">.40</span> -p <span class="number">8989</span> -f m -t <span class="number">30</span> -u -b <span class="number">1</span>G</span><br><span class="line"></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-30.00</span>  sec   <span class="number">710</span> MBytes   <span class="number">198</span> Mbits/sec  <span class="number">0.000</span> ms  <span class="number">0</span>/<span class="number">509813</span> (<span class="number">0</span>%)  sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-30.19</span>  sec   <span class="number">701</span> MBytes   <span class="number">195</span> Mbits/sec  <span class="number">0.201</span> ms  <span class="number">6626</span>/<span class="number">509809</span> (<span class="number">1.3</span>%)  receiver</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于<code>UDP</code>没有流控，整体的丢包率<code>1.3%</code>还不错，但带宽明显太小了，只有理论值的<code>1/5</code>不到。从这个结果可以看到，实际带宽不足是因为发送端的速率太小了，导致整个通道未被充分占满。这就好比一个粗大的水管，但实际传输的水流太小了，容量利用率不够。要想提高利用率，只能想法提升发送端的速率。<code>iperf</code>中，我们可以通过<a href="https://serverfault.com/questions/691723/extreme-udp-packet-loss-at-300mbit-14-but-tcp-800mbit-w-o-retransmits">提高包大小来达到这一目的</a>：</p><ul><li>使用最大的<code>UDP</code>包大小(<code>65507</code>)进行测试</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务端: iperf3 -s -p <span class="number">8989</span> -f m</span><br><span class="line">客户端: iperf3 -c <span class="number">172.20</span><span class="number">.2</span><span class="number">.40</span> -p <span class="number">8989</span> -f m -t <span class="number">30</span> -u -b <span class="number">1</span>G -l <span class="number">65507</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ ID] Interval           Transfer     Bitrate         Jitter    Lost/Total Datagrams</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-10.00</span>  sec  <span class="number">1.16</span> GBytes  <span class="number">1000</span> Mbits/sec  <span class="number">0.000</span> ms  <span class="number">0</span>/<span class="number">19079</span> (<span class="number">0</span>%)  sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-10.18</span>  sec   <span class="number">723</span> MBytes   <span class="number">595</span> Mbits/sec  <span class="number">0.282</span> ms  <span class="number">7508</span>/<span class="number">19079</span> (<span class="number">39</span>%)  receiver</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这次测试带宽明显有所提升，但接收端的丢包率却达到了惊人的<code>39%</code>。为什么会出现如此高的丢包率了？这还是要从<code>UDP</code>的传输机制说起了。我们都知道，<a href="http://www.tcpipguide.com/free/t_UDPOverviewHistoryandStandards.htm"><code>UDP</code>是无连接的数据报文传输协议</a>，也没有类似<code>TCP</code>滑动窗口的流量控制机制，因此快速的一方很有可能会淹没慢速的一方。这个时候就需要适当的调整慢速一端的<code>socket</code>缓冲区大小了。</p><p>对于<code>UDP</code>来说，主要有如下几个参数会影响实际传输时<code>socket</code>缓冲区的大小(可以参考内核文档<code>ip-sysctl.txt</code>)：</p><ul><li><code>net.core.wmem_default/net.core.wmem_max</code>: 默认、最大的发送缓冲区大小(bytes)，如果没用通过<code>setsockopt</code>來设置<code>SO_SNDBUF</code>的值，则会使用内核默认的缓冲区大小</li><li><code>net.core.rmem_default/net.core.rmem_max</code>: 默认、最大的接收缓冲区大小(bytes), 类似的，如果没有通过<code>SO_RCVBUF</code>来设置发送缓冲区的值，则使用内核默认的<code>net.core.rmem_default</code>值</li><li><code>net.ipv4.udp_mem=&quot;min pressure max&quot;</code>: 系统中所有<code>UDP</code>连接<code>socket</code>可以使用的最小、压力、最大页数（页大小一般为<code>4K</code>)，默认值一般在系统启动的时候根据当前可用内存计算出来的</li><li><code>net.ipv4.udp_rmem_min/net.ipv4.udp_wmen_min</code>: 系统中单个<code>UDP</code>连接<code>socket</code>可用的最小内存(bytes), 默认是<code>4K</code>。</li></ul><p>要想减少测试中的丢包率，就需要提高慢速端(也就是接收端)的缓冲区大小，确保其有足够的空间来保存接收到的数据，不至于来不及处理而被内核丢弃。我们可以选择在发送端或者接收端设置缓冲区的大小，对于<code>iperf</code>只能通过<code>-w</code>控制客户端的缓冲区大小, 这里我们直接在客户端设置发送缓冲区的大小为<code>10M</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务端: iperf3 -s -p <span class="number">8989</span> -f m</span><br><span class="line">客户端: iperf3 -c <span class="number">172.20</span><span class="number">.2</span><span class="number">.40</span> -p <span class="number">8989</span> -f m -t <span class="number">30</span> -u -b <span class="number">1</span>G -l <span class="number">65507</span> -w <span class="number">10</span>M</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ ID] Interval           Transfer     Bitrate         Jitter    Lost/Total Datagrams</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-10.00</span>  sec  <span class="number">1.16</span> GBytes  <span class="number">1000</span> Mbits/sec  <span class="number">0.000</span> ms  <span class="number">0</span>/<span class="number">19081</span> (<span class="number">0</span>%)  sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-10.19</span>  sec  <span class="number">1.16</span> GBytes   <span class="number">981</span> Mbits/sec  <span class="number">0.593</span> ms  <span class="number">0</span>/<span class="number">19079</span> (<span class="number">0</span>%)  receiver</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，丢包率速率下降了到预期的程度。如果我们要在服务端设置接收缓冲区的大小，可以有两种方式: 一种是通过设置<code>net.core.rmem_default</code>大小，一种是修改<code>iperf3</code>的源码，确保服务端也可以通过<code>-w</code>来设置缓冲区的大小。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>网络的带宽优化涉及了Linux内核协议栈和网卡驱动，充分理解网络数据的传输流程以及<code>TCP/UDP</code>等传输协议的机制，才有可能找到性能的瓶颈。总的来说，这些优化很值得很深入研究，可以让人完整的把各个知识点都梳理串联起来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两天质量的同学反馈说&lt;code&gt;iperf&lt;/code&gt;测试时结果很差，跟实际的千兆带宽差别很大。确认了半天，发现内核的各项参数都已经完全按照千兆的目标速率进行配置了，那为什么还是会出现&lt;code&gt;TCP/UDP&lt;/code&gt;带宽不足的问题？ 记得当时优化参数时，自己摸底测试的&lt;code&gt;TCP&lt;/code&gt;结果挺好的，都达到了预期的&lt;code&gt;900Mbps&lt;/code&gt;以上，看起来最近有什么修改导致了这个测试结果差异。&lt;/p&gt;
&lt;p&gt;偶然的一个机会查看内核配置时，发现最近有人打开了&lt;code&gt;trace&lt;/code&gt;功能，看起来很可能是这个修改导致了网络性能的下降了。拿早前未开启&lt;code&gt;trace&lt;/code&gt;功能的版本一对比，果真是&lt;code&gt;trace&lt;/code&gt;功能影响了&lt;code&gt;TCP&lt;/code&gt;的带宽。</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="iperf" scheme="https://sniffer.site/tags/iperf/"/>
    
    <category term="UDP" scheme="https://sniffer.site/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>再见2022</title>
    <link href="https://sniffer.site/2022/12/31/%E5%86%8D%E8%A7%812022/"/>
    <id>https://sniffer.site/2022/12/31/%E5%86%8D%E8%A7%812022/</id>
    <published>2022-12-31T09:08:35.000Z</published>
    <updated>2023-01-10T07:18:34.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>创造力 &#x3D; 能力 × 热情 × 思维方式</p><ul><li>“能力”是指努力学到的知识、经验和技能</li><li>“热情”是指工作时所有的激情和渴望成功等因素</li><li>“思维方式”则指对待工作的心态、精神状态和价值偏好</li></ul><p>一个人和一个企业能够取得多大成就，就看三个因素的乘积</p><p><strong>稻盛和夫</strong></p></blockquote><p><img src="https://images.unsplash.com/photo-1661306118447-6eac9ce5866f?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1074&q=80" alt="flow on the sea"></p><span id="more"></span><p>即将迈入新的一年了，时不待人。未曾想到2022年终的几天是在与新冠病毒共存中度过的，从最初的感染到恢复，前后历经6天，最高发烧到39度，身体好几天都处于酸痛而乏力的状态，确实让人难受。所幸的是，家里的娃娃跟老人都没有感染。三年来，新冠病毒演化到今天的奥密克戎，看起来毒性确实减弱了不少，政策放开后，唯一让人的担心是，这个如此狡猾的新冠病毒是否会继续在交叉传播中变异，卷土重来？人类是否有能力研发出新的疫苗，从此让新冠病毒彻底偃旗息鼓，尚待确证。</p><p>不得不说，新冠病毒肆虐的这三年是人类历史上注定无法被遗忘的一段历史，纵然生活变化多端，那些被撕碎的感情，被摧残的个人、家庭，无不让人唏嘘，让人看到人自身的脆弱，看到自然更迭的无情与沧桑，看到社会治理中诸多折腾与无效。人，像是浮萍，像是沙子，又像是一滴水，随时被风吹走，被洪流裹挟，被卷到某个角落，再无人问津，被遗忘，仿佛从未来过这里。那么，人的价值到底在哪里？ 我们毕竟有血有肉、有意志、有信念；我们渴望温情，渴望创造，渴望活的有价值，而不是浑浑噩噩的度过上苍赋予的3万天。最近在想，为何我们成为了如今这个样子？ 为何这个社会、国家成为了现在这个状态而不是另外的状态了？ 究竟是什么力量在塑造着人的心灵，又是什么力量塑造了社会与国家？ 我们每个人可能都笃定自己掌握了生活的主动权，掌控着自己头脑中的信念与想法，但仔细想一想，很多我们头脑中深信不疑的观念只不过是在某个时间悄然溜进了我们的身体而已，那并不是我们自己思考出来的。如果不加检点，我们就有可能成为这些偷偷溜进来的想法的奴隶。</p><p>言归正传，总结下过去的一年吧。今天早上，翻开自己2022年的计划，大多数立下的flag都未能兑现，大都停留在纸上谈兵了。365天，忙忙碌碌竟然忘了自己的最初的目标了。定目标还是不能求多求大，能落地，越具体越好。</p><ul><li>阅读上有了广度，一年下来大概有十几本吧(不包括电子书)，印象比较深刻的有<code>这才是心理学</code>，吴军的<code>数学之美</code>、<code>计算之魂</code>，<code>经济学通识课</code>，<code>生命是什么</code>，<code>影响力</code>，<code>错误的行为</code>， <code>量子传-究竟什么才是现实</code>等。今年养成了一个习惯，就是好的书读完第一遍后，过一段时间再读第二遍，这样可以比较好的理解书中的某些观点。阅读这件事情，在以前看起来其实挺费时间，需要大块时间才能去做，如今发现随便一个时间，哪怕是几分钟也可以利用起来，随时翻一翻。这样一本书，可能个把月出头也就看完了。</li><li>工作上，发现只要自己足够用心，深入思考，完全可以把之前认为做不到或者别人认为难以完成的任务做到。从另一个角度来说，个人实际上是有潜力的，即便是到了而立之年也同样可以不断提高，只是提高的速度没能达到20岁出头那种程度而已。</li><li>每周都坚持打一次羽毛球，两个小时的锻炼确实让人获益匪浅，人的精力与状态都得到了足够的支撑。今年花点钱再改善下装备，希望再高手的带领下，水平能够再上一个台阶。</li><li>女儿三岁了，自己也在她的拉扯下慢慢成为一个有责任心的父亲。与小宝贝相处的过程，发现父母就是领导者，领导者要带领好跟队的人，让对方的行为符合预期，仅仅有言语的教导还远远不够，更重要的是以身作则，用榜样去引导，用耐心而温情的去陪伴。</li></ul><p>新的一年，以如下三点来勉励自己，希望能够在各个方面有更多更大的拓展与进步。</p><h2 id="专注于目标"><a href="#专注于目标" class="headerlink" title="专注于目标"></a><strong>专注于目标</strong></h2><p>人是一个情感的动物，很多时候都会被情绪控制，诸如别人为什么这么无礼；别人为什么会这么粗鲁；别人为什么会如此待人等等此类问题经常控制着我们日常的心绪，让我们分心费神而忘了生活本来的面目。加上网络上无数的新闻热点更是把我们的关注力都打散，然后真正投入到有价值的目标中的时间精力其实并不多。扪心自问，很多时候我们之所以没能做的更好，是因为我们没有足够专注，没有把时间与精力用到正确的地方，那些琐碎而毫无价值的事情占据了我们太多的心力，从而让我们看起来总是碌碌无为。</p><p>正本清源，关注人生中有价值的部分，长期专注的投入才能获得更长足的进步。</p><h2 id="追求卓越"><a href="#追求卓越" class="headerlink" title="追求卓越"></a><strong>追求卓越</strong></h2><p>偶然的机会，了解了稻盛和夫，听了两本他的有声书(&lt;思维方式&gt;，&lt;稻盛和夫给年轻人的忠告&gt;)，有种被敲醒的感觉，很多的道理看似简单，要放到之前我可能都认为是心灵鸡汤，不值得理会，但如今再深思，竟然觉得说的太对，太好了。真是<code>too young, too simple</code>。年轻气盛，实则是头脑简单，想的太少，段位太低了。从稻盛和夫的人生哲学中，我看到了追求卓越的价值与意义。在任何事情上，能做到95分，就决不能满足于90分，只要有提升的空间，都要不遗余力的为之努力。人生的价值在于创造，在于不断的发掘自身的潜能，在于追求卓越的过程。</p><h2 id="开放与自省"><a href="#开放与自省" class="headerlink" title="开放与自省"></a><strong>开放与自省</strong></h2><p>认真想一想，人经常竭力维护的骄傲与自尊实际上并没有太重要的价值，有时反而是阻碍我们获得真相的绊脚石。思维的桎梏部分是因为经年累月的懒惰造成，部分是社会文化的传染影响导致。要想获得创造力与想象力，打开心灵，保持开放与自省才是正道。开放，意味着准备接纳任何观念与事实，不去人为的设定限制；自省，则是给自己的心灵提供一个观察自我的窗口，让我们看到在内心的深处，我们并没有想的那么聪明，让我们懂得谦卑，懂得看到这个世界多元的价值与意义， 不至于走向偏执。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;创造力 &amp;#x3D; 能力 × 热情 × 思维方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“能力”是指努力学到的知识、经验和技能&lt;/li&gt;
&lt;li&gt;“热情”是指工作时所有的激情和渴望成功等因素&lt;/li&gt;
&lt;li&gt;“思维方式”则指对待工作的心态、精神状态和价值偏好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个人和一个企业能够取得多大成就，就看三个因素的乘积&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;稻盛和夫&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1661306118447-6eac9ce5866f?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1074&amp;q=80&quot; alt=&quot;flow on the sea&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="https://sniffer.site/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="新冠病毒" scheme="https://sniffer.site/tags/%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92/"/>
    
    <category term="个人总结" scheme="https://sniffer.site/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络优化之AVB/TSN</title>
    <link href="https://sniffer.site/2022/12/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BAVB-TSN/"/>
    <id>https://sniffer.site/2022/12/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BAVB-TSN/</id>
    <published>2022-12-06T10:15:35.000Z</published>
    <updated>2023-04-18T01:51:19.479Z</updated>
    
    <content type="html"><![CDATA[<p>这是<code>Linux</code>网络优化系列的第四篇文章，也是最后一篇了。最近有点忙，没有抽出时间来梳理这些知识点, 看了下文章历史，这个优化系列文章前后持续了大半年时间，今天总算达成了目标*_*。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>自从互联网诞生以来, 音视频(Audio&#x2F;Video, AV)在网络上传输已经是稀松平常的事情. 那么, 为什么还需要一个新的基于以太网的协议来传输AV数据了? 传统的音视频传输都是点对点单向连接, 比如音频通常使用<code>I2S</code>或<code>SPDIF/AES</code>; 视频则使用<code>SDI</code>或者<code>HDMI</code>, 这种专用的单向连接在多设备情况下往往容易出现杂乱无章的连接线束:</p><span id="more"></span><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/StudioWiring.png" alt="AV wiring"></p><p>为了解决上述问题, 满足音视频数据传输中<a href="https://web.archive.org/web/20140405091013if_/http://www.avnu.org/files/static_page_files/AAF3193A-1D09-3519-AD45FC42893D1949/No-excuses%20Audio%20Video%20Networking%20v2.pdf">低延迟&#x2F;严格时间同步的需求</a>, 解决音视频传输中丢包&#x2F;传输延迟等问题，在2004年左右, IEEE 802.3小组接收了一个<code>CFI(Call For Interest)</code>有关将以太网用于低时延(<code>Time-sensitive</code>)的音视频传输的方案. 传统以太网是没有时间同步的, 而且由于网络链路存在难以预料的时延以及拥塞, 很难满足AV数据的传输要求, 为此IEEE专门成立了一个<code>802.1 Audio/Video Bridging</code>任务小组, 该小组开发出了一系列新的协议来解决上面碰到的问题, 即<code>AVB(Audio/Video Bridging)</code>协议族。<code>AVB</code>最开始是面向音视频数据传输，但其低延迟的特性使得<code>AVB</code>能很好的解决汽车领域中诸如娱乐座舱（摄像头&#x2F;屏幕显示），车身控制以及自动驾驶等领域的问题。<code>AVB</code>核心的协议主要由如下三个标准协议组成：</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/protocol_for_AE.png" alt="protocol stack of AE"></p><ul><li><code>IEEE 802.1AS-2011 (gPTP)</code>： 精确的时间同步(<code>precise synchronization</code>)</li><li>支持对多媒体数据的流整形(<code>traffic shaping</code>), 用于数据流均衡, 对应<code>IEEE 802.1Qav-2009 (FQTSS, Forwarding and Queuing for Time-Sensitive Streams)</code></li><li>带宽允许控制(<code>admission controls</code>), 预分配足够的带宽用于AV数据传输, 即<code>IEEE 802.1Qat-2010 (Stream Reservation Protocol, SRP)</code>， 由<a href="https://www.juniper.net/documentation/us/en/software/junos/mvrp/multicast-l2/topics/concept/mvrp-mx-series-understanding.html"><code>MMRP</code>&#x2F;<code>MVRP</code>&#x2F;<code>MSRP</code></a>三个协议组成。</li></ul><p>同时, AVB还提供两个传输层协议: <code>IEEE 1722-2011(AV Transport Protocol, AVTP)</code>用于音视频数据的传输;<code>IEEE 1722.1-2013(Device Discovery, Connection Management, and Control Protocol)</code>用于AVB设备的发现与连接管理. 到2012年, 为了更好的体现AVB协议的核心理念: 通过IEEE 802(以太网)提供时间同步&#x2F;低延迟的流媒体数据传输服务, AVB被重新命名为<code>TSN(Time-Sensitive Network)</code>, 后续所有的标准化工作都在<code>IEEE 802.1 TSN</code>小组展开.</p><p>随着近年来智能座舱概念的落地, 在汽车中引入更多娱乐设备, 比如扬声器, 摄像头, 甚至直播设备逐渐成为未来的趋势. 加之车载以太网从原来的<code>100Mbps</code>成熟演变到如今的<code>1Gbps</code>, 以太网已经成为车上各个域控制器的相互通讯的标准接口, 成为将车上各种设备如摄像头，扬声器，自动驾驶控制器等相互连接的方式，因此可以预见, <code>AVB/TSN</code>会成为车载娱乐领域&#x2F;自动驾驶相关的支撑技术而得到更为广泛的应用.</p><h2 id="AVB协议"><a href="#AVB协议" class="headerlink" title="AVB协议"></a><strong>AVB协议</strong></h2><p>AVB协议基于MAC层(L2)改进而来, 发送AV数据的设备称为<code>Talker</code>, 而接收AV数据的设备则称为<code>Listener</code>. 接受端与发送端应用基于AVB通讯时(一个<code>Talker</code>可能对应多个<code>Listener</code>, 因此实际上AVB的数据流都是多播数据, 通常需要通过<code>VLAN</code>对数据流进行分组), 不再通过TCP&#x2F;IP协议栈, 而是直接用<code>RAW SOCKET</code>与MAC层进行通讯, 与<code>TCP/IP</code>的实现不同，AVB协议都是在用户空间中实现的:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/AVB%20stack.png" alt="AVB stack"></p><p>接下来, 我们就重点来看看AVB三个核心协议的具体是如何工作的.</p><h3 id="时间同步-gPTP"><a href="#时间同步-gPTP" class="headerlink" title="时间同步-gPTP"></a><strong>时间同步-gPTP</strong></h3><p>AVB设备需要通过一个基准时钟定时同步时间信息, 以确保多个数据流的时间严格同步, 同时保证数据的发送与接收处于相同的时间序列. 这个用于精确时间同步的协议就是<code>IEEE 802.1AS gPTP</code>(<code>generic Precise Time Protocol</code>), gPTP实际是另一个时间同步协议<a href="https://en.wikipedia.org/wiki/Precision_Time_Protocol">IEEE 1588 PTP</a>的子集. <code>IEEE 802.1AS gPTP</code>与<code>IEEE 1588 PTP</code>的区别在与, <code>gPTP</code>假定所有的节点的通讯都是基于<code>IEEE 802 MAC</code>的PDU格式以及寻址, 而<code>PTP</code>可以支持从MAC层(L2)到L3&#x2F;L4的通讯协议. 对于gPTP来说, 在一个时间同步域(<code>timing domain</code>, 遵循gPTP标准并使用其同步时间的所有设备构成一个同步域)内, 有一个设备提供主时钟信号, 为其他所有设备提供参考时钟, 这个设备被称为<code>Grand Master Clock(GMC)</code>.</p><p>对于<code>gPTP</code>协议来说, 有两个问题需要解决: </p><ul><li>如何选择<code>Grand Master Clock</code>?</li><li>各个通讯节点如何同步时间?</li></ul><p>一般来说, <code>Grand Master Clock</code>设备可以在连接初始化时动态选择也可以预先配置(对车载网络来说, 可以选择静态配置的方式, 通常选择网关作为<code>Grand Master</code>). 动态选择需要通过<code>BMCA(Best Master Clock selection Algorithm)</code>.<code>BMCA</code>是一个分布式算法, 其工作原理大致是: 每个可做<code>Grand Master</code>的节点收到<code>announce</code>消息后, 比较自身时间与当前最好的<code>Grand Master</code>时间之间的质量值(如何衡量时间相关的质量值?), 如果8次不同的评价产生了一个比当前<code>Grand Master</code>时钟更好的时间值, 则完成<code>Grand Master</code>选择过程, 该节点宣称自己成为<code>Grand Master</code>.</p><p><code>AVB</code>设备在物理连接建立的过程中, 会交换设备的能力信息, 如果对端设备支持PTP, 则两个设备会开始同步时钟, 否则就形成一个时间同步域(该过程通过<a href="https://en.wikipedia.org/wiki/Spanning_Tree_Protocol">生成树算法</a>完成):</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/1024px-AVB-Ethernet-connections.png" alt="AVB domains"></p><p>要同步各个节点的时间, 首先, 每个网络节点需要知道消息在网络中传递的延迟, 在<code>gPTP</code>协议中有一个被称为<code>pDelay</code>衡量的过程: 确保节点都能准确知道其与邻近节点的消息传播延迟. 为了得到准确的<code>pDelay</code>值, 最好利用网卡硬件的时间戳而不是软件时间来进行时间采样. 时间同步的最后关键一步是, <code>Grand Master</code>需要发送<code>sync/folow-up</code>两个消息来完成与各个节点的时间同步. <code>gPTP</code>的整个功能如下图所示:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/how_gPTP_works.png" alt="how gPTP works"></p><h3 id="带宽预留-SRP"><a href="#带宽预留-SRP" class="headerlink" title="带宽预留-SRP"></a><strong>带宽预留-SRP</strong></h3><p><code>IEEE 802.1Qat Stream Reservation Protocol(SRP)</code>用于AVB网络中各个节点预分配带宽以满足音视频数据传输带宽的要求. 其大致流程是, <code>Talker</code>(数据发送节点)会发送广播消息到其他AVB节点, 告知有可用的数据流; 如果某个<code>Listener</code>(数据接收节点)需要接收数据流, 同样需要广播该消息, 如此所有节点(包括switch)会预留足够的带宽以确保数据流可以通过.如果预留失败, 则<code>SRP</code>的带宽预留请求失败. 通常, 对于A类(<code>class A</code>, 优先级最高)流量可以最多预留50%的带宽; B类流量(<code>class B</code>)流量预留20%的带宽.</p><blockquote><p>对于车载应用来说, SRP预留带宽失败是不可接受的(万一此时有摄像头需要传递比较关键的ADAS数据就悲剧了), 因此可以采取静态预留带宽的方式, 由各个节点在网卡初始化时提前预留带宽.</p></blockquote><p>对于带宽预留请求而言, 只需要一个唯一的64bit的<code>stream ID</code>即可; <code>stream ID</code>通常由<code>Talker</code>的MAC地址, 一个16bit由<code>Talker</code>分配的数值以及该<code>stream</code>的质量数据(包括数据流类型, 包速率以及每个包的长度)组成. 下图是非压缩的立体声音频数据在不同数据流类型下所需要预留的带宽:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/required_bandwidth_for_audio.png" alt="required bandwidth for stereo audio data"></p><p>SRP协议使用了一组协议, <a href="(https://en.wikipedia.org/wiki/Multiple_Registration_Protocol)"><code>MMRP(Multiple MAC Registration Protocol)</code></a>(以太网协议ID为<code>0x88F6</code>)用于控制分组注册, <code>MVRP(Multiple VLAN Registration Protocol)</code>(协议ID为<code>0x88F6</code>)用于VLAN组成员管理, <a href="https://en.wikipedia.org/wiki/Multiple_Registration_Protocol"><code>MSRP(Multiple Stream Registration Protocol)</code></a>(协议ID为<code>0x22EA</code>)用于数据流带宽的预留.</p><h3 id="数据流整形-FQTSS"><a href="#数据流整形-FQTSS" class="headerlink" title="数据流整形-FQTSS"></a><strong>数据流整形-FQTSS</strong></h3><p>AVB要求数据包在传输过程中不能出现丢包, 因此就要求网络中各个节点确保AVB数据包进行高效&#x2F;快速(确保延迟满足要求)转发， 同时为了能够有效利用带宽，保证普通的数据包（<code>Best Effort</code>)与AVB数据直接的公平性，引入了<code>IEEE 802.1Qav Forwarding and Queuing for Time-Sensitive Streams</code>(简称<code>FQTSS</code>)协议。<code>FQTSS</code>主要用于流整形（<code>traffic shaping</code>)， 其基于<a href="https://en.wikipedia.org/wiki/Credit-based_fair_queuing"><code>基于信用的流整形(credit-based shaper)</code></a>的算法，对数据流进行排队与转发; 通常来说， AVB流量优先级要高于普通流量， 而AVB中的A类流量优先级又要高于B类流量。</p><p>下图是<code>CBS</code>算法的一个示意图，AVB数据与非AVB数据(<code>Best Effort, BE</code>)的传输都受到当前<code>credit</code>值的影响：</p><ul><li>当<code>credit &gt;= 0</code>时，如果没有AVB数据， <code>credit</code>就会设为0; 否则持续发送AVB数据直到<code>credit</code>的值变为负（根据<code>sendSlope</code>开始减小)</li><li>当<code>credit &lt; 0</code>时， 发送普通的BE类数据, <code>credit</code>会基于<code>idleSlope</code>不断累积直到等于0</li><li><code>credit</code>的变化由<code>sendSlope</code>以及<code>idleSlope</code>两个值确定， <code>sendSlope</code>与<code>idleSlope</code>的关系如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sendSlope = idleSlope − portTransmitRate</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里<code>portTransmitRate</code>即端口的理论速率， 比如对于<code>1000Mbps</code>网络来说，该值为<code>10000bit/s</code>。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/credit-based_shaping_with_fqtss.png" alt="traffic shaping using FQTSS"></p><p>Linux的网络驱动中增加了一个<code>CBS</code>的流量控制模块（代码路径<code>kernel/net/sched/sched_cbs.c</code>)， 支持软件模拟网关中硬件的<code>CBS</code>算法， 同时还可以将算法卸负（<code>offload</code>）到网卡。 详细信息也可以参考<code>http://manpages.ubuntu.com/manpages/bionic/man8/tc-cbs.8.html</code>.</p><h2 id="Open-AVB"><a href="#Open-AVB" class="headerlink" title="Open-AVB"></a><strong>Open-AVB</strong></h2><p>早在2013年左右， TSN标准化机构<a href="https://avnu.org/"><code>AVNU</code></a>开发了一套开源的AVB协议栈<a href="https://github.com/Avnu/OpenAvnu"><code>openAVB</code></a>, 其实现了常见的AVB协议， 如<code>gPTP</code>&#x2F;<code>SRP</code>&#x2F;<code>FQTSS</code>&#x2F;<code>AVTP</code>&#x2F;<code>AVDECC</code>等。基于这套协议， 我们可以开发自己的AVB应用， 更多有关该<code>AVB</code>协议开发的一些信息可以参考官方文档<a href="http://avnu.github.io/OpenAvnu/avtp-pipeline/html/index.html">Open-AVB AVTP Pipeline SDK</a>.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://en.wikipedia.org/wiki/Time-Sensitive_Networking">Time Sensitive Networking</a></li><li><a href="http://avnu.github.io/OpenAvnu/avtp-pipeline/html/sdk_overview.html">OpenAVB SDK overview</a></li><li><a href="https://github.com/Avnu/OpenAvnu">OpenAvnm AVB protocol stack</a></li><li><a href="https://tsn.readthedocs.io/avb.html">Getting Started with AVB on linux</a></li><li><a href="https://source.codeaurora.org/quic/la/platform/external/Open-AVB">Codeaurora Open-AVB</a></li><li><a href="https://www.ieee802.org/1/pages/802.1ba.html">IEEE 802 AVB相关协议</a></li><li><a href="https://web.archive.org/web/20140405091013if_/http://www.avnu.org/files/static_page_files/AAF3193A-1D09-3519-AD45FC42893D1949/No-excuses%20Audio%20Video%20Networking%20v2.pdf">AVB诞生的一些历史</a></li><li><a href="https://www.ijeat.org/wp-content/uploads/papers/v9i1s5/A13801291S52019.pdf">Qualitative Examination of Credit Based Shaper in IEEE 802.1AVB</a></li><li><a href="https://avnu.org/wp-content/uploads/2014/05/AVnu-AAA2C_Types-of-Traffic-in-AVB-2_Michael-Johas-Teener-Markus-Jochim.pdf">Types of Traffic in AVB 2</a></li><li><a href="https://www.amazon.com/Automotive-Ethernet-Kirsten-Matheus/dp/1108841953">Automative Ethernet 3rd Edition</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是&lt;code&gt;Linux&lt;/code&gt;网络优化系列的第四篇文章，也是最后一篇了。最近有点忙，没有抽出时间来梳理这些知识点, 看了下文章历史，这个优化系列文章前后持续了大半年时间，今天总算达成了目标*_*。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;自从互联网诞生以来, 音视频(Audio&amp;#x2F;Video, AV)在网络上传输已经是稀松平常的事情. 那么, 为什么还需要一个新的基于以太网的协议来传输AV数据了? 传统的音视频传输都是点对点单向连接, 比如音频通常使用&lt;code&gt;I2S&lt;/code&gt;或&lt;code&gt;SPDIF/AES&lt;/code&gt;; 视频则使用&lt;code&gt;SDI&lt;/code&gt;或者&lt;code&gt;HDMI&lt;/code&gt;, 这种专用的单向连接在多设备情况下往往容易出现杂乱无章的连接线束:&lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="Linux" scheme="https://sniffer.site/tags/Linux/"/>
    
    <category term="AVB" scheme="https://sniffer.site/tags/AVB/"/>
    
    <category term="TSN" scheme="https://sniffer.site/tags/TSN/"/>
    
    <category term="网络优化" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>如何用FFmpeg在Android上实现音视频解码</title>
    <link href="https://sniffer.site/2022/09/30/%E5%A6%82%E4%BD%95%E7%94%A8FFMPEG%E5%9C%A8Android%E4%B8%8A%E5%81%9A%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81/"/>
    <id>https://sniffer.site/2022/09/30/%E5%A6%82%E4%BD%95%E7%94%A8FFMPEG%E5%9C%A8Android%E4%B8%8A%E5%81%9A%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81/</id>
    <published>2022-09-30T09:44:43.000Z</published>
    <updated>2023-04-25T06:18:03.107Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发投屏功能，需要对<code>H.264</code>视频数据流进行解码，然后显示出来。Android原生的<code>MediaCodec</code>虽然使用了硬件解码，但是延迟较大（超过300ms），无法满足要求。于是研究了下如何基于<a href="https://ffmpeg.org/">FFMPEG</a>来做视频流的软解码。这里对整个过程做简要的总结，看下如何在<code>Android Studio</code>中完成<code>FFMPEG</code>的视频解码: </p><ul><li>简单介绍下FFMPEG框架</li><li>如何利用交叉编译生成所需要的FFMPEG共享库, 以及如何进行<code>Android Studio</code>的配置</li><li>FFMPEG解码H264的大致调用流程</li></ul><span id="more"></span><h2 id="FFMPEG框架介绍"><a href="#FFMPEG框架介绍" class="headerlink" title="FFMPEG框架介绍"></a><strong>FFMPEG框架介绍</strong></h2><p><a href="https://en.wikipedia.org/wiki/FFmpeg">FFmpeg(Fast Forward mpeg)</a>是音视频编解码开源框架的标杆，支持常见音视频格式的编解码，如<code>H.264</code>&#x2F;<code>AAC</code>&#x2F;<code>H.265</code>&#x2F;<code>MP4</code>等，也支持不同格式之间的转码，同时还支持流媒体协议如<code>RTSP</code>&#x2F;<code>RTMP</code>。目前，不少视频网站如<code>Youtube</code>&#x2F;<code>Bilibili</code>等都是通过<code>FFmpeg</code>来实现音视频的处理的。</p><p>按功能模块划分，<code>FFmpeg</code>大致分为如下几个部分:</p><ul><li><code>libavcodec</code>: 包含了所有音视频编解码的核心代码</li><li><code>libavdevice</code>: 用于操作内部、外部音视频设备，以达到硬件加速&#x2F;显示&#x2F;加速等功能</li><li><code>libavfilter</code>: 音视频滤波器的开发，如宽高比、裁剪、格式化、非格式化、伸缩等</li><li><code>libavformat</code>： 用于解析各种不同的音视频封装格式</li><li><code>libavutil</code>： 包含公共的工具函数，如算术运算、字符操作等</li><li><code>libswresample</code>： 原始音频格式转码</li><li><code>libswscale</code>： 用于视频场景比例缩放、色彩映射转换、图像颜色空间或格式转换,如RGB565&#x2F;RGB888等与 YUV420等之间的转换。</li></ul><p>同时，<code>FFmpeg</code>源码中包含了<code>ffprobe</code>(用于分析音视频数据流)&#x2F;<code>ffplay</code>(基于<a href="https://www.libsdl.org/">SDL</a>的播放器)&#x2F;<code>ffmpeg</code>(视频转换工具)等常用的工具。初次使用<code>FFmepg</code>接口时，可以参考源码中的示例<code>doc/examples</code>, 里面给出了很多常见接口的使用方法。</p><p>更多有关<code>FFmpeg</code>的资料，可以参考:</p><ul><li><a href="https://blog.csdn.net/leixiaohua1020/category_1360795.html?spm=1001.2014.3001.5482">雷霄骅(leixiaohua1020)的专栏</a></li><li><a href="https://ffmpeg.org/">FFmpeg官方网站</a></li></ul><p>下面我们就来看下如何在<code>Ubuntu</code>环境中交叉编译<code>FFmpeg</code>到基于Android的<code>ARM64</code>平台架构上。</p><blockquote><p>我使用的编译环境是 Ubuntu 18.04 + Android ndk 22.1.7171670</p></blockquote><h2 id="交叉编译FFmpeg到Android平台"><a href="#交叉编译FFmpeg到Android平台" class="headerlink" title="交叉编译FFmpeg到Android平台"></a><strong>交叉编译FFmpeg到Android平台</strong></h2><p>首先通过<code>git</code>下载<code>FFmpeg</code>源码, 为确保功能稳定，编译使用的是最近发布版本分支<code>release/5.1</code>的代码: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git clone https://github.com/FFmpeg/FFmpeg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到5.1分支</span></span><br><span class="line">git checkout -b rel_5.1 origin/release/5.1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下载完后，可以通过<code>./configure -h</code>来查看各种编译配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Usage: configure [options]</span><br><span class="line">Options: [defaults in brackets after descriptions]</span><br><span class="line"></span><br><span class="line">Help options:</span><br><span class="line">  --help                   print this message</span><br><span class="line">  --quiet                  Suppress showing informative output</span><br><span class="line">  --list-decoders          show all available decoders</span><br><span class="line">  --list-encoders          show all available encoders</span><br><span class="line">  --list-hwaccels          show all available hardware accelerators</span><br><span class="line">  --list-demuxers          show all available demuxers</span><br><span class="line">  --list-muxers            show all available muxers</span><br><span class="line">  --list-parsers           show all available parsers</span><br><span class="line">  --list-protocols         show all available protocols</span><br><span class="line">  --list-bsfs              show all available bitstream filters</span><br><span class="line">  --list-indevs            show all available input devices</span><br><span class="line">  --list-outdevs           show all available output devices</span><br><span class="line">  --list-filters           show all available filters</span><br><span class="line"></span><br><span class="line">Standard options:</span><br><span class="line">  --logfile=FILE           log tests and output to FILE [ffbuild/config.log]</span><br><span class="line">  --disable-logging        do not log configure debug information</span><br><span class="line">  --fatal-warnings         fail if any configure warning is generated</span><br><span class="line">  --prefix=PREFIX          install in PREFIX [/usr/local]</span><br><span class="line">  --bindir=DIR             install binaries in DIR [PREFIX/bin]</span><br><span class="line">  --datadir=DIR            install data files in DIR [PREFIX/share/ffmpeg]</span><br><span class="line">  --docdir=DIR             install documentation in DIR [PREFIX/share/doc/ffmpeg]</span><br><span class="line">  --libdir=DIR             install libs in DIR [PREFIX/lib]</span><br><span class="line">  --shlibdir=DIR           install shared libs in DIR [LIBDIR]</span><br><span class="line">  --incdir=DIR             install includes in DIR [PREFIX/include]</span><br><span class="line">  --mandir=DIR             install man page in DIR [PREFIX/share/man]</span><br><span class="line">  --pkgconfigdir=DIR       install pkg-config files in DIR [LIBDIR/pkgconfig]</span><br><span class="line">  --enable-rpath           use rpath to allow installing libraries in paths</span><br><span class="line">                           not part of the dynamic linker search path</span><br><span class="line">                           use rpath when linking programs (USE WITH CARE)</span><br><span class="line">  --install-name-dir=DIR   Darwin directory name for installed targets</span><br><span class="line"></span><br><span class="line">Licensing options:</span><br><span class="line">  --enable-gpl             allow use of GPL code, the resulting libs</span><br><span class="line">                           and binaries will be under GPL [no]</span><br><span class="line">  --enable-version3        upgrade (L)GPL to version 3 [no]</span><br><span class="line">  --enable-nonfree         allow use of nonfree code, the resulting libs</span><br><span class="line">                           and binaries will be unredistributable [no]</span><br><span class="line"></span><br><span class="line">Configuration options:</span><br><span class="line">  --disable-static         do not build static libraries [no]</span><br><span class="line">  --enable-shared          build shared libraries [no]</span><br><span class="line">  --enable-small           optimize for size instead of speed</span><br><span class="line">  --disable-runtime-cpudetect disable detecting CPU capabilities at runtime (smaller binary)</span><br><span class="line">  --enable-gray            enable full grayscale support (slower color)</span><br><span class="line">  --disable-swscale-alpha  disable alpha channel support in swscale</span><br><span class="line">  --disable-all            disable building components, libraries and programs</span><br><span class="line">  --disable-autodetect     disable automatically detected external libraries [no]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，为了便于编译，我们需要写一个编译脚本<code>build_android.sh</code>，用于配置交叉编译的参数与环境变量(这里只编译了64位系统的库，如果要编译32位的库，修改下ARCH、CPU变量即可: <code>ARCH=arm; CPU=armv7-a</code>):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export NDK=/xxx/AndroidSDK/ndk/22.1.7171670</span><br><span class="line">TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">function build_android</span><br><span class="line">&#123;</span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--disable-postproc \</span><br><span class="line">--disable-debug \</span><br><span class="line">--disable-symver \</span><br><span class="line">--disable-static \</span><br><span class="line">--enable-shared \</span><br><span class="line">--disable-doc \</span><br><span class="line">--disable-ffmpeg \</span><br><span class="line">--cross-prefix=$CROSS_PREFIX \</span><br><span class="line">--target-os=android \</span><br><span class="line">--arch=$ARCH \</span><br><span class="line">--cpu=$CPU \</span><br><span class="line">--cc=$CC \</span><br><span class="line">--cxx=$CXX \</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--enable-gpl \</span><br><span class="line">--sysroot=$SYSROOT \</span><br><span class="line">--extra-cflags=&quot;-Os -fpic $OPTIMIZE_CFLAGS&quot; \</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--extra-ldflags=<span class="string">&quot;<span class="variable">$ADDI_LDFLAGS</span>&quot;</span></span></span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">echo &quot;============== build android arm64-v8a success ==============&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arm64-v8a</span></span><br><span class="line">ARCH=arm64</span><br><span class="line">CPU=armv8-a</span><br><span class="line">API=26</span><br><span class="line">CC=$TOOLCHAIN/bin/aarch64-linux-android$API-clang</span><br><span class="line">CXX=$TOOLCHAIN/bin/aarch64-linux-android$API-clang++</span><br><span class="line">SYSROOT=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot</span><br><span class="line">CROSS_PREFIX=$TOOLCHAIN/bin/aarch64-linux-android-</span><br><span class="line">PREFIX=$(pwd)/android/$CPU</span><br><span class="line">OPTIMIZE_CFLAGS=&quot;-march=$CPU&quot;</span><br><span class="line">ADDI_LDFLAGS=&quot;LDFLAGS=&#x27;-Wl,-z,relro -Wl,-z,now -pie&quot;</span><br><span class="line"></span><br><span class="line">echo $CC</span><br><span class="line"></span><br><span class="line">build_android</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行<code>chmod a+x ./build_android.sh; ./build_android.sh</code>就开始了编译。编译成功后，会有一个<code>android/armv8-a</code>的文件夹，里边包含了交叉编译生成的静态与动态库:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./android/armv8-a</span></span><br><span class="line"></span><br><span class="line">bin --&gt; 常用的工具，如`ffmpeg`, `ffprobe`</span><br><span class="line">lib --&gt; 共享库，如`libavcodec`,`libavformat`, `libswscale`等</span><br><span class="line">include --&gt; 包含所有开发所需的头文件</span><br><span class="line">share --&gt; 包含了相关示例与文档</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际开发时，我们只需要用到<code>include</code>&#x2F;<code>lib</code>两个目录中的文件即可。</p><h2 id="将共享库集成到Android-Studio"><a href="#将共享库集成到Android-Studio" class="headerlink" title="将共享库集成到Android Studio"></a><strong>将共享库集成到Android Studio</strong></h2><p>最开始配置的时候，把编译好的库放到<code>src/main/jniLibs/armv8-a</code>目录下面，编译虽然正常，但是运行时却找不到对应的库。只好新建一个目录<code>libs</code>将头文件跟预编译的库放在这里(参考<a href="https://developer.android.com/studio/projects/configure-cmake">配置CMAKE</a>):</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/as-ffmpeg-config.png" alt="FFmpeg config"></p><p>然后在<code>CMakeLists.txt</code>里添加对应的库与头文件:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">set</span>(ffmpeg_lib_dir ../../../../libs/arm64-v8a)</span><br><span class="line"><span class="built_in">set</span>(ffmpeg_head_dir ../../../../libs/arm64-v8a/include)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_library</span>( avcodec</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED)</span><br><span class="line"><span class="built_in">set_target_properties</span>(avcodec</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        $&#123;ffmpeg_lib_dir&#125;/libavcodec.so)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_library</span>( avformat</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED)</span><br><span class="line"><span class="built_in">set_target_properties</span>(avformat</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        $&#123;ffmpeg_lib_dir&#125;/libavformat.so)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_library</span>( avutil</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED)</span><br><span class="line"><span class="built_in">set_target_properties</span>(avutil</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        $&#123;ffmpeg_lib_dir&#125;/libavutil.so)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_library</span>( swscale</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED)</span><br><span class="line"><span class="built_in">set_target_properties</span>(swscale</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        $&#123;ffmpeg_lib_dir&#125;/libswscale.so)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">include_directories</span>(libs/arm64-v8a/include)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>开发使用的Android Studio的版本是<code>4.2.1</code>。</p></blockquote><p>配置完成就可以基于<code>FFmpeg</code>的接口开发了。下面我们简单来看看如何用<code>FFmpeg</code>解码<code>H264</code>的视频流。</p><h2 id="FFmpeg解码H264视频流"><a href="#FFmpeg解码H264视频流" class="headerlink" title="FFmpeg解码H264视频流"></a><strong>FFmpeg解码H264视频流</strong></h2><p>关于如何利用<code>FFmpeg</code>来解码音视频文件，网络上有很多参考资料了，比如:</p><ul><li>[FFmpeg官网参考代码]<a href="https://ffmpeg.org/doxygen/trunk/decode_video_8c-example.html">https://ffmpeg.org/doxygen/trunk/decode_video_8c-example.html</a></li><li><a href="https://www.sobyte.net/post/2022-03/android-ffmpeg/">基于Android的FFmpeg完整参考示例</a></li></ul><p>解码从网络端接收到的视频流，大致流程基本一致， 主要分为几个关键的步骤:</p><ul><li>初始化<code>FFmpeg</code>解码器, 如找到对应的解码器，配置解码器:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mVideoDecoder = <span class="built_in">avcodec_find_decoder</span>(AV_CODEC_ID_H264);</span><br><span class="line"><span class="keyword">if</span> (mVideoDecoder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;%s: fail to find h264 decoder&quot;</span>, __func__ );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mVCodecCtx = <span class="built_in">avcodec_alloc_context3</span>(mVideoDecoder);</span><br><span class="line"><span class="keyword">if</span> (mVCodecCtx == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;%s: fail to create codec context&quot;</span>, __func__ );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mVCodecCtx-&gt;flags |= AV_CODEC_FLAG_LOW_DELAY;</span><br><span class="line"><span class="comment">//mVCodecCtx-&gt;flags |= AV_CODEC_FLAG2_FAST;</span></span><br><span class="line"></span><br><span class="line">mVCodecCtx-&gt;width = mVideoW;</span><br><span class="line">mVCodecCtx-&gt;height = mVideoH;</span><br><span class="line">mVCodecCtx-&gt;bit_rate = IDecoder::BIT_RATE;</span><br><span class="line">mVCodecCtx-&gt;framerate = <span class="built_in">av_make_q</span>(IDecoder::FRAME_RATE, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(mVCodecCtx, mVideoDecoder, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;%s: Fail to open codec: %s&quot;</span>, __func__ , <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="built_in">avcodec_free_context</span>(&amp;mVCodecCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>将接收到的<code>H264</code>数据流分片NAL(<code>Network Abstraction Layer</code>)后，放入队列</li><li>解码线程从队列中取出数据包，然后解码;解码的过程大致分为四个步骤：<ul><li>发送待解码的数据报给解码器<code>avcodec_send_packet</code></li><li>从解码器接收解码后的包<code>avcodec_receive_frame</code></li><li>将解码的包从<code>YUV</code>格式转换为<code>RGB</code>格式</li><li>将<code>RGB</code>格式的视频帧拷贝到<code>Surface</code>进行渲染</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FFmpegDecoder::doDecode</span><span class="params">(h264_decode_struct *packet)</span> </span>&#123;</span><br><span class="line">    AVPacket *raw_packet = mDecoderResources-&gt;avPacket;</span><br><span class="line">    <span class="keyword">if</span> (raw_packet != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        raw_packet-&gt;data = packet-&gt;data;</span><br><span class="line">        raw_packet-&gt;size = packet-&gt;data_len;</span><br><span class="line">        raw_packet-&gt;pts = packet-&gt;pts;</span><br><span class="line">        <span class="comment">/* send raw packet to decode */</span></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">avcodec_send_packet</span>(mCodecCtx, raw_packet);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span> &amp;&amp; res != <span class="built_in">AVERROR</span>(EAGAIN)) &#123;</span><br><span class="line">            <span class="built_in">LOGE</span>(<span class="string">&quot;%s: Could not send video packet&quot;</span>, __func__ );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* decode frame */</span></span><br><span class="line">        AVFrame *frame = mDecoderResources-&gt;decodeFrame;</span><br><span class="line">        res = <span class="built_in">avcodec_receive_frame</span>(mCodecCtx, frame);</span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            <span class="built_in">LOGD</span>(<span class="string">&quot;%s: decoded frame pts = %lld, pixel-format = %d, picture-type = %d&quot;</span>, __func__ , (<span class="type">long</span> <span class="type">long</span>)frame-&gt;pts, frame-&gt;format, frame-&gt;pict_type);</span><br><span class="line">            <span class="keyword">if</span> (frame-&gt;width != mVideoW || frame-&gt;height != mVideoH) &#123;</span><br><span class="line">                <span class="built_in">LOGE</span>(<span class="string">&quot;%s: video size changed, drop frame&quot;</span>, __func__ );</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * render to Surface</span></span><br><span class="line"><span class="comment">             * decoded frame is YUV format which need to transform to RGB before rendering</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            AVFrame *rgb_frame = mDecoderResources-&gt;rgbFrame;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">av_image_fill_arrays</span>(rgb_frame-&gt;data, rgb_frame-&gt;linesize, mDecodeOutBuf, AV_PIX_FMT_RGBA,</span><br><span class="line">                                 mVideoW, mVideoH, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">SwsContext</span> *data_convert_ctx = <span class="built_in">sws_getContext</span>(mVideoW, mVideoH, mCodecCtx-&gt;pix_fmt,</span><br><span class="line">                                                                 mVideoW, mVideoH, AV_PIX_FMT_RGBA,</span><br><span class="line">                                                                 SWS_BICUBIC, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">            <span class="comment">/* from YUV to RGA */</span></span><br><span class="line">            res = <span class="built_in">sws_scale</span>(data_convert_ctx, (<span class="type">const</span> <span class="type">uint8_t</span> * <span class="type">const</span> *) frame-&gt;data, frame-&gt;linesize, <span class="number">0</span>,</span><br><span class="line">                            mVideoH, rgb_frame-&gt;data, rgb_frame-&gt;linesize);</span><br><span class="line">            <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">sws_freeContext</span>(data_convert_ctx);</span><br><span class="line">                <span class="built_in">LOGE</span>(<span class="string">&quot;%s: Fail to scale frame : %s&quot;</span>, __func__ , <span class="built_in">strerror</span>(errno));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* render to screen */</span></span><br><span class="line">                res = <span class="built_in">ANativeWindow_lock</span>(mNativeWin, mWindowBuf, <span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">LOGE</span>(<span class="string">&quot;%s: Fail to lock window&quot;</span>, __func__ );</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">uint8_t</span> *bits = (<span class="type">uint8_t</span> *) mWindowBuf-&gt;bits;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mVideoH; ++i) &#123;</span><br><span class="line">                        <span class="built_in">memcpy</span>(bits + i * mWindowBuf-&gt;stride * <span class="number">4</span>,</span><br><span class="line">                               mDecodeOutBuf + i * rgb_frame-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                               rgb_frame-&gt;linesize[<span class="number">0</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">ANativeWindow_unlockAndPost</span>(mNativeWin);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sws_freeContext</span>(data_convert_ctx);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LOGE</span>(<span class="string">&quot;%s: fail to receive frame %d&quot;</span>, __func__ , res);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相比Android原生的<code>MediaCodec</code>硬解码，<code>FFmpeg</code>解码效率提升了很多，延迟从原来的<code>400+ms</code>减少到了<code>100ms</code>左右，改善明显。但是由于使用了CPU进行解码操作，系统的负载与CPU使用率都会有所升高。因此，在进行高清视频的解码时硬解码会更合适。</p><p>总结下来，<code>FFmpeg</code>框架确实十分强大，也有比较完善的生态社区，可以说是搞音视频开发必不可少的利器。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://www.sobyte.net/post/2022-03/android-ffmpeg/">https://www.sobyte.net/post/2022-03/android-ffmpeg/</a></li><li><a href="https://trac.ffmpeg.org/wiki/CompilationGuide/Android">https://trac.ffmpeg.org/wiki/CompilationGuide/Android</a></li><li><a href="https://yumichan.net/video-processing/video-compression/introduction-to-h264-nal-unit/">https://yumichan.net/video-processing/video-compression/introduction-to-h264-nal-unit/</a></li><li><a href="https://trac.ffmpeg.org/wiki/CompilationGuide/Ubuntu#FFmpeg">https://trac.ffmpeg.org/wiki/CompilationGuide/Ubuntu#FFmpeg</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近开发投屏功能，需要对&lt;code&gt;H.264&lt;/code&gt;视频数据流进行解码，然后显示出来。Android原生的&lt;code&gt;MediaCodec&lt;/code&gt;虽然使用了硬件解码，但是延迟较大（超过300ms），无法满足要求。于是研究了下如何基于&lt;a href=&quot;https://ffmpeg.org/&quot;&gt;FFMPEG&lt;/a&gt;来做视频流的软解码。这里对整个过程做简要的总结，看下如何在&lt;code&gt;Android Studio&lt;/code&gt;中完成&lt;code&gt;FFMPEG&lt;/code&gt;的视频解码: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单介绍下FFMPEG框架&lt;/li&gt;
&lt;li&gt;如何利用交叉编译生成所需要的FFMPEG共享库, 以及如何进行&lt;code&gt;Android Studio&lt;/code&gt;的配置&lt;/li&gt;
&lt;li&gt;FFMPEG解码H264的大致调用流程&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Android" scheme="https://sniffer.site/categories/Android/"/>
    
    
    <category term="Android" scheme="https://sniffer.site/tags/Android/"/>
    
    <category term="FFmpeg" scheme="https://sniffer.site/tags/FFmpeg/"/>
    
    <category term="H.264" scheme="https://sniffer.site/tags/H-264/"/>
    
    <category term="音视频" scheme="https://sniffer.site/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>如何通过QEMU启动Linux系统</title>
    <link href="https://sniffer.site/2022/08/27/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87QEMU%E5%90%AF%E5%8A%A8Linux%E7%B3%BB%E7%BB%9F/"/>
    <id>https://sniffer.site/2022/08/27/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87QEMU%E5%90%AF%E5%8A%A8Linux%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-08-27T12:00:03.000Z</published>
    <updated>2022-08-30T02:57:23.387Z</updated>
    
    <content type="html"><![CDATA[<p>看Linux驱动相关的代码， 却没有一个好的调试环境可以跟踪内核相关的调用流程。于是，想着用QEMU虚拟机来搭建一个Linux系统。花了大半天时间，终于能够启动一个简单的Linux系统了。中间踩了不少坑，找了不少资料，这里简单总结下整个过程。</p><blockquote><p>以下操作都是基于Ubuntu 18.04 x86_64平台</p></blockquote><p>最开始参考了<a href="https://yuankun.me/posts/running-raw-linux-kernel-in-qemu/">如何使用QEMU跑内核</a>，使用系统自带的QEMU工具，结果提示如下错误:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">qemu-system-aarch64 rom check and register reset failed</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>怀疑是QEMU的版本太低导致，于是只好又重新编译QEMU源码，最后总算大功告成。总的说来，大致要做的事情有这么几个:</p><ul><li>编译Linux内核，利用busybox来生成一个小的rootfs（关于什么是rootfs，可以参考<a href="https://tldp.org/LDP/sag/html/root-fs.html">The rootfs FS</a>)</li><li>编译QEMU，确保正常配置ARM64架构的虚拟环境</li><li>一切就绪，通过<code>qemu-system-aarch64</code>跑起来虚拟机来</li></ul><span id="more"></span><h2 id="编译Linux内核"><a href="#编译Linux内核" class="headerlink" title="编译Linux内核"></a><strong>编译Linux内核</strong></h2><p>交叉编译Linux内核，需要确保系统中存在必须的编译环境与工具:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install binutils-multiarch</span><br><span class="line">sudo apt-get install ncurses-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install gcc-aarch64-linux-gnu</span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">拷贝源码`git <span class="built_in">clone</span> https://github.com/torvalds/linux`， 进入对应目录, 执行:</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment">#创建编译目录，用于输出产物</span></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"></span><br><span class="line">make distclean</span><br><span class="line">make O=./build ARCH=arm64 defconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果需要编辑某些config，可以使用menuconfig来配置</span></span><br><span class="line">make O=./build ARCH=arm64 nconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">make O=./build ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j8</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译成功后，会在<code>arch/arm64/boot</code>下面生成内核镜像:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-rw-rw-r-- 1 jason jason 36M Aug 25 14:20 <span class="built_in">arch</span>/arm64/boot/Image</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个就是后面用于跑Linux内核的镜像文件。</p><h2 id="编译Qemu源码"><a href="#编译Qemu源码" class="headerlink" title="编译Qemu源码"></a><strong>编译Qemu源码</strong></h2><p>编译QEMU比较方便，先下载源码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/qemu/qemu</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> qemu</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">../configure</span><br><span class="line">make -j16</span><br><span class="line"></span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译大概会持续十几分钟的样子，最后记得编译完成后执行<code>make install</code>, 否则在最后启动虚拟机时会提示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">qemu-system-aarch64: failed to find romfile <span class="string">&quot;efi-virtio.rom&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编译Busybox-制作rootfs"><a href="#编译Busybox-制作rootfs" class="headerlink" title="编译Busybox,制作rootfs"></a><strong>编译Busybox,制作rootfs</strong></h2><p>编译Busybox稍微麻烦一点，需要编辑配置列表，确保生成的是静态库形式的执行文件, 大概有这么几个步骤:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"></span><br><span class="line">make O=../build/ ARCH=arm64 defconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过菜单配置config</span></span><br><span class="line">make O=../build/ ARCH=arm64 menuconfig</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/busybox_menuconfig.png" alt="busybox menuconfig"></p><p>菜单配置的方式与Linux内核的配置类似，按下<code>/</code>可以直接搜索你要设置的选项; 如果觉得菜单配置比较麻烦，也可以通过直接编辑生成的<code>.config</code>来配置选项编译为静态的方式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CONFIG_STATIC=y</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完成配置后，执行编译:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j16</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>busybox/_install</code>下面可以看到编译的产物。有了busybox我们就可以制作一个简单的rootfs文件系统了。对于busybox的系统来说，大致的启动顺序如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/sbin/init --&gt; /etc/inittab --&gt; /etc/init.d/rcS --&gt; /etc/fstab</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进入<code>busybox/_install</code>目录可以看到当前生成的目录结构:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4.0K./proc</span><br><span class="line">1.9M./bin</span><br><span class="line">16K./etc</span><br><span class="line">4.0K./tmp</span><br><span class="line">4.0K./root</span><br><span class="line">4.0K./sys</span><br><span class="line">4.0K./home</span><br><span class="line">4.0K./var</span><br><span class="line">4.0K./lib</span><br><span class="line">4.0K./mnt</span><br><span class="line">12K./usr</span><br><span class="line">4.0K./sbin</span><br><span class="line">12K./dev</span><br><span class="line">34M./</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>制作一个rootfs，可以按照如下几个步骤操作:</p><ul><li>创建目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建必要的目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p dev etc home lib mnt proc root sys tmp var</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>生成启动所需的文件</p><ul><li>etc&#x2F;inittab: 将如下内容写入到该文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::respawn:-/bin/sh</span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line">::cttlaltdel:/bin/umount -a -r</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编辑完成后，修改文件权限: <code>chmod 0755 etc/inittab</code></p><ul><li>etc&#x2F;init.d: 系统初始化脚本，可以用于创建设备以及执行文件系统挂载等操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p etc/init.d/</span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑rcS文件,输入如下内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;mount pseudo sys&quot;</span></span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">/sbin/mdev -s</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;init rc done&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了确保该文件正常执行，需要修改权限<code>chmod 0755 etc/init.d/rcS</code>. 如果除了上述<code>proc/sys</code>文件系统外，还有其他需要挂载的设备，可以放在<code>etc/fstab</code>中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">temps/tmp  rpoc  defaults 0 0</span><br><span class="line">none /tmp  ramfs defaults 0 0</span><br><span class="line">mdev /dev  ramfs defaults 0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>创建特殊文件节点</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cd</span> dev</span><br><span class="line">sudo <span class="built_in">mknod</span> console c 5 1</span><br><span class="line">sudo <span class="built_in">mknod</span> null c 1 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>将该目录的文件打包成rootfs压缩文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">find . | cpio -o -H newc &gt; rootfs.cpio </span><br><span class="line">gzip -c rootfs.cpio &gt; rootfs.cpio.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>到这里，所有的准备工作就绪了，就下来可以测试下虚拟机是否正常能跑起来了.</p><h2 id="QEMU跑起来"><a href="#QEMU跑起来" class="headerlink" title="QEMU跑起来"></a><strong>QEMU跑起来</strong></h2><p>执行如下命令，启动Linux虚拟机(具体的参数可以通过<code>qemu-system-aarch64 -h</code>查看)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">qemu-system-aarch64 \</span><br><span class="line">    -machine virt \</span><br><span class="line">    -cpu cortex-a57 \</span><br><span class="line">    -nographic -smp 1 \</span><br><span class="line">    -kernel ./Image \</span><br><span class="line">    -initrd ./rootfs.cpio.gz \</span><br><span class="line">    -append <span class="string">&quot;rdinit=/linuxrc console=ttyAMA0&quot;</span> \</span><br><span class="line">    -s <span class="comment"># 开启GDB TCP调试口</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正常启动的话，可以看到内核加载的日志以及一个虚拟的终端设备:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qemu-virt-linux.png" alt="Qemu Virt linux"></p><p>有了这个虚拟环境，无论是驱动开发，还是学习Linux内核都会方便很多了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://yuankun.me/posts/running-raw-linux-kernel-in-qemu/">https://yuankun.me/posts/running-raw-linux-kernel-in-qemu/</a></li><li><a href="https://ops.tips/notes/booting-linux-on-qemu/">https://ops.tips/notes/booting-linux-on-qemu/</a></li><li><a href="https://gts3.org/2017/cross-kernel.html">https://gts3.org/2017/cross-kernel.html</a></li><li><a href="http://events17.linuxfoundation.org/sites/events/files/slides/Shuah_Khan_cross_compile_linux.pdf">http://events17.linuxfoundation.org/sites/events/files/slides/Shuah_Khan_cross_compile_linux.pdf</a></li><li><a href="https://android.googlesource.com/platform/external/syzkaller/+/HEAD/docs/linux/setup_linux-host_qemu-vm_arm64-kernel.md">https://android.googlesource.com/platform/external/syzkaller/+/HEAD/docs/linux/setup_linux-host_qemu-vm_arm64-kernel.md</a></li><li><a href="http://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/">http://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;看Linux驱动相关的代码， 却没有一个好的调试环境可以跟踪内核相关的调用流程。于是，想着用QEMU虚拟机来搭建一个Linux系统。花了大半天时间，终于能够启动一个简单的Linux系统了。中间踩了不少坑，找了不少资料，这里简单总结下整个过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下操作都是基于Ubuntu 18.04 x86_64平台&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最开始参考了&lt;a href=&quot;https://yuankun.me/posts/running-raw-linux-kernel-in-qemu/&quot;&gt;如何使用QEMU跑内核&lt;/a&gt;，使用系统自带的QEMU工具，结果提示如下错误:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;qemu-system-aarch64 rom check and register reset failed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;怀疑是QEMU的版本太低导致，于是只好又重新编译QEMU源码，最后总算大功告成。总的说来，大致要做的事情有这么几个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译Linux内核，利用busybox来生成一个小的rootfs（关于什么是rootfs，可以参考&lt;a href=&quot;https://tldp.org/LDP/sag/html/root-fs.html&quot;&gt;The rootfs FS&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;编译QEMU，确保正常配置ARM64架构的虚拟环境&lt;/li&gt;
&lt;li&gt;一切就绪，通过&lt;code&gt;qemu-system-aarch64&lt;/code&gt;跑起来虚拟机来&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://sniffer.site/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://sniffer.site/tags/Linux/"/>
    
    <category term="Kernel" scheme="https://sniffer.site/tags/Kernel/"/>
    
    <category term="Qemu" scheme="https://sniffer.site/tags/Qemu/"/>
    
    <category term="busybox" scheme="https://sniffer.site/tags/busybox/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络优化之DPDK与XDP</title>
    <link href="https://sniffer.site/2022/08/12/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BDPDK%E4%B8%8EXDP/"/>
    <id>https://sniffer.site/2022/08/12/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BDPDK%E4%B8%8EXDP/</id>
    <published>2022-08-12T05:45:40.000Z</published>
    <updated>2022-08-12T05:56:20.588Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的一篇文章<a href="https://sniffer.site/2022/04/13/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/">Linux网络优化之链路层优化</a>中，我们已经看到，随着网卡速率超过<code>1Gbps</code>，增加到<code>10Gbps/100Gbps</code>时，CPU已经很难处理如此大量的数据包了。总结来说，主要有如下瓶颈：</p><ul><li>内核协议栈处理在<code>L3(IP)/L4(TCP)</code>的数据处理上，消耗了比较多的时间，会导致网络延迟与传输受限</li><li>高速网卡会在短时间内产生大量中断，导致CPU频繁发生上下文切换，性能收到影响，进而影响网络吞吐</li></ul><p>针对<code>10Gbps/100Gbps</code>等高速网卡中存在的延迟与带宽受限问题，<a href="https://en.wikipedia.org/wiki/Data_Plane_Development_Kit">Intel在2010年提出了<code>DPDK(Data Plane Development Kit)</code>基于用户空间的解决方案</a>，并开源了实现方案, 目前<code>DPDK</code>支持包括Intel&#x2F;ARM等多个芯片架构的指令集; 同样是Intel的工程师在2018年提出了<code>XDP(eXpress Data Path)</code>，与<code>DPDK</code>不一样的是，<code>XDP</code>基于现有内核<code>socket</code>接口，与<code>eBPF</code>相结合实现网卡与用户空间的数据传输，从而避免了内核协议栈的处理延迟。</p><span id="more"></span><p>下面我们来简单看下<code>DPDK</code>与<code>XDP</code>的实现原理。</p><blockquote><p>本文主要是简要介绍基本原理，收集一些参考资料</p></blockquote><h2 id="DPDK-Data-Plane-Development-Kit"><a href="#DPDK-Data-Plane-Development-Kit" class="headerlink" title="DPDK(Data Plane Development Kit)"></a><strong>DPDK(Data Plane Development Kit)</strong></h2><p><code>DPDK</code>是由一系列开源库组成的用于网络加速的工具集，其提供了数据平面(<code>data-plane</code>)以及用户空间基于poll模式的网卡驱动，以跳过内核<code>TCP/IP</code>协议栈， 加速网络数据的传输。<code>DPDK</code>为如<code>PowerPC</code>&#x2F;<code>Arm</code>&#x2F;<code>x86</code>等多个平台提供了一个框架，用于高速网络情况的数据处理，常用在数据中心节点之间的数据传输。</p><p><img src="https://www.accton.com/wp-content/uploads/2018/07/linux-kernel-w-DPDK-800x524.png" alt="DPDK in linux kernel"></p><p>有关更多<code>DPDK</code>实现原理与细节可以参考如下资料:</p><ul><li><a href="https://en.wikipedia.org/wiki/Data_Plane_Development_Kit">Wikipedia DPDK</a></li><li><a href="https://lwn.net/Articles/725254/">Network Acceleration with DPDK</a></li><li><a href="https://doc.dpdk.org/guides/linux_gsg/index.html">Linux development Guide</a></li><li><a href="https://www.cse.iitb.ac.in/~mythili/os/anno_slides/DPDK_deep_dive_slides.pdf">Deep-dive into DPDK</a></li><li><a href="https://www.intel.com/content/www/us/en/developer/articles/code-sample/introduction-to-the-dpdk-sample-applications.html">DPDK Sample Applications</a></li><li><a href="https://github.com/DPDK/dpdk">DPDK source code</a></li></ul><h2 id="XDP-eXpress-Data-Path"><a href="#XDP-eXpress-Data-Path" class="headerlink" title="XDP(eXpress Data Path)"></a><strong>XDP(eXpress Data Path)</strong></h2><p><code>XDP</code>方案与<code>DPDK</code>类似，都是尝试跳过内核协议栈从而加速数据包的处理，只不过<code>XDP</code>是基于内核已有的<code>socket</code>接口来实现，其增加了一个<code>AF_XDP</code>的地址类型，用户进程可以通过<code>AF_XDP</code>的接口来实现与内核的交互， 比如映射接收数据包的共享内存，加载接收网卡数据包的<code>BPF</code>内核程序(有关内核BFP可以参考<a href="https://sniffer.site/2019/11/07/bpf%E4%B8%8Eebpf/">BPF与eBPF</a>)。</p><p><img src="https://www.iovisor.org/wp-content/uploads/sites/8/2016/09/xdp-packet-processing-768x420.png" alt="XDP"></p><p>从<code>XDP</code>的实现原理来说，相比于<code>DPDK</code>， <code>XDP</code>更贴近Linux内核，因而使用起来更为方便，而且其总体性能可以接近于<code>DPDK</code>。有关<code>XDP</code>实现原理与细节可以参考如下资料:</p><ul><li><a href="https://www.iovisor.org/technology/xdp">Introduction to XDP</a></li><li><a href="https://lwn.net/Articles/750845/">Accelerating networking with AF_XDP</a></li><li><a href="https://www.kernel.org/doc/html/v4.18/networking/af_xdp.html">Kernel networking-XDP</a></li><li><a href="https://blog.cloudflare.com/l4drop-xdp-ebpf-based-ddos-mitigations/">DDos Mitigations based on XDP</a></li><li><a href="https://developers.redhat.com/blog/2021/04/01/get-started-with-xdp">Get started with XDP</a></li><li><a href="https://lwn.net/Articles/750293/">AF_XDP kernel patch</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://www.iovisor.org/technology/xdp">Introduction to XDP</a></li><li><a href="https://www.accton.com/Technology-Brief/intel-dpdk-performance-on-the-sau5081i-server/">Intel® DPDK Performance on the SAU5081I Server</a></li><li><a href="https://lwn.net/Articles/725254/">Network acceleration with DPDK</a></li><li><a href="https://lwn.net/Articles/750845/">Accelerating networking with AF_XDP</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面的一篇文章&lt;a href=&quot;https://sniffer.site/2022/04/13/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/&quot;&gt;Linux网络优化之链路层优化&lt;/a&gt;中，我们已经看到，随着网卡速率超过&lt;code&gt;1Gbps&lt;/code&gt;，增加到&lt;code&gt;10Gbps/100Gbps&lt;/code&gt;时，CPU已经很难处理如此大量的数据包了。总结来说，主要有如下瓶颈：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核协议栈处理在&lt;code&gt;L3(IP)/L4(TCP)&lt;/code&gt;的数据处理上，消耗了比较多的时间，会导致网络延迟与传输受限&lt;/li&gt;
&lt;li&gt;高速网卡会在短时间内产生大量中断，导致CPU频繁发生上下文切换，性能收到影响，进而影响网络吞吐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对&lt;code&gt;10Gbps/100Gbps&lt;/code&gt;等高速网卡中存在的延迟与带宽受限问题，&lt;a href=&quot;https://en.wikipedia.org/wiki/Data_Plane_Development_Kit&quot;&gt;Intel在2010年提出了&lt;code&gt;DPDK(Data Plane Development Kit)&lt;/code&gt;基于用户空间的解决方案&lt;/a&gt;，并开源了实现方案, 目前&lt;code&gt;DPDK&lt;/code&gt;支持包括Intel&amp;#x2F;ARM等多个芯片架构的指令集; 同样是Intel的工程师在2018年提出了&lt;code&gt;XDP(eXpress Data Path)&lt;/code&gt;，与&lt;code&gt;DPDK&lt;/code&gt;不一样的是，&lt;code&gt;XDP&lt;/code&gt;基于现有内核&lt;code&gt;socket&lt;/code&gt;接口，与&lt;code&gt;eBPF&lt;/code&gt;相结合实现网卡与用户空间的数据传输，从而避免了内核协议栈的处理延迟。&lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="Linux" scheme="https://sniffer.site/tags/Linux/"/>
    
    <category term="网络优化" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    
    <category term="DPDK" scheme="https://sniffer.site/tags/DPDK/"/>
    
    <category term="XDP" scheme="https://sniffer.site/tags/XDP/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络优化之TCP优化</title>
    <link href="https://sniffer.site/2022/06/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BTCP%E4%BC%98%E5%8C%96/"/>
    <id>https://sniffer.site/2022/06/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BTCP%E4%BC%98%E5%8C%96/</id>
    <published>2022-06-06T05:43:24.000Z</published>
    <updated>2022-06-06T05:53:47.023Z</updated>
    
    <content type="html"><![CDATA[<p>TCP(<code>Transmision Control Protocol</code>)即传输控制协议, 位于TCP&#x2F;IP协议栈的第三层(L3), 是一种提供了可靠连接的字节流协议; TCP是目前使用最为广泛的协议之一, HTTP&#x2F;MQTT&#x2F;FTP等诸多应用层协议都是基于TCP实现的, 更多关于TCP协议相关的具体内容可以参考标准文档<a href="https://datatracker.ietf.org/doc/html/rfc793">RFC793</a>以及早前写的一篇<a href="https://sniffer.site/2019/07/30/%E8%81%8A%E4%B8%80%E8%81%8Atcp%E5%8D%8F%E8%AE%AE/">聊一聊TCP协议</a>. </p><p>在上一篇文章中讲到了高速以太网如1Gbps&#x2F;10Gpbs中<a href="https://sniffer.site/2022/04/13/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/">Linux网络L2(链路层)</a>的一些优化方法, 包括了<code>offload(卸荷)</code>以及<code>scaling(缩放)</code>两种技术. 随着高速网络的不断普及, 1Gbps&#x2F;10Gpbs以太网已经被广泛使用, 40Gbps&#x2F;100Gbps也已经制定标准, TCP也在随着网络带宽的提升而不断进化.这篇文章我们就来看下如何在高速以太网下对TCP相关的参数的进行调优.</p><span id="more"></span><h2 id="TCP窗口大小"><a href="#TCP窗口大小" class="headerlink" title="TCP窗口大小"></a><strong>TCP窗口大小</strong></h2><p>TCP为了协调客户端与服务端数据的发送&#x2F;接收, 使用窗口机制来确保两者保持一致的速率, 确保快速的发送方不会超过慢速的接收方. 接收方需要通过窗口更新(<code>Window Update</code>)消息来告知发送方当前可以发送多少数据. 当接收方应用处理数据时, 可向发送方发送<code>窗口更新消息</code>; 窗口更新消息最快需要一个返回时间(<code>RTT-Round Trip Time</code>), 因此窗口越大, 同一个RTT可以接收的数据就越多; 类似地, RTT越大, 则同样的时间可以接收的数据会越少. 为此, 我们可以得到如下公式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">吞吐量 &lt;= 窗口大小/RTT</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TCP原始设计中, 窗口大小为<code>65535</code>字节(64KiB - 1), 这是发送方在收到窗口更新之前允许发送的最大数据量. 但随着网络带宽越来越高, 1Gbps&#x2F;10Gbps的网络已经得到广泛使用, 这个窗口值无法让高速网络的带宽得到有效利用. 为了让高速网络的带宽得到充分利用, 一般需要通过带宽时延成乘积BDP(<code>Bandwidth-delay product</code>)公式来计算真实的TCP窗口大小.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BDP（位）= 带宽（位/秒）* RTT（秒）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假如, 我们有一个<code>1Gbps</code>的网络, RTT为<code>10ms</code>, 通过BDP公式可以大致计算出网络实际的带宽:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">带宽(bit/s) = BDP/RTT </span><br><span class="line">           = (65535Byte * 8bit/Byte)/10ms</span><br><span class="line">           = 524280 bit/0.01s</span><br><span class="line">           = 5242800 bit/s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也就是说, 如果按照TCP原始的<code>64KiB</code>的窗口设定, 一个千兆网络的实际吞吐量才不到50Mbps, 这远没有达到1000Mbps的理论值. 那么, 要如何解决这个问题了? 标准协议通过增加一个窗口缩放选项来扩张TCP窗口大小.</p><h3 id="TCP窗口缩放"><a href="#TCP窗口缩放" class="headerlink" title="TCP窗口缩放"></a><strong>TCP窗口缩放</strong></h3><p>为了改变TCP原有设计对窗口大小的限定, <a href="https://datatracker.ietf.org/doc/html/rfc7323">RFC7323</a>引入了扩展协议, 在TCP头中增加一个<code>Window Scaling Factor</code>的参数, 可以使窗口大小扩展到<code>1,073,725,440</code>字节(接近1GiB).具体可以参考<a href="https://datatracker.ietf.org/doc/html/rfc7323">RFC7323</a>中的说明.</p><p>要在Linux中确认是否开启了窗口缩放功能, 可以通过命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo sysctl net.ipv4.tcp_window_scaling</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果这个值为<code>1</code>, 则表示开启了该选项(看4.4的内核版本已经默认打开了)；如果没有打开, 要开启该选项, 只需要通过下述命令打开即可:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo sysctl -w net.ipv4.tcp_window_scaling=1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="调整TCP窗口大小"><a href="#调整TCP窗口大小" class="headerlink" title="调整TCP窗口大小"></a><strong>调整TCP窗口大小</strong></h2><p>现在开启了窗口缩放选项, 我们就可以根据<code>BDP</code>来计算给定理论带宽与延迟情况下, 对应的TCP窗口大小了. 还是以<code>1Gbps</code>网络为例, 假设延迟(可以通过ping来大致判断)为<code>3ms</code>, 那么对应的窗口大小应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">窗口大小 = (理论带宽 * 延迟)/8bit</span><br><span class="line">       = (1000Mbps * 0.03)/8bit</span><br><span class="line">       = 3750000b</span><br><span class="line">       = 3.6Mb</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是说至少需要将TCP窗口的大小设置为<code>3.6Mb</code>大小才能确保实际吞吐量达到网络的理论带宽. 在Linux中, 一般需要设置如下几个参数来设定TCP窗口大小:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">net.core.rmem_max</span><br><span class="line">net.core.wmem_max</span><br><span class="line">net.ipv4.tcp_rmem</span><br><span class="line">net.ipv4.tcp_wmem</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中前两个参数<code>rmem_max/wmem_max</code>表示应用最大可用的TCP窗口大小, <code>tcp_rmem</code>&#x2F;<code>tcp_wmem</code>表示单个应用允许分配的最大TCP窗口大小(对应有三个值, 分别表示最小&#x2F;默认&#x2F;最大的TCP窗口大小). 为了保证TCP的性能与理论比较接近, 我们可以将上述四个参数都按照上述计算得到的TCP窗口进行设定:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MaxExpectedBDP=3750000</span><br><span class="line">sudo sysctl -w net.core.rmem_max=$MaxExpectedBDP</span><br><span class="line">sudo sysctl -w net.core.wmem_max=$MaxExpectedBDP</span><br><span class="line">sudo sysctl -w net.ipv4.tcp_rmem=&quot;4096 87380 $MaxExpectedBDP&quot;</span><br><span class="line">sudo sysctl -w net.ipv4.tcp_wmem=&quot;4096 16384 $MaxExpectedBDP&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者可以通过直接写对应<code>/proc</code>的文件节点来设定上述参数, 如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MaxExpectedBDP=3750000</span><br><span class="line">echo $MaxExpectedBDP &gt; /proc/sys/net/core/wmem_max;</span><br><span class="line">echo $MaxExpectedBDP &gt; /proc/sys/net/core/rmem_max;</span><br><span class="line">echo 4096 1048576 $MaxExpectedBDP &gt; /proc/sys/net/ipv4/tcp_rmem;</span><br><span class="line">echo 4096 1048576 $MaxExpectedBDP &gt; /proc/sys/net/ipv4/tcp_wmem;</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/tcp_window_scaling;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了上述根据<code>BDP</code>公式来优化TCP窗口大小之外, 对于高速以太网, 通常还可以通过开启TCP时间戳(增加一次往返RTT时间的估算准确度), 对TCP头进行压缩(减少TCP传输数据的大小)等方式来优化, 具体可以参考<a href="https://datatracker.ietf.org/doc/html/rfc7323">RFC7323</a>.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>本文首先介绍了TCP在高速网络中需要解决的窗口不足的问题， 然后阐述了TCP标准协议是如何解决该问题的。接着着重说明了如何在Linux中配置TCP参数，确保TCP性能达到最优。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://en.wikipedia.org/wiki/TCP_tuning">TCP参数优化</a></li><li><a href="https://cloud.google.com/architecture/tcp-optimization-for-network-performance-in-gcp-and-hybrid">Google云服务器TCP参数调优</a></li><li><a href="https://datatracker.ietf.org/doc/html/rfc7323">TCP Extensions for High Performance</a></li><li><a href="https://datatracker.ietf.org/doc/html/rfc7414">A Roadmap for Transmission Control Protocol</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;TCP(&lt;code&gt;Transmision Control Protocol&lt;/code&gt;)即传输控制协议, 位于TCP&amp;#x2F;IP协议栈的第三层(L3), 是一种提供了可靠连接的字节流协议; TCP是目前使用最为广泛的协议之一, HTTP&amp;#x2F;MQTT&amp;#x2F;FTP等诸多应用层协议都是基于TCP实现的, 更多关于TCP协议相关的具体内容可以参考标准文档&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc793&quot;&gt;RFC793&lt;/a&gt;以及早前写的一篇&lt;a href=&quot;https://sniffer.site/2019/07/30/%E8%81%8A%E4%B8%80%E8%81%8Atcp%E5%8D%8F%E8%AE%AE/&quot;&gt;聊一聊TCP协议&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;在上一篇文章中讲到了高速以太网如1Gbps&amp;#x2F;10Gpbs中&lt;a href=&quot;https://sniffer.site/2022/04/13/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/&quot;&gt;Linux网络L2(链路层)&lt;/a&gt;的一些优化方法, 包括了&lt;code&gt;offload(卸荷)&lt;/code&gt;以及&lt;code&gt;scaling(缩放)&lt;/code&gt;两种技术. 随着高速网络的不断普及, 1Gbps&amp;#x2F;10Gpbs以太网已经被广泛使用, 40Gbps&amp;#x2F;100Gbps也已经制定标准, TCP也在随着网络带宽的提升而不断进化.这篇文章我们就来看下如何在高速以太网下对TCP相关的参数的进行调优.&lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="Linux" scheme="https://sniffer.site/tags/Linux/"/>
    
    <category term="网络优化" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    
    <category term="TCP" scheme="https://sniffer.site/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络优化之链路层优化</title>
    <link href="https://sniffer.site/2022/04/13/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/"/>
    <id>https://sniffer.site/2022/04/13/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/</id>
    <published>2022-04-13T11:51:44.000Z</published>
    <updated>2022-12-06T10:25:39.928Z</updated>
    
    <content type="html"><![CDATA[<p>现在车内网络都开始内卷到<code>1Gbps</code>了, 有同学给我反馈说以太网的吞吐量上不来, 跟理论带宽差距很大, 之前虽然优化了一波<code>TCP</code>相关的参数, 但估计不能解决全部问题. 遂决定重新学习下网络优化, 从底层链路对开发平台上的网络进行改善. 趁着这个机会, 索性写一个系列文章-Linux网络优化, 用来总结下Linux网络优化的一些方法与技术, 目前计划从如下几篇文章展开(希望不要放飞了):</p><ul><li>Linux网络优化之数据链路层优化: 数据链路层<code>L2</code>的优化, 如何从收发两个方面优化网卡吞吐量，即本篇。</li><li>Linux网络优化之TCP优化: <a href="https://sniffer.site/2022/06/06/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8Btcp%E4%BC%98%E5%8C%96/">以TCP协议为例, 说明<code>L3</code>协议栈优化</a></li><li>Linux网络优化之高速网络优化: <a href="https://sniffer.site/2022/08/12/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8Bdpdk%E4%B8%8Exdp/">基于<code>DPDK/XDP</code>解决高速网络传输延迟问题</a></li><li>Linux网络优化之AVB: <a href="https://sniffer.site/2022/12/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BAVB-TSN/">介绍以太网中用于音视频传输的低时延<code>TSN/AVB</code>协议</a></li></ul><p>这篇文章主要讲第一个话题: Linux是如何在数据链路层<code>L2</code>对网络数据的接收与发送进行优化的. </p><span id="more"></span><p>我们都知道, Linux的网络协议栈<code>L4</code>到<code>L2</code>(传输层)以下都是在内核实现的, 其主要存在的问题是日益增加的网络带宽与CPU处理能力(包括内核协议栈)之间矛盾, 随着后续100G甚至400G的网卡出现, 这个矛盾只会更加突出. 针对这种速度上的不平衡, 涌现出了各种解决方案, 有些是基于Linux内核协议栈, 在内核的基础上进行优化, 比如将部分耗时的操作丢给网卡处理(<code>offload</code>); 有些则是基于L4协议做优化, 比如优化TCP参数, 使用更好的拥塞控制算法, 使用<code>zero-copy</code>技术减少内存拷贝; 有些则完全跳过了内核协议, 直接把网卡的数据送往用户进程, 进而避免了内核处理慢的问题, 比如<a href="https://en.wikipedia.org/wiki/Express_Data_Path"><code>XDP/DPDK</code></a>; 还有一些是从<code>L2</code>到应用层针对音视频数据传输做了大量优化, 确保低延迟以及足够的预留带宽, 这就是<a href="https://en.wikipedia.org/wiki/Audio_Video_Bridging"><code>TSN/AVB</code></a>协议.</p><p>这篇文章, 就来看下那些Linux网络驱动以及协议栈中各种网络优化技术, 包括<code>offload</code>与<code>scaling</code>两个部分. 先来看下发送端的<code>offload</code>优化方案.</p><h2 id="链路层优化-offload技术"><a href="#链路层优化-offload技术" class="headerlink" title="链路层优化-offload技术"></a><strong>链路层优化-offload技术</strong></h2><p>内核协议栈在传输数据时(内核数据的传输流程可以参考之前的文章<a href="https://sniffer.site/2021/04/08/linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B/">Linux网络协议之数据发送流程</a>, 除了从内核空间拷贝数据耗时外, 还有两件事情需要消耗CPU资源:</p><ul><li>数据包传送到网络层L2时, 需要按照网卡的MTU对数据包进行分片</li><li>传送数据时需要对数据包进行校验和计算(checksum)</li></ul><p>一般来说网卡的MTU都默认设置为<code>1500</code>字节, 一旦TCP&#x2F;UDP等L3的数据包超过了设定的MTU, 网络层L2就需要将其分割成MTU大小的数据段. 比如为了传输<code>3200bytes</code>的数据, 通常需要分割成3个包进行发送. 为了避免分片, 可以通过设置一个大的MTU, 比如在需要高速网络传输时将MTU设置为9000(JUBO frame), 但这个在广域网中很难行的通, 因为不同的通讯节点很难保持统一的MTU设置. 这时就需要用到<code>segmentation offload</code>(分片卸荷)技术. <code>offloads</code>本质上就是将原本需要CPU处理的部分丢给网卡来处理, 其最高可支持<code>64KB</code>大小的数据包, 这样可以减少网络包的数量, 降低网络中断数量, 增加网络吞吐量.</p><p>常见的<code>offload</code>有如下几种:</p><ul><li>TSO(<code>TCP Segmentation Offload</code>): 开启TSO功能的网卡可以将一个大的单帧数据分割成固定大小(MTU)多个帧. TSO一般需要与网卡的<code>checksum offload</code>以及<code>scatter-gather</code>功能一起配置使用.</li><li>UFO(<code>UDP Fragmentation Offload</code>): 网卡可以将一个大的UDP报文分割成固定MTU大小的数据包; UFO目前已经废弃不用, 大部分内核不再支持.</li><li>GSO(<code>Generic Segmentation Offload</code>): GSO可以看作是TSO的补充, 当网卡无法支持TSO&#x2F;UFO时, GSO可以确保数据包进入驱动处理时按照MTU的大小进行分片处理, 从而避免数据包无法发送的情况. GSO一般要与GRO(<code>Generic Receive Offload</code>)一起使用.</li><li>LRO(<code>Large Receive Offload</code>): 在数据包进入协议栈之前进行重新组合成一个更大的报文, 以减少数据包的数量, 降低CPU负载.  LRO通常会忽略数据包头中的差异以及其他存在的错误. 通常来说, LRO无法与内核中的IP转发(<code>IP Forwarding</code>)功能一起使用, 因此在开启LRO时需要关闭IP转发功能.</li><li>GRO(<code>Generic Receive Offload</code>): 与LRO类似, 不过在合成包时会对每个数据包进行更严格的检查, 比如会检查数据包的MAC头; 查看TCP的时间戳. GRO可以通过软件或者在网卡中实现.</li></ul><p>在Linux中, 可以通过<code>ethtool</code>工具来查看以及设定网卡的<code>offload</code>配置:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 查看网卡offload配置</span></span><br><span class="line">ethtool --show-offload  enp0s31f6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到有如下输出:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Features <span class="keyword">for</span> enp0s31f6:</span><br><span class="line">rx-checksumming: on</span><br><span class="line">tx-checksumming: on</span><br><span class="line">tx-checksum-ipv4: off [fixed]</span><br><span class="line">tx-checksum-ip-generic: on</span><br><span class="line">tx-checksum-ipv6: off [fixed]</span><br><span class="line">tx-checksum-fcoe-crc: off [fixed]</span><br><span class="line">tx-checksum-sctp: off [fixed]</span><br><span class="line">scatter-gather: on</span><br><span class="line">tx-scatter-gather: on</span><br><span class="line">tx-scatter-gather-fraglist: off [fixed]</span><br><span class="line">tcp-segmentation-offload: on</span><br><span class="line">tx-tcp-segmentation: on</span><br><span class="line">tx-tcp-ecn-segmentation: off [fixed]</span><br><span class="line">tx-tcp-mangleid-segmentation: off</span><br><span class="line">tx-tcp6-segmentation: on</span><br><span class="line">udp-fragmentation-offload: off</span><br><span class="line">generic-segmentation-offload: on</span><br><span class="line">generic-receive-offload: on</span><br><span class="line">large-receive-offload: off [fixed]</span><br><span class="line">rx-vlan-offload: on</span><br><span class="line">tx-vlan-offload: on</span><br><span class="line">ntuple-filters: off [fixed]</span><br><span class="line">receive-hashing: on</span><br><span class="line">highdma: on [fixed]</span><br><span class="line">rx-vlan-filter: off [fixed]</span><br><span class="line">vlan-challenged: off [fixed]</span><br><span class="line">tx-lockless: off [fixed]</span><br><span class="line">netns-local: off [fixed]</span><br><span class="line">tx-gso-robust: off [fixed]</span><br><span class="line">tx-fcoe-segmentation: off [fixed]</span><br><span class="line">tx-gre-segmentation: off [fixed]</span><br><span class="line">tx-gre-csum-segmentation: off [fixed]</span><br><span class="line">tx-ipxip4-segmentation: off [fixed]</span><br><span class="line">tx-ipxip6-segmentation: off [fixed]</span><br><span class="line">tx-udp_tnl-segmentation: off [fixed]</span><br><span class="line">tx-udp_tnl-csum-segmentation: off [fixed]</span><br><span class="line">tx-gso-partial: off [fixed]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="数据链路层优化-scaling技术"><a href="#数据链路层优化-scaling技术" class="headerlink" title="数据链路层优化-scaling技术"></a><strong>数据链路层优化-scaling技术</strong></h2><p>上面讲到的<code>offload</code>技术主要是针对数据传输(包括接收与发送)的优化, 这里说的<code>scaling</code>(伸缩，即具备弹性，随着系统的增大而性能不会收到影响)技术则主要是针对接收的优化, 其主要是用于增加多核CPU系统中网络并发处理能力, 改善网络性能. </p><p>了解Linux网络协议栈数据接收的流程(参考<a href="https://sniffer.site/2020/05/12/%E4%BB%8Enapi%E8%AF%B4%E4%B8%80%E8%AF%B4linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/">从NAPI说一说Linux内核数据的接收流程</a>, 我们知道, 网卡接收到数据后, 会以DMA的形式拷贝到内存, 然后发送中断告知CPU进行处理. 对于多核CPU系统来说, 有如下几个问题需要仔细考量:</p><ul><li>如何减少网络中断: 在高速网卡中, 可能有大量的中断产生, 过多的中断会影响CPU的性能, 进而影响网络吞吐量. Linux内核协议栈采用了<code>NAPI</code>技术来达到减少中断的目的; 除了<code>NAPI</code>技术, 很多网卡也会提供中断合并(<code>Interrupt Coalescence</code>)方法来减少中断数量, 简单来说, 中断合并是指网卡会等某个超时时间或者传送了某个数量的帧后才会向CPU发送一个数据接收的中断.</li><li>中断在哪个CPU上处理: 多队列网卡上, 每个队列都可能有自己的中断, 如何将中断均衡的分配到每个CPU上在一定程度上影响网络性能.</li><li>数据包要在哪个CPU上处理: 默认情况下, 数据包会发送给处理中断的CPU上, 但这对多队列网卡来说, 这会造成一定程度上的CPU负载不均衡, 从而影响系统性能.</li></ul><p>内核中的<code>scaling</code>技术就是针对这后面两个情况进行优化的. 常见的<code>scaling</code>技术有如下几种:</p><ul><li><strong>RSS</strong>(<code>Receive Side Scaling</code>):  对现在的网卡来说, 可能存在多个队列, 每个队列又会有一个中断; 如何把数据包均衡的分布到每个队列,  将多个网卡中断均衡发送到每个CPU上就是RSS需要解决的问题. 对于数据包的均衡,  需要通过网卡中的<code>indirection table</code>来实现; 中断均衡可以通过设置中断的CPU亲和性来实现.</li><li><strong>RPS</strong>(<code>Receive Packet Steering</code>): RPS可以看作是RSS的软件实现版, 区别在于RPS是在中断处理之后CPU处理数据包时进行. RPS旨在把网卡发送的数据包发送给给定的CPU进行处理, 从而实现数据包的均衡.相比RSS, RPS具有更好的灵活性, 可以适配任何网卡与协议, 并且不会增加物理设备的中断频率. </li><li><strong>RPS Flow Limit</strong>(<code>RFS</code>): 在某些情况下, 网络数据可能呈现不均衡的情况, 一些数据流可能更大, 从而造成小数据流处理慢的情况. 针对这个问题, RFS在某个CPU输入队列的数据长度超过限值(<code>net.core.netdev_max_backlog</code>)时, 新的数据包会被丢弃. RFS默认是关闭的.</li><li><strong>RFS</strong>(<code>Receive Flow Steering</code>): RPS只是根据包的哈希值来选择处理数据包的CPU, 但没有考虑数据包接收端的本地性(<code>application locality</code>), 就是说处理的CPU可能并不是用户进程接收数据包的CPU. RFS正是用于解决该问题, 确保处理数据包的与用户接收进程同在一个CPU上, 从而增强数据缓存命中率.</li><li><strong>aRFS</strong>(<code>Accelerated Receive Flow Steering</code>): aRFS之于RFS类似于RSS之于RPS; aRFS就是RFS的硬件实现, 需要网卡支持硬件加速功能才能实现. 在一定程度上, 由于数据包是直接发送给消费进程所在的本地CPU(进程同一CPU, 或对应缓存架构上应用线程本地的CPU), aRFS在性能上要优于RFS. </li><li><strong>XPS</strong>(<code>Transmit Packet Steering</code>): XPS是针对多队列网卡如何选择发送队列问题的优化策略. 开启XPS时, 内核会记录网卡队列与CPU之间的映射关系, 确保网卡的某个队列与固定的CPU之间绑定, 确保传输完成的中断由对应队列的CPU处理, 这样做一可以减少CPU在网卡队列上的等待时间; 一可以减少内存缓存缺失.</li></ul><p>综合来看, 无论是RSS&#x2F;RPS, 还是RFS&#x2F;XPS, 都是尝试在多CPU与多队列网卡之间的数据包处理上达成均衡分配的目的, 以减少CPU处理压力, 增加内存缓存命中率, 提高网卡的吞吐量. 接下来就来看看如何在Linux中配置<code>scaling</code>的优化方案.</p><ul><li><strong>RSS配置</strong>: 将数据包均匀的发送到不同CPU上可以减少网卡的队列长度, 希望优化网络延迟的情况下可以打开该配置. 如果网卡本身支持RSS, 可以尝试通过<code>ethtool</code>来设置; 对中断均衡, 可以通过配置网卡中断亲和性来确保RSS起作用, 比如<code>echo 0xff &gt; /proc/irq/&lt;irq_no&gt;/smp_affinity</code>.</li><li><strong>RPS配置</strong>: RPS需要内核配置<code>CONFIG_RPS</code>才会编译; 如果要开启, 还需要显式的指定网卡队列需要绑定的CPU: <code> /sys/class/net/&lt;dev&gt;/queues/rx-&lt;n&gt;/rps_cpus</code>, 如果这个值是0, RPS是关闭状态, 这时数据包会发送到处理中断的CPU. 如果网卡本身是多队列的, 并且每个队列都对应映射到每个CPU上, RPS可以不用配置; 但如果网卡队列数量少于CPU数量, RPS仍然是有益的.</li><li><strong>RPS Flow Limit配置</strong>: RPS限流内核配置(<code>CONFIG_NET_FLOW_LIMIT</code>)是默认打开的, 但是功能本身是关闭状态, 需要通过设置<code> /proc/sys/net/core/flow_limit_cpu_bitmap</code>(与<code>rps_cpus</code>设置一样)来开启该功能.</li><li><strong>RFS配置</strong>: RFS只有在<code>CONFIG_RPS</code>打开的情况下才可用, 该功能需要配置两个参数, 一个用于配置全局流表, <code>/proc/sys/net/core/rps_sock_flow_entries</code>;  一个是用于配置网卡每个队列的限流数量, <code> /sys/class/net/&lt;dev&gt;/queues/rx-&lt;n&gt;/rps_flow_cnt</code>.</li><li><strong>aRFS配置</strong>: aRFS需要使能内核配置<code>CONFIG_RFS_ACCEL</code>并且需要网卡本身支持. 有硬件加速功能个的网卡通常都实现了<code>ndo_rx_flow_steer</code>这个函数.</li><li><strong>XPS配置</strong>: XPS需要配置内核<code>CONFIG_XPS</code>, 如果要打开该功能, 配置CPU的位图即可<code>/sys/class/net/&lt;dev&gt;/queues/tx-&lt;n&gt;/xps_cpus</code>.</li></ul><p>有关上述网络优化方案的详细配置可以参考内核文档<code>Documentation/networking/scaling.txt</code>.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rfs">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rfs</a></li><li>Linux Documentation&#x2F;networking(scaling&#x2F;segmentation-offloads)</li><li><a href="https://www.linkedin.com/pulse/modern-high-speed-networking-techniques-hardware-john-velegrakis">https://www.linkedin.com/pulse/modern-high-speed-networking-techniques-hardware-john-velegrakis</a></li><li><a href="https://lwn.net/Articles/188489/">GSO: Generic Segmentation Offload</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-nic-offloads">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-nic-offloads</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在车内网络都开始内卷到&lt;code&gt;1Gbps&lt;/code&gt;了, 有同学给我反馈说以太网的吞吐量上不来, 跟理论带宽差距很大, 之前虽然优化了一波&lt;code&gt;TCP&lt;/code&gt;相关的参数, 但估计不能解决全部问题. 遂决定重新学习下网络优化, 从底层链路对开发平台上的网络进行改善. 趁着这个机会, 索性写一个系列文章-Linux网络优化, 用来总结下Linux网络优化的一些方法与技术, 目前计划从如下几篇文章展开(希望不要放飞了):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux网络优化之数据链路层优化: 数据链路层&lt;code&gt;L2&lt;/code&gt;的优化, 如何从收发两个方面优化网卡吞吐量，即本篇。&lt;/li&gt;
&lt;li&gt;Linux网络优化之TCP优化: &lt;a href=&quot;https://sniffer.site/2022/06/06/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8Btcp%E4%BC%98%E5%8C%96/&quot;&gt;以TCP协议为例, 说明&lt;code&gt;L3&lt;/code&gt;协议栈优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Linux网络优化之高速网络优化: &lt;a href=&quot;https://sniffer.site/2022/08/12/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8Bdpdk%E4%B8%8Exdp/&quot;&gt;基于&lt;code&gt;DPDK/XDP&lt;/code&gt;解决高速网络传输延迟问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Linux网络优化之AVB: &lt;a href=&quot;https://sniffer.site/2022/12/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BAVB-TSN/&quot;&gt;介绍以太网中用于音视频传输的低时延&lt;code&gt;TSN/AVB&lt;/code&gt;协议&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章主要讲第一个话题: Linux是如何在数据链路层&lt;code&gt;L2&lt;/code&gt;对网络数据的接收与发送进行优化的. &lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="Linux" scheme="https://sniffer.site/tags/Linux/"/>
    
    <category term="网络优化" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>重学Modern C++</title>
    <link href="https://sniffer.site/2022/03/31/%E9%87%8D%E5%AD%A6C++/"/>
    <id>https://sniffer.site/2022/03/31/%E9%87%8D%E5%AD%A6C++/</id>
    <published>2022-03-31T06:58:15.000Z</published>
    <updated>2023-04-23T02:46:04.742Z</updated>
    
    <content type="html"><![CDATA[<p>断断续续看了Bjarne Stroustrup的’C++之旅(<code>a tour of C++</code>)’, 作者把很多原本看起来复杂的概念模型都讲的比较清晰, 也有不少好的代码示例, 有种拨云见雾的感觉. 于是想着写一篇文章来总结重新学习C++的一些经验, 主要阐述下现代C++(<code>&gt;=C++11</code>)中那些容易让人混淆而觉得陌生的技术.</p><p>了解C++历史的人都知道, <code>Bjarne Stroustrup</code>是在Bell实验室(就是Unix操作系统与C语言诞生的地方)发明了C++, 初衷是在C中加入类(class)的概念, 增强C语言在系统编程上的效率与灵活性, 也正式因为这个原因, C++在1979年最初的名字是<code>带类的C</code>(c with class), 直到1984年才改名为<code>C++</code>. 到今天, <code>C++</code>的发展历经了快40年历史, 但真正一次大的标准修改是在2011年, 这个版本也称为<code>C++11</code>(<code>C++11</code>之后的版本也统称为<code>Modern C++</code>).接下来我们就来一起来回顾下现代C++中那些曾经让人<code>头疼</code>的技术吧.</p><span id="more"></span><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/evolution_of_c%2B%2B.png" alt="history_of_cpp"></p><h2 id="constants"><a href="#constants" class="headerlink" title="constants"></a><strong>constants</strong></h2><p>除了<code>const</code>之外, C++还引入了<code>constexpr</code>这个关键字. <code>const</code>的意思是这个变量不会被修改, 编译器在编译的时候会确保这一点: 如果尝试修改<code>const</code>的赋值, 则会提示错误. 而<code>constexpr</code>是说这个表达式会在编译的时候进行判定(不用等到运行时):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vi)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;;  <span class="comment">//示例</span></span><br><span class="line"> <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">constexpr</span> <span class="type">double</span> m1 = <span class="number">1.6</span> * <span class="built_in">square</span>(im);</span><br><span class="line"><span class="comment">//constexpr double m2 = 1.6 * square(var); // 不允许使用非const变量</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vi = &#123;<span class="number">4</span>, <span class="number">58</span>, <span class="number">8</span> , <span class="number">9</span>&#125;; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> si = <span class="built_in">sum</span>(vi);</span><br><span class="line"><span class="comment">//constexpr int sii = sum(vi); // sum不是constexpr表达式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果一个函数要在<code>constexpr</code>表达式中使用, 则必须要以<code>constexpr</code>开头, 并且函数的实现需要足够简单: 只由一个返回值的表达式组成，且不能调用任何其他非<code>constexpr</code>的函数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于在编译时就完成了计算, 使用<code>constexpr</code>通常可以改善性能, 但据<code>c++ standar library: a tutorial and refernce</code>里边提到的, 引入<code>constexpr</code>是为了解决C++98<code>numeric_limits</code>标准库中的一个bug:<code>std::numeric_limits&lt;short&gt;::max()</code> 无法在常量表达式中使用.</p><h2 id="引用与右值"><a href="#引用与右值" class="headerlink" title="引用与右值"></a><strong>引用与右值</strong></h2><p>C++针对C中的指针引入了<code>引用(reference)</code>的概念, 引用类似于指针, 其通过<code>&amp;</code>进行声明, 但实际使用的时候无需在通过<code>*</code>来引用对象, 更重要的是引用一旦被初始化就不能再被修改, 引用其他的对象.</p><blockquote><p>引用类似指针，但非指针;引用只是对象的别名。引用与指针存在三个区别: 1) 没有空引用(<code>null reference</code>),就是说引用始终指向一个有效的对象 2) 所有引用需要初始化  3) 一个引用永远指向它初始化的那个对象</p></blockquote><p>引用对于不管理资源的对象来说, 一般不会有什么问题, 但涉及到大量的数据&#x2F;内存时(比如容器), 单纯的拷贝会变得低效. 有时, 我们只希望在不同对象之间<code>移动(move)</code>数据而不是拷贝, 以避免产生不必要的临时对象. 比如我们有一个<code>String</code>类, 包含了一个字符数组:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">String</span>(): <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>]) &#123;</span><br><span class="line"> data[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str): <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>]) &#123;</span><br><span class="line"> <span class="keyword">if</span> (str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"> <span class="built_in">strncpy</span>(data, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"> data[<span class="built_in">strlen</span>(str)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">String</span>(<span class="type">const</span> String&amp; str): <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">char</span>[str.<span class="built_in">size</span>() + <span class="number">1</span>]) &#123;</span><br><span class="line"> <span class="built_in">strncpy</span>(data, str.<span class="built_in">c_str</span>(), str.<span class="built_in">size</span>());</span><br><span class="line"> data[str.<span class="built_in">size</span>()] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> String&amp; <span class="keyword">operator</span>=(String &amp;rhs) &#123;</span><br><span class="line"> <span class="built_in">swap</span>(rhs);</span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">String</span>() &#123;</span><br><span class="line"> <span class="keyword">delete</span>[] data;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">strlen</span>(data);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> data;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(String &amp;rhs)</span> </span>&#123;</span><br><span class="line"> std::<span class="built_in">swap</span>(data, rhs.data);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如我们要往一个容器中插入对象, 那么每次实际容器中实际得到的都是一个拷贝的对象, 这就导致了不必要的内存拷贝, 如果对象本身很大(占用较大内存), 则拷贝会消耗更多的时间.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">String <span class="title">s</span><span class="params">(<span class="string">&quot;agaga&quot;</span>)</span></span>;</span><br><span class="line">std::set&lt;String&gt; ss;</span><br><span class="line">ss.<span class="built_in">insert</span>(s); <span class="comment">// get a copy of s</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>针对这种临时对象的拷贝, <code>C++11</code>中引入了<code>移动(move)</code>语义, 这样就可以支持对象之间数据的转移而不是拷贝了, 从而改善了程序的性能. 要让上述<code>String</code>对象支持<code>move</code>语义, 其实也很简单:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// move constructor</span></span><br><span class="line"><span class="built_in">String</span>(String &amp;&amp;str): <span class="built_in">data</span>(str.data) &#123;</span><br><span class="line"> str.data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// move assignment</span></span><br><span class="line">String&amp; <span class="keyword">operator</span>=(String&amp;&amp; rhs) &#123;</span><br><span class="line"> data = rhs.data;</span><br><span class="line"> rhs.data = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码中<code>&amp;&amp;</code>表示一个右值引用(<code>rval refernece</code>), 就是说该引用跟一个右值绑定, 这通常有别于左值(赋值语句的左边), 由于右值引用无法进行赋值, 因此我们可以<code>偷取</code>它的值与资源. C++标准库中也有一个<code>move</code>函数可以用于操作右值引用(头文件<code>utility</code>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;gaga&quot;</span>)</span></span>;</span><br><span class="line">String s2 = s1; <span class="comment">// copy</span></span><br><span class="line">String s3 = std::<span class="built_in">move</span>(s2); <span class="comment">// move</span></span><br><span class="line"></span><br><span class="line">std::set&lt;String&gt; ss;</span><br><span class="line">ss.<span class="built_in">insert</span>(std::<span class="built_in">move</span>(s1)); <span class="comment">// move</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要留意的时, 对于函数返回值不应该返回右值或使用<code>move()</code>要返回的值, 对于如下函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">String <span class="title">fcn</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">s</span><span class="params">(<span class="string">&quot;hi, move&quot;</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>C++会确保返回值按照如下规则进行:</p><ul><li>如果<code>String</code>有move构造函数或者赋值函数, 编译器可能会忽略拷贝对象, 这种技术被称为返回值优化(<code>returned value optimization</code>), 在C++11之前就有了.</li><li>否则就使用move构造函数返回对象</li><li>如果没有move构造函数, 则使用拷贝构造函数返回拷贝对象</li><li>否则就会抛出编译时异常</li></ul><p>有关更多右值引用、移动语义可以参考如下两篇文章:</p><ul><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#:~:text=Rvalue%20references%20is%20a%20small,performance%20and%20more%20robust%20libraries.">A Brief Introduction to Rvalue References</a></li><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">A Proposal to Add Move Semantics Support to the C++ Language</a></li></ul><h2 id="lamda表达式与函数对象"><a href="#lamda表达式与函数对象" class="headerlink" title="lamda表达式与函数对象"></a><strong>lamda表达式与函数对象</strong></h2><p>C++11引入了<code>lambda</code>表达式; <code>lambda</code>表达式可以用于创建简单的函数对象(<code>function object</code>), 构建匿名函数, 其返回的对象被称为闭包对象(<code>closure object</code>). 一般来说, <code>lambda</code>表达式由如下三个部分组成:</p><ul><li><p>捕获列表(<code>caputure list</code>): <code>[]</code> , 一个对象被捕获以后就可以在<code>lambda</code>函数内部使用(值复制或者引用的形式), <code>=</code>用于值的形式捕获所有本地变量;<code>&amp;</code>则表示以引用的形式捕获所有本地变量. 如果需要指定捕获的变量, 则需要在符号后面加上对应变量的名字, 如<code>=a</code>, <code>&amp;a</code>等. 不指定捕获符号则默认的捕获是值形式.</p></li><li><p>参数列表(<code>parameter list</code>): <code>()</code>, 参数列表与普通函数完全一致, 如果没有参数, 可以选择直接忽略表达式中的<code>()</code>(只有C++14以上的版本支持)</p></li><li><p>函数体(<code>function body</code>): <code>&#123;&#125;</code>表示函数体, 这与普通函数是一样的.</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[=(&amp;)] ()&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>lambda</code>表达式源自于<code>lambda calculus</code>, 是<code>Alonzo Church</code>在1930s用于研究逻辑与计算时使用的数学形式语言, 这也是函数式编程语言<code>LISP</code>的基础.</p></blockquote><p>比如实现判断一个数值是否大于<code>10</code>的<code>lamda</code>表达式, 可以这么做:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">[=a](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; a; &#125;;</span><br><span class="line"></span><br><span class="line">[&amp;a](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; a; &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认情况下, 未被显式指定捕获本地变量都无法在表达式函内使用, 但可以隐式的在函数体内捕获这些变量:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[=]() &#123; <span class="keyword">return</span> a + b; &#125;; <span class="comment">// a and b caputured by value</span></span><br><span class="line"></span><br><span class="line">[&amp;]() &#123; <span class="keyword">return</span> a + b; &#125;; <span class="comment">// a and b caputured by reference</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果同时使用了两种形式的捕获, 显式捕获会覆盖默认的捕获:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> a  = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">[=, &amp;b] () &#123;</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// Illegal, a is caputured by value and lamda is not mutable </span></span><br><span class="line">b = <span class="number">3</span>; <span class="comment">// OK , b is caputured by value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是, <code>lambda</code>表达式可以使用泛型参数, 这个在本质上是等同于函数式对象, 不妨来看个示例: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">auto</span> copy = [] (<span class="keyword">auto</span> x) &#123; <span class="keyword">return</span> x + x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">copy</span>(<span class="number">2</span>); <span class="comment">// i = 4</span></span><br><span class="line">std::string s = <span class="built_in">copy</span>(<span class="string">&quot;hi&quot;</span>); <span class="comment">// s = &quot;hihi&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述表达式可以写成如下形式的函数对象(标准库中很多算法广泛使用了函数对象来扩展实现, 如<code>for_each</code>, <code>bind</code>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CopyValue</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x + x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="智能指针-smart-pointers"><a href="#智能指针-smart-pointers" class="headerlink" title="智能指针(smart pointers)"></a><strong>智能指针(smart pointers)</strong></h2><p>长期以来, C被大家所诟病的一个缺陷就是指针引发的一系列内存管理问题, 比如空指针, 内存泄漏等, C++虽然通过引入了<code>引用(reference</code>)在一定程度上避免了指针带来内存管理的困扰, 但并没有从根源上解决指针所引发的资源管理问题. 现代C++普遍采用<a href="https://docs.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-170"><code>RAII(Resource Acquisition Is Initialization)</code></a>原则;从C++11开始, 标准库引入了智能指针(smart pointers)避免内存泄漏: <code>unique_ptr</code>&#x2F;<code>shared_ptr</code>, 用以替换之前的<code>auto_ptr</code>. </p><ul><li><code>unique_ptr</code>: 表示一个唯一的所属关系, 始终只有一个指针指向该对象</li><li><code>shared_ptr</code>: 表示一个共有的所属关系, 可以有多个指针共享对象资源</li></ul><p>标准库中提供了接口用于方便的创建<code>unique_ptr</code>&#x2F;<code>shared_ptr</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">std::unique_ptr&lt;X&gt; up &#123; <span class="keyword">new</span> X &#125;; <span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// since C++14</span></span><br><span class="line">std::unique_ptr&lt;X&gt; up = std::<span class="built_in">make_unique</span>&lt;X&gt;(); </span><br><span class="line"><span class="comment">// move unique_ptr to another</span></span><br><span class="line">std::unique_ptr&lt;X&gt; up1 = std::<span class="built_in">move</span>(up); <span class="comment">// now up is undefined</span></span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;X&gt; sp &#123;<span class="keyword">new</span> X&#125;; <span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// since C++14</span></span><br><span class="line">std::shared_ptr&lt;X&gt; sp = std::<span class="built_in">make_shared</span>&lt;X&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;X&gt; <span class="title">sp1</span><span class="params">(sp)</span></span>; <span class="comment">// shared with sp1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类型推断-auto-x2F-decltype"><a href="#类型推断-auto-x2F-decltype" class="headerlink" title="类型推断(auto&#x2F;decltype)"></a><strong>类型推断(auto&#x2F;decltype)</strong></h2><p>C++11引入了<code>auto</code>关键字用于告诉编译器对变量, 函数以及模板类进行推断, 从而避免让用户自己显式的声明类型(<code>auto</code>变量必须初始化，这样可以避免手动声明变量未被初始化的问题). 比如, 相比写一堆嵌套的模板实例类型, 使用<code>auto</code>可以简化声明:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>,list&lt;string&gt;&gt;::iterator i = m.<span class="built_in">begin</span>(); <span class="comment">// C-style</span></span><br><span class="line"><span class="keyword">auto</span> i = m.<span class="built_in">begin</span>(); <span class="comment">// modern C++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//using auto to simplify code</span></span><br><span class="line"><span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::const_iterator itr = myvec.<span class="built_in">cbegin</span>(); itr != myvec.<span class="built_in">cend</span>(); ++itr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> itr = myvec.<span class="built_in">cbegin</span>(); itr != myvec.<span class="built_in">cend</span>(); ++itr)</span><br></pre></td></tr></table></figure><p>需要注意的是，C++11开始支持括号列表初始化方式，如下的声明实际得到的两个变量<code>x1</code>&#x2F;<code>x2</code>是不一样的，编译器会把<code>x1</code>的类型推断为<code>int</code>值，而<code>x2</code>推断为<code>std::initializer_list</code>, 这类似与变量<code>x3</code>的类型(具体可以参考<a href="https://book.douban.com/subject/26793803/">Effective Modern C++</a>书中的第二条有关<code>auto</code>类型推断的解释)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">33</span>; <span class="comment">// or auto x1(33), x1 is int</span></span><br><span class="line"><span class="keyword">auto</span> x2 = &#123;<span class="number">35</span>&#125;; <span class="comment">// or auto x2&#123;35&#125;, x2 is std::initializer_list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x3 = &#123;<span class="number">2</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">13</span>&#125;;  <span class="comment">// x3 is std::initializer_list</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外, C++11还增加了一个关键字<code>decltype</code>, 用于在编译的时候获取某个变量或者表达式的类型, 例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">decltype</span>(a) c = <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不过需要注意的是, <code>decltype</code>推断出来的类型与<code>auto</code>的实际类型可能有差异(示例来自<a href="%60https://en.wikipedia.org/wiki/C++11%60">wikipedia</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> a = v[<span class="number">0</span>];        <span class="comment">// a has type int</span></span><br><span class="line"><span class="keyword">decltype</span>(v[<span class="number">0</span>]) b = <span class="number">1</span>; <span class="comment">// b has type const int&amp;, the return type of</span></span><br><span class="line"><span class="comment">//   std::vector&lt;int&gt;::operator[](size_type) const</span></span><br><span class="line"><span class="keyword">auto</span> c = <span class="number">0</span>;           <span class="comment">// c has type int</span></span><br><span class="line"><span class="keyword">auto</span> d = c;           <span class="comment">// d has type int</span></span><br><span class="line"><span class="keyword">decltype</span>(c) e;        <span class="comment">// e has type int, the type of the entity named by c</span></span><br><span class="line"><span class="keyword">decltype</span>((c)) f = c;  <span class="comment">// f has type int&amp;, because (c) is an lvalue</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">0</span>) g;        <span class="comment">// g has type int, because 0 is an rvalue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a><strong>标准库</strong></h2><p>C++标准库中已经实现了大量通用的算法, 包括查找, 排序, 过滤以及随机算法等, 如果你正瞅着自己实现某个算法时, 可以直接看看标准模板库(<code>STL</code>, Stardard Template Libarary)的算法. 举几个例子:</p><ul><li><code>for_each</code>: 可以利用迭代器<code>iterator</code>很方便的对容器进行遍历操作</li><li><code>transform</code>: 对容器元素根据某个特定规则进行变换</li><li><code>find_if</code>: 根据某个函数对象对进行搜索查找</li><li><code>sort</code>&#x2F;<code>lower_bound</code>: 排序&#x2F;搜索算法</li></ul><p>标准模板库<code>STL</code>包含了三大组件：容器（<code>Container</code>）、算法（<code>Algorithm</code>）以及迭代器（<code>Interator</code>）。</p><ul><li>容器用于容纳&#x2F;组织对象，是一种数据结构的抽象，以类模板的方式实现</li><li>算法执行对象的操作，是一种函数的抽象，通过函数模板来实现</li><li>迭代器用于访问容器中的元素，为容器与算法提供一种协同工作的机制。</li></ul><p>更多有关标注库的算法可以参考<a href="https://book.douban.com/subject/10440485/">The C++ Standard Library, 2nd Edition</a>.</p><h2 id="转型操作符"><a href="#转型操作符" class="headerlink" title="转型操作符"></a><strong>转型操作符</strong></h2><p>C++中引入了很多类型转换（cast）操作，比如<code>const_cast</code>, <code>dynamic_cast</code>等，为转换操作提供了明确的语法表达。</p><ul><li><code>const_cast</code>： 去除类型中的const信息，只是去掉转型类型修饰符。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> Shape *sp = <span class="keyword">new</span> Shape</span><br><span class="line">Share *sp1 = <span class="built_in">const_cast</span>&lt;Shape *&gt;(sp)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>static_cast</code>: 用于相对而言可跨平台的移植的转型，最常的用于将一个基类指针或者引用，向下转型为一个派生类指针与引用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Shape *sp = <span class="keyword">new</span> Circle;</span><br><span class="line"></span><br><span class="line">Circle *cp = <span class="built_in">static_cast</span>&lt;Circle *&gt;(sp)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>dynamic_cast</code>: 基类指针向下（downcast）转型为派生类指针, 与static_cast不同的是， dynamic_cast仅用于多态类型的向下转型（就是说被转型的类型中，必须是一个指向带有虚函数的类类型的指针），并且会执行运行期的检查，确保了转型的正确。这也为<code>dynamic_cast</code>带来了额外的开销。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> Circle *cp = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Circle*&gt;(<span class="built_in">getNextShape</span>());</span><br><span class="line"><span class="keyword">if</span> (cp) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果转型失败，会抛出一个<code>std::bad_cast</code>的异常。</p><ul><li><code>reinterpret_cast</code>: 允许从<code>bit</code>位的角度重新看待一个对象，将其看做是完全不同的东西</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">char</span> *cp =  <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(<span class="number">0x00ff0000</span>);</span><br><span class="line"><span class="type">int</span> *ip = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span> *&gt;(cp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通常来说，<code>reinterpret_cast</code>并不具备可移植性，因此使用时需要谨慎。用于类类型转换时，注意其与<code>static_cast</code>的区别，<code>reinterpret_cast</code>只是将基类指针假装成一个派生类指针而不改变其值，而<code>static_cast</code>则会执行地址操作。</p><p>更多关于类型转换可以参考<a href="https://belaycpp.com/2021/10/14/history-of-c-the-genesis-of-casting/">The genesis of casting.</a>.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://book.douban.com/subject/25720141/">A Tour of C++</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?redirectedfrom=MSDN&view=msvc-170">Modern C++</a></li><li><a href="http://mindhacks.cn/2012/08/27/modern-cpp-practices/">C++11（及现代C++风格）和快速迭代式开发</a></li><li><a href="https://www.boost.org/doc/libs/1_78_0/libs/libraries.htm">Boost库参考资料</a></li><li><a href="https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list">C++必读书籍系列-从入门到高级</a></li><li><a href="http://www.parashift.com/c++-faq-lite/index.html">C++ FAQ系列</a></li><li><a href="http://norvig.com/21-days.html">Teach Yourself Programming in Ten Years</a></li><li><a href="https://isocpp.org/wiki/faq">C++ Super FAQ</a></li><li><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">Modern C++ Core Guidelines</a></li><li><a href="https://book.douban.com/subject/25923597/">Effective Modern C++</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;断断续续看了Bjarne Stroustrup的’C++之旅(&lt;code&gt;a tour of C++&lt;/code&gt;)’, 作者把很多原本看起来复杂的概念模型都讲的比较清晰, 也有不少好的代码示例, 有种拨云见雾的感觉. 于是想着写一篇文章来总结重新学习C++的一些经验, 主要阐述下现代C++(&lt;code&gt;&amp;gt;=C++11&lt;/code&gt;)中那些容易让人混淆而觉得陌生的技术.&lt;/p&gt;
&lt;p&gt;了解C++历史的人都知道, &lt;code&gt;Bjarne Stroustrup&lt;/code&gt;是在Bell实验室(就是Unix操作系统与C语言诞生的地方)发明了C++, 初衷是在C中加入类(class)的概念, 增强C语言在系统编程上的效率与灵活性, 也正式因为这个原因, C++在1979年最初的名字是&lt;code&gt;带类的C&lt;/code&gt;(c with class), 直到1984年才改名为&lt;code&gt;C++&lt;/code&gt;. 到今天, &lt;code&gt;C++&lt;/code&gt;的发展历经了快40年历史, 但真正一次大的标准修改是在2011年, 这个版本也称为&lt;code&gt;C++11&lt;/code&gt;(&lt;code&gt;C++11&lt;/code&gt;之后的版本也统称为&lt;code&gt;Modern C++&lt;/code&gt;).接下来我们就来一起来回顾下现代C++中那些曾经让人&lt;code&gt;头疼&lt;/code&gt;的技术吧.&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://sniffer.site/categories/C/"/>
    
    
    <category term="C++" scheme="https://sniffer.site/tags/C/"/>
    
    <category term="编程语言" scheme="https://sniffer.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>如何用pktgen测试网卡性能?</title>
    <link href="https://sniffer.site/2022/03/18/%E4%BD%BF%E7%94%A8pktgen%E6%B5%8B%E8%AF%95%E7%BD%91%E5%8D%A1%E6%80%A7%E8%83%BD/"/>
    <id>https://sniffer.site/2022/03/18/%E4%BD%BF%E7%94%A8pktgen%E6%B5%8B%E8%AF%95%E7%BD%91%E5%8D%A1%E6%80%A7%E8%83%BD/</id>
    <published>2022-03-18T02:45:14.000Z</published>
    <updated>2022-03-23T08:52:44.144Z</updated>
    
    <content type="html"><![CDATA[<p>在优化网络性能时, 不可避免要对网络的带宽进行测试. 通常大家可能都会使用<code>iperf</code>来执行网络链路的吞吐量测试, 但<code>iperf</code>只能测试<code>TCP/IP</code>协议层的速度, 这个带宽数据跟<code>TCP/UDP</code>协议的参数配置以及应用层缓冲区的大小都有关系. 有时, 我们希望直接测试网卡本身的实际吞吐量, 看看网卡实际的发包能力. Linux内核提供了<code>pktgen</code>工具用以产生数据包, 向网卡注入<code>TCP/UDP</code>数据. 这里, 我们就来看下具体如何通过<code>pktgen</code>来测试网卡性能.</p><span id="more"></span><h2 id="模块配置-x2F-加载"><a href="#模块配置-x2F-加载" class="headerlink" title="模块配置&#x2F;加载"></a><strong>模块配置&#x2F;加载</strong></h2><p><code>pktgen</code>在内核中是以模块的形式编译的, 使用之前确保内核配置了<code>CONFIG_NET_PKTGEN</code>; 如果<code>CONFIG_NET_PKTGEN</code>配置为<code>m</code>, 则使用时需要<code>modprobe pktgen</code>先加载模块. 模块加载完成后, 我们可以在<code>/proc/net/pktgen</code>下面看到有如下几个目录: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">~<span class="meta"># ls -al /proc/net/pktgen/</span></span><br><span class="line">total <span class="number">0</span></span><br><span class="line">dr-xr-xr-x <span class="number">2</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> .</span><br><span class="line">dr-xr-xr-x <span class="number">6</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> ..</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> kpktgend_0</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> kpktgend_1</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> kpktgend_2</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> kpktgend_3</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> kpktgend_4</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> kpktgend_5</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> kpktgend_6</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> kpktgend_7</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> pgctrl</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中<code>kpktgend_*</code>是内核数据包生产线程, 每个CPU都会启动一个相应的线程, 如果要添加某个测试网卡, 可以通过向该文件节点写入<code>add_device ethX</code>; <code>pgctrl</code>用于控制网卡性能测试状态需要在对应的线程执行网卡的吞吐量测试, 有<code>start</code>&#x2F;<code>stop</code>&#x2F;<code>reset</code>三种状态.</p><blockquote><p>更多<code>pktgen</code>的信息可以参考内核文档<code>pktgen.txt</code>以及源代码<code>pktgen.c</code></p></blockquote><h2 id="脚本测试"><a href="#脚本测试" class="headerlink" title="脚本测试"></a><strong>脚本测试</strong></h2><p>刚开始碰到<code>pktgen</code>测试网卡, 会被一堆参数搞得头晕, 好在内核的代码示例已经有了一些基本的脚本, 我们只需要根据自己的需要稍加改造就可以用起来了, 具体可以参考内核源码目录<code>samples/pktgen</code>. 下面贴了一段用于配置&#x2F;启动测试的脚本, 完整的代码示例可以参考<a href="https://github.com/runningforlife/CodingExamples/blob/main/shell/pktgen_test.sh">pktgen_test.sh</a>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pg_ctrl <span class="string">&quot;reset&quot;</span></span><br><span class="line"><span class="comment"># Config Start Here -------------------------------------</span></span><br><span class="line"><span class="keyword">for</span> (( thread = 0; thread &lt; <span class="variable">$THREADS</span>; ++thread )); <span class="keyword">do</span></span><br><span class="line">  PGDEV=<span class="variable">$&#123;DEV&#125;</span>@<span class="variable">$thread</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Removing all devices&quot;</span></span><br><span class="line">  pg_thread <span class="variable">$thread</span> <span class="string">&quot;rem_device_all&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Adding eth0&quot;</span></span><br><span class="line">  pg_thread <span class="variable">$thread</span> <span class="string">&quot;add_device <span class="variable">$PGDEV</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Notice config queue to map to cpu (mirrors smp_processor_id())</span></span><br><span class="line">    <span class="comment"># It is beneficial to map IRQ /proc/irq/*/smp_affinity 1:1 to CPU number</span></span><br><span class="line">    pg_set <span class="variable">$PGDEV</span> <span class="string">&quot;flag QUEUE_MAP_CPU&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># device config</span></span><br><span class="line">  CLONE_SKB=<span class="string">&quot;clone_skb 000000&quot;</span></span><br><span class="line">  <span class="comment">#PGDEV=/proc/net/pktgen/eth0</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Configuring <span class="variable">$PGDEV</span>&quot;</span></span><br><span class="line">  pg_set <span class="variable">$PGDEV</span> <span class="string">&quot;count 10000000&quot;</span></span><br><span class="line">  pg_set <span class="variable">$PGDEV</span> <span class="string">&quot;clone_skb 000000&quot;</span></span><br><span class="line">  pg_set <span class="variable">$PGDEV</span> <span class="string">&quot;pkt_size <span class="variable">$PKT_SIZE</span>&quot;</span></span><br><span class="line">  pg_set <span class="variable">$PGDEV</span> <span class="string">&quot;delay 0&quot;</span></span><br><span class="line">  pg_set <span class="variable">$PGDEV</span> <span class="string">&quot;dst <span class="variable">$DEST_IP</span>&quot;</span></span><br><span class="line">  pg_set <span class="variable">$PGDEV</span> <span class="string">&quot;dst_mac <span class="variable">$DEST_MAC</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time to run</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running... ctrl^C to stop&quot;</span></span><br><span class="line"><span class="built_in">trap</span> pg_stop SIGINT</span><br><span class="line"></span><br><span class="line">pg_ctrl <span class="string">&quot;start&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Done&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Print results</span></span><br><span class="line"><span class="keyword">for</span> ((thread = 0; thread &lt; <span class="variable">$THREADS</span>; thread++)); <span class="keyword">do</span></span><br><span class="line">    dev=<span class="variable">$&#123;DEV&#125;</span>@<span class="variable">$&#123;thread&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Device: <span class="variable">$dev</span>&quot;</span></span><br><span class="line">    <span class="built_in">cat</span> /proc/net/pktgen/<span class="variable">$dev</span> | grep -A2 <span class="string">&quot;Result:&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个脚本总体说来主要分为三个步骤:</p><ul><li><code>pg_ctrl &quot;reset&quot;</code>: 清除上一次测试状态</li><li><code>pg_thread $thread &quot;add_device $PGDEV&quot;</code>: 配置测试的网卡</li><li><code>pg_ctrl &quot;start&quot;</code>: 开启测试, 按<code>ctrl+C</code>后, 进程退出, 内核结束发包</li></ul><p>比如, 执行<code>./pktgen_test.sh -i enp0s31f6 -d 10.193.200.1 -m 31:b6:89:55:b3:8c -t 2</code>(使用两个内核线程发包), 测试结束后, 会打印出测试结果(实际查看<code>/proc/net/pktgen/enp0s31f6*</code>的结果会输出更多信息, 脚本里对输出做了过滤), 包括测试的时间&#x2F;是否出现错误以及吞吐量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Device: enp0s31f6@<span class="number">0</span></span><br><span class="line">Result: OK: <span class="number">1662287</span>(c1662114+d172) usec, <span class="number">89218</span> (<span class="number">1024b</span>yte,<span class="number">0f</span>rags)</span><br><span class="line">  <span class="number">53671</span>pps <span class="number">439</span>Mb/sec (<span class="number">439672832b</span>ps) errors: <span class="number">0</span></span><br><span class="line">Device: enp0s31f6@<span class="number">1</span></span><br><span class="line">Result: OK: <span class="number">1606214</span>(c1605962+d252) usec, <span class="number">108442</span> (<span class="number">1024b</span>yte,<span class="number">0f</span>rags)</span><br><span class="line">  <span class="number">67514</span>pps <span class="number">553</span>Mb/sec (<span class="number">553074688b</span>ps) errors: <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面可以看到, 网卡的<code>PPS</code>(<code>Packet Per Second</code>)大约在<code>121185</code>(1.2Mpps), 带宽在<code>992Mb/s</code>, 这个速度已经比较接近于千兆网卡的理论吞吐量<code>1.5Mpps</code>(1000bps&#x2F;((64 + 20)*8))了(这里64B为以太网数据帧的最小尺寸, <code>46(pad) + 14(dmac,smac,type) + 4(CRC)</code>, 20B 为以太网帧前导和帧间距的大小).</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li>内核文档<code>Documentation/networking/pktgen.txt</code></li><li><a href="https://github.com/torvalds/linux/blob/master/net/core/pktgen.c">pktgen内核源码</a></li><li><a href="https://github.com/torvalds/linux/tree/master/samples/pktgen">pktgen内核示例代码</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在优化网络性能时, 不可避免要对网络的带宽进行测试. 通常大家可能都会使用&lt;code&gt;iperf&lt;/code&gt;来执行网络链路的吞吐量测试, 但&lt;code&gt;iperf&lt;/code&gt;只能测试&lt;code&gt;TCP/IP&lt;/code&gt;协议层的速度, 这个带宽数据跟&lt;code&gt;TCP/UDP&lt;/code&gt;协议的参数配置以及应用层缓冲区的大小都有关系. 有时, 我们希望直接测试网卡本身的实际吞吐量, 看看网卡实际的发包能力. Linux内核提供了&lt;code&gt;pktgen&lt;/code&gt;工具用以产生数据包, 向网卡注入&lt;code&gt;TCP/UDP&lt;/code&gt;数据. 这里, 我们就来看下具体如何通过&lt;code&gt;pktgen&lt;/code&gt;来测试网卡性能.&lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="网络性能" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/"/>
    
    <category term="带宽测试" scheme="https://sniffer.site/tags/%E5%B8%A6%E5%AE%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="pktgen" scheme="https://sniffer.site/tags/pktgen/"/>
    
  </entry>
  
  <entry>
    <title>「置顶」收藏的学习资料</title>
    <link href="https://sniffer.site/2022/03/17/%E6%94%B6%E8%97%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    <id>https://sniffer.site/2022/03/17/%E6%94%B6%E8%97%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</id>
    <published>2022-03-17T01:14:38.000Z</published>
    <updated>2023-04-10T10:32:13.209Z</updated>
    
    <content type="html"><![CDATA[<p>以下是从事软件开发以来收藏的资料&#x2F;书籍&#x2F;网站, 欢迎推荐~</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a><strong>基础</strong></h2><ul><li><a href="https://akaedu.github.io/book/">Linux C一站式学习</a>: 收藏已久, 值得一看</li><li><a href="https://book.douban.com/subject/4822685/">Code: The Hidden Language of Computer Hardware and Software</a>: 最开始学单片机时就对CPU是如何执行代码, 如何解析代码并正常运营感到疑惑, <code>Code</code>这本书正是从零开始解释了计算机内部是如何工作的, 看了两遍, 感觉都很过瘾, 值得学习</li><li><a href="https://book.douban.com/subject/5333562/">Computer Systems: A Programmer’s Perspective</a>: 从计算机基础原理讲起, 阐述了计算机的原理, 内存&#x2F;网络都有涵盖, 想进入软件行业的入门比读书之一; 平时也可以作为参考书籍不时翻一翻.</li></ul><span id="more"></span><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a><strong>网络协议</strong></h2><ul><li><a href="http://www.tcpipguide.com/index.htm">TCP&#x2F;IP指南</a>: TCP&#x2F;IP协议很详细的介绍, 有很多绘制精美的流程图, 是学习TCP&#x2F;IP很好的网站</li><li><a href="http://www.embeddedlinux.org.cn/linux_net/">深入理解Linux网络协议栈</a>: 很好的内核协议的在线书籍, 从协议栈初始化到数据接收发送, 再到路由都有介绍, 是研究Linux内核协议不可多得的参考资料</li><li><a href="https://book.douban.com/subject/10510747/">计算机网络(第5版)</a>: 详尽的介绍了计算机网络相关的知识，从以太网到WIFI、蓝牙都有涉及，难度不高，很合适入门学习</li></ul><h2 id="LINUX开发"><a href="#LINUX开发" class="headerlink" title="LINUX开发"></a><strong>LINUX开发</strong></h2><ul><li><a href="https://book.douban.com/subject/1692629/">Advanced Programming in the UNIX Environment</a>: 熟悉Unix&#x2F;Linux系统开发的必读书之一, 对了解Unix类的操作系统工作原理很有帮助, 可以多看, 作为参考书常备.</li><li><a href="https://book.douban.com/subject/1500149/">Unix Network Programming</a>: 专门讲Unix类操作系统网络编程开发, 涵盖了网络编程的方方面面，软件开发人员必读书目.</li><li><a href="https://book.douban.com/subject/2287506/">深入理解LINUX内核</a>: 基于2.6版本的内核代码讲解Linux内核的具体实现原理, 内容翔实深入，是理解Linux内核的不可少的参考书之一.</li><li><a href="https://book.douban.com/subject/3652388/">程序员的自我修养</a>: 从库的加载与程序编译的角度讲解了Linux&#x2F;Windows下代码从编译到实际运行的具体过程, 对理解计算机代码的执行过程很有帮助, 可以作为参考书。</li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/performance_tuning_guide/index">Redhat系统优化手册</a>: 包含了Linux系统中内存&#x2F;IO&#x2F;网络相关的优化, 可以很好的将Linux系统与内核的知识串联在一起, 值得深入学习</li><li><a href="https://lwn.net/Kernel/">Linux内核周报</a>: Linux内核官方权威文档, 有很多值得一看的资料</li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a><strong>拓展</strong></h2><ul><li><a href="https://book.douban.com/subject/6021440/">黑客与画家</a>: 作者<code>Paul Graham</code>素有硅谷创业教父之称, 把计算机软件行业的各种问题都看得十分透彻, 值得多读</li><li><a href="https://book.douban.com/subject/10750155/">数学之美</a>: 吴军博士写的有关算法在互联网以及人工智能应用方面的科普类书籍，最近又看了一遍，值得学习。</li><li><a href="https://book.douban.com/subject/2243615/">Head First设计模式</a>: 再看一遍，是一本很不错的软件设计模式的书籍，深入浅出，还有很好的配图与案例，值得看看</li><li><a href="https://book.douban.com/subject/35953050/">思维突破-如何获得好想法</a>: 人的大脑中存在很多思维偏见与认知障碍，本书通过很多案例与工具阐述了如何让我们变得更有创造力。另外还讲了组织中存在的创新力不足的问题以及如何去提升团队与组织的创新力。是提升自己思维与认知，开拓视野不可多得的好书。值得一看。</li></ul><h2 id="大牛的网站"><a href="#大牛的网站" class="headerlink" title="大牛的网站"></a><strong>大牛的网站</strong></h2><ul><li><a href="https://coolshell.cn/">左耳朵耗子叔的个人网站</a></li><li><a href="http://mindhacks.cn/">刘未鹏</a></li><li><a href="http://www.ruanyifeng.com/home.html">阮一峰的个人网站</a></li><li><a href="http://blog.codingnow.com/">云风的BLOG</a></li><li><a href="https://blog.youxu.info/">4GSpace(徐宥)</a></li><li><a href="https://byvoid.com/zhs/blog/">Beyond The Void</a></li><li><a href="http://www.matrix67.com/blog/">matrix67</a></li><li><a href="https://www.joelonsoftware.com/">Joel On Software</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下是从事软件开发以来收藏的资料&amp;#x2F;书籍&amp;#x2F;网站, 欢迎推荐~&lt;/p&gt;
&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;&lt;strong&gt;基础&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://akaedu.github.io/book/&quot;&gt;Linux C一站式学习&lt;/a&gt;: 收藏已久, 值得一看&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/4822685/&quot;&gt;Code: The Hidden Language of Computer Hardware and Software&lt;/a&gt;: 最开始学单片机时就对CPU是如何执行代码, 如何解析代码并正常运营感到疑惑, &lt;code&gt;Code&lt;/code&gt;这本书正是从零开始解释了计算机内部是如何工作的, 看了两遍, 感觉都很过瘾, 值得学习&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/5333562/&quot;&gt;Computer Systems: A Programmer’s Perspective&lt;/a&gt;: 从计算机基础原理讲起, 阐述了计算机的原理, 内存&amp;#x2F;网络都有涵盖, 想进入软件行业的入门比读书之一; 平时也可以作为参考书籍不时翻一翻.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="学习资料" scheme="https://sniffer.site/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>如何移植openssh到ARM开发板</title>
    <link href="https://sniffer.site/2022/02/16/%E5%A6%82%E4%BD%95%E7%A7%BB%E6%A4%8Dopenssh%E5%88%B0armv7%E7%B3%BB%E7%BB%9F/"/>
    <id>https://sniffer.site/2022/02/16/%E5%A6%82%E4%BD%95%E7%A7%BB%E6%A4%8Dopenssh%E5%88%B0armv7%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-02-16T06:54:00.000Z</published>
    <updated>2022-02-16T12:36:25.961Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为公司安全的需求, 要修改<code>openssh</code>的源码, 将其移植到一个ARM的嵌入式系统上, 替换原有的预编译的版本. 参考了网上的一些移植<code>openssh</code>的资料, 如<a href="https://wiki.openssl.org/index.php/Compilation_and_Installation">openssl官网编译安装说明</a>; <a href="https://www.cnblogs.com/TaXueWuYun/p/15314124.html">移植openssh到arm-linux</a>, 但是由于目标平台不一样, 实践起来并不能完全参考, 会有细微的差异. 这里把整个流程写下来, 总结一下, 方便后面移植相关开发工具.</p><span id="more"></span><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a><strong>下载源码</strong></h2><p><code>openssh</code>的编译依赖于<code>openssl</code>, <code>zlib</code>两个库, 因此编译的第一步是把所有这些源码都下载过来, 三个开源仓库下载路径如下:</p><ul><li><code>openssh</code>: git仓库以及各个release版本, <a href="https://www.openssh.com/portable.html">https://www.openssh.com/portable.html</a>; 由于release版本才有<code>Configure</code>脚本, 因此我直接下载了一个<code>v6.6p1</code>的稳定版本</li><li><code>openssl</code>: 包含github仓库以及文档说明, <a href="https://www.openssl.org/">https://www.openssl.org/</a>; github上的源码基本包含了历史分支信息, 因此可以直接通过<code>git clone</code>下载, 然后<code>checkout</code>到对应版本的分支(使用<code>v1.0.1</code>版本)</li><li><code>z-lib</code>: 官网上有下载链接, <a href="https://zlib.net/">https://zlib.net/</a>; github上也有仓库, 但是没有历史分支信息, 所以下载了版本<code>zlib-1.2.11</code>的源码.</li></ul><blockquote><p><code>openssh</code>的<code>INSTALL</code>文档中对所要求的<code>openssl</code>&#x2F;<code>z-lib</code>版本有具体说明, 可以参考.</p></blockquote><p>由于目标移植平台已有的<code>openssh</code>使用的版本是<code>OpenSSH_6.6p1</code>, 因此实际下载的源码版本信息如下:</p><ul><li><code>openssh</code>: Openssh_6.6p1</li><li><code>openssl</code>: OpenSSL_1_0_1-stable</li><li><code>z-lib</code>: zlib-1.2.11</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/usr/local/bin # ./ssh -V</span><br><span class="line">OpenSSH_6<span class="number">.6</span>p1, OpenSSL <span class="number">1.0</span><span class="number">.1</span>h <span class="number">5</span> Jun <span class="number">2014</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a><strong>编译源码</strong></h2><p>为了方便管理以及查看编译结果, 可以把三个软件包解压放到一个目录: <code>/data/wxn/openSSH</code>. 本地机器CPU是<code>x86_64</code>, 操作系统是Ubuntu16, 目标平台是<code>armv7</code>架构, 交叉编译使用的工具是<code>arm-none-linux-gnueabi-gcc</code>(gcc 4.6.2).</p><h3 id="编译zlib"><a href="#编译zlib" class="headerlink" title="编译zlib"></a><strong>编译zlib</strong></h3><p>进入<code>/data/wxn/openSSH/zlib-1.2.11</code>, 通过<code>./configure -h</code>查看编译配置说明:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">./configure -h</span><br><span class="line">usage:</span><br><span class="line">  configure [--<span class="type">const</span>] [--zprefix] [--prefix=PREFIX]  [--eprefix=EXPREFIX]</span><br><span class="line">    [--<span class="type">static</span>] [-<span class="number">-64</span>] [--libdir=LIBDIR] [--sharedlibdir=LIBDIR]</span><br><span class="line">    [--includedir=INCLUDEDIR] [--archs=<span class="string">&quot;-arch i386 -arch x86_64&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果只需要生成静态库, 就指定参数<code>--static</code>; 另外需要指定生成文件的路径:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">./configure --<span class="type">static</span> --prefix=/data/wxn/openSSH</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述指令生成编译的<code>Makefile</code>后, 修改其中的编译工具, 将其指向交叉编译工具所在的路径(需要修改<code>gcc</code>&#x2F;<code>ar</code>两个工具的路径): </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TOOL_PREFIX=/data/wxn/toolchainbin/arm-none-linux-gnueabi-</span><br><span class="line">CC=$(TOOL_PREFIX)gcc</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行<code>make;make install</code>, 在目录<code>/data/wxn/openSSH/lib</code>下可以看到生成了一个<code>libz.a</code>的静态库.</p><h3 id="编译openssl"><a href="#编译openssl" class="headerlink" title="编译openssl"></a><strong>编译openssl</strong></h3><p>编译<code>openssl</code>会稍微麻烦点. 同样查看<code>./Configure -h</code>可以看到, 需要配置目标平台的系统类型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">./Configure -h</span><br><span class="line">Configuring <span class="keyword">for</span></span><br><span class="line"> </span><br><span class="line">Usage: Configure [no-&lt;cipher&gt; ...] [enable-&lt;cipher&gt; ...] [experimental-&lt;cipher&gt; ...] [-Dxxx] [-lxxx] [-Lxxx] [-fxxx] [-Kxxx] [no-hw-xxx|no-hw] [[no-]threads] [[no-]shared] [[no-]zlib|zlib-dynamic] [no-<span class="keyword">asm</span>] [no-dso] [no-krb5] [sctp] [<span class="number">386</span>] [--prefix=DIR] [--openssldir=OPENSSLDIR] [--with-xxx[=vvv]] [--test-sanity] os/compiler[:flags]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译配置<code>Configure</code>中已经添加了很多平台类型(<code>./Configure LIST</code>可以查看已经支持的平台), 但是好像并没有发现<code>armv7</code>架构的平台, <a href="https://wiki.openssl.org/index.php/Compilation_and_Installation#ARM">openssl官网</a>建议自己手动添加一个配置, 但看了其他地方说可以使用相似平台的配置, 看配置列表跟arm相关的有<code>android-armv7</code>&#x2F;<code>linux-armv4</code>两个, 尝试了<code>armv4</code>发现是可以(<code>android-armv7</code>会出现编译错误):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">./Configure linux-armv4 --prefix=/data/wxn/openSSH</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改生成的<code>Makefile</code>, 按照之前的<code>zlib</code>配置, 将其中<code>gcc/nm/ar</code>的地方都指向交叉编译工具所在的目录, 执行<code>make; make install</code>, 即可看到<code>/data/wxn/openSSH</code>生成了<code>lib/bin</code>两个目录, <code>lib</code>目录包含了<code>libssl.a/libcrypto.a</code>静态库, <code>bin</code>下包含了<code>openssl</code>工具.</p><h3 id="编译openssh"><a href="#编译openssh" class="headerlink" title="编译openssh"></a><strong>编译openssh</strong></h3><p>编译<code>openssh</code>跟之前两个库的编译类似(具体可以参考<code>INSTALL</code>文档), 只不过需要指定生成的<code>openssl</code>&#x2F;<code>zlib</code>所在目录(进入代码根目录):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GCC=/data/wxn/toolchain/arm-none-linux-gnueabi-gcc</span><br><span class="line">AAR=/data/wxn/toolchain/arm-none-linux-gnueabi-ar</span><br><span class="line">./configure --host=arm-linux --prefix=/usr/local --with-zlib=/data/wxn/openSSH --with-ssl-dir=/data/wxn/openSSH --disable-etc-<span class="keyword">default</span>-login --disable-strip CC=$GCC AR=$AAR</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着执行<code>make</code>(不用执行安装指令<code>make install</code>), 可以看到根目录下多了<code>ssh/sshd/scp</code>等工具.将其拷贝到目标平台对应目录<code>/usr/local/bin</code>, 确认可以正常运行, 至此大功告成.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近因为公司安全的需求, 要修改&lt;code&gt;openssh&lt;/code&gt;的源码, 将其移植到一个ARM的嵌入式系统上, 替换原有的预编译的版本. 参考了网上的一些移植&lt;code&gt;openssh&lt;/code&gt;的资料, 如&lt;a href=&quot;https://wiki.openssl.org/index.php/Compilation_and_Installation&quot;&gt;openssl官网编译安装说明&lt;/a&gt;; &lt;a href=&quot;https://www.cnblogs.com/TaXueWuYun/p/15314124.html&quot;&gt;移植openssh到arm-linux&lt;/a&gt;, 但是由于目标平台不一样, 实践起来并不能完全参考, 会有细微的差异. 这里把整个流程写下来, 总结一下, 方便后面移植相关开发工具.&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://sniffer.site/categories/Linux/"/>
    
    
    <category term="openssh" scheme="https://sniffer.site/tags/openssh/"/>
    
    <category term="ARM嵌入式开发" scheme="https://sniffer.site/tags/ARM%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深度学习简介</title>
    <link href="https://sniffer.site/2022/01/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/"/>
    <id>https://sniffer.site/2022/01/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/</id>
    <published>2022-01-29T07:58:11.000Z</published>
    <updated>2022-03-23T03:27:46.227Z</updated>
    
    <content type="html"><![CDATA[<p>深度学习(<code>Deep Learning</code>)是近年来人工智能的热门研究领域, 广泛地应用在工业与商业领域, 如计算机视觉(<code>Computer Vision</code>), 语音识别(<code>Speech Recognition</code>), 自然语言处理(<code>Natural Language Processing</code>), 机器翻译(<code>Machine Translation</code>), 以及医学图像分析, 药物发现等领域都采用了深度学习方法. 从本质上来说, 深度学习属于机器学习(<code>Machine Learning</code>)的一个分支, 是一种从大规模数据进行学习然后能在新数据集进行推理泛化的数学模型.</p><p>相比人工智能, 深度学习只是最近十来年才出现的概念, 但为何会在在最近几年(2010开始)内出现井喷式的增长, 成为人工智能领域炙手可热的研究方向了? 总结来说主要有如下几个原因:</p><span id="more"></span><ul><li>数据集: 随着大型互联网公司的出现, 大规模的数据集变得触手可得</li><li>物理设备: 存储设备容量更大, 价格更便宜, 能够保存更多的数据; GPU等支持并行计算的专用处理器为深度学习模型的训练提供必要的物理基础, 让模型训练时间更短</li><li>Google&#x2F;Facebook等公司开源了<code>Tensorflow</code>&#x2F;<code>Caffe</code>&#x2F;<code>PyTorch</code>等开源了深度学习的框架, 为深度学习的应用与传播起到了重要的推动作用</li></ul><p>深度学习核心思想来自于人工神经网络(<code>Artificial Neural Network</code>), 但从结构上来说, 深度学习网络具有更多的层级, 网络结构更为复杂, 存在前馈&#x2F;循环以及深度生成对抗网络等多种形式, 因此并不与神经网络等价, 可以看作是神经网络的升级版. 从技术的范畴来说, 深度学习是机器学习的一个子集, 而机器学习是人工智能(<code>Artificial Inteligence</code>)的一个分支而已.</p><p align="center">    <img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/AI-ML-DL.svg.png" width=500 height=500></p><blockquote><p>这篇文章旨在对深度学习的历史以及基本概念做梳理, 可能有很多疏漏跟错误的地方, 感兴趣的同学可以自行参考文末的文献进行深入了解.</p></blockquote><h2 id="人工智能的发展历程"><a href="#人工智能的发展历程" class="headerlink" title="人工智能的发展历程"></a><strong>人工智能的发展历程</strong></h2><p>人工智能是人类尝试通过计算机模拟生物智能尤其是人类智能活动, 从而实现机器智能的目标. 人脑经历上千万年的进化才得以形成如此复杂的结构, 想要让机器具备人一样的智能, 机器需要拥有感知(计算机视觉, 语音识别), 学习(模式识别, 机器学习, 强化学习), 语言(自然语言处理), 决策(规划, 数据挖掘)等多种能力. 而这些都构成了人工智能的研究领域.</p><p>一般来说, 人工智能的研究领域大致可以分为如下几个部分:</p><ul><li>感知(<code>perception</code>): 模拟生物的感知能力,  对外部信息如视觉&#x2F;听觉进行处理加工, 主要研究领域包括计算机视觉和语音信息处理等</li><li>学习(<code>Learning</code>): 模拟生物的学习能力, 研究如何从已有数据集或从与环境的交互中进行学习, 研究领域包括监督学习(<code>Supervised Learning</code>), 无监督学习(<code>Unsupervised Learning</code>)以及强化学习(<code>Reinforcement Learning</code>)等</li><li>认知(<code>Cognition</code>): 模拟生物的认知能力, 研究领域包括知识表示, 自然语言理解, 推理&#x2F;规划&#x2F;决策等</li></ul><p>自人工智能诞生以来, 大致经历了三个重要的发展阶段:</p><p align="center">    <img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ai_history.png"></p><ul><li>推理期:  1956年达特茅斯的人工智能会议后, 相关的研究开始涌现出来. 研究者基于逻辑或者事实归纳出来一系列规则, 基于这些规则通过编程尝试让计算机完成某些特定的任务. 但当时的人们过于乐观, 也低估了人工智能系统实现的难度, 很多项目难以达到预期的目标. 人工智能的研究在之后的数年时间陷入了低谷, 很多研究项目被中止, 经费被削减.</li><li>知识期:  到20世纪70年代, 人们开始意识到知识对人工智能系统的重要性. 这一时期开始出现很多专家系统(<code>Expert System</code>), 并在特定的领域取得了很多成果. 专家系统一般采用知识表示和知识推理来完成由领域专家才能解决的问题. 为了解决这些问题, 人们开发出了Prolog(<code>Programming in Logic</code>)语言来构造专家系统&#x2F;知识库以及实现自然语言理解等.</li><li>学习期: 到这个阶段, 研究者尝试利用数据让机器自动学习, 即采用机器学习(<code>Machine Learning</code>)的方式让计算机从数据(经验)中学习并获得规律(模型), 然后再利用该模型在未知的数据集上进行预测推理.</li></ul><blockquote><p>参考<a href="https://nndl.github.io/">&lt;神经网络与深度学习&gt;</a></p></blockquote><p>人工智能的发展距今已经超过60年, 大数据与深度学习方法的结合让原本看来很困难的问题, 如图像识别, 语音识别, 机器翻译等变得更加容易, 甚至在某些特定的领域这些深度学习模型能够超越人类的表现. 但要想真正实现与人同样的智能程度, 还有很多的困难需要解决, 还有很长的路要走.</p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a><strong>机器学习</strong></h2><p>机器学习(<code>Machine Learning</code>)是指从有限的观测数据中学习出具有一般性的规律(找出数据中模式), 并利用这些规律对未知的数据进行预测的方法. 国际机器学习大会的创始人之一<code>Tom Mitchell</code>对机器学习的定义是：计算机程序从经验 <code>E</code> 中学习，解决某一任务<code>T</code>，进行某一性能度量<code>P</code>，通过<code>P</code>测定在<code>T</code>上的表现因经验<code>E</code>而提高.</p><p>要训练一个机器学习模型, 通常包含如下几个部分:</p><ul><li>数据(<code>data</code>):  用于训练模型与验证模型的数据集. 数据集由一个个样本(<code>sample</code>)组成, 大多数时候, 这些样本都遵循独立同分布(<code>Independently and Identcally Distributed</code>), 每个样本通常由一组特征(<code>features</code>, 也称为协变量-<code>covariables</code>)组成. 机器学习模型会根据这些属性进行预测.</li><li>模型(<code>model</code>): 模型是对给定数据集的抽象表示, 可以看作参数化的数学模型.</li><li>目标函数: 要想从数据中学习到某种规律(经验), 首先要有一种度量模型质量的方法, 在大多数情况下, 这个模型度量是可优化的, 我们称之为目标函数(<code>objective function</code>), 也称为损失函数(<code>loss function</code>&#x2F;<code>cost function</code>).  通常, 目标函数是根据模型参数定义的, 并取决于数据集. 为了确保模型在未知的数据上具备足够的泛化能力(<code>generalization</code>), 通常需要将数据集划分成训练集(<code>training set</code>)和测试集(<code>test set</code>)两个部分. 训练集用于训练模型, 而测试集用于验证模型的能力. 如果一个模型在训练集上表现很好, 但在测试集上却表现比较差, 我们称这种情况为模型过拟合(<code>over-fitting</code>); 有时在训练模型的过程中, 通常还需要将数据集分出一部分用于验证评估模型的质量, 这部分数据集就称为验证集(<code>validation set</code>).</li><li>模型优化算法: 模型训练的过程, 其实就是对模型参数进行搜索, 从而最小化目标函数. 比如常用的梯度下降(<code>gradient descent</code>)算法, 在每个步骤中, 会对每个参数沿着目标函数减小的方向(对应的梯度是下降的)进行调整, 直到目标函数达到某个局部最小点或者全局最小点.</li></ul><p>按类别来说, 机器学习一般来说分为监督学习, 非监督学习和强化学习三种:</p><p align="center">    <img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ml_types.png"></p><ul><li>监督学习(<code>supervised-learning</code>)是指在一组特征(faeture, 输入)与标签(label, 输出)的情况下对特定输入特征进行预测的一类算法, 常见的有回归, 分类, 以及序列学习等.</li></ul><p align="center">    <img src="https://zh-v2.d2l.ai/_images/supervised-learning.svg"></p><ul><li><p>无监督学习(<code>unsupervised learning</code>), 与监督学习不同的是, 只有输入特征, 却没有一个可以参考的输出标签; 需要从这些数据中找出特定的关系, 挖掘数据内在的联系. 比如在没有标签信息的情况下, 如何把一堆图标分类成风景, 动物, 婴儿等; 找到较少的参数来描述数据中的线性关系, 从不同的数据中找到相关性. 常见的有聚类分析, 主成分分析, 以及概率图模型&#x2F;生成对抗网络等.</p></li><li><p>强化学习(<code>reinforcement learning</code>): 上述两种方法都采用的是预先获取到的经验数据来训练模型, 并没有从外部环境交互中获取数据, 因此是离线学习(<code>offline learning</code>).  与此不同的是, 强化学习中的<code>agent</code>会通过观察者(<code>observation</code>)不断与环境进行交互, 然后从中获得奖励<code>reward</code>, <code>agent</code>根据奖励来调整自己的执行动作<code>action</code>, 以输出一个更好的策略.这个过程会随着系统与外界环境交互持续进行. 强化学习是一个十分强大的通用性学习框架, 打败世界围棋冠军的<code>AlphaGo</code>就是基于强化学习开发的.</p></li></ul><h2 id="人工神经网络与深度学习"><a href="#人工神经网络与深度学习" class="headerlink" title="人工神经网络与深度学习"></a><strong>人工神经网络与深度学习</strong></h2><p>说到深度学习, 就不得不提人工神经网络(<code>Artificial Neural Network</code>), 因为正是有了前期人工神经网络的技术积累, 尤其是多层网络的训练算法-反向传播算法(<code>backpropagation</code>),才有了深度学习今天的广泛应用.</p><p>人工神经网络基本的单元-人工神经元(<code>neuron</code>)本质上是模拟大脑的神经元构建出来的, 一般由三个部分组成: 输入(<code>inputs</code>), 激活函数(<code>activation function</code>)以及输出(<code>outpus</code>), 写成数学表达式如下:</p><p>$$y &#x3D; \varphi(\sum_{i&#x3D;1}^{m} w(i) * x(i) + b)$$</p><p align="center">    <img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/artificial-neuron.jpg" width="500"></p><p>人工神经网络是在单个神经元的基础上做了扩展, 引入了一个隐藏层(<code>hidden layer</code>), 从而形成一个多层的结构, 这个就类似于人脑的神经网络了: 网络通过从数据中获取知识, 每个神经元的权重值保存了学习到的知识. 人工神经网络具有较强的拟合能力, 可以看作一个通用的函数逼近器(一个两层的神经网络可以逼近任意函数). </p><p align="center">    <img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/multiple_layers_ann.png" width="600"></p><p>深度学习(<code>Deep Learning</code>)是在人工神经网络的基础上发展而来, 只是在网络结构上引入了更多的隐藏层, 网络的结构也更为多样复杂. 常见的网络结构有前馈网络, 记忆网络以及图网络:</p><ul><li>前馈网络(<code>feedforward neural network</code>): 各个神经元属于不同的层, 每一层可以接收上一层的输出为输入, 并产生信号输出到下一层. 网络的第0层为输入层, 最后一层为输出, 其他层均为隐藏层. 常见的前馈网络有卷积神经网络(<code>Convolutional Neural Network</code>)</li><li>记忆网络: 记忆网络也称为反馈网络(<code>feedback network</code>), 网络中的神经元不但可以接收来自上一层神经元的信息, 也可以接收来自自身的信息; 记忆网络中的神经元具有记忆功能, 在不同时刻具有不同状态. 常见的记忆网络有循环神经网络(<code>Recurrent Neural Network</code>), Hopfiled网络, 波尔兹曼机(<code>boltzmann machine </code>)等.</li><li>图网络: 前馈网络和记忆网络的输入都可以表示为向量或向量序列,但在实际应用中, 如知识图谱, 社交网络, 分子(molecular)网络等都是图结构的数据, 这类数据网络需要用图网络来学表达. 在图网络中, 每个节点由一个或一组神经元构成, 节点之间的连接可以是有向的, 也可以是无向的, 每个节点可以接收来自相邻节点或者自身的信息. 常见的图网络有图卷积网络(<code>Graph Convolutional Network</code>), 图注意力网络(<code>Graph Attention Network</code>)等.</li></ul><p align="center">    <img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/nn_types.png" width="600"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>深度学习从概念的出现到今天的大规模应用, 也不过20来年的历史, 但已经在图像识别, 语音识别, 自然语言处理等各个方面都取得了令人惊讶的成绩, 基于深度学习的AI模型不仅可以准确识别图像, 也可以在围棋上战胜人类冠军; 可以与人展开对话, 也可以执行自动驾驶的功能. 未来, 随着大数据与AI技术的发展, 深度学习会在更多的行业与领域得到更广泛的应用. 近年来, 基于多个机器学习模型的多模态技术(<code>multimodal machine learning</code>)的逐渐发展, 在很多领域都取得了不错的成果. 相信在不久的将来, 无论是手机终端, 还是汽车&#x2F;飞机都会有深度学习的身影, 在人类生活的各个方面都发挥至关重要的作用.未来会是一个基于大数据的智能化时代-一个大数据与深度学习等人工智能技术紧密结合的智能化时代.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://en.wikipedia.org/wiki/History_of_artificial_intelligence">AI的历史</a></li><li><a href="http://deeplearning.cs.cmu.edu/F21/index.html">CMU深度学习课程, 值得收藏学习</a></li><li><a href="https://en.wikipedia.org/wiki/Deep_learning">https://en.wikipedia.org/wiki/Deep_learning</a></li><li><a href="https://zh-v2.d2l.ai/chapter_introduction/index.html">动手学习深度学习, 实践与理论结合, 非常好的开源书籍</a></li><li><a href="http://neuralnetworksanddeeplearning.com/">国外大牛写的开源书籍</a></li><li><a href="https://nndl.github.io/">神经网络与深度学习, 国内大牛的开源书籍</a></li><li><a href="https://towardsdatascience.com/the-past-present-and-future-of-deep-learning-adb4d60eaf24">简要介绍深度学习的历史</a></li><li><a href="https://github.com/microsoft/ML-For-Beginners">微软开发的一个机器学习入门课程, 值得学习</a></li><li><a href="https://www.tensorflow.org/guide/basics">Tensorflow官网</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;深度学习(&lt;code&gt;Deep Learning&lt;/code&gt;)是近年来人工智能的热门研究领域, 广泛地应用在工业与商业领域, 如计算机视觉(&lt;code&gt;Computer Vision&lt;/code&gt;), 语音识别(&lt;code&gt;Speech Recognition&lt;/code&gt;), 自然语言处理(&lt;code&gt;Natural Language Processing&lt;/code&gt;), 机器翻译(&lt;code&gt;Machine Translation&lt;/code&gt;), 以及医学图像分析, 药物发现等领域都采用了深度学习方法. 从本质上来说, 深度学习属于机器学习(&lt;code&gt;Machine Learning&lt;/code&gt;)的一个分支, 是一种从大规模数据进行学习然后能在新数据集进行推理泛化的数学模型.&lt;/p&gt;
&lt;p&gt;相比人工智能, 深度学习只是最近十来年才出现的概念, 但为何会在在最近几年(2010开始)内出现井喷式的增长, 成为人工智能领域炙手可热的研究方向了? 总结来说主要有如下几个原因:&lt;/p&gt;</summary>
    
    
    
    <category term="人工智能" scheme="https://sniffer.site/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="人工智能" scheme="https://sniffer.site/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="机器学习" scheme="https://sniffer.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://sniffer.site/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Deep Learning" scheme="https://sniffer.site/tags/Deep-Learning/"/>
    
    <category term="Machine Learning" scheme="https://sniffer.site/tags/Machine-Learning/"/>
    
    <category term="AI" scheme="https://sniffer.site/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>感悟2021</title>
    <link href="https://sniffer.site/2021/12/31/%E6%84%9F%E6%82%9F2021/"/>
    <id>https://sniffer.site/2021/12/31/%E6%84%9F%E6%82%9F2021/</id>
    <published>2021-12-31T10:06:49.000Z</published>
    <updated>2022-02-28T10:27:54.750Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>天之道, 利而不害; 圣人之道, 为而不争</p><p>老子</p></blockquote><p><img src="https://images.unsplash.com/photo-1526772662000-3f88f10405ff?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1074&q=80" alt="A Thinking Man"></p><span id="more"></span><p>到了年终时刻, 面对新年的来临, 总免不了回想过去365天所发生的一些事情, 脑海里重放经历过的点点滴滴. 过去一年, 有成长, 有失落; 有痛苦, 有欢乐. 看了年初立下的flag, 有些实现了, 有些还没有, 总的说来差强人意.  感概, 领悟, 波折起伏之后方才懂得人生哪些事情是重要的, 需要用心用气力去呵护与完善; 哪些是不重要的, 不足挂齿, 发生了依然可以云淡风轻.</p><ul><li>2021年女儿两岁了,  变成了一个调皮捣蛋的小可爱, 每天都会粑粑粑粑的叫个不停. 女儿的成长让我这个缺乏耐心, 时不时发脾气的父亲变得更温和, 更有责任心与同理心, 也是我每天进步的动力.</li><li>工作上, 今年开始有所沉淀, 遇到什么问题都会深究与总结, 一年下来也写了快10篇博客; 下半年开始了解深度学习, 算摸到了机器学习的门, 这个也会是后面重点投入的方向.</li><li>由于公司开始了双休制度, 得以有时间开始锻炼身体, 周末打几个小时的羽毛球, 着实收获良多, 不仅人的精力更好, 精神状态也改善了不少.</li><li>看了不少书,  技术的有, 哲学的也有, 思维方式的也有, 有数量, 但是不够系统. 印象比较深刻的是混沌大学李善友的&lt;第一性原理&gt;与&lt;第二曲线创新&gt;, 吴军的&lt;智能时代-大数据智能革命&gt;以及日本哲学家饮茶写的&lt;了不起的哲学家&gt;. 希望今年能够开始系统性的学习研究某些方向, 争取有所输出, 而不是单纯的阅读.</li></ul><p>再细细想想, 2021年有几个感悟值得写下来, 共勉.</p><h2 id="从现实出发-与生活和解"><a href="#从现实出发-与生活和解" class="headerlink" title="从现实出发, 与生活和解"></a>从现实出发, 与生活和解</h2><p>现代人的生活繁忙而带着些许焦虑, 一周大部分时间都在忙着工作, 很少会有足够的时间静下来思考生活, 思考人生. 从小到大, 我们都被教育要争第一, 可是没有人告诉我们, 得到第一之后应该怎么做. 我们都在围绕着得到而努力, 为了获取而挣扎. 儿时, 如果得不到一个想要的玩具, 我们会伤心痛哭, 汪汪的流泪；长大后, 我们会为了金钱, 职称;大的房子, 好的车子不断奋斗, 一旦得不到就会难过痛苦. 在内心深处, 我们只是把财富&#x2F;功名&#x2F;车子&#x2F;房子这些外在的东西内化成了自己儿时的<code>玩具</code>, 把它们当成了自己的一部分, 所以没有得到或者失去这些东西会让我们伤心. 但, 我们却从来没有问自己, 得到这些外在的东西之后, 会怎么样? 应该怎么样?</p><p>换个角度, 如果我们把这些外在的物质与内心的真正需求切割开来, 会如何? 归根结底, 内心的富足与幸福跟这些外在的玩具没有什么必然的联系, 只是在成长过程中, 社会把这些价值观念在潜移默化中烙印在我们的心灵上, 而我们也不假思索的予以接纳罢了. 我们一直在向外需求幸福与快乐, 却得到的总是失落与痛苦, 而实际能让我们获得安宁与富足的是内心的强大与开放.</p><p>向内求而不是向外求. 这才是生活与快乐与幸福的源泉. 向外求, 依靠外在的财富与名利不断来达成人生的目标与自我价值的认可, 是一条失去自我的不归路-有钱了, 才会觉得安全, 一旦失去财富可能会让你难过痛苦; 有了各种名号, 才觉得被认可与尊重, 一旦得不到就失落而难以自处; 有了10万, 我们希望有100万, 有了一个房子, 我们希望有一个别墅. 这种无止境的追求外在的物质财富, 是让我们迷失自我, 丧失个人价值与幸福的根源. 我们已经忘了, 人生到头, 名利财富终究是一场空. 那些我们绞尽脑汁,日夜寻思的东西其实都是让我们失去自我的魔鬼. 佛教在很早之前就道出了这些真理, 所谓<code>色即是空, 空即是色</code>. 形形色色的物欲不但偷走了我们的时间精力, 也让我们丧失了内心的安宁. </p><p>但毕竟我们每个人都有无法从现实脱身的理由-有妻儿, 有父母, 有兄弟姐妹, 有朋友, 我们也很难做到像释迦牟尼一样从一个王子变成一个追寻信仰的修道者, 成为宗教领袖. 我们都是凡人, 都有凡身. 但依然, 我们可以选择, 在纷繁复杂的世界里, 我们依然可以有所作为. 基于现实, 向内求, 不要纠结一时的得失, 不要纠结名利, 要从更长远的角度来看待人生与生命的价值&#x2F;意义, 要与生活的一切和解, 理解, 包容, 温和, 有度, 在混沌中寻求内心的富足与安宁.</p><h2 id="享受成长的痛苦"><a href="#享受成长的痛苦" class="headerlink" title="享受成长的痛苦"></a>享受成长的痛苦</h2><p>向外求, 其实是容易的; 向内求更难. 向内求, 需要我们去感知内心, 尝试理解自己头脑中思维模式, 尝试找到一切困惑与苦恼的源头. 这种探索与寻求并不容易. 历史上的各路牛人, 释迦牟尼, 老子, 耶稣, 尼采; 牛顿, 爱因斯坦等在用不同的方式追问人生与宇宙的奥秘, 而天资平平的我们要依靠什么去追问内心的答案, 得到人生的真谛.</p><p>这注定是一条艰难的路. 思维与认知的转变好像总是伴随痛苦, 就好像母亲孕育一个新生命一样-十月怀胎, 呕吐难受, 没有几天踏实安静的日子; 等到要生产时, 几乎要将一个母亲脱胎换骨, 一个生命才会真正诞生. 一个人的成长其实是类似的,  若非有苦痛, 可能就像是温水里的青蛙, 自我感觉良好, 没有危机感, 感知不到外界的变化, 实际上只是在原地踏步, 并没有任何的长进. 真正的成长, 是认知冲突后带来的思维方式的变化, 总会伴随着阵痛与挣扎. 而要想获得突破, 我们也要适应这种内心的冲突, 不断的挑战与调整已有的认知, 保持好奇心, 主动去寻求与探索现有的边界.</p><p>那么, 对于个人来说, 如何做到拓展认知与思维的界限? 以个人经验来说, 大致有如下几个方法:</p><ul><li>建立系统性的思维框架: 不管是了解一个陌生还是一个熟悉的领域, 建立一套有效可行的思维框架都至关重要, 这也是初学者与专家的重要区别. 有了思维框架, 可以让我们对一个领域会有更深入全面的理解, 也为我们探索新的知识领域提供夯实的基础.</li><li>阅读, 多读经典: 所谓开卷有益, 养成阅读尤其是经典好书的习惯, 让大脑处于一个放空的模式-接收未曾了解过的新思路, 新方法. 有时, 即使是随便翻翻书, 也可能会有不一样的收获.</li><li>要有意识的进行输出: 如果没有将阅读与思考进行输出, 我们可能很难清晰的看到自己内心真正的想法是什么样子. 输出不仅是重新厘清大脑中认知的模糊地带, 也有助于建立自己的知识体系.</li><li>锻炼身体与磨砺心智一样重要: 虽然在哲学上, 关于心灵与肉体的统一尚有争论, 但无可否认, 一个健康的身体有利于大脑的良好运转, 让大脑处于一个更高效&#x2F;更有活力的状态. 不要忽略你的身体, 节制的饮食, 定时的锻炼都能帮助大脑运转的更好(大脑是否等同于心灵了, 暂且不论).</li></ul><p>2021已经成为永恒记忆的一部分了-一切过往,皆为序章. 2022, 你好.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;天之道, 利而不害; 圣人之道, 为而不争&lt;/p&gt;
&lt;p&gt;老子&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1526772662000-3f88f10405ff?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1074&amp;q=80&quot; alt=&quot;A Thinking Man&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="https://sniffer.site/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="成长" scheme="https://sniffer.site/tags/%E6%88%90%E9%95%BF/"/>
    
    <category term="个人总结" scheme="https://sniffer.site/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>理解Android eBPF</title>
    <link href="https://sniffer.site/2021/11/26/%E7%90%86%E8%A7%A3Android-eBPF/"/>
    <id>https://sniffer.site/2021/11/26/%E7%90%86%E8%A7%A3Android-eBPF/</id>
    <published>2021-11-26T07:34:45.000Z</published>
    <updated>2023-02-08T06:26:58.533Z</updated>
    
    <content type="html"><![CDATA[<p>Android从9.0版本开始全面支持eBPF(<code>extended Berkeley Packet Filters</code>), 其主要用在流量统计上, 也可以用来监控CPU&#x2F;IO&#x2F;内存等模块的状态.简单来说, <code>eBPF</code>可以与内核的<code>kprobe</code>&#x2F;<code>tracepoints</code>&#x2F;<code>skfilter</code>等模块相结合, 将eBPF的函数hook到内核事件从而监控相应的系统状态.</p><p>Android为eBPF提供了许多封装的库, 并提供了eBPF加载器<code>bpfloader</code>:</p><ul><li><code>bpfloader</code>: 位于<code>/system/bpf/bpfloader</code>, 系统启动时负责加载位于<code>/system/etc/bpf</code> 中的eBPF目标文件</li><li><code>libbpf_android</code>: 位于<code>/system/bpf/libbpf_android</code>提供创建bpf容器&#x2F;加载bpf目标文件的接口</li><li><code>libbpf</code>: 位于<code>/external/bcc</code>, 封装了bpf的系统调用, 提供如attach&#x2F;dettach程序的接口</li><li><code>libnetdbpf</code>: 位于<code>/system/netd/libnetdbpf</code>, 实现了netd流量统计功能的函数</li></ul><p>目前在Android(Q)上有两处eBPF的代码: 一个是<code>/system/netd/bpf_progs/netd.c</code>, 主要是用于流量统计；一个是<code>/system/bpfprogs/time_in_state.c</code>用于监控CPU运行频率以及上下文切换的耗时.</p><p>接下来我们就从三个部分来深入理解下Android是如何利用eBPF的:</p><ul><li>eBPF程序与目标文件格式</li><li>Android eBPF加载与执行流程</li><li>Android如何基于eBPF实现流量统计</li></ul><span id="more"></span><blockquote><p>有关BPF的介绍可以参考之前的文章<a href="https://sniffer.site/2019/11/07/bpf%E4%B8%8Eebpf/">BPF与eBPF</a></p></blockquote><h2 id="eBPF程序与目标文件的格式"><a href="#eBPF程序与目标文件的格式" class="headerlink" title="eBPF程序与目标文件的格式"></a><strong>eBPF程序与目标文件的格式</strong></h2><p>在Android中, 一个eBPF的c程序格式通常如下, 总的说来分为三个部分:</p><ul><li>通过<code>DEFINE_BPF_MAP</code>定义BPF数据容器的类型以及访问接口</li><li>声明代码段, 比如<code>SEC(&quot;cgroupsock/inet/create&quot;)</code></li><li>声明BPF段的证书类型,  一般是<code>GPL</code>或者跟GPL兼容的证书类型（如果要使用内核的某些辅助函数，如<code>bpf_trace_printk</code>的话一定要使用<code>GPL</code>证书，否则无正常加载）</li></ul><blockquote><p>看内核代码, 对于大部分的BPF容器类型可以是<code>GPL</code>的, 也可以是其他证书, 但对于<code>stackmap.c</code>则要求只能是<code>GPL</code>的.但如果要使用某些函数，如<code>bpf_perf_event_read</code>&#x2F;<code>bpf_trace_printk</code>则要求使用GPL，否则会验证不过，无法加载，具体可以参考<code>bpf_trace.c</code>, 有关辅助函数可以参考<a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">bpf-helpers</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf_helpers.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define one or more maps in the maps section, for example</span></span><br><span class="line"><span class="comment"> * define a map of type array int -&gt; uint32_t, with 10 entries</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DEFINE_BPF_MAP(name_of_my_map, ARRAY, <span class="type">int</span>, <span class="type">uint32_t</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* this will also define type-safe accessors:</span></span><br><span class="line"><span class="comment"> *   value * bpf_name_of_my_map_lookup_elem(&amp;key);</span></span><br><span class="line"><span class="comment"> *   int bpf_name_of_my_map_update_elem(&amp;key, &amp;value, flags);</span></span><br><span class="line"><span class="comment"> *   int bpf_name_of_my_map_delete_elem(&amp;key);</span></span><br><span class="line"><span class="comment"> * as such it is heavily suggested to use lowercase *_map names.</span></span><br><span class="line"><span class="comment"> * Also note that due to compiler deficiencies you cannot use a type</span></span><br><span class="line"><span class="comment"> * of &#x27;struct foo&#x27; but must instead use just &#x27;foo&#x27;.  As such structs</span></span><br><span class="line"><span class="comment"> * must not be defined as &#x27;struct foo &#123;&#125;&#x27; and must instead be</span></span><br><span class="line"><span class="comment"> * &#x27;typedef struct &#123;&#125; foo&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;PROGTYPE/PROGNAME&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">PROGFUNC</span><span class="params">(..args..)</span> &#123;</span><br><span class="line">   &lt;body-of-code</span><br><span class="line">    ... read or write to MY_MAPNAME</span><br><span class="line">    ... <span class="keyword">do</span> other things</span><br><span class="line">   &gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> _license[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>; <span class="comment">// or other license</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码中<code>PROGFUNC</code>定义了一个函数, 编译后会生成一个<code>PROGTYPE/PROGNAME</code>的段(section), 其中<code>PROGTYPE</code>是<code>eBPF</code>代码类型, (对Android来说)必须是下表中的名字:</p><table><thead><tr><th>事件类型</th><th>BPF代码类型</th><th>说明</th></tr></thead><tbody><tr><td>kprobe</td><td>BPF_PROG_TYPE_KPROBE</td><td>将ePBF函数hook到kprope上以探测内核事件, PROGNAME必须是内核中被kprobe监控的函数名</td></tr><tr><td>tracepoint</td><td>BPF_PROG_TYPE_TRACEPOINT</td><td>将eBPF函数hook到tracepoint事件上, PROGNAME必须是<code>SUBSYSTEM/EVENT</code>的格式, 例如用于监控上下文切换的段可以写成<code>SEC(tracepoint/sched/sched_switch</code>, 具体可以参考&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#96;下面各个系统事件名</td></tr><tr><td>skfilter</td><td>BPF_PROG_TYPE_SOCKET_FILTER</td><td>将eBPF函数当作一个netfilter模块执行, 参考内核代码<code>xt_bpf.c</code></td></tr><tr><td>schedcls</td><td>BPF_PROG_TYPE_SCHED_CLS</td><td>将eBPF函数当作一个网络数据包的分类器(classifier), 参考内核代码<code>cls_bpf.c</code></td></tr><tr><td>cgroupskb&#x2F;cgroupsock</td><td>BPF_PROG_TYPE_CGROUP_SKB&#x2F;BPF_PROG_TYPE_CGROUP_SOCK</td><td>每当指定的cgroup上有数据传输(SKB); 创建<code>AF_INET/AF_INET6</code>的socket(SOCK)时就执行eBPF函数 ,参考<code>bpf-cgroup.h </code>&#x2F;<code>bpf/cgroup.c</code></td></tr></tbody></table><p>每个eBPF c语言程序都会通过LLVM编译成ELF(<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"><code>Executable-Link Format</code></a>目标文件, 我们可以通过linux中的<code>readelf</code>&#x2F;<code>objdump</code>工具来查看ELF文件. 比如利用<code>readelf -S netd.o</code>查看<code>netd.o</code>的段头信息, 从这里可以看到<code>netd.c</code>中定义的各个段:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/netdo_elf_sh.png" alt="netd.o sections"></p><h2 id="Android中eBPF加载流程"><a href="#Android中eBPF加载流程" class="headerlink" title="Android中eBPF加载流程"></a><strong>Android中eBPF加载流程</strong></h2><p>在系统启动阶段, Android会把位于<code>/system/etc/bpf/</code>的eBPF目标文件通过<code>bpfloader</code>这个服务加载到内核:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">service bpfloader /system/bin/bpfloader</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">capabilities</span> <span class="title">SYS_ADMIN</span></span></span><br><span class="line"><span class="class">    # <span class="title">Set</span> <span class="title">RLIMIT_MEMLOCK</span> <span class="title">to</span> 64<span class="title">MB</span> <span class="title">for</span> <span class="title">bpfloader</span></span></span><br><span class="line"><span class="class">    # <span class="title">Actually</span> <span class="title">only</span> 8<span class="title">MB</span> <span class="title">is</span> <span class="title">needed</span>, <span class="title">but</span> <span class="title">since</span> <span class="title">bpfloader</span> <span class="title">runs</span> <span class="title">as</span> <span class="title">root</span>, <span class="title">it</span> <span class="title">shares</span></span></span><br><span class="line"><span class="class">    # <span class="title">the</span> <span class="title">global</span> <span class="title">rlimit</span>. <span class="title">Once</span> <span class="title">bpfloader</span> <span class="title">is</span> <span class="title">running</span> <span class="title">as</span> <span class="title">its</span> <span class="title">own</span> <span class="title">user</span> <span class="title">in</span> <span class="title">the</span></span></span><br><span class="line"><span class="class">    # <span class="title">future</span>, <span class="title">it</span> <span class="title">will</span> <span class="title">have</span> <span class="title">dedicated</span> <span class="title">rlimit</span> <span class="title">to</span> <span class="title">itself</span> <span class="title">and</span> <span class="title">this</span> <span class="title">can</span> <span class="title">be</span> 8<span class="title">MB</span>.</span></span><br><span class="line"><span class="class">    <span class="title">rlimit</span> <span class="title">memlock</span> 67108864 67108864</span></span><br><span class="line"><span class="class">    <span class="title">oneshot</span></span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure><p>进入<code>BpfLoader.cpp</code>看下<code>main</code>函数, 实际是调用<code>loadAllElfObjects</code>加载各个ELF文件: 读取<code>/system/etc/bpf/</code>下面所有<code>.o</code>结束的文件, 然后加载到内核.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_PROG_PATH <span class="string">&quot;/system/etc/bpf/&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loadAllElfObjects</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    DIR* dir;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((dir = opendir(BPF_PROG_PATH)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> ((ent = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">string</span> s = ent-&gt;d_name;</span><br><span class="line">    <span class="keyword">if</span> (!EndsWith(s, <span class="string">&quot;.o&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> progPath = BPF_PROG_PATH + s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = android::bpf::loadProg(progPath.c_str());</span><br><span class="line">    ALOGI(<span class="string">&quot;Attempted load object: %s, ret: %s&quot;</span>, progPath.c_str(), <span class="built_in">std</span>::strerror(-ret));</span><br><span class="line">&#125;</span><br><span class="line">closedir(dir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数<code>loadProg</code>根据eBPF目标文件中的段创建容器类型, 并加载代码到内核:</p><ul><li>首先检查是否存在证书的段(<code>section</code>)</li><li><code>readCodeSections</code>:读取ELF文件中段信息, 生成代码段<code>CodeSection</code>的列表</li><li><code>createMaps</code>: 根据ELF目标文件中的<code>maps</code>段信息创建对应的容器对象</li><li><code>applyMapRelo</code>: 看代码应该是对BPF中的指令进行重定位(如何进行重定位?)</li><li><code>loadCodeSections</code>: 加载目标文件到内核, 并将加载后的fd固定到特定的路径</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">loadProg</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* elfPath)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; license;</span><br><span class="line">    <span class="built_in">vector</span>&lt;codeSection&gt; cs;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; mapFds;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ifstream <span class="title function_">elfFile</span><span class="params">(elfPath, ios::in | ios::binary)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!elfFile.is_open()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    ret = readSectionByName(<span class="string">&quot;license&quot;</span>, elfFile, license);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">       ALOGE(<span class="string">&quot;Couldn&#x27;t find license in %s\n&quot;</span>, elfPath);</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ALOGD(<span class="string">&quot;Loading ELF object %s with license %s\n&quot;</span>, elfPath, (<span class="type">char</span>*)license.data());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = readCodeSections(elfFile, cs);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">       ALOGE(<span class="string">&quot;Couldn&#x27;t read all code sections in %s\n&quot;</span>, elfPath);</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Just for future debugging */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) dumpAllCs(cs);</span><br><span class="line"></span><br><span class="line">    ret = createMaps(elfPath, elfFile, mapFds);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">       ALOGE(<span class="string">&quot;Failed to create maps: (ret=%d) in %s\n&quot;</span>, ret, elfPath);</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)mapFds.size(); i++)</span><br><span class="line">       ALOGD(<span class="string">&quot;map_fd found at %d is %d in %s\n&quot;</span>, i, mapFds[i], elfPath);</span><br><span class="line"></span><br><span class="line">    applyMapRelo(elfFile, mapFds, cs);</span><br><span class="line"></span><br><span class="line">    ret = loadCodeSections(elfPath, cs, <span class="built_in">string</span>(license.data()));</span><br><span class="line">    <span class="keyword">if</span> (ret) ALOGE(<span class="string">&quot;Failed to load programs, loadCodeSections ret=%d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面就分别来看下其中的几个关键步骤.</p><h3 id="生成代码段-创建map"><a href="#生成代码段-创建map" class="headerlink" title="生成代码段,创建map"></a><strong>生成代码段,创建map</strong></h3><p>函数<code>readCodeSections</code>读取ELF目标文件中的段头信息, 获取到每个BPF段的代码类型, 常见的有<code>BPF_PROG_TYPE_KPROBE</code>, <code>BPF_PROG_TYPE_SOCKET_FILTER</code>等(见上述表中的说明). 接着查看该段是否需要进行重定位.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">readCodeSections</span><span class="params">(ifstream&amp; elfFile, <span class="built_in">vector</span>&lt;codeSection&gt;&amp; cs)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Elf64_Shdr&gt; shTable;</span><br><span class="line">    <span class="type">int</span> entries, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = readSectionHeadersAll(elfFile, shTable);</span><br><span class="line">    <span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line">    entries = shTable.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; entries; i++) &#123;</span><br><span class="line">       <span class="built_in">string</span> name;</span><br><span class="line">       codeSection cs_temp;</span><br><span class="line">       cs_temp.type = BPF_PROG_TYPE_UNSPEC;</span><br><span class="line"></span><br><span class="line">       ret = getSymName(elfFile, shTable[i].sh_name, name);</span><br><span class="line">       <span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">       <span class="class"><span class="keyword">enum</span> <span class="title">bpf_prog_type</span> <span class="title">ptype</span> =</span> getSectionType(name);</span><br><span class="line">       <span class="keyword">if</span> (ptype != BPF_PROG_TYPE_UNSPEC) &#123;</span><br><span class="line">           deslash(name);</span><br><span class="line">           cs_temp.type = ptype;</span><br><span class="line">           cs_temp.name = name;</span><br><span class="line"></span><br><span class="line">           ret = readSectionByIdx(elfFile, i, cs_temp.data);</span><br><span class="line">           <span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line">           ALOGD(<span class="string">&quot;Loaded code section %d (%s)\n&quot;</span>, i, name.c_str());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Check for rel section */</span></span><br><span class="line">       <span class="keyword">if</span> (cs_temp.data.size() &gt; <span class="number">0</span> &amp;&amp; i &lt; entries) &#123;</span><br><span class="line">           ret = getSymName(elfFile, shTable[i + <span class="number">1</span>].sh_name, name);</span><br><span class="line">           <span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (isRelSection(cs_temp, name)) &#123;</span><br><span class="line">               ret = readSectionByIdx(elfFile, i + <span class="number">1</span>, cs_temp.rel_data);</span><br><span class="line">               <span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line">               ALOGD(<span class="string">&quot;Loaded relo section %d (%s)\n&quot;</span>, i, name.c_str());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (cs_temp.data.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           cs.push_back(cs_temp);</span><br><span class="line">           ALOGD(<span class="string">&quot;Adding section %d to cs list\n&quot;</span>, i);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着根据<code>CodeSection</code>列表创建内核的map对象(用于保存内核事件结果, 常见的有<code>arraymap</code>, <code>hashmap</code>等几种类型):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">createMaps</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* elfPath, ifstream&amp; elfFile, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; mapFds)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret, fd;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; mdData;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_def</span>&gt;</span> md;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; mapNames;</span><br><span class="line">    <span class="built_in">string</span> fname = pathToFilename(<span class="built_in">string</span>(elfPath), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    ret = readSectionByName(<span class="string">&quot;maps&quot;</span>, elfFile, mdData);</span><br><span class="line">    <span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line">    md.resize(mdData.size() / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bpf_map_def));</span><br><span class="line">    <span class="built_in">memcpy</span>(md.data(), mdData.data(), mdData.size());</span><br><span class="line"></span><br><span class="line">    ret = getMapNames(elfFile, mapNames);</span><br><span class="line">    <span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    mapFds.resize(mapNames.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)mapNames.size(); i++) &#123;</span><br><span class="line">       <span class="comment">// Format of pin location is /sys/fs/bpf/map_&lt;filename&gt;_&lt;mapname&gt;</span></span><br><span class="line">       <span class="built_in">string</span> mapPinLoc;</span><br><span class="line">       <span class="type">bool</span> reuse = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       mapPinLoc = <span class="built_in">string</span>(BPF_FS_PATH) + <span class="string">&quot;map_&quot;</span> + fname + <span class="string">&quot;_&quot;</span> + <span class="built_in">string</span>(mapNames[i]);</span><br><span class="line">       <span class="keyword">if</span> (access(mapPinLoc.c_str(), F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">           fd = bpf_obj_get(mapPinLoc.c_str());</span><br><span class="line">           ALOGD(<span class="string">&quot;bpf_create_map reusing map %s, ret: %d\n&quot;</span>, mapNames[i].c_str(), fd);</span><br><span class="line">           reuse = <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           fd = bpf_create_map(md[i].type, mapNames[i].c_str(), md[i].key_size, md[i].value_size,</span><br><span class="line">                               md[i].max_entries, md[i].map_flags);</span><br><span class="line">           ALOGD(<span class="string">&quot;bpf_create_map name %s, ret: %d\n&quot;</span>, mapNames[i].c_str(), fd);</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!reuse) &#123;</span><br><span class="line">           ret = bpf_obj_pin(fd, mapPinLoc.c_str());</span><br><span class="line">           <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mapFds[i] = fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了避免map对象在<code>bpfloader</code>服务退出之后被销毁, 最后都会通过<code>bpf_obj_pin</code>把这些对象固定到<code>/sys/fs/bpf</code>文件节点.</p><h3 id="加载代码到内核"><a href="#加载代码到内核" class="headerlink" title="加载代码到内核"></a><strong>加载代码到内核</strong></h3><p>要监听到内核事件, eBPF的ELF目标文件首先需要加载到内核, 然后在内核发生对应事件后触发对应的eBPF代码逻辑(内核的bpf虚拟机在执行代码之前会对目标文件代码进行校验, 以确保代码没有死循环等逻辑错误). </p><ul><li><code>bpf_prog_load</code>: 加载bpf程序到内核</li><li><code>bpf_obj_pin</code>: 将bpf程序固定到<code>/sys/fs/bpf</code>文件节点, 确保服务退出后, bpf程序依然可以正常执行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">loadCodeSections</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* elfPath, <span class="built_in">vector</span>&lt;codeSection&gt;&amp; cs, <span class="type">const</span> <span class="built_in">string</span>&amp; license)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret, fd, kvers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((kvers = getMachineKvers()) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> fname = pathToFilename(<span class="built_in">string</span>(elfPath), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)cs.size(); i++) &#123;</span><br><span class="line">       <span class="built_in">string</span> progPinLoc;</span><br><span class="line">       <span class="type">bool</span> reuse = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Format of pin location is</span></span><br><span class="line">       <span class="comment">// /sys/fs/bpf/prog_&lt;filename&gt;_&lt;mapname&gt;</span></span><br><span class="line">       progPinLoc = <span class="built_in">string</span>(BPF_FS_PATH) + <span class="string">&quot;prog_&quot;</span> + fname + <span class="string">&quot;_&quot;</span> + cs[i].name;</span><br><span class="line">       <span class="keyword">if</span> (access(progPinLoc.c_str(), F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">           fd = bpf_obj_get(progPinLoc.c_str());</span><br><span class="line">           ALOGD(<span class="string">&quot;New bpf prog load reusing prog %s, ret: %d\n&quot;</span>, cs[i].name.c_str(), fd);</span><br><span class="line">           reuse = <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; log_buf(BPF_LOAD_LOG_SZ, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">           fd = bpf_prog_load(cs[i].type, cs[i].name.c_str(), (<span class="keyword">struct</span> bpf_insn*)cs[i].data.data(), cs[i].data.size(), license.c_str(), kvers, <span class="number">0</span>, log_buf.data(), log_buf.size());</span><br><span class="line">           ALOGD(<span class="string">&quot;New bpf core prog_load for %s (%s) returned: %d\n&quot;</span>, elfPath, cs[i].name.c_str(),fd);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (fd &lt;= <span class="number">0</span>)</span><br><span class="line">               ALOGE(<span class="string">&quot;bpf_prog_load: log_buf contents: %s\n&quot;</span>, (<span class="type">char</span> *)log_buf.data());</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!reuse) &#123;</span><br><span class="line">           ret = bpf_obj_pin(fd, progPinLoc.c_str());</span><br><span class="line">           <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       cs[i].prog_fd = fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这一步, eBPF完成了初始化, 目标文件也load到了内核, 此时只要内核有相应事件发生, 都会把结果保存到对应的map对象中. 用户进程只需要通过bpf的系统调用<code>BPF_MAP_LOOKUP_ELEM</code>等指令获取map对象中的数据.</p><h2 id="Android如何使用eBPF统计流量"><a href="#Android如何使用eBPF统计流量" class="headerlink" title="Android如何使用eBPF统计流量"></a><strong>Android如何使用eBPF统计流量</strong></h2><p>Android系统支持多种粒度的流量统计, 比如统计每个网卡的流量, 每个用户使用的流量, 有关Android流量统计的细节可以参考之前的博文<a href="https://sniffer.site/2020/04/01/%E8%AF%B4%E8%AF%B4android%E4%B8%AD%E7%9A%84%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1/">Android是如何实现流量统计的</a>. 这里我们主要看下如何基于eBPF来实现对网卡以及每个用户的流量统计.</p><p>Android中有一个<code>netd</code>进程负责网络管理, 流量统计等功能, 在启动的时候会初始化一个<code>TrafficController</code>的类, 这个类就是负责流量统计功能的, 其在初始化的时候会创建几个<code>BpfMap</code>(实际是一个key-value的容器模板)对象, 用于保存不同流量统计的结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TrafficController::initMaps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">guard</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(mAppUidStatsMap.<span class="built_in">init</span>(APP_UID_STATS_MAP_PATH));</span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(<span class="built_in">changeOwnerAndMode</span>(APP_UID_STATS_MAP_PATH, AID_NET_BW_STATS, <span class="string">&quot;AppUidStatsMap&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(mStatsMapA.<span class="built_in">init</span>(STATS_MAP_A_PATH));</span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(<span class="built_in">changeOwnerAndMode</span>(STATS_MAP_A_PATH, AID_NET_BW_STATS, <span class="string">&quot;StatsMapA&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(mStatsMapB.<span class="built_in">init</span>(STATS_MAP_B_PATH));</span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(<span class="built_in">changeOwnerAndMode</span>(STATS_MAP_B_PATH, AID_NET_BW_STATS, <span class="string">&quot;StatsMapB&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(mIfaceIndexNameMap.<span class="built_in">init</span>(IFACE_INDEX_NAME_MAP_PATH);</span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(<span class="built_in">changeOwnerAndMode</span>(IFACE_INDEX_NAME_MAP_PATH, AID_NET_BW_STATS,<span class="string">&quot;IfaceIndexNameMap&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(mIfaceStatsMap.<span class="built_in">init</span>(IFACE_STATS_MAP_PATH));</span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(<span class="built_in">changeOwnerAndMode</span>(IFACE_STATS_MAP_PATH, AID_NET_BW_STATS, <span class="string">&quot;IfaceStatsMap&quot;</span>,<span class="literal">false</span>));</span><br><span class="line">       ...</span><br><span class="line">    <span class="keyword">return</span> netdutils::status::ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看<code>BpfMap</code>模板(在<code>BpfMap.h</code>中定义)中的<code>init</code>函数可以知道, <code>mAppUidStatsMap.init/mIfaceStatsMap.init</code>实际是获取到固定在<code>/sys/fs/bpf</code>目录下的各个map对象节点文件描述符, 然后就可以通过该描述符来操作对应的map对象了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">netdutils::Status BpfMap&lt;Key, Value&gt;::<span class="built_in">init</span>(<span class="type">const</span> <span class="type">char</span>* path) &#123;</span><br><span class="line">    mMapFd = base::<span class="built_in">unique_fd</span>(<span class="built_in">mapRetrieve</span>(path, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (mMapFd == <span class="number">-1</span>) &#123;</span><br><span class="line">       <span class="built_in">reset</span>();</span><br><span class="line">       <span class="keyword">return</span> netdutils::<span class="built_in">statusFromErrno</span>(</span><br><span class="line">               errno,</span><br><span class="line">               base::<span class="built_in">StringPrintf</span>(<span class="string">&quot;pinned map not accessible or does not exist: (%s)\n&quot;</span>, path));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> netdutils::status::ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于<code>cgroupskb</code>类型的bpf程序, 还需要通过<code>BPF_PROG_ATTACH</code>命令把固定到<code>/sys/fs/bpf</code>的代码附着到对应的cgroup上(这样我们就可以监控特定cgroup上的进程的网络状态了):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Status <span class="title">initPrograms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string cg2_path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CgroupGetControllerPath</span>(CGROUPV2_CONTROLLER_NAME, &amp;cg2_path)) &#123;</span><br><span class="line">       <span class="type">int</span> ret = errno;</span><br><span class="line">       <span class="built_in">ALOGE</span>(<span class="string">&quot;Failed to find cgroup v2 root&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">statusFromErrno</span>(ret, <span class="string">&quot;Failed to find cgroup v2 root&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">unique_fd <span class="title">cg_fd</span><span class="params">(open(cg2_path.c_str(), O_DIRECTORY | O_RDONLY | O_CLOEXEC))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (cg_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">       <span class="type">int</span> ret = errno;</span><br><span class="line">       <span class="built_in">ALOGE</span>(<span class="string">&quot;Failed to open the cgroup directory: %s&quot;</span>, <span class="built_in">strerror</span>(ret));</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">statusFromErrno</span>(ret, <span class="string">&quot;Open the cgroup directory failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(<span class="built_in">attachProgramToCgroup</span>(BPF_EGRESS_PROG_PATH, cg_fd, BPF_CGROUP_INET_EGRESS));</span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(<span class="built_in">attachProgramToCgroup</span>(BPF_INGRESS_PROG_PATH, cg_fd, BPF_CGROUP_INET_INGRESS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For the devices that support cgroup socket filter, the socket filter</span></span><br><span class="line">    <span class="comment">// should be loaded successfully by bpfloader. So we attach the filter to</span></span><br><span class="line">    <span class="comment">// cgroup if the program is pinned properly.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> delete the if statement once all devices should support cgroup</span></span><br><span class="line">    <span class="comment">// socket filter (ie. the minimum kernel version required is 4.14).</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access</span>(CGROUP_SOCKET_PROG_PATH, F_OK)) &#123;</span><br><span class="line">         <span class="built_in">RETURN_IF_NOT_OK</span>(</span><br><span class="line">        <span class="built_in">attachProgramToCgroup</span>(CGROUP_SOCKET_PROG_PATH, cg_fd, BPF_CGROUP_INET_SOCK_CREATE));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> netdutils::status::ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>cgroup是linux管理系统资源的资源分配与隔离方案, 在同一个cgroup的进程共享同样的CPU, 内存以及网络资源.</p></blockquote><p>Android提供了一个<code>libnetdbpf</code>库封装了获取系统<code>UID</code>以及网卡的流量统计接口，提供给框架层使用, 比如想要获取某个UID的流量，可以使用<code>bpfGetUidStats</code>这个接口获取:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bpfGetUidStatsInternal</span><span class="params">(<span class="type">uid_t</span> uid, Stats* stats,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> BpfMap&lt;<span class="type">uint32_t</span>, StatsValue&gt;&amp; appUidStatsMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> statsEntry = appUidStatsMap.<span class="built_in">readValue</span>(uid);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isOk</span>(statsEntry)) &#123;</span><br><span class="line">        stats-&gt;rxPackets = statsEntry.<span class="built_in">value</span>().rxPackets;</span><br><span class="line">        stats-&gt;txPackets = statsEntry.<span class="built_in">value</span>().txPackets;</span><br><span class="line">        stats-&gt;rxBytes = statsEntry.<span class="built_in">value</span>().rxBytes;</span><br><span class="line">        stats-&gt;txBytes = statsEntry.<span class="built_in">value</span>().txBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> statsEntry.<span class="built_in">status</span>().<span class="built_in">code</span>() == ENOENT ? <span class="number">0</span> : -statsEntry.<span class="built_in">status</span>().<span class="built_in">code</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bpfGetUidStats</span><span class="params">(<span class="type">uid_t</span> uid, Stats* stats)</span> </span>&#123;</span><br><span class="line">    <span class="function">BpfMap&lt;<span class="type">uint32_t</span>, StatsValue&gt; <span class="title">appUidStatsMap</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        mapRetrieve(APP_UID_STATS_MAP_PATH, BPF_OPEN_FLAGS))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!appUidStatsMap.<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> ret = -errno;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Opening appUidStatsMap(%s) failed: %s&quot;</span>, APP_UID_STATS_MAP_PATH, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bpfGetUidStatsInternal</span>(uid, stats, appUidStatsMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多的实现细节可以参考<code>BpfNetworkStats.cpp``, BpfMap.h</code>以及<code>TrafficController.cpp</code>. </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这篇文章主要将了Android中eBPF程序的格式, 以及如何加载eBPF程序, 最后阐述了Android上如何利用eBPF来实现流量统计的功能. 对eBPF的逻辑与流程理清楚后, 在Android上开发自己的eBPF功能也就不是什么难事了.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://blogs.oracle.com/linux/post/bpf-a-tour-of-program-types">详细介绍了BPF程序类型</a></li><li><a href="https://source.android.com/devices/architecture/kernel/bpf">Android中如何支持eBPF</a></li><li><a href="https://source.android.com/devices/tech/datausage/ebpf-traffic-monitor">如何使用eBPF进行流量统计</a></li><li><a href="https://www.netronome.com/blog/bpf-ebpf-xdp-and-bpfilter-what-are-these-things-and-what-do-they-mean-enterprise/">https://www.netronome.com/blog/bpf-ebpf-xdp-and-bpfilter-what-are-these-things-and-what-do-they-mean-enterprise/</a></li><li><a href="https://lwn.net/Articles/750845/">Accelerating networking with AF_XDP</a></li><li><a href="https://www.kernel.org/doc/Documentation/networking/filter.txt">https://www.kernel.org/doc/Documentation/networking/filter.txt</a></li><li><a href="http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html">http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html</a></li><li><a href="https://linux.cn/article-9507-1.html">eBPF的阅读清单</a></li><li><a href="https://lwn.net/Articles/132196/">https://lwn.net/Articles/132196/</a></li><li><a href="https://www.ferrisellis.com/content/ebpf_syscall_and_maps/">eBPF的系统调用与容器类型</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Android从9.0版本开始全面支持eBPF(&lt;code&gt;extended Berkeley Packet Filters&lt;/code&gt;), 其主要用在流量统计上, 也可以用来监控CPU&amp;#x2F;IO&amp;#x2F;内存等模块的状态.简单来说, &lt;code&gt;eBPF&lt;/code&gt;可以与内核的&lt;code&gt;kprobe&lt;/code&gt;&amp;#x2F;&lt;code&gt;tracepoints&lt;/code&gt;&amp;#x2F;&lt;code&gt;skfilter&lt;/code&gt;等模块相结合, 将eBPF的函数hook到内核事件从而监控相应的系统状态.&lt;/p&gt;
&lt;p&gt;Android为eBPF提供了许多封装的库, 并提供了eBPF加载器&lt;code&gt;bpfloader&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bpfloader&lt;/code&gt;: 位于&lt;code&gt;/system/bpf/bpfloader&lt;/code&gt;, 系统启动时负责加载位于&lt;code&gt;/system/etc/bpf&lt;/code&gt; 中的eBPF目标文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;libbpf_android&lt;/code&gt;: 位于&lt;code&gt;/system/bpf/libbpf_android&lt;/code&gt;提供创建bpf容器&amp;#x2F;加载bpf目标文件的接口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;libbpf&lt;/code&gt;: 位于&lt;code&gt;/external/bcc&lt;/code&gt;, 封装了bpf的系统调用, 提供如attach&amp;#x2F;dettach程序的接口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;libnetdbpf&lt;/code&gt;: 位于&lt;code&gt;/system/netd/libnetdbpf&lt;/code&gt;, 实现了netd流量统计功能的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前在Android(Q)上有两处eBPF的代码: 一个是&lt;code&gt;/system/netd/bpf_progs/netd.c&lt;/code&gt;, 主要是用于流量统计；一个是&lt;code&gt;/system/bpfprogs/time_in_state.c&lt;/code&gt;用于监控CPU运行频率以及上下文切换的耗时.&lt;/p&gt;
&lt;p&gt;接下来我们就从三个部分来深入理解下Android是如何利用eBPF的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eBPF程序与目标文件格式&lt;/li&gt;
&lt;li&gt;Android eBPF加载与执行流程&lt;/li&gt;
&lt;li&gt;Android如何基于eBPF实现流量统计&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://sniffer.site/categories/Linux/"/>
    
    <category term="Android" scheme="https://sniffer.site/categories/Linux/Android/"/>
    
    
    <category term="Android" scheme="https://sniffer.site/tags/Android/"/>
    
    <category term="extended Berkeley Packet Filters" scheme="https://sniffer.site/tags/extended-Berkeley-Packet-Filters/"/>
    
    <category term="eBPF" scheme="https://sniffer.site/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>什么是GARP</title>
    <link href="https://sniffer.site/2021/10/09/%E4%BB%80%E4%B9%88%E6%98%AFGARP/"/>
    <id>https://sniffer.site/2021/10/09/%E4%BB%80%E4%B9%88%E6%98%AFGARP/</id>
    <published>2021-10-09T07:30:19.000Z</published>
    <updated>2021-10-09T08:37:38.778Z</updated>
    
    <content type="html"><![CDATA[<p><code>ARP(Address Resolution Protocol)</code>即地址解析协议, 用于将网络层L3的IP地址转换成数据链路层的L2地址(MAC地址), 常用在诸如以太网, 无线网络等局域网中, 但对如点对点(P2P)网络, 组播与多播IP地址, 都无需使用<code>ARP</code>协议.</p><p>一般来说, L3-L2地址的转换通常被成为邻区协议(<code>neighboring protocol</code>), 这种发现邻居节点(<code>neighbor</code>)的协议被统称为邻居发现协议(<code>Neighbor Discovery Protocol</code>, <code>ND</code>). <code>ARP</code>可以看作是<code>ND</code>的ipv4版本(参考<a href="https://www.rfc-editor.org/rfc/rfc826.txt">RFC826</a>), 在ipv6中则直接称为<code>ND</code>(参考<a href="https://www.rfc-editor.org/rfc/rfc4861">RFC4861</a>).</p><blockquote><p>邻居节点(<code>neighbor</code>)指的是跟主机在同一局域网(<code>LAN</code>)的其他节点</p></blockquote><p><code>ND</code>协议有两种消息类型:</p><ul><li><code>Solicitation Request</code>(也称为<code>Neighbor Solicitation</code>): 用于主机发送消息到网络中查询是否有主机拥有某个L3的IP地址, 该消息可以是单播, 组播或者广播形式.</li><li><code>Solicitation Reply</code>(又称为<code>Neighbor Advertisement</code>): 收到<code>Solicitation Request</code>包时发出的回应包(有可能是HOST本身发出的, 也有可能是<code>ARP</code>代理服务器发送的)</li></ul><p>那么, 什么是<code>Gratuitous ARP</code>(简称<code>GARP</code>, 免费ARP)了? 简单来说, <code>GARP</code>是一种用于告知网络中其他节点某些特定信息的ARP请求包, 但无须其他节点发送回应包, 常用于如下<a href="http://www.embeddedlinux.org.cn/linux_net/0596002556/understandlni-CHP-28-SECT-3.html#understandlni-CHP-28-SECT-3">三种情况</a>:</p><span id="more"></span><ul><li>检测局域网内的IP地址冲突(参考<a href="https://datatracker.ietf.org/doc/html/rfc5227">RFC5227</a>)</li><li>L2地址(MAC地址)发生变化时</li><li>虚拟IP(<code>virtual IP</code>), 用于服务器的冗余</li></ul><p>接下来就看看<code>GARP</code>在这三种场景的具体应用.</p><h2 id="IP冲突检测"><a href="#IP冲突检测" class="headerlink" title="IP冲突检测"></a><strong>IP冲突检测</strong></h2><p>当局域网中采用静态IP与动态(基于<code>DHCP</code>)IP配置结合的方式时, 有可能两个节点之间的IP会相同;这时需要使用<code>GARP</code>来检测IP冲突: 网络节点在配置IP时, 发送一个<code>GARP</code>到其他节点, 如果有节点的IP与之相同, 则会回应一个<code>ARP</code>包, 告诉该IP已经有节点使用了; 如果该IP没有被使用, 则不会收到任何<code>ARP</code>的回应.</p><h2 id="MAC地址变更"><a href="#MAC地址变更" class="headerlink" title="MAC地址变更"></a><strong>MAC地址变更</strong></h2><p>当某个网络节点的L2地址(MAC地址)发生变化时, 网络中的其他节点是无法知道的, 因此需要一个协议来同步这个变化, 以便于其他的节点及时更新<code>ARP</code>缓存. 这样比每个节点自己主动更新会来的更省事方便(也不会导致短暂的网络黑洞, 参见上一篇文章<a href="https://sniffer.site/2021/09/28/%E4%B8%80%E4%B8%AAarp-cache%E4%B8%8D%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/">ARP cache不更新导致的网络问题</a>)</p><h2 id="服务器冗余"><a href="#服务器冗余" class="headerlink" title="服务器冗余"></a><strong>服务器冗余</strong></h2><p>在某些情况下, 为了实现在多个服务器之间的故障恢复(<code>failover</code>), 通常会使用<code>GARP</code>来到达服务器冗余(<code>redundancy</code>)的目的, 这时两个服务器会共享IP或MAC地址, 当某个服务器发生故障(死机, 物理故障等)时, 服务器群里的各个机器通过心跳机制来定时侦测故障, 当备用服务器侦测到与其共享IP的服务器故障时, 会发送一个<code>GARP</code>包, 告诉各个服务器更新对应的ARP缓存, 确保服务能快速恢复.</p><p>下面我们就来看一看Linux内核(4.14)是如何处理<code>GARP</code>的.</p><h2 id="Linux如何处理GARP"><a href="#Linux如何处理GARP" class="headerlink" title="Linux如何处理GARP"></a><strong>Linux如何处理GARP</strong></h2><p>Linux提供了<code>ARP/GARP</code>相关的配置选项, 在<code>/proc/sys/net/ipv4/conf/</code>中有如下几个节点(参考Linux文档<code>ip-sysctl.txt</code>):</p><ul><li><code>arp_announce</code>: 控制<code>ARP</code>请求时发送的本地网卡源IP地址的类型, <code>0</code>(默认)表示可以使用任何本地IP地址, <code>1</code>表示只使用同一子网内的IP地址, <code>2</code>表示只使用网卡的首要IP地址(<code>primary ip</code>)</li><li><code>arp_igonre</code>: 控制收到<code>ARP</code>请求后发送回包时的目标IP地址类型: <code>0</code>(默认)表示发送任何本地的IP地址, <code>1</code>只发送当前收到<code>ARP</code>包网卡的本地地址, <code>2</code>只回送接收<code>ARP</code>包的网卡与<code>ARP</code>请求方在同一子网的IP地址, <code>3</code>回送域(scope)为<code>global/link</code>的地址, 不回送<code>host</code>的地址; <code>4-7</code>保留值, <code>8</code>表示不回送任何地址</li><li><code>arp_notify</code>: 网卡状态变化时是否发送<code>GARP</code>, <code>0</code>表示什么都不做, <code>1</code>表示设备UP或MAC地址变化时发送<code>GARP</code></li><li><code>arp_accept</code>: 收到<code>GARP</code>时是否创建<code>ARP</code>缓存, <code>0</code>不创建, <code>1</code>表示创建(如果<code>ARP</code>缓存已经包含了<code>GARP</code>包的IP地址, 不管是否开启该选项, 都会更新<code>ARP</code>缓存)</li><li><code>drop_gratuitous_arp</code>: 丢弃所有<code>GARP</code>包, 默认是<code>0</code>(关闭)</li></ul><p>最后, 不妨看下内核是如何实现<code>GARP</code>的发送的.</p><p>当网卡UP或者MAC地址发生变化时(前提是<code>arp_notify</code>处于开启状态)会发送<code>GARP</code>, 设备驱动也可以通过发送<code>NETDEV_NOTIFY_PEERS</code>事件来触发<code>GARP</code>告知其他节点状态的变化:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//dev.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_set_mac_address</span><span class="params">(<span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> sockaddr *sa)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> *<span class="title">ops</span> =</span> dev-&gt;netdev_ops;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ops-&gt;ndo_set_mac_address)</span><br><span class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">    <span class="keyword">if</span> (sa-&gt;sa_family != dev-&gt;type)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!netif_device_present(dev))</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    err = ops-&gt;ndo_set_mac_address(dev, sa);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    dev-&gt;addr_assign_type = NET_ADDR_SET;</span><br><span class="line">    <span class="comment">//MAC地址发生变化, 发送事件通知其他模块</span></span><br><span class="line">    call_netdevice_notifiers(NETDEV_CHANGEADDR, dev);</span><br><span class="line">    add_device_randomness(dev-&gt;dev_addr, dev-&gt;addr_len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(dev_set_mac_address);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>内核初始化时注册的通知回调<code>inetdev_event</code>在接收到事件通知后, 就会发送<code>GARP</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//devinet.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">inetdev_event</span><span class="params">(<span class="keyword">struct</span> notifier_block *this, <span class="type">unsigned</span> <span class="type">long</span> event,</span></span><br><span class="line"><span class="params">            <span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> netdev_notifier_info_to_dev(ptr);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_device</span> *<span class="title">in_dev</span> =</span> __in_dev_get_rtnl(dev);</span><br><span class="line"></span><br><span class="line">    ASSERT_RTNL();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_dev) &#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">    <span class="keyword">case</span> NETDEV_REGISTER:</span><br><span class="line">        pr_debug(<span class="string">&quot;%s: bug\n&quot;</span>, __func__);</span><br><span class="line">        RCU_INIT_POINTER(dev-&gt;ip_ptr, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NETDEV_UP:</span><br><span class="line">        <span class="keyword">if</span> (!inetdev_valid_mtu(dev-&gt;mtu))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;flags &amp; IFF_LOOPBACK) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">in_ifaddr</span> *<span class="title">ifa</span> =</span> inet_alloc_ifa();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ifa) &#123;</span><br><span class="line">                INIT_HLIST_NODE(&amp;ifa-&gt;hash);</span><br><span class="line">                ifa-&gt;ifa_local =</span><br><span class="line">                ifa-&gt;ifa_address = htonl(INADDR_LOOPBACK);</span><br><span class="line">                ifa-&gt;ifa_prefixlen = <span class="number">8</span>;</span><br><span class="line">                ifa-&gt;ifa_mask = inet_make_mask(<span class="number">8</span>);</span><br><span class="line">                in_dev_hold(in_dev);</span><br><span class="line">                ifa-&gt;ifa_dev = in_dev;</span><br><span class="line">                ifa-&gt;ifa_scope = RT_SCOPE_HOST;</span><br><span class="line">                <span class="built_in">memcpy</span>(ifa-&gt;ifa_label, dev-&gt;name, IFNAMSIZ);</span><br><span class="line">                set_ifa_lifetime(ifa, INFINITY_LIFE_TIME,</span><br><span class="line">                        INFINITY_LIFE_TIME);</span><br><span class="line">                ipv4_devconf_setall(in_dev);</span><br><span class="line">                neigh_parms_data_state_setall(in_dev-&gt;arp_parms);</span><br><span class="line">                inet_insert_ifa(ifa);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ip_mc_up(in_dev);</span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line">    <span class="keyword">case</span> NETDEV_CHANGEADDR:</span><br><span class="line">        <span class="comment">// `arp_notify`如果关闭, 则不会发送GARP包</span></span><br><span class="line">        <span class="keyword">if</span> (!IN_DEV_ARP_NOTIFY(in_dev))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line">    <span class="keyword">case</span> NETDEV_NOTIFY_PEERS:</span><br><span class="line">        <span class="comment">/* Send gratuitous ARP to notify of link change */</span></span><br><span class="line">        inetdev_send_gratuitous_arp(dev, in_dev);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> NOTIFY_DONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当收到<code>GARP</code>包是内核是如何处理的, 可以参考<code>net/ipv4/arp.c</code>中的函数<code>arp_process</code>.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="http://www.embeddedlinux.org.cn/linux_net">http://www.embeddedlinux.org.cn/linux_net</a></li><li><a href="https://www.practicalnetworking.net/series/arp/gratuitous-arp/">https://www.practicalnetworking.net/series/arp/gratuitous-arp/</a></li><li><a href="http://www.embeddedlinux.org.cn/linux_net/0596002556/understandlni-CHP-28-SECT-3.html">http://www.embeddedlinux.org.cn/linux_net/0596002556/understandlni-CHP-28-SECT-3.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;ARP(Address Resolution Protocol)&lt;/code&gt;即地址解析协议, 用于将网络层L3的IP地址转换成数据链路层的L2地址(MAC地址), 常用在诸如以太网, 无线网络等局域网中, 但对如点对点(P2P)网络, 组播与多播IP地址, 都无需使用&lt;code&gt;ARP&lt;/code&gt;协议.&lt;/p&gt;
&lt;p&gt;一般来说, L3-L2地址的转换通常被成为邻区协议(&lt;code&gt;neighboring protocol&lt;/code&gt;), 这种发现邻居节点(&lt;code&gt;neighbor&lt;/code&gt;)的协议被统称为邻居发现协议(&lt;code&gt;Neighbor Discovery Protocol&lt;/code&gt;, &lt;code&gt;ND&lt;/code&gt;). &lt;code&gt;ARP&lt;/code&gt;可以看作是&lt;code&gt;ND&lt;/code&gt;的ipv4版本(参考&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc826.txt&quot;&gt;RFC826&lt;/a&gt;), 在ipv6中则直接称为&lt;code&gt;ND&lt;/code&gt;(参考&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc4861&quot;&gt;RFC4861&lt;/a&gt;).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;邻居节点(&lt;code&gt;neighbor&lt;/code&gt;)指的是跟主机在同一局域网(&lt;code&gt;LAN&lt;/code&gt;)的其他节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;ND&lt;/code&gt;协议有两种消息类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Solicitation Request&lt;/code&gt;(也称为&lt;code&gt;Neighbor Solicitation&lt;/code&gt;): 用于主机发送消息到网络中查询是否有主机拥有某个L3的IP地址, 该消息可以是单播, 组播或者广播形式.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Solicitation Reply&lt;/code&gt;(又称为&lt;code&gt;Neighbor Advertisement&lt;/code&gt;): 收到&lt;code&gt;Solicitation Request&lt;/code&gt;包时发出的回应包(有可能是HOST本身发出的, 也有可能是&lt;code&gt;ARP&lt;/code&gt;代理服务器发送的)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么, 什么是&lt;code&gt;Gratuitous ARP&lt;/code&gt;(简称&lt;code&gt;GARP&lt;/code&gt;, 免费ARP)了? 简单来说, &lt;code&gt;GARP&lt;/code&gt;是一种用于告知网络中其他节点某些特定信息的ARP请求包, 但无须其他节点发送回应包, 常用于如下&lt;a href=&quot;http://www.embeddedlinux.org.cn/linux_net/0596002556/understandlni-CHP-28-SECT-3.html#understandlni-CHP-28-SECT-3&quot;&gt;三种情况&lt;/a&gt;:&lt;/p&gt;</summary>
    
    
    
    
    <category term="ARP" scheme="https://sniffer.site/tags/ARP/"/>
    
    <category term="Address Resolution Protocol" scheme="https://sniffer.site/tags/Address-Resolution-Protocol/"/>
    
    <category term="GARP" scheme="https://sniffer.site/tags/GARP/"/>
    
  </entry>
  
</feed>
