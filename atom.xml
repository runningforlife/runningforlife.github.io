<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasonWang&#39;s Blog</title>
  
  <subtitle>本色做人，角色做事</subtitle>
  <link href="https://sniffer.site/atom.xml" rel="self"/>
  
  <link href="https://sniffer.site/"/>
  <updated>2023-01-10T09:23:40.137Z</updated>
  <id>https://sniffer.site/</id>
  
  <author>
    <name>Jason Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么iperf测试时UDP会出现高丢包率</title>
    <link href="https://sniffer.site/2023/01/10/%E4%B8%BA%E4%BB%80%E4%B9%88iperf%E6%B5%8B%E8%AF%95%E6%97%B6UDP%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%AB%98%E4%B8%A2%E5%8C%85%E7%8E%87/"/>
    <id>https://sniffer.site/2023/01/10/%E4%B8%BA%E4%BB%80%E4%B9%88iperf%E6%B5%8B%E8%AF%95%E6%97%B6UDP%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%AB%98%E4%B8%A2%E5%8C%85%E7%8E%87/</id>
    <published>2023-01-10T07:13:25.000Z</published>
    <updated>2023-01-10T09:23:40.137Z</updated>
    
    <content type="html"><![CDATA[<p>这两天质量的同学反馈说<code>iperf</code>测试时结果很差，跟实际的千兆带宽差别很大。确认了半天，发现内核的各项参数都已经完全按照千兆的目标速率进行配置了，那为什么还是会出现<code>TCP/UDP</code>带宽不足的问题？ 记得当时优化参数时，自己摸底测试的<code>TCP</code>结果挺好的，都达到了预期的<code>900Mbps</code>以上，看起来最近有什么修改导致了这个测试结果差异。</p><p>偶然的一个机会查看内核配置时，发现最近有人打开了<code>trace</code>功能，看起来很可能是这个修改导致了网络性能的下降了。拿早前未开启<code>trace</code>功能的版本一对比，果真是<code>trace</code>功能影响了<code>TCP</code>的带宽。<span id="more"></span>但是测试<code>UDP</code>还是会出现如下结果，看起來好像网络很差(注意对<code>UDP</code>测试需要通过设置<code>-b</code>参数来限制可能的带宽，否则也可能出现测试结果偏差)：</p><ul><li>使用<code>iperf</code>默认的的包大小测试(看源码，对<code>UDP</code>来说，默认的包大小为<code>1024</code>， 最大为<code>65507</code>)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务端: iperf3 -s -p <span class="number">8989</span> -f m</span><br><span class="line">客户端: iperf3 -c <span class="number">172.20</span><span class="number">.2</span><span class="number">.40</span> -p <span class="number">8989</span> -f m -t <span class="number">30</span> -u -b <span class="number">1</span>G</span><br><span class="line"></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-30.00</span>  sec   <span class="number">710</span> MBytes   <span class="number">198</span> Mbits/sec  <span class="number">0.000</span> ms  <span class="number">0</span>/<span class="number">509813</span> (<span class="number">0</span>%)  sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-30.19</span>  sec   <span class="number">701</span> MBytes   <span class="number">195</span> Mbits/sec  <span class="number">0.201</span> ms  <span class="number">6626</span>/<span class="number">509809</span> (<span class="number">1.3</span>%)  receiver</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于<code>UDP</code>没有流控，整体的丢包率<code>1.3%</code>还不错，但带宽明显太小了，只有理论值的<code>1/5</code>不到。从这个结果可以看到，实际带宽不足是因为发送端的速率太小了，导致整个通道未被充分占满。这就好比一个粗大的水管，但实际传输的水流太小了，容量利用率不够。要想提高利用率，只能想法提升发送端的速率。<code>iperf</code>中，我们可以通过<a href="https://serverfault.com/questions/691723/extreme-udp-packet-loss-at-300mbit-14-but-tcp-800mbit-w-o-retransmits">提高包大小来达到这一目的</a>：</p><ul><li>使用最大的<code>UDP</code>包大小(<code>65507</code>)进行测试</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务端: iperf3 -s -p <span class="number">8989</span> -f m</span><br><span class="line">客户端: iperf3 -c <span class="number">172.20</span><span class="number">.2</span><span class="number">.40</span> -p <span class="number">8989</span> -f m -t <span class="number">30</span> -u -b <span class="number">1</span>G -l <span class="number">65507</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ ID] Interval           Transfer     Bitrate         Jitter    Lost/Total Datagrams</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-10.00</span>  sec  <span class="number">1.16</span> GBytes  <span class="number">1000</span> Mbits/sec  <span class="number">0.000</span> ms  <span class="number">0</span>/<span class="number">19079</span> (<span class="number">0</span>%)  sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-10.18</span>  sec   <span class="number">723</span> MBytes   <span class="number">595</span> Mbits/sec  <span class="number">0.282</span> ms  <span class="number">7508</span>/<span class="number">19079</span> (<span class="number">39</span>%)  receiver</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这次测试带宽明显有所提升，但接收端的丢包率却达到了惊人的<code>39%</code>。为什么会出现如此高的丢包率了？这还是要从<code>UDP</code>的传输机制说起了。我们都知道，<a href="http://www.tcpipguide.com/free/t_UDPOverviewHistoryandStandards.htm"><code>UDP</code>是无连接的数据报文传输协议</a>，也没有类似<code>TCP</code>滑动窗口的流量控制机制，因此快速的一方很有可能会淹没慢速的一方。这个时候就需要适当的调整慢速一端的<code>socket</code>缓冲区大小了。</p><p>对于<code>UDP</code>来说，主要有如下几个参数会影响实际传输时<code>socket</code>缓冲区的大小(可以参考内核文档<code>ip-sysctl.txt</code>)：</p><ul><li><code>net.core.wmem_default/net.core.wmem_max</code>: 默认、最大的发送缓冲区大小(bytes)，如果没用通过<code>setsockopt</code>來设置<code>SO_SNDBUF</code>的值，则会使用内核默认的缓冲区大小</li><li><code>net.core.rmem_default/net.core.rmem_max</code>: 默认、最大的接收缓冲区大小(bytes), 类似的，如果没有通过<code>SO_RCVBUF</code>来设置发送缓冲区的值，则使用内核默认的<code>net.core.rmem_default</code>值</li><li><code>net.ipv4.udp_mem=&quot;min pressure max&quot;</code>: 系统中所有<code>UDP</code>连接<code>socket</code>可以使用的最小、压力、最大页数（页大小一般为<code>4K</code>)，默认值一般在系统启动的时候根据当前可用内存计算出来的</li><li><code>net.ipv4.udp_rmem_min/net.ipv4.udp_wmen_min</code>: 系统中单个<code>UDP</code>连接<code>socket</code>可用的最小内存(bytes), 默认是<code>4K</code>。</li></ul><p>要想减少测试中的丢包率，就需要提高慢速端(也就是接收端)的缓冲区大小，确保其有足够的空间来保存接收到的数据，不至于来不及处理而被内核丢弃。我们可以选择在发送端或者接收端设置缓冲区的大小，对于<code>iperf</code>只能通过<code>-w</code>控制客户端的缓冲区大小, 这里我们直接在客户端设置发送缓冲区的大小为<code>10M</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务端: iperf3 -s -p <span class="number">8989</span> -f m</span><br><span class="line">客户端: iperf3 -c <span class="number">172.20</span><span class="number">.2</span><span class="number">.40</span> -p <span class="number">8989</span> -f m -t <span class="number">30</span> -u -b <span class="number">1</span>G -l <span class="number">65507</span> -w <span class="number">10</span>M</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ ID] Interval           Transfer     Bitrate         Jitter    Lost/Total Datagrams</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-10.00</span>  sec  <span class="number">1.16</span> GBytes  <span class="number">1000</span> Mbits/sec  <span class="number">0.000</span> ms  <span class="number">0</span>/<span class="number">19081</span> (<span class="number">0</span>%)  sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-10.19</span>  sec  <span class="number">1.16</span> GBytes   <span class="number">981</span> Mbits/sec  <span class="number">0.593</span> ms  <span class="number">0</span>/<span class="number">19079</span> (<span class="number">0</span>%)  receiver</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，丢包率速率下降了到预期的程度。如果我们要在服务端设置接收缓冲区的大小，可以有两种方式: 一种是通过设置<code>net.core.rmem_default</code>大小，一种是修改<code>iperf3</code>的源码，确保服务端也可以通过<code>-w</code>来设置缓冲区的大小。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>网络的带宽优化涉及了Linux内核协议栈和网卡驱动，充分理解网络数据的传输流程以及<code>TCP/UDP</code>等传输协议的机制，才有可能找到性能的瓶颈。总的来说，这些优化很值得很深入研究，可以让人完整的把各个知识点都梳理串联起来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两天质量的同学反馈说&lt;code&gt;iperf&lt;/code&gt;测试时结果很差，跟实际的千兆带宽差别很大。确认了半天，发现内核的各项参数都已经完全按照千兆的目标速率进行配置了，那为什么还是会出现&lt;code&gt;TCP/UDP&lt;/code&gt;带宽不足的问题？ 记得当时优化参数时，自己摸底测试的&lt;code&gt;TCP&lt;/code&gt;结果挺好的，都达到了预期的&lt;code&gt;900Mbps&lt;/code&gt;以上，看起来最近有什么修改导致了这个测试结果差异。&lt;/p&gt;
&lt;p&gt;偶然的一个机会查看内核配置时，发现最近有人打开了&lt;code&gt;trace&lt;/code&gt;功能，看起来很可能是这个修改导致了网络性能的下降了。拿早前未开启&lt;code&gt;trace&lt;/code&gt;功能的版本一对比，果真是&lt;code&gt;trace&lt;/code&gt;功能影响了&lt;code&gt;TCP&lt;/code&gt;的带宽。</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="iperf" scheme="https://sniffer.site/tags/iperf/"/>
    
    <category term="UDP" scheme="https://sniffer.site/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>再见2022</title>
    <link href="https://sniffer.site/2022/12/31/%E5%86%8D%E8%A7%812022/"/>
    <id>https://sniffer.site/2022/12/31/%E5%86%8D%E8%A7%812022/</id>
    <published>2022-12-31T09:08:35.000Z</published>
    <updated>2023-01-10T07:18:34.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>创造力 &#x3D; 能力 × 热情 × 思维方式</p><ul><li>“能力”是指努力学到的知识、经验和技能</li><li>“热情”是指工作时所有的激情和渴望成功等因素</li><li>“思维方式”则指对待工作的心态、精神状态和价值偏好</li></ul><p>一个人和一个企业能够取得多大成就，就看三个因素的乘积</p><p><strong>稻盛和夫</strong></p></blockquote><p><img src="https://images.unsplash.com/photo-1661306118447-6eac9ce5866f?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1074&q=80" alt="flow on the sea"></p><span id="more"></span><p>即将迈入新的一年了，时不待人。未曾想到2022年终的几天是在与新冠病毒共存中度过的，从最初的感染到恢复，前后历经6天，最高发烧到39度，身体好几天都处于酸痛而乏力的状态，确实让人难受。所幸的是，家里的娃娃跟老人都没有感染。三年来，新冠病毒演化到今天的奥密克戎，看起来毒性确实减弱了不少，政策放开后，唯一让人的担心是，这个如此狡猾的新冠病毒是否会继续在交叉传播中变异，卷土重来？人类是否有能力研发出新的疫苗，从此让新冠病毒彻底偃旗息鼓，尚待确证。</p><p>不得不说，新冠病毒肆虐的这三年是人类历史上注定无法被遗忘的一段历史，纵然生活变化多端，那些被撕碎的感情，被摧残的个人、家庭，无不让人唏嘘，让人看到人自身的脆弱，看到自然更迭的无情与沧桑，看到社会治理中诸多折腾与无效。人，像是浮萍，像是沙子，又像是一滴水，随时被风吹走，被洪流裹挟，被卷到某个角落，再无人问津，被遗忘，仿佛从未来过这里。那么，人的价值到底在哪里？ 我们毕竟有血有肉、有意志、有信念；我们渴望温情，渴望创造，渴望活的有价值，而不是浑浑噩噩的度过上苍赋予的3万天。最近在想，为何我们成为了如今这个样子？ 为何这个社会、国家成为了现在这个状态而不是另外的状态了？ 究竟是什么力量在塑造着人的心灵，又是什么力量塑造了社会与国家？ 我们每个人可能都笃定自己掌握了生活的主动权，掌控着自己头脑中的信念与想法，但仔细想一想，很多我们头脑中深信不疑的观念只不过是在某个时间悄然溜进了我们的身体而已，那并不是我们自己思考出来的。如果不加检点，我们就有可能成为这些偷偷溜进来的想法的奴隶。</p><p>言归正传，总结下过去的一年吧。今天早上，翻开自己2022年的计划，大多数立下的flag都未能兑现，大都停留在纸上谈兵了。365天，忙忙碌碌竟然忘了自己的最初的目标了。定目标还是不能求多求大，能落地，越具体越好。</p><ul><li>阅读上有了广度，一年下来大概有十几本吧(不包括电子书)，印象比较深刻的有<code>这才是心理学</code>，吴军的<code>数学之美</code>、<code>计算之魂</code>，<code>经济学通识课</code>，<code>生命是什么</code>，<code>影响力</code>，<code>错误的行为</code>， <code>量子传-究竟什么才是现实</code>等。今年养成了一个习惯，就是好的书读完第一遍后，过一段时间再读第二遍，这样可以比较好的理解书中的某些观点。阅读这件事情，在以前看起来其实挺费时间，需要大块时间才能去做，如今发现随便一个时间，哪怕是几分钟也可以利用起来，随时翻一翻。这样一本书，可能个把月出头也就看完了。</li><li>工作上，发现只要自己足够用心，深入思考，完全可以把之前认为做不到或者别人认为难以完成的任务做到。从另一个角度来说，个人实际上是有潜力的，即便是到了而立之年也同样可以不断提高，只是提高的速度没能达到20岁出头那种程度而已。</li><li>每周都坚持打一次羽毛球，两个小时的锻炼确实让人获益匪浅，人的精力与状态都得到了足够的支撑。今年花点钱再改善下装备，希望再高手的带领下，水平能够再上一个台阶。</li><li>女儿三岁了，自己也在她的拉扯下慢慢成为一个有责任心的父亲。与小宝贝相处的过程，发现父母就是领导者，领导者要带领好跟队的人，让对方的行为符合预期，仅仅有言语的教导还远远不够，更重要的是以身作则，用榜样去引导，用耐心而温情的去陪伴。</li></ul><p>新的一年，以如下三点来勉励自己，希望能够在各个方面有更多更大的拓展与进步。</p><h2 id="专注于目标"><a href="#专注于目标" class="headerlink" title="专注于目标"></a><strong>专注于目标</strong></h2><p>人是一个情感的动物，很多时候都会被情绪控制，诸如别人为什么这么无礼；别人为什么会这么粗鲁；别人为什么会如此待人等等此类问题经常控制着我们日常的心绪，让我们分心费神而忘了生活本来的面目。加上网络上无数的新闻热点更是把我们的关注力都打散，然后真正投入到有价值的目标中的时间精力其实并不多。扪心自问，很多时候我们之所以没能做的更好，是因为我们没有足够专注，没有把时间与精力用到正确的地方，那些琐碎而毫无价值的事情占据了我们太多的心力，从而让我们看起来总是碌碌无为。</p><p>正本清源，关注人生中有价值的部分，长期专注的投入才能获得更长足的进步。</p><h2 id="追求卓越"><a href="#追求卓越" class="headerlink" title="追求卓越"></a><strong>追求卓越</strong></h2><p>偶然的机会，了解了稻盛和夫，听了两本他的有声书(&lt;思维方式&gt;，&lt;稻盛和夫给年轻人的忠告&gt;)，有种被敲醒的感觉，很多的道理看似简单，要放到之前我可能都认为是心灵鸡汤，不值得理会，但如今再深思，竟然觉得说的太对，太好了。真是<code>too young, too simple</code>。年轻气盛，实则是头脑简单，想的太少，段位太低了。从稻盛和夫的人生哲学中，我看到了追求卓越的价值与意义。在任何事情上，能做到95分，就决不能满足于90分，只要有提升的空间，都要不遗余力的为之努力。人生的价值在于创造，在于不断的发掘自身的潜能，在于追求卓越的过程。</p><h2 id="开放与自省"><a href="#开放与自省" class="headerlink" title="开放与自省"></a><strong>开放与自省</strong></h2><p>认真想一想，人经常竭力维护的骄傲与自尊实际上并没有太重要的价值，有时反而是阻碍我们获得真相的绊脚石。思维的桎梏部分是因为经年累月的懒惰造成，部分是社会文化的传染影响导致。要想获得创造力与想象力，打开心灵，保持开放与自省才是正道。开放，意味着准备接纳任何观念与事实，不去人为的设定限制；自省，则是给自己的心灵提供一个观察自我的窗口，让我们看到在内心的深处，我们并没有想的那么聪明，让我们懂得谦卑，懂得看到这个世界多元的价值与意义， 不至于走向偏执。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;创造力 &amp;#x3D; 能力 × 热情 × 思维方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“能力”是指努力学到的知识、经验和技能&lt;/li&gt;
&lt;li&gt;“热情”是指工作时所有的激情和渴望成功等因素&lt;/li&gt;
&lt;li&gt;“思维方式”则指对待工作的心态、精神状态和价值偏好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个人和一个企业能够取得多大成就，就看三个因素的乘积&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;稻盛和夫&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1661306118447-6eac9ce5866f?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1074&amp;q=80&quot; alt=&quot;flow on the sea&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="https://sniffer.site/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="新冠病毒" scheme="https://sniffer.site/tags/%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92/"/>
    
    <category term="个人总结" scheme="https://sniffer.site/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络优化之AVB/TSN</title>
    <link href="https://sniffer.site/2022/12/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BAVB-TSN/"/>
    <id>https://sniffer.site/2022/12/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BAVB-TSN/</id>
    <published>2022-12-06T10:15:35.000Z</published>
    <updated>2022-12-14T03:16:05.284Z</updated>
    
    <content type="html"><![CDATA[<p>这是<code>Linux</code>网络优化系列的第四篇文章，也是最后一篇了。最近有点忙，没有抽出时间来梳理这些知识点, 看了下文章历史，这个优化系列文章前后持续了大半年时间，今天总算达成了目标*_*。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>自从互联网诞生以来, 音视频(Audio&#x2F;Video, AV)在网络上传输已经是稀松平常的事情. 那么, 为什么还需要一个新的基于以太网的协议来传输AV数据了? 传统的音视频传输都是点对点单向连接, 比如音频通常使用<code>I2S</code>或<code>SPDIF/AES</code>; 视频则使用<code>SDI</code>或者<code>HDMI</code>, 这种专用的单向连接在多设备情况下往往容易出现杂乱无章的连接线束:</p><span id="more"></span><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/StudioWiring.png" alt="AV wiring"></p><p>为了解决上述问题, 满足音视频数据传输中<a href="https://web.archive.org/web/20140405091013if_/http://www.avnu.org/files/static_page_files/AAF3193A-1D09-3519-AD45FC42893D1949/No-excuses%20Audio%20Video%20Networking%20v2.pdf">低延迟&#x2F;严格时间同步的需求</a>, 解决音视频传输中丢包&#x2F;传输延迟等问题，在2004年左右, IEEE 802.3小组接收了一个<code>CFI(Call For Interest)</code>有关将以太网用于低时延(<code>Time-sensitive</code>)的音视频传输的方案. 传统以太网是没有时间同步的, 而且由于网络链路存在难以预料的时延以及拥塞, 很难满足AV数据的传输要求, 为此IEEE专门成立了一个<code>802.1 Audio/Video Bridging</code>任务小组, 该小组开发出了一系列新的协议来解决上面碰到的问题, 即<code>AVB(Audio/Video Bridging)</code>协议族。<code>AVB</code>最开始是面向音视频数据传输，但其低延迟的特性使得<code>AVB</code>能很好的解决汽车领域中诸如娱乐座舱（摄像头&#x2F;屏幕显示），车身控制以及自动驾驶等领域的问题。<code>AVB</code>核心的协议主要由如下三个标准协议组成：</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/protocol_for_AE.png" alt="protocol stack of AE"></p><ul><li><code>IEEE 802.1AS-2011 (gPTP)</code>： 精确的时间同步(<code>precise synchronization</code>)</li><li>支持对多媒体数据的流整形(<code>traffic shaping</code>), 用于数据流均衡, 对应<code>IEEE 802.1Qav-2009 (FQTSS, Forwarding and Queuing for Time-Sensitive Streams)</code></li><li>带宽允许控制(<code>admission controls</code>), 预分配足够的带宽用于AV数据传输, 即<code>IEEE 802.1Qat-2010 (Stream Reservation Protocol, SRP)</code>， 由<a href="https://www.juniper.net/documentation/us/en/software/junos/mvrp/multicast-l2/topics/concept/mvrp-mx-series-understanding.html"><code>MMRP</code>&#x2F;<code>MVRP</code>&#x2F;<code>MSRP</code></a>三个协议组成。</li></ul><p>同时, AVB还提供两个传输层协议: <code>IEEE 1722-2011(AV Transport Protocol, AVTCP)</code>用于音视频数据的传输;<code>IEEE 1722.1-2013(Device Discovery, Connection Management, and Control Protocol)</code>用于AVB设备的发现与连接管理. 到2012年, 为了更好的体现AVB协议的核心理念: 通过IEEE 802(以太网)提供时间同步&#x2F;低延迟的流媒体数据传输服务, AVB被重新命名为<code>TSN(Time-Sensitive Network)</code>, 后续所有的标准化工作都在<code>IEEE 802.1 TSN</code>小组展开.</p><p>随着近年来智能座舱概念的落地, 在汽车中引入更多娱乐设备, 比如扬声器, 摄像头, 甚至直播设备逐渐成为未来的趋势. 加之车载以太网从原来的<code>100Mbps</code>成熟演变到如今的<code>1Gbps</code>, 以太网已经成为车上各个域控制器的相互通讯的标准接口, 成为将车上各种设备如摄像头，扬声器，自动驾驶控制器等相互连接的方式，因此可以预见, <code>AVB/TSN</code>会成为车载娱乐领域&#x2F;自动驾驶相关的支撑技术而得到更为广泛的应用.</p><h2 id="AVB协议"><a href="#AVB协议" class="headerlink" title="AVB协议"></a><strong>AVB协议</strong></h2><p>AVB协议基于MAC层(L2)改进而来, 发送AV数据的设备称为<code>Talker</code>, 而接收AV数据的设备则称为<code>Listener</code>. 接受端与发送端应用基于AVB通讯时(一个<code>Talker</code>可能对应多个<code>Listener</code>, 因此实际上AVB的数据流都是多播数据, 通常需要通过<code>VLAN</code>对数据流进行分组), 不再通过TCP&#x2F;IP协议栈, 而是直接用<code>RAW SOCKET</code>与MAC层进行通讯, 与<code>TCP/IP</code>的实现不同，AVB协议都是在用户空间中实现的:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/AVB%20stack.png" alt="AVB stack"></p><p>接下来, 我们就重点来看看AVB三个核心协议的具体是如何工作的.</p><h3 id="时间同步-gPTP"><a href="#时间同步-gPTP" class="headerlink" title="时间同步-gPTP"></a><strong>时间同步-gPTP</strong></h3><p>AVB设备需要通过一个基准时钟定时同步时间信息, 以确保多个数据流的时间严格同步, 同时保证数据的发送与接收处于相同的时间序列. 这个用于精确时间同步的协议就是<code>IEEE 802.1AS gPTP</code>(<code>generic Precise Time Protocol</code>), gPTP实际是另一个时间同步协议<a href="https://en.wikipedia.org/wiki/Precision_Time_Protocol">IEEE 1588 PTP</a>的子集. <code>IEEE 802.1AS gPTP</code>与<code>IEEE 1588 PTP</code>的区别在与, <code>gPTP</code>假定所有的节点的通讯都是基于<code>IEEE 802 MAC</code>的PDU格式以及寻址, 而<code>PTP</code>可以支持从MAC层(L2)到L3&#x2F;L4的通讯协议. 对于gPTP来说, 在一个时间同步域(<code>timing domain</code>, 遵循gPTP标准并使用其同步时间的所有设备构成一个同步域)内, 有一个设备提供主时钟信号, 为其他所有设备提供参考时钟, 这个设备被称为<code>Grand Master Clock(GMC)</code>.</p><p>对于<code>gPTP</code>协议来说, 有两个问题需要解决: </p><ul><li>如何选择<code>Grand Master Clock</code>?</li><li>各个通讯节点如何同步时间?</li></ul><p>一般来说, <code>Grand Master Clock</code>设备可以在连接初始化时动态选择也可以预先配置(对车载网络来说, 可以选择静态配置的方式, 通常选择网关作为<code>Grand Master</code>). 动态选择需要通过<code>BMCA(Best Master Clock selection Algorithm)</code>.<code>BMCA</code>是一个分布式算法, 其工作原理大致是: 每个可做<code>Grand Master</code>的节点收到<code>announce</code>消息后, 比较自身时间与当前最好的<code>Grand Master</code>时间之间的质量值(如何衡量时间相关的质量值?), 如果8次不同的评价产生了一个比当前<code>Grand Master</code>时钟更好的时间值, 则完成<code>Grand Master</code>选择过程, 该节点宣称自己成为<code>Grand Master</code>.</p><p><code>AVB</code>设备在物理连接建立的过程中, 会交换设备的能力信息, 如果对端设备支持PTP, 则两个设备会开始同步时钟, 否则就形成一个时间同步域(该过程通过<a href="https://en.wikipedia.org/wiki/Spanning_Tree_Protocol">生成树算法</a>完成):</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/1024px-AVB-Ethernet-connections.png" alt="AVB domains"></p><p>要同步各个节点的时间, 首先, 每个网络节点需要知道消息在网络中传递的延迟, 在<code>gPTP</code>协议中有一个被称为<code>pDelay</code>衡量的过程: 确保节点都能准确知道其与邻近节点的消息传播延迟. 为了得到准确的<code>pDelay</code>值, 最好利用网卡硬件的时间戳而不是软件时间来进行时间采样. 时间同步的最后关键一步是, <code>Grand Master</code>需要发送<code>sync/folow-up</code>两个消息来完成与各个节点的时间同步. <code>gPTP</code>的整个功能如下图所示:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/how_gPTP_works.png" alt="how gPTP works"></p><h3 id="带宽预留-SRP"><a href="#带宽预留-SRP" class="headerlink" title="带宽预留-SRP"></a><strong>带宽预留-SRP</strong></h3><p><code>IEEE 802.1Qat Stream Reservation Protocol(SRP)</code>用于AVB网络中各个节点预分配带宽以满足音视频数据传输带宽的要求. 其大致流程是, <code>Talker</code>(数据发送节点)会发送广播消息到其他AVB节点, 告知有可用的数据流; 如果某个<code>Listener</code>(数据接收节点)需要接收数据流, 同样需要广播该消息, 如此所有节点(包括switch)会预留足够的带宽以确保数据流可以通过.如果预留失败, 则<code>SRP</code>的带宽预留请求失败. 通常, 对于A类(<code>class A</code>, 优先级最高)流量可以最多预留50%的带宽; B类流量(<code>class B</code>)流量预留20%的带宽.</p><blockquote><p>对于车载应用来说, SRP预留带宽失败是不可接受的(万一此时有摄像头需要传递比较关键的ADAS数据就悲剧了), 因此可以采取静态预留带宽的方式, 由各个节点在网卡初始化时提前预留带宽.</p></blockquote><p>对于带宽预留请求而言, 只需要一个唯一的64bit的<code>stream ID</code>即可; <code>stream ID</code>通常由<code>Talker</code>的MAC地址, 一个16bit由<code>Talker</code>分配的数值以及该<code>stream</code>的质量数据(包括数据流类型, 包速率以及每个包的长度)组成. 下图是非压缩的立体声音频数据在不同数据流类型下所需要预留的带宽:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/required_bandwidth_for_audio.png" alt="required bandwidth for stereo audio data"></p><p>SRP协议使用了一组协议, <a href="(https://en.wikipedia.org/wiki/Multiple_Registration_Protocol)"><code>MMRP(Multiple MAC Registration Protocol)</code></a>(以太网协议ID为<code>0x88F6</code>)用于控制分组注册, <code>MVRP(Multiple VLAN Registration Protocol)</code>(协议ID为<code>0x88F6</code>)用于VLAN组成员管理, <a href="https://en.wikipedia.org/wiki/Multiple_Registration_Protocol"><code>MSRP(Multiple Stream Registration Protocol)</code></a>(协议ID为<code>0x22EA</code>)用于数据流带宽的预留.</p><h3 id="数据流整形-FQTSS"><a href="#数据流整形-FQTSS" class="headerlink" title="数据流整形-FQTSS"></a><strong>数据流整形-FQTSS</strong></h3><p>AVB要求数据包在传输过程中不能出现丢包, 因此就要求网络中各个节点确保AVB数据包进行高效&#x2F;快速(确保延迟满足要求)转发， 同时为了能够有效利用带宽，保证普通的数据包（<code>Best Effort</code>)与AVB数据直接的公平性，引入了<code>IEEE 802.1Qav Forwarding and Queuing for Time-Sensitive Streams</code>(简称<code>FQTSS</code>)协议。<code>FQTSS</code>主要用于流整形（<code>traffic shaping</code>)， 其基于<a href="https://en.wikipedia.org/wiki/Credit-based_fair_queuing"><code>基于信用的流整形(credit-based shaper)</code></a>的算法，对数据流进行排队与转发; 通常来说， AVB流量优先级要高于普通流量， 而AVB中的A类流量优先级又要高于B类流量。</p><p>下图是<code>CBS</code>算法的一个示意图，AVB数据与非AVB数据(<code>Best Effort, BE</code>)的传输都受到当前<code>credit</code>值的影响：</p><ul><li>当<code>credit &gt;= 0</code>时，如果没有AVB数据， <code>credit</code>就会设为0; 否则持续发送AVB数据直到<code>credit</code>的值变为负（根据<code>sendSlope</code>开始减小)</li><li>当<code>credit &lt; 0</code>时， 发送普通的BE类数据, <code>credit</code>会基于<code>idleSlope</code>不断累积直到等于0</li><li><code>credit</code>的变化由<code>sendSlope</code>以及<code>idleSlope</code>两个值确定， <code>sendSlope</code>与<code>idleSlope</code>的关系如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sendSlope = idleSlope − portTransmitRate</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里<code>portTransmitRate</code>即端口的理论速率， 比如对于<code>1000Mbps</code>网络来说，该值为<code>10000bit/s</code>。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/credit-based_shaping_with_fqtss.png" alt="traffic shaping using FQTSS"></p><p>Linux的网络驱动中增加了一个<code>CBS</code>的流量控制模块（代码路径<code>kernel/net/sched/sched_cbs.c</code>)， 支持软件模拟网关中硬件的<code>CBS</code>算法， 同时还可以将算法卸负（<code>offload</code>）到网卡。 详细信息也可以参考<code>http://manpages.ubuntu.com/manpages/bionic/man8/tc-cbs.8.html</code>.</p><h2 id="Open-AVB"><a href="#Open-AVB" class="headerlink" title="Open-AVB"></a><strong>Open-AVB</strong></h2><p>早在2013年左右， TSN标准化机构<a href="https://avnu.org/"><code>AVNU</code></a>开发了一套开源的AVB协议栈<a href="https://github.com/Avnu/OpenAvnu"><code>openAVB</code></a>, 其实现了常见的AVB协议， 如<code>gPTP</code>&#x2F;<code>SRP</code>&#x2F;<code>FQTSS</code>&#x2F;<code>AVTP</code>&#x2F;<code>AVDECC</code>等。基于这套协议， 我们可以开发自己的AVB应用， 更多有关该<code>AVB</code>协议开发的一些信息可以参考官方文档<a href="http://avnu.github.io/OpenAvnu/avtp-pipeline/html/index.html">Open-AVB AVTP Pipeline SDK</a>.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://en.wikipedia.org/wiki/Time-Sensitive_Networking">Time Sensitive Networking</a></li><li><a href="http://avnu.github.io/OpenAvnu/avtp-pipeline/html/sdk_overview.html">OpenAVB SDK overview</a></li><li><a href="https://github.com/Avnu/OpenAvnu">OpenAvnm AVB protocol stack</a></li><li><a href="https://tsn.readthedocs.io/avb.html">Getting Started with AVB on linux</a></li><li><a href="https://source.codeaurora.org/quic/la/platform/external/Open-AVB">Codeaurora Open-AVB</a></li><li><a href="https://www.ieee802.org/1/pages/802.1ba.html">IEEE 802 AVB相关协议</a></li><li><a href="https://web.archive.org/web/20140405091013if_/http://www.avnu.org/files/static_page_files/AAF3193A-1D09-3519-AD45FC42893D1949/No-excuses%20Audio%20Video%20Networking%20v2.pdf">AVB诞生的一些历史</a></li><li><a href="https://www.ijeat.org/wp-content/uploads/papers/v9i1s5/A13801291S52019.pdf">Qualitative Examination of Credit Based Shaper in IEEE 802.1AVB</a></li><li><a href="https://avnu.org/wp-content/uploads/2014/05/AVnu-AAA2C_Types-of-Traffic-in-AVB-2_Michael-Johas-Teener-Markus-Jochim.pdf">Types of Traffic in AVB 2</a></li><li><a href="https://www.amazon.com/Automotive-Ethernet-Kirsten-Matheus/dp/1108841953">Automative Ethernet 3rd Edition</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是&lt;code&gt;Linux&lt;/code&gt;网络优化系列的第四篇文章，也是最后一篇了。最近有点忙，没有抽出时间来梳理这些知识点, 看了下文章历史，这个优化系列文章前后持续了大半年时间，今天总算达成了目标*_*。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;自从互联网诞生以来, 音视频(Audio&amp;#x2F;Video, AV)在网络上传输已经是稀松平常的事情. 那么, 为什么还需要一个新的基于以太网的协议来传输AV数据了? 传统的音视频传输都是点对点单向连接, 比如音频通常使用&lt;code&gt;I2S&lt;/code&gt;或&lt;code&gt;SPDIF/AES&lt;/code&gt;; 视频则使用&lt;code&gt;SDI&lt;/code&gt;或者&lt;code&gt;HDMI&lt;/code&gt;, 这种专用的单向连接在多设备情况下往往容易出现杂乱无章的连接线束:&lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="Linux" scheme="https://sniffer.site/tags/Linux/"/>
    
    <category term="AVB" scheme="https://sniffer.site/tags/AVB/"/>
    
    <category term="TSN" scheme="https://sniffer.site/tags/TSN/"/>
    
    <category term="网络优化" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>如何用FFmpeg在Android上实现音视频解码</title>
    <link href="https://sniffer.site/2022/09/30/%E5%A6%82%E4%BD%95%E7%94%A8FFMPEG%E5%9C%A8Android%E4%B8%8A%E5%81%9A%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81/"/>
    <id>https://sniffer.site/2022/09/30/%E5%A6%82%E4%BD%95%E7%94%A8FFMPEG%E5%9C%A8Android%E4%B8%8A%E5%81%9A%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81/</id>
    <published>2022-09-30T09:44:43.000Z</published>
    <updated>2022-10-09T09:06:49.348Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发投屏功能，需要对<code>H.264</code>视频数据流进行解码，然后显示出来。Android原生的<code>MediaCodec</code>虽然使用了硬件解码，但是延迟较大（超过300ms），无法满足要求。于是研究了下如何基于<a href="https://ffmpeg.org/">FFMPEG</a>来做视频流的软解码。这里对整个过程做简要的总结，看下如何在<code>Android Studio</code>中完成<code>FFMPEG</code>的视频解码: </p><ul><li>简单介绍下FFMPEG框架</li><li>如何利用交叉编译生成所需要的FFMPEG共享库, 以及如何进行<code>Android Studio</code>的配置</li><li>FFMPEG解码H264的大致调用流程</li></ul><span id="more"></span><h2 id="FFMPEG框架介绍"><a href="#FFMPEG框架介绍" class="headerlink" title="FFMPEG框架介绍"></a><strong>FFMPEG框架介绍</strong></h2><p><a href="https://en.wikipedia.org/wiki/FFmpeg">FFmpeg(Fast Forward mpeg)</a>是音视频编解码开源框架的标杆，支持常见音视频格式的编解码，如<code>H.264</code>&#x2F;<code>AAC</code>&#x2F;<code>H.265</code>&#x2F;<code>MP4</code>等，也支持不同格式之间的转码，同时还支持流媒体协议如<code>RTSP</code>&#x2F;<code>RTMP</code>。目前，不少视频网站如<code>Youtube</code>&#x2F;<code>Bilibili</code>等都是通过<code>FFmpeg</code>来实现音视频的处理的。</p><p>按功能模块划分，<code>FFmpeg</code>大致分为如下几个部分:</p><ul><li><code>libavcodec</code>: 包含了所有音视频编解码的核心代码</li><li><code>libavdevice</code>: 用于操作内部、外部音视频设备，以达到硬件加速&#x2F;显示&#x2F;加速等功能</li><li><code>libavfilter</code>: 音视频滤波器的开发，如宽高比、裁剪、格式化、非格式化、伸缩等</li><li><code>libavformat</code>： 用于解析各种不同的音视频封装格式</li><li><code>libavutil</code>： 包含公共的工具函数，如算术运算、字符操作等</li><li><code>libswresample</code>： 原始音频格式转码</li><li><code>libswscale</code>： 用于视频场景比例缩放、色彩映射转换、图像颜色空间或格式转换,如RGB565&#x2F;RGB888等与 YUV420等之间的转换。</li></ul><p>同时，<code>FFmpeg</code>源码中包含了<code>ffprobe</code>(用于分析音视频数据流)&#x2F;<code>ffplay</code>(基于<a href="https://www.libsdl.org/">SDL</a>的播放器)&#x2F;<code>ffmpeg</code>(视频转换工具)等常用的工具。初次使用<code>FFmepg</code>接口时，可以参考源码中的示例<code>doc/examples</code>, 里面给出了很多常见接口的使用方法。</p><p>更多有关<code>FFmpeg</code>的资料，可以参考:</p><ul><li><a href="https://blog.csdn.net/leixiaohua1020/category_1360795.html?spm=1001.2014.3001.5482">雷霄骅(leixiaohua1020)的专栏</a></li><li><a href="https://ffmpeg.org/">FFmpeg官方网站</a></li></ul><p>下面我们就来看下如何在<code>Ubuntu</code>环境中交叉编译<code>FFmpeg</code>到基于Android的<code>ARM64</code>平台架构上。</p><blockquote><p>我使用的编译环境是 Ubuntu 18.04 + Android ndk 22.1.7171670</p></blockquote><h2 id="交叉编译FFmpeg到Android平台"><a href="#交叉编译FFmpeg到Android平台" class="headerlink" title="交叉编译FFmpeg到Android平台"></a><strong>交叉编译FFmpeg到Android平台</strong></h2><p>首先通过<code>git</code>下载<code>FFmpeg</code>源码, 为确保功能稳定，编译使用的是最近发布版本分支<code>release/5.1</code>的代码: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git clone https://github.com/FFmpeg/FFmpeg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到5.1分支</span></span><br><span class="line">git checkout -b rel_5.1 origin/release/5.1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下载完后，可以通过<code>./configure -h</code>来查看各种编译配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Usage: configure [options]</span><br><span class="line">Options: [defaults in brackets after descriptions]</span><br><span class="line"></span><br><span class="line">Help options:</span><br><span class="line">  --help                   print this message</span><br><span class="line">  --quiet                  Suppress showing informative output</span><br><span class="line">  --list-decoders          show all available decoders</span><br><span class="line">  --list-encoders          show all available encoders</span><br><span class="line">  --list-hwaccels          show all available hardware accelerators</span><br><span class="line">  --list-demuxers          show all available demuxers</span><br><span class="line">  --list-muxers            show all available muxers</span><br><span class="line">  --list-parsers           show all available parsers</span><br><span class="line">  --list-protocols         show all available protocols</span><br><span class="line">  --list-bsfs              show all available bitstream filters</span><br><span class="line">  --list-indevs            show all available input devices</span><br><span class="line">  --list-outdevs           show all available output devices</span><br><span class="line">  --list-filters           show all available filters</span><br><span class="line"></span><br><span class="line">Standard options:</span><br><span class="line">  --logfile=FILE           log tests and output to FILE [ffbuild/config.log]</span><br><span class="line">  --disable-logging        do not log configure debug information</span><br><span class="line">  --fatal-warnings         fail if any configure warning is generated</span><br><span class="line">  --prefix=PREFIX          install in PREFIX [/usr/local]</span><br><span class="line">  --bindir=DIR             install binaries in DIR [PREFIX/bin]</span><br><span class="line">  --datadir=DIR            install data files in DIR [PREFIX/share/ffmpeg]</span><br><span class="line">  --docdir=DIR             install documentation in DIR [PREFIX/share/doc/ffmpeg]</span><br><span class="line">  --libdir=DIR             install libs in DIR [PREFIX/lib]</span><br><span class="line">  --shlibdir=DIR           install shared libs in DIR [LIBDIR]</span><br><span class="line">  --incdir=DIR             install includes in DIR [PREFIX/include]</span><br><span class="line">  --mandir=DIR             install man page in DIR [PREFIX/share/man]</span><br><span class="line">  --pkgconfigdir=DIR       install pkg-config files in DIR [LIBDIR/pkgconfig]</span><br><span class="line">  --enable-rpath           use rpath to allow installing libraries in paths</span><br><span class="line">                           not part of the dynamic linker search path</span><br><span class="line">                           use rpath when linking programs (USE WITH CARE)</span><br><span class="line">  --install-name-dir=DIR   Darwin directory name for installed targets</span><br><span class="line"></span><br><span class="line">Licensing options:</span><br><span class="line">  --enable-gpl             allow use of GPL code, the resulting libs</span><br><span class="line">                           and binaries will be under GPL [no]</span><br><span class="line">  --enable-version3        upgrade (L)GPL to version 3 [no]</span><br><span class="line">  --enable-nonfree         allow use of nonfree code, the resulting libs</span><br><span class="line">                           and binaries will be unredistributable [no]</span><br><span class="line"></span><br><span class="line">Configuration options:</span><br><span class="line">  --disable-static         do not build static libraries [no]</span><br><span class="line">  --enable-shared          build shared libraries [no]</span><br><span class="line">  --enable-small           optimize for size instead of speed</span><br><span class="line">  --disable-runtime-cpudetect disable detecting CPU capabilities at runtime (smaller binary)</span><br><span class="line">  --enable-gray            enable full grayscale support (slower color)</span><br><span class="line">  --disable-swscale-alpha  disable alpha channel support in swscale</span><br><span class="line">  --disable-all            disable building components, libraries and programs</span><br><span class="line">  --disable-autodetect     disable automatically detected external libraries [no]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，为了便于编译，我们需要写一个编译脚本<code>build_android.sh</code>，用于配置交叉编译的参数与环境变量(这里只编译了64位系统的库，如果要编译32位的库，修改下ARCH、CPU变量即可: <code>ARCH=arm; CPU=armv7-a</code>):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export NDK=/xxx/AndroidSDK/ndk/22.1.7171670</span><br><span class="line">TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">function build_android</span><br><span class="line">&#123;</span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--disable-postproc \</span><br><span class="line">--disable-debug \</span><br><span class="line">--disable-symver \</span><br><span class="line">--disable-static \</span><br><span class="line">--enable-shared \</span><br><span class="line">--disable-doc \</span><br><span class="line">--disable-ffmpeg \</span><br><span class="line">--cross-prefix=$CROSS_PREFIX \</span><br><span class="line">--target-os=android \</span><br><span class="line">--arch=$ARCH \</span><br><span class="line">--cpu=$CPU \</span><br><span class="line">--cc=$CC \</span><br><span class="line">--cxx=$CXX \</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--enable-gpl \</span><br><span class="line">--sysroot=$SYSROOT \</span><br><span class="line">--extra-cflags=&quot;-Os -fpic $OPTIMIZE_CFLAGS&quot; \</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--extra-ldflags=<span class="string">&quot;<span class="variable">$ADDI_LDFLAGS</span>&quot;</span></span></span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">echo &quot;============== build android arm64-v8a success ==============&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arm64-v8a</span></span><br><span class="line">ARCH=arm64</span><br><span class="line">CPU=armv8-a</span><br><span class="line">API=26</span><br><span class="line">CC=$TOOLCHAIN/bin/aarch64-linux-android$API-clang</span><br><span class="line">CXX=$TOOLCHAIN/bin/aarch64-linux-android$API-clang++</span><br><span class="line">SYSROOT=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot</span><br><span class="line">CROSS_PREFIX=$TOOLCHAIN/bin/aarch64-linux-android-</span><br><span class="line">PREFIX=$(pwd)/android/$CPU</span><br><span class="line">OPTIMIZE_CFLAGS=&quot;-march=$CPU&quot;</span><br><span class="line">ADDI_LDFLAGS=&quot;LDFLAGS=&#x27;-Wl,-z,relro -Wl,-z,now -pie&quot;</span><br><span class="line"></span><br><span class="line">echo $CC</span><br><span class="line"></span><br><span class="line">build_android</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行<code>chmod a+x ./build_android.sh; ./build_android.sh</code>就开始了编译。编译成功后，会有一个<code>android/armv8-a</code>的文件夹，里边包含了交叉编译生成的静态与动态库:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./android/armv8-a</span></span><br><span class="line"></span><br><span class="line">bin --&gt; 常用的工具，如`ffmpeg`, `ffprobe`</span><br><span class="line">lib --&gt; 共享库，如`libavcodec`,`libavformat`, `libswscale`等</span><br><span class="line">include --&gt; 包含所有开发所需的头文件</span><br><span class="line">share --&gt; 包含了相关示例与文档</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际开发时，我们只需要用到<code>include</code>&#x2F;<code>lib</code>两个目录中的文件即可。</p><h2 id="将共享库集成到Android-Studio"><a href="#将共享库集成到Android-Studio" class="headerlink" title="将共享库集成到Android Studio"></a><strong>将共享库集成到Android Studio</strong></h2><p>最开始配置的时候，把编译好的库放到<code>src/main/jniLibs/armv8-a</code>目录下面，编译虽然正常，但是运行时却找不到对应的库。只好新建一个目录<code>libs</code>将头文件跟预编译的库放在这里(参考<a href="https://developer.android.com/studio/projects/configure-cmake">配置CMAKE</a>):</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/as-ffmpeg-config.png" alt="FFmpeg config"></p><p>然后在<code>CMakeLists.txt</code>里添加对应的库与头文件:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">set</span>(ffmpeg_lib_dir ../../../../libs/arm64-v8a)</span><br><span class="line"><span class="built_in">set</span>(ffmpeg_head_dir ../../../../libs/arm64-v8a/include)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_library</span>( avcodec</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED)</span><br><span class="line"><span class="built_in">set_target_properties</span>(avcodec</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        $&#123;ffmpeg_lib_dir&#125;/libavcodec.so)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_library</span>( avformat</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED)</span><br><span class="line"><span class="built_in">set_target_properties</span>(avformat</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        $&#123;ffmpeg_lib_dir&#125;/libavformat.so)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_library</span>( avutil</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED)</span><br><span class="line"><span class="built_in">set_target_properties</span>(avutil</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        $&#123;ffmpeg_lib_dir&#125;/libavutil.so)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_library</span>( swscale</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED)</span><br><span class="line"><span class="built_in">set_target_properties</span>(swscale</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        $&#123;ffmpeg_lib_dir&#125;/libswscale.so)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">include_directories</span>(libs/arm64-v8a/include)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>开发使用的Android Studio的版本是<code>4.2.1</code>。</p></blockquote><p>配置完成就可以基于<code>FFmpeg</code>的接口开发了。下面我们简单来看看如何用<code>FFmpeg</code>解码<code>H264</code>的视频流。</p><h2 id="FFmpeg解码H264视频流"><a href="#FFmpeg解码H264视频流" class="headerlink" title="FFmpeg解码H264视频流"></a><strong>FFmpeg解码H264视频流</strong></h2><p>关于如何利用<code>FFmpeg</code>来解码音视频文件，网络上有很多参考资料了，比如:</p><ul><li>[FFmpeg官网参考代码]<a href="https://ffmpeg.org/doxygen/trunk/decode_video_8c-example.html">https://ffmpeg.org/doxygen/trunk/decode_video_8c-example.html</a></li><li><a href="https://www.sobyte.net/post/2022-03/android-ffmpeg/">基于Android的FFmpeg完整参考示例</a></li></ul><p>解码从网络端接收到的视频流，大致流程基本一致， 主要分为几个关键的步骤:</p><ul><li>初始化<code>FFmpeg</code>解码器, 如找到对应的解码器，配置解码器:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mVideoDecoder = <span class="built_in">avcodec_find_decoder</span>(AV_CODEC_ID_H264);</span><br><span class="line"><span class="keyword">if</span> (mVideoDecoder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;%s: fail to find h264 decoder&quot;</span>, __func__ );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mVCodecCtx = <span class="built_in">avcodec_alloc_context3</span>(mVideoDecoder);</span><br><span class="line"><span class="keyword">if</span> (mVCodecCtx == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;%s: fail to create codec context&quot;</span>, __func__ );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mVCodecCtx-&gt;flags |= AV_CODEC_FLAG_LOW_DELAY;</span><br><span class="line"><span class="comment">//mVCodecCtx-&gt;flags |= AV_CODEC_FLAG2_FAST;</span></span><br><span class="line"></span><br><span class="line">mVCodecCtx-&gt;width = mVideoW;</span><br><span class="line">mVCodecCtx-&gt;height = mVideoH;</span><br><span class="line">mVCodecCtx-&gt;bit_rate = IDecoder::BIT_RATE;</span><br><span class="line">mVCodecCtx-&gt;framerate = <span class="built_in">av_make_q</span>(IDecoder::FRAME_RATE, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(mVCodecCtx, mVideoDecoder, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;%s: Fail to open codec: %s&quot;</span>, __func__ , <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="built_in">avcodec_free_context</span>(&amp;mVCodecCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>将接收到的<code>H264</code>数据流分片NAL(<code>Network Abstraction Layer</code>)后，放入队列</li><li>解码线程从队列中取出数据包，然后解码;解码的过程大致分为四个步骤：<ul><li>发送待解码的数据报给解码器<code>avcodec_send_packet</code></li><li>从解码器接收解码后的包<code>avcodec_receive_frame</code></li><li>将解码的包从<code>YUV</code>格式转换为<code>RGB</code>格式</li><li>将<code>RGB</code>格式的视频帧拷贝到<code>Surface</code>进行渲染</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FFmpegDecoder::doDecode</span><span class="params">(h264_decode_struct *packet)</span> </span>&#123;</span><br><span class="line">    AVPacket *raw_packet = mDecoderResources-&gt;avPacket;</span><br><span class="line">    <span class="keyword">if</span> (raw_packet != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        raw_packet-&gt;data = packet-&gt;data;</span><br><span class="line">        raw_packet-&gt;size = packet-&gt;data_len;</span><br><span class="line">        raw_packet-&gt;pts = packet-&gt;pts;</span><br><span class="line">        <span class="comment">/* send raw packet to decode */</span></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">avcodec_send_packet</span>(mCodecCtx, raw_packet);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span> &amp;&amp; res != <span class="built_in">AVERROR</span>(EAGAIN)) &#123;</span><br><span class="line">            <span class="built_in">LOGE</span>(<span class="string">&quot;%s: Could not send video packet&quot;</span>, __func__ );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* decode frame */</span></span><br><span class="line">        AVFrame *frame = mDecoderResources-&gt;decodeFrame;</span><br><span class="line">        res = <span class="built_in">avcodec_receive_frame</span>(mCodecCtx, frame);</span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            <span class="built_in">LOGD</span>(<span class="string">&quot;%s: decoded frame pts = %lld, pixel-format = %d, picture-type = %d&quot;</span>, __func__ , (<span class="type">long</span> <span class="type">long</span>)frame-&gt;pts, frame-&gt;format, frame-&gt;pict_type);</span><br><span class="line">            <span class="keyword">if</span> (frame-&gt;width != mVideoW || frame-&gt;height != mVideoH) &#123;</span><br><span class="line">                <span class="built_in">LOGE</span>(<span class="string">&quot;%s: video size changed, drop frame&quot;</span>, __func__ );</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * render to Surface</span></span><br><span class="line"><span class="comment">             * decoded frame is YUV format which need to transform to RGB before rendering</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            AVFrame *rgb_frame = mDecoderResources-&gt;rgbFrame;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">av_image_fill_arrays</span>(rgb_frame-&gt;data, rgb_frame-&gt;linesize, mDecodeOutBuf, AV_PIX_FMT_RGBA,</span><br><span class="line">                                 mVideoW, mVideoH, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">SwsContext</span> *data_convert_ctx = <span class="built_in">sws_getContext</span>(mVideoW, mVideoH, mCodecCtx-&gt;pix_fmt,</span><br><span class="line">                                                                 mVideoW, mVideoH, AV_PIX_FMT_RGBA,</span><br><span class="line">                                                                 SWS_BICUBIC, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">            <span class="comment">/* from YUV to RGA */</span></span><br><span class="line">            res = <span class="built_in">sws_scale</span>(data_convert_ctx, (<span class="type">const</span> <span class="type">uint8_t</span> * <span class="type">const</span> *) frame-&gt;data, frame-&gt;linesize, <span class="number">0</span>,</span><br><span class="line">                            mVideoH, rgb_frame-&gt;data, rgb_frame-&gt;linesize);</span><br><span class="line">            <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">sws_freeContext</span>(data_convert_ctx);</span><br><span class="line">                <span class="built_in">LOGE</span>(<span class="string">&quot;%s: Fail to scale frame : %s&quot;</span>, __func__ , <span class="built_in">strerror</span>(errno));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* render to screen */</span></span><br><span class="line">                res = <span class="built_in">ANativeWindow_lock</span>(mNativeWin, mWindowBuf, <span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">LOGE</span>(<span class="string">&quot;%s: Fail to lock window&quot;</span>, __func__ );</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">uint8_t</span> *bits = (<span class="type">uint8_t</span> *) mWindowBuf-&gt;bits;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mVideoH; ++i) &#123;</span><br><span class="line">                        <span class="built_in">memcpy</span>(bits + i * mWindowBuf-&gt;stride * <span class="number">4</span>,</span><br><span class="line">                               mDecodeOutBuf + i * rgb_frame-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                               rgb_frame-&gt;linesize[<span class="number">0</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">ANativeWindow_unlockAndPost</span>(mNativeWin);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sws_freeContext</span>(data_convert_ctx);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LOGE</span>(<span class="string">&quot;%s: fail to receive frame %d&quot;</span>, __func__ , res);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相比Android原生的<code>MediaCodec</code>硬解码，<code>FFmpeg</code>解码效率提升了很多，延迟从原来的<code>400+ms</code>减少到了<code>100ms</code>左右，改善明显。但是由于使用了CPU进行解码操作，系统的负载与CPU使用率都会有所升高。因此，在进行高清视频的解码时硬解码会更合适。</p><p>总结下来，<code>FFmpeg</code>框架确实十分强大，也有比较完善的生态社区，可以说是搞音视频开发必不可少的利器。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://www.sobyte.net/post/2022-03/android-ffmpeg/">https://www.sobyte.net/post/2022-03/android-ffmpeg/</a></li><li><a href="https://trac.ffmpeg.org/wiki/CompilationGuide/Android">https://trac.ffmpeg.org/wiki/CompilationGuide/Android</a></li><li><a href="https://yumichan.net/video-processing/video-compression/introduction-to-h264-nal-unit/">https://yumichan.net/video-processing/video-compression/introduction-to-h264-nal-unit/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近开发投屏功能，需要对&lt;code&gt;H.264&lt;/code&gt;视频数据流进行解码，然后显示出来。Android原生的&lt;code&gt;MediaCodec&lt;/code&gt;虽然使用了硬件解码，但是延迟较大（超过300ms），无法满足要求。于是研究了下如何基于&lt;a href=&quot;https://ffmpeg.org/&quot;&gt;FFMPEG&lt;/a&gt;来做视频流的软解码。这里对整个过程做简要的总结，看下如何在&lt;code&gt;Android Studio&lt;/code&gt;中完成&lt;code&gt;FFMPEG&lt;/code&gt;的视频解码: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单介绍下FFMPEG框架&lt;/li&gt;
&lt;li&gt;如何利用交叉编译生成所需要的FFMPEG共享库, 以及如何进行&lt;code&gt;Android Studio&lt;/code&gt;的配置&lt;/li&gt;
&lt;li&gt;FFMPEG解码H264的大致调用流程&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Android" scheme="https://sniffer.site/categories/Android/"/>
    
    
    <category term="Android" scheme="https://sniffer.site/tags/Android/"/>
    
    <category term="FFmpeg" scheme="https://sniffer.site/tags/FFmpeg/"/>
    
    <category term="H.264" scheme="https://sniffer.site/tags/H-264/"/>
    
    <category term="音视频" scheme="https://sniffer.site/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>如何通过QEMU启动Linux系统</title>
    <link href="https://sniffer.site/2022/08/27/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87QEMU%E5%90%AF%E5%8A%A8Linux%E7%B3%BB%E7%BB%9F/"/>
    <id>https://sniffer.site/2022/08/27/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87QEMU%E5%90%AF%E5%8A%A8Linux%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-08-27T12:00:03.000Z</published>
    <updated>2022-08-30T02:57:23.387Z</updated>
    
    <content type="html"><![CDATA[<p>看Linux驱动相关的代码， 却没有一个好的调试环境可以跟踪内核相关的调用流程。于是，想着用QEMU虚拟机来搭建一个Linux系统。花了大半天时间，终于能够启动一个简单的Linux系统了。中间踩了不少坑，找了不少资料，这里简单总结下整个过程。</p><blockquote><p>以下操作都是基于Ubuntu 18.04 x86_64平台</p></blockquote><p>最开始参考了<a href="https://yuankun.me/posts/running-raw-linux-kernel-in-qemu/">如何使用QEMU跑内核</a>，使用系统自带的QEMU工具，结果提示如下错误:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">qemu-system-aarch64 rom check and register reset failed</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>怀疑是QEMU的版本太低导致，于是只好又重新编译QEMU源码，最后总算大功告成。总的说来，大致要做的事情有这么几个:</p><ul><li>编译Linux内核，利用busybox来生成一个小的rootfs（关于什么是rootfs，可以参考<a href="https://tldp.org/LDP/sag/html/root-fs.html">The rootfs FS</a>)</li><li>编译QEMU，确保正常配置ARM64架构的虚拟环境</li><li>一切就绪，通过<code>qemu-system-aarch64</code>跑起来虚拟机来</li></ul><span id="more"></span><h2 id="编译Linux内核"><a href="#编译Linux内核" class="headerlink" title="编译Linux内核"></a><strong>编译Linux内核</strong></h2><p>交叉编译Linux内核，需要确保系统中存在必须的编译环境与工具:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install binutils-multiarch</span><br><span class="line">sudo apt-get install ncurses-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install gcc-aarch64-linux-gnu</span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">拷贝源码`git <span class="built_in">clone</span> https://github.com/torvalds/linux`， 进入对应目录, 执行:</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment">#创建编译目录，用于输出产物</span></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"></span><br><span class="line">make distclean</span><br><span class="line">make O=./build ARCH=arm64 defconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果需要编辑某些config，可以使用menuconfig来配置</span></span><br><span class="line">make O=./build ARCH=arm64 nconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">make O=./build ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j8</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译成功后，会在<code>arch/arm64/boot</code>下面生成内核镜像:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-rw-rw-r-- 1 jason jason 36M Aug 25 14:20 <span class="built_in">arch</span>/arm64/boot/Image</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个就是后面用于跑Linux内核的镜像文件。</p><h2 id="编译Qemu源码"><a href="#编译Qemu源码" class="headerlink" title="编译Qemu源码"></a><strong>编译Qemu源码</strong></h2><p>编译QEMU比较方便，先下载源码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/qemu/qemu</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> qemu</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">../configure</span><br><span class="line">make -j16</span><br><span class="line"></span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译大概会持续十几分钟的样子，最后记得编译完成后执行<code>make install</code>, 否则在最后启动虚拟机时会提示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">qemu-system-aarch64: failed to find romfile <span class="string">&quot;efi-virtio.rom&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编译Busybox-制作rootfs"><a href="#编译Busybox-制作rootfs" class="headerlink" title="编译Busybox,制作rootfs"></a><strong>编译Busybox,制作rootfs</strong></h2><p>编译Busybox稍微麻烦一点，需要编辑配置列表，确保生成的是静态库形式的执行文件, 大概有这么几个步骤:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"></span><br><span class="line">make O=../build/ ARCH=arm64 defconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过菜单配置config</span></span><br><span class="line">make O=../build/ ARCH=arm64 menuconfig</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/busybox_menuconfig.png" alt="busybox menuconfig"></p><p>菜单配置的方式与Linux内核的配置类似，按下<code>/</code>可以直接搜索你要设置的选项; 如果觉得菜单配置比较麻烦，也可以通过直接编辑生成的<code>.config</code>来配置选项编译为静态的方式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CONFIG_STATIC=y</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完成配置后，执行编译:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j16</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>busybox/_install</code>下面可以看到编译的产物。有了busybox我们就可以制作一个简单的rootfs文件系统了。对于busybox的系统来说，大致的启动顺序如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/sbin/init --&gt; /etc/inittab --&gt; /etc/init.d/rcS --&gt; /etc/fstab</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进入<code>busybox/_install</code>目录可以看到当前生成的目录结构:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4.0K./proc</span><br><span class="line">1.9M./bin</span><br><span class="line">16K./etc</span><br><span class="line">4.0K./tmp</span><br><span class="line">4.0K./root</span><br><span class="line">4.0K./sys</span><br><span class="line">4.0K./home</span><br><span class="line">4.0K./var</span><br><span class="line">4.0K./lib</span><br><span class="line">4.0K./mnt</span><br><span class="line">12K./usr</span><br><span class="line">4.0K./sbin</span><br><span class="line">12K./dev</span><br><span class="line">34M./</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>制作一个rootfs，可以按照如下几个步骤操作:</p><ul><li>创建目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建必要的目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p dev etc home lib mnt proc root sys tmp var</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>生成启动所需的文件</p><ul><li>etc&#x2F;inittab: 将如下内容写入到该文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::respawn:-/bin/sh</span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line">::cttlaltdel:/bin/umount -a -r</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编辑完成后，修改文件权限: <code>chmod 0755 etc/inittab</code></p><ul><li>etc&#x2F;init.d: 系统初始化脚本，可以用于创建设备以及执行文件系统挂载等操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p etc/init.d/</span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑rcS文件,输入如下内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;mount pseudo sys&quot;</span></span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">/sbin/mdev -s</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;init rc done&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了确保该文件正常执行，需要修改权限<code>chmod 0755 etc/init.d/rcS</code>. 如果除了上述<code>proc/sys</code>文件系统外，还有其他需要挂载的设备，可以放在<code>etc/fstab</code>中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">temps/tmp  rpoc  defaults 0 0</span><br><span class="line">none /tmp  ramfs defaults 0 0</span><br><span class="line">mdev /dev  ramfs defaults 0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>创建特殊文件节点</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cd</span> dev</span><br><span class="line">sudo <span class="built_in">mknod</span> console c 5 1</span><br><span class="line">sudo <span class="built_in">mknod</span> null c 1 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>将该目录的文件打包成rootfs压缩文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">find . | cpio -o -H newc &gt; rootfs.cpio </span><br><span class="line">gzip -c rootfs.cpio &gt; rootfs.cpio.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>到这里，所有的准备工作就绪了，就下来可以测试下虚拟机是否正常能跑起来了.</p><h2 id="QEMU跑起来"><a href="#QEMU跑起来" class="headerlink" title="QEMU跑起来"></a><strong>QEMU跑起来</strong></h2><p>执行如下命令，启动Linux虚拟机(具体的参数可以通过<code>qemu-system-aarch64 -h</code>查看)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">qemu-system-aarch64 \</span><br><span class="line">    -machine virt \</span><br><span class="line">    -cpu cortex-a57 \</span><br><span class="line">    -nographic -smp 1 \</span><br><span class="line">    -kernel ./Image \</span><br><span class="line">    -initrd ./rootfs.cpio.gz \</span><br><span class="line">    -append <span class="string">&quot;rdinit=/linuxrc console=ttyAMA0&quot;</span> \</span><br><span class="line">    -s <span class="comment"># 开启GDB TCP调试口</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正常启动的话，可以看到内核加载的日志以及一个虚拟的终端设备:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qemu-virt-linux.png" alt="Qemu Virt linux"></p><p>有了这个虚拟环境，无论是驱动开发，还是学习Linux内核都会方便很多了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://yuankun.me/posts/running-raw-linux-kernel-in-qemu/">https://yuankun.me/posts/running-raw-linux-kernel-in-qemu/</a></li><li><a href="https://ops.tips/notes/booting-linux-on-qemu/">https://ops.tips/notes/booting-linux-on-qemu/</a></li><li><a href="https://gts3.org/2017/cross-kernel.html">https://gts3.org/2017/cross-kernel.html</a></li><li><a href="http://events17.linuxfoundation.org/sites/events/files/slides/Shuah_Khan_cross_compile_linux.pdf">http://events17.linuxfoundation.org/sites/events/files/slides/Shuah_Khan_cross_compile_linux.pdf</a></li><li><a href="https://android.googlesource.com/platform/external/syzkaller/+/HEAD/docs/linux/setup_linux-host_qemu-vm_arm64-kernel.md">https://android.googlesource.com/platform/external/syzkaller/+/HEAD/docs/linux/setup_linux-host_qemu-vm_arm64-kernel.md</a></li><li><a href="http://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/">http://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;看Linux驱动相关的代码， 却没有一个好的调试环境可以跟踪内核相关的调用流程。于是，想着用QEMU虚拟机来搭建一个Linux系统。花了大半天时间，终于能够启动一个简单的Linux系统了。中间踩了不少坑，找了不少资料，这里简单总结下整个过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下操作都是基于Ubuntu 18.04 x86_64平台&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最开始参考了&lt;a href=&quot;https://yuankun.me/posts/running-raw-linux-kernel-in-qemu/&quot;&gt;如何使用QEMU跑内核&lt;/a&gt;，使用系统自带的QEMU工具，结果提示如下错误:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;qemu-system-aarch64 rom check and register reset failed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;怀疑是QEMU的版本太低导致，于是只好又重新编译QEMU源码，最后总算大功告成。总的说来，大致要做的事情有这么几个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译Linux内核，利用busybox来生成一个小的rootfs（关于什么是rootfs，可以参考&lt;a href=&quot;https://tldp.org/LDP/sag/html/root-fs.html&quot;&gt;The rootfs FS&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;编译QEMU，确保正常配置ARM64架构的虚拟环境&lt;/li&gt;
&lt;li&gt;一切就绪，通过&lt;code&gt;qemu-system-aarch64&lt;/code&gt;跑起来虚拟机来&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://sniffer.site/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://sniffer.site/tags/Linux/"/>
    
    <category term="Kernel" scheme="https://sniffer.site/tags/Kernel/"/>
    
    <category term="Qemu" scheme="https://sniffer.site/tags/Qemu/"/>
    
    <category term="busybox" scheme="https://sniffer.site/tags/busybox/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络优化之DPDK与XDP</title>
    <link href="https://sniffer.site/2022/08/12/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BDPDK%E4%B8%8EXDP/"/>
    <id>https://sniffer.site/2022/08/12/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BDPDK%E4%B8%8EXDP/</id>
    <published>2022-08-12T05:45:40.000Z</published>
    <updated>2022-08-12T05:56:20.588Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的一篇文章<a href="https://sniffer.site/2022/04/13/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/">Linux网络优化之链路层优化</a>中，我们已经看到，随着网卡速率超过<code>1Gbps</code>，增加到<code>10Gbps/100Gbps</code>时，CPU已经很难处理如此大量的数据包了。总结来说，主要有如下瓶颈：</p><ul><li>内核协议栈处理在<code>L3(IP)/L4(TCP)</code>的数据处理上，消耗了比较多的时间，会导致网络延迟与传输受限</li><li>高速网卡会在短时间内产生大量中断，导致CPU频繁发生上下文切换，性能收到影响，进而影响网络吞吐</li></ul><p>针对<code>10Gbps/100Gbps</code>等高速网卡中存在的延迟与带宽受限问题，<a href="https://en.wikipedia.org/wiki/Data_Plane_Development_Kit">Intel在2010年提出了<code>DPDK(Data Plane Development Kit)</code>基于用户空间的解决方案</a>，并开源了实现方案, 目前<code>DPDK</code>支持包括Intel&#x2F;ARM等多个芯片架构的指令集; 同样是Intel的工程师在2018年提出了<code>XDP(eXpress Data Path)</code>，与<code>DPDK</code>不一样的是，<code>XDP</code>基于现有内核<code>socket</code>接口，与<code>eBPF</code>相结合实现网卡与用户空间的数据传输，从而避免了内核协议栈的处理延迟。</p><span id="more"></span><p>下面我们来简单看下<code>DPDK</code>与<code>XDP</code>的实现原理。</p><blockquote><p>本文主要是简要介绍基本原理，收集一些参考资料</p></blockquote><h2 id="DPDK-Data-Plane-Development-Kit"><a href="#DPDK-Data-Plane-Development-Kit" class="headerlink" title="DPDK(Data Plane Development Kit)"></a><strong>DPDK(Data Plane Development Kit)</strong></h2><p><code>DPDK</code>是由一系列开源库组成的用于网络加速的工具集，其提供了数据平面(<code>data-plane</code>)以及用户空间基于poll模式的网卡驱动，以跳过内核<code>TCP/IP</code>协议栈， 加速网络数据的传输。<code>DPDK</code>为如<code>PowerPC</code>&#x2F;<code>Arm</code>&#x2F;<code>x86</code>等多个平台提供了一个框架，用于高速网络情况的数据处理，常用在数据中心节点之间的数据传输。</p><p><img src="https://www.accton.com/wp-content/uploads/2018/07/linux-kernel-w-DPDK-800x524.png" alt="DPDK in linux kernel"></p><p>有关更多<code>DPDK</code>实现原理与细节可以参考如下资料:</p><ul><li><a href="https://en.wikipedia.org/wiki/Data_Plane_Development_Kit">Wikipedia DPDK</a></li><li><a href="https://lwn.net/Articles/725254/">Network Acceleration with DPDK</a></li><li><a href="https://doc.dpdk.org/guides/linux_gsg/index.html">Linux development Guide</a></li><li><a href="https://www.cse.iitb.ac.in/~mythili/os/anno_slides/DPDK_deep_dive_slides.pdf">Deep-dive into DPDK</a></li><li><a href="https://www.intel.com/content/www/us/en/developer/articles/code-sample/introduction-to-the-dpdk-sample-applications.html">DPDK Sample Applications</a></li><li><a href="https://github.com/DPDK/dpdk">DPDK source code</a></li></ul><h2 id="XDP-eXpress-Data-Path"><a href="#XDP-eXpress-Data-Path" class="headerlink" title="XDP(eXpress Data Path)"></a><strong>XDP(eXpress Data Path)</strong></h2><p><code>XDP</code>方案与<code>DPDK</code>类似，都是尝试跳过内核协议栈从而加速数据包的处理，只不过<code>XDP</code>是基于内核已有的<code>socket</code>接口来实现，其增加了一个<code>AF_XDP</code>的地址类型，用户进程可以通过<code>AF_XDP</code>的接口来实现与内核的交互， 比如映射接收数据包的共享内存，加载接收网卡数据包的<code>BPF</code>内核程序(有关内核BFP可以参考<a href="https://sniffer.site/2019/11/07/bpf%E4%B8%8Eebpf/">BPF与eBPF</a>)。</p><p><img src="https://www.iovisor.org/wp-content/uploads/sites/8/2016/09/xdp-packet-processing-768x420.png" alt="XDP"></p><p>从<code>XDP</code>的实现原理来说，相比于<code>DPDK</code>， <code>XDP</code>更贴近Linux内核，因而使用起来更为方便，而且其总体性能可以接近于<code>DPDK</code>。有关<code>XDP</code>实现原理与细节可以参考如下资料:</p><ul><li><a href="https://www.iovisor.org/technology/xdp">Introduction to XDP</a></li><li><a href="https://lwn.net/Articles/750845/">Accelerating networking with AF_XDP</a></li><li><a href="https://www.kernel.org/doc/html/v4.18/networking/af_xdp.html">Kernel networking-XDP</a></li><li><a href="https://blog.cloudflare.com/l4drop-xdp-ebpf-based-ddos-mitigations/">DDos Mitigations based on XDP</a></li><li><a href="https://developers.redhat.com/blog/2021/04/01/get-started-with-xdp">Get started with XDP</a></li><li><a href="https://lwn.net/Articles/750293/">AF_XDP kernel patch</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://www.iovisor.org/technology/xdp">Introduction to XDP</a></li><li><a href="https://www.accton.com/Technology-Brief/intel-dpdk-performance-on-the-sau5081i-server/">Intel® DPDK Performance on the SAU5081I Server</a></li><li><a href="https://lwn.net/Articles/725254/">Network acceleration with DPDK</a></li><li><a href="https://lwn.net/Articles/750845/">Accelerating networking with AF_XDP</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面的一篇文章&lt;a href=&quot;https://sniffer.site/2022/04/13/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/&quot;&gt;Linux网络优化之链路层优化&lt;/a&gt;中，我们已经看到，随着网卡速率超过&lt;code&gt;1Gbps&lt;/code&gt;，增加到&lt;code&gt;10Gbps/100Gbps&lt;/code&gt;时，CPU已经很难处理如此大量的数据包了。总结来说，主要有如下瓶颈：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核协议栈处理在&lt;code&gt;L3(IP)/L4(TCP)&lt;/code&gt;的数据处理上，消耗了比较多的时间，会导致网络延迟与传输受限&lt;/li&gt;
&lt;li&gt;高速网卡会在短时间内产生大量中断，导致CPU频繁发生上下文切换，性能收到影响，进而影响网络吞吐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对&lt;code&gt;10Gbps/100Gbps&lt;/code&gt;等高速网卡中存在的延迟与带宽受限问题，&lt;a href=&quot;https://en.wikipedia.org/wiki/Data_Plane_Development_Kit&quot;&gt;Intel在2010年提出了&lt;code&gt;DPDK(Data Plane Development Kit)&lt;/code&gt;基于用户空间的解决方案&lt;/a&gt;，并开源了实现方案, 目前&lt;code&gt;DPDK&lt;/code&gt;支持包括Intel&amp;#x2F;ARM等多个芯片架构的指令集; 同样是Intel的工程师在2018年提出了&lt;code&gt;XDP(eXpress Data Path)&lt;/code&gt;，与&lt;code&gt;DPDK&lt;/code&gt;不一样的是，&lt;code&gt;XDP&lt;/code&gt;基于现有内核&lt;code&gt;socket&lt;/code&gt;接口，与&lt;code&gt;eBPF&lt;/code&gt;相结合实现网卡与用户空间的数据传输，从而避免了内核协议栈的处理延迟。&lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="Linux" scheme="https://sniffer.site/tags/Linux/"/>
    
    <category term="网络优化" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    
    <category term="DPDK" scheme="https://sniffer.site/tags/DPDK/"/>
    
    <category term="XDP" scheme="https://sniffer.site/tags/XDP/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络优化之TCP优化</title>
    <link href="https://sniffer.site/2022/06/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BTCP%E4%BC%98%E5%8C%96/"/>
    <id>https://sniffer.site/2022/06/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BTCP%E4%BC%98%E5%8C%96/</id>
    <published>2022-06-06T05:43:24.000Z</published>
    <updated>2022-06-06T05:53:47.023Z</updated>
    
    <content type="html"><![CDATA[<p>TCP(<code>Transmision Control Protocol</code>)即传输控制协议, 位于TCP&#x2F;IP协议栈的第三层(L3), 是一种提供了可靠连接的字节流协议; TCP是目前使用最为广泛的协议之一, HTTP&#x2F;MQTT&#x2F;FTP等诸多应用层协议都是基于TCP实现的, 更多关于TCP协议相关的具体内容可以参考标准文档<a href="https://datatracker.ietf.org/doc/html/rfc793">RFC793</a>以及早前写的一篇<a href="https://sniffer.site/2019/07/30/%E8%81%8A%E4%B8%80%E8%81%8Atcp%E5%8D%8F%E8%AE%AE/">聊一聊TCP协议</a>. </p><p>在上一篇文章中讲到了高速以太网如1Gbps&#x2F;10Gpbs中<a href="https://sniffer.site/2022/04/13/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/">Linux网络L2(链路层)</a>的一些优化方法, 包括了<code>offload(卸荷)</code>以及<code>scaling(缩放)</code>两种技术. 随着高速网络的不断普及, 1Gbps&#x2F;10Gpbs以太网已经被广泛使用, 40Gbps&#x2F;100Gbps也已经制定标准, TCP也在随着网络带宽的提升而不断进化.这篇文章我们就来看下如何在高速以太网下对TCP相关的参数的进行调优.</p><span id="more"></span><h2 id="TCP窗口大小"><a href="#TCP窗口大小" class="headerlink" title="TCP窗口大小"></a><strong>TCP窗口大小</strong></h2><p>TCP为了协调客户端与服务端数据的发送&#x2F;接收, 使用窗口机制来确保两者保持一致的速率, 确保快速的发送方不会超过慢速的接收方. 接收方需要通过窗口更新(<code>Window Update</code>)消息来告知发送方当前可以发送多少数据. 当接收方应用处理数据时, 可向发送方发送<code>窗口更新消息</code>; 窗口更新消息最快需要一个返回时间(<code>RTT-Round Trip Time</code>), 因此窗口越大, 同一个RTT可以接收的数据就越多; 类似地, RTT越大, 则同样的时间可以接收的数据会越少. 为此, 我们可以得到如下公式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">吞吐量 &lt;= 窗口大小/RTT</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TCP原始设计中, 窗口大小为<code>65535</code>字节(64KiB - 1), 这是发送方在收到窗口更新之前允许发送的最大数据量. 但随着网络带宽越来越高, 1Gbps&#x2F;10Gbps的网络已经得到广泛使用, 这个窗口值无法让高速网络的带宽得到有效利用. 为了让高速网络的带宽得到充分利用, 一般需要通过带宽时延成乘积BDP(<code>Bandwidth-delay product</code>)公式来计算真实的TCP窗口大小.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BDP（位）= 带宽（位/秒）* RTT（秒）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假如, 我们有一个<code>1Gbps</code>的网络, RTT为<code>10ms</code>, 通过BDP公式可以大致计算出网络实际的带宽:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">带宽(bit/s) = BDP/RTT </span><br><span class="line">           = (65535Byte * 8bit/Byte)/10ms</span><br><span class="line">           = 524280 bit/0.01s</span><br><span class="line">           = 5242800 bit/s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也就是说, 如果按照TCP原始的<code>64KiB</code>的窗口设定, 一个千兆网络的实际吞吐量才不到50Mbps, 这远没有达到1000Mbps的理论值. 那么, 要如何解决这个问题了? 标准协议通过增加一个窗口缩放选项来扩张TCP窗口大小.</p><h3 id="TCP窗口缩放"><a href="#TCP窗口缩放" class="headerlink" title="TCP窗口缩放"></a><strong>TCP窗口缩放</strong></h3><p>为了改变TCP原有设计对窗口大小的限定, <a href="https://datatracker.ietf.org/doc/html/rfc7323">RFC7323</a>引入了扩展协议, 在TCP头中增加一个<code>Window Scaling Factor</code>的参数, 可以使窗口大小扩展到<code>1,073,725,440</code>字节(接近1GiB).具体可以参考<a href="https://datatracker.ietf.org/doc/html/rfc7323">RFC7323</a>中的说明.</p><p>要在Linux中确认是否开启了窗口缩放功能, 可以通过命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo sysctl net.ipv4.tcp_window_scaling</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果这个值为<code>1</code>, 则表示开启了该选项(看4.4的内核版本已经默认打开了)；如果没有打开, 要开启该选项, 只需要通过下述命令打开即可:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo sysctl -w net.ipv4.tcp_window_scaling=1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="调整TCP窗口大小"><a href="#调整TCP窗口大小" class="headerlink" title="调整TCP窗口大小"></a><strong>调整TCP窗口大小</strong></h2><p>现在开启了窗口缩放选项, 我们就可以根据<code>BDP</code>来计算给定理论带宽与延迟情况下, 对应的TCP窗口大小了. 还是以<code>1Gbps</code>网络为例, 假设延迟(可以通过ping来大致判断)为<code>3ms</code>, 那么对应的窗口大小应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">窗口大小 = (理论带宽 * 延迟)/8bit</span><br><span class="line">       = (1000Mbps * 0.03)/8bit</span><br><span class="line">       = 3750000b</span><br><span class="line">       = 3.6Mb</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是说至少需要将TCP窗口的大小设置为<code>3.6Mb</code>大小才能确保实际吞吐量达到网络的理论带宽. 在Linux中, 一般需要设置如下几个参数来设定TCP窗口大小:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">net.core.rmem_max</span><br><span class="line">net.core.wmem_max</span><br><span class="line">net.ipv4.tcp_rmem</span><br><span class="line">net.ipv4.tcp_wmem</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中前两个参数<code>rmem_max/wmem_max</code>表示应用最大可用的TCP窗口大小, <code>tcp_rmem</code>&#x2F;<code>tcp_wmem</code>表示单个应用允许分配的最大TCP窗口大小(对应有三个值, 分别表示最小&#x2F;默认&#x2F;最大的TCP窗口大小). 为了保证TCP的性能与理论比较接近, 我们可以将上述四个参数都按照上述计算得到的TCP窗口进行设定:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MaxExpectedBDP=3750000</span><br><span class="line">sudo sysctl -w net.core.rmem_max=$MaxExpectedBDP</span><br><span class="line">sudo sysctl -w net.core.wmem_max=$MaxExpectedBDP</span><br><span class="line">sudo sysctl -w net.ipv4.tcp_rmem=&quot;4096 87380 $MaxExpectedBDP&quot;</span><br><span class="line">sudo sysctl -w net.ipv4.tcp_wmem=&quot;4096 16384 $MaxExpectedBDP&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者可以通过直接写对应<code>/proc</code>的文件节点来设定上述参数, 如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MaxExpectedBDP=3750000</span><br><span class="line">echo $MaxExpectedBDP &gt; /proc/sys/net/core/wmem_max;</span><br><span class="line">echo $MaxExpectedBDP &gt; /proc/sys/net/core/rmem_max;</span><br><span class="line">echo 4096 1048576 $MaxExpectedBDP &gt; /proc/sys/net/ipv4/tcp_rmem;</span><br><span class="line">echo 4096 1048576 $MaxExpectedBDP &gt; /proc/sys/net/ipv4/tcp_wmem;</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/tcp_window_scaling;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了上述根据<code>BDP</code>公式来优化TCP窗口大小之外, 对于高速以太网, 通常还可以通过开启TCP时间戳(增加一次往返RTT时间的估算准确度), 对TCP头进行压缩(减少TCP传输数据的大小)等方式来优化, 具体可以参考<a href="https://datatracker.ietf.org/doc/html/rfc7323">RFC7323</a>.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>本文首先介绍了TCP在高速网络中需要解决的窗口不足的问题， 然后阐述了TCP标准协议是如何解决该问题的。接着着重说明了如何在Linux中配置TCP参数，确保TCP性能达到最优。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://en.wikipedia.org/wiki/TCP_tuning">TCP参数优化</a></li><li><a href="https://cloud.google.com/architecture/tcp-optimization-for-network-performance-in-gcp-and-hybrid">Google云服务器TCP参数调优</a></li><li><a href="https://datatracker.ietf.org/doc/html/rfc7323">TCP Extensions for High Performance</a></li><li><a href="https://datatracker.ietf.org/doc/html/rfc7414">A Roadmap for Transmission Control Protocol</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;TCP(&lt;code&gt;Transmision Control Protocol&lt;/code&gt;)即传输控制协议, 位于TCP&amp;#x2F;IP协议栈的第三层(L3), 是一种提供了可靠连接的字节流协议; TCP是目前使用最为广泛的协议之一, HTTP&amp;#x2F;MQTT&amp;#x2F;FTP等诸多应用层协议都是基于TCP实现的, 更多关于TCP协议相关的具体内容可以参考标准文档&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc793&quot;&gt;RFC793&lt;/a&gt;以及早前写的一篇&lt;a href=&quot;https://sniffer.site/2019/07/30/%E8%81%8A%E4%B8%80%E8%81%8Atcp%E5%8D%8F%E8%AE%AE/&quot;&gt;聊一聊TCP协议&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;在上一篇文章中讲到了高速以太网如1Gbps&amp;#x2F;10Gpbs中&lt;a href=&quot;https://sniffer.site/2022/04/13/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/&quot;&gt;Linux网络L2(链路层)&lt;/a&gt;的一些优化方法, 包括了&lt;code&gt;offload(卸荷)&lt;/code&gt;以及&lt;code&gt;scaling(缩放)&lt;/code&gt;两种技术. 随着高速网络的不断普及, 1Gbps&amp;#x2F;10Gpbs以太网已经被广泛使用, 40Gbps&amp;#x2F;100Gbps也已经制定标准, TCP也在随着网络带宽的提升而不断进化.这篇文章我们就来看下如何在高速以太网下对TCP相关的参数的进行调优.&lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="Linux" scheme="https://sniffer.site/tags/Linux/"/>
    
    <category term="网络优化" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    
    <category term="TCP" scheme="https://sniffer.site/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络优化之链路层优化</title>
    <link href="https://sniffer.site/2022/04/13/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/"/>
    <id>https://sniffer.site/2022/04/13/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/</id>
    <published>2022-04-13T11:51:44.000Z</published>
    <updated>2022-12-06T10:25:39.928Z</updated>
    
    <content type="html"><![CDATA[<p>现在车内网络都开始内卷到<code>1Gbps</code>了, 有同学给我反馈说以太网的吞吐量上不来, 跟理论带宽差距很大, 之前虽然优化了一波<code>TCP</code>相关的参数, 但估计不能解决全部问题. 遂决定重新学习下网络优化, 从底层链路对开发平台上的网络进行改善. 趁着这个机会, 索性写一个系列文章-Linux网络优化, 用来总结下Linux网络优化的一些方法与技术, 目前计划从如下几篇文章展开(希望不要放飞了):</p><ul><li>Linux网络优化之数据链路层优化: 数据链路层<code>L2</code>的优化, 如何从收发两个方面优化网卡吞吐量，即本篇。</li><li>Linux网络优化之TCP优化: <a href="https://sniffer.site/2022/06/06/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8Btcp%E4%BC%98%E5%8C%96/">以TCP协议为例, 说明<code>L3</code>协议栈优化</a></li><li>Linux网络优化之高速网络优化: <a href="https://sniffer.site/2022/08/12/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8Bdpdk%E4%B8%8Exdp/">基于<code>DPDK/XDP</code>解决高速网络传输延迟问题</a></li><li>Linux网络优化之AVB: <a href="https://sniffer.site/2022/12/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BAVB-TSN/">介绍以太网中用于音视频传输的低时延<code>TSN/AVB</code>协议</a></li></ul><p>这篇文章主要讲第一个话题: Linux是如何在数据链路层<code>L2</code>对网络数据的接收与发送进行优化的. </p><span id="more"></span><p>我们都知道, Linux的网络协议栈<code>L4</code>到<code>L2</code>(传输层)以下都是在内核实现的, 其主要存在的问题是日益增加的网络带宽与CPU处理能力(包括内核协议栈)之间矛盾, 随着后续100G甚至400G的网卡出现, 这个矛盾只会更加突出. 针对这种速度上的不平衡, 涌现出了各种解决方案, 有些是基于Linux内核协议栈, 在内核的基础上进行优化, 比如将部分耗时的操作丢给网卡处理(<code>offload</code>); 有些则是基于L4协议做优化, 比如优化TCP参数, 使用更好的拥塞控制算法, 使用<code>zero-copy</code>技术减少内存拷贝; 有些则完全跳过了内核协议, 直接把网卡的数据送往用户进程, 进而避免了内核处理慢的问题, 比如<a href="https://en.wikipedia.org/wiki/Express_Data_Path"><code>XDP/DPDK</code></a>; 还有一些是从<code>L2</code>到应用层针对音视频数据传输做了大量优化, 确保低延迟以及足够的预留带宽, 这就是<a href="https://en.wikipedia.org/wiki/Audio_Video_Bridging"><code>TSN/AVB</code></a>协议.</p><p>这篇文章, 就来看下那些Linux网络驱动以及协议栈中各种网络优化技术, 包括<code>offload</code>与<code>scaling</code>两个部分. 先来看下发送端的<code>offload</code>优化方案.</p><h2 id="链路层优化-offload技术"><a href="#链路层优化-offload技术" class="headerlink" title="链路层优化-offload技术"></a><strong>链路层优化-offload技术</strong></h2><p>内核协议栈在传输数据时(内核数据的传输流程可以参考之前的文章<a href="https://sniffer.site/2021/04/08/linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B/">Linux网络协议之数据发送流程</a>, 除了从内核空间拷贝数据耗时外, 还有两件事情需要消耗CPU资源:</p><ul><li>数据包传送到网络层L2时, 需要按照网卡的MTU对数据包进行分片</li><li>传送数据时需要对数据包进行校验和计算(checksum)</li></ul><p>一般来说网卡的MTU都默认设置为<code>1500</code>字节, 一旦TCP&#x2F;UDP等L3的数据包超过了设定的MTU, 网络层L2就需要将其分割成MTU大小的数据段. 比如为了传输<code>3200bytes</code>的数据, 通常需要分割成3个包进行发送. 为了避免分片, 可以通过设置一个大的MTU, 比如在需要高速网络传输时将MTU设置为9000(JUBO frame), 但这个在广域网中很难行的通, 因为不同的通讯节点很难保持统一的MTU设置. 这时就需要用到<code>segmentation offload</code>(分片卸荷)技术. <code>offloads</code>本质上就是将原本需要CPU处理的部分丢给网卡来处理, 其最高可支持<code>64KB</code>大小的数据包, 这样可以减少网络包的数量, 降低网络中断数量, 增加网络吞吐量.</p><p>常见的<code>offload</code>有如下几种:</p><ul><li>TSO(<code>TCP Segmentation Offload</code>): 开启TSO功能的网卡可以将一个大的单帧数据分割成固定大小(MTU)多个帧. TSO一般需要与网卡的<code>checksum offload</code>以及<code>scatter-gather</code>功能一起配置使用.</li><li>UFO(<code>UDP Fragmentation Offload</code>): 网卡可以将一个大的UDP报文分割成固定MTU大小的数据包; UFO目前已经废弃不用, 大部分内核不再支持.</li><li>GSO(<code>Generic Segmentation Offload</code>): GSO可以看作是TSO的补充, 当网卡无法支持TSO&#x2F;UFO时, GSO可以确保数据包进入驱动处理时按照MTU的大小进行分片处理, 从而避免数据包无法发送的情况. GSO一般要与GRO(<code>Generic Receive Offload</code>)一起使用.</li><li>LRO(<code>Large Receive Offload</code>): 在数据包进入协议栈之前进行重新组合成一个更大的报文, 以减少数据包的数量, 降低CPU负载.  LRO通常会忽略数据包头中的差异以及其他存在的错误. 通常来说, LRO无法与内核中的IP转发(<code>IP Forwarding</code>)功能一起使用, 因此在开启LRO时需要关闭IP转发功能.</li><li>GRO(<code>Generic Receive Offload</code>): 与LRO类似, 不过在合成包时会对每个数据包进行更严格的检查, 比如会检查数据包的MAC头; 查看TCP的时间戳. GRO可以通过软件或者在网卡中实现.</li></ul><p>在Linux中, 可以通过<code>ethtool</code>工具来查看以及设定网卡的<code>offload</code>配置:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 查看网卡offload配置</span></span><br><span class="line">ethtool --show-offload  enp0s31f6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到有如下输出:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Features <span class="keyword">for</span> enp0s31f6:</span><br><span class="line">rx-checksumming: on</span><br><span class="line">tx-checksumming: on</span><br><span class="line">tx-checksum-ipv4: off [fixed]</span><br><span class="line">tx-checksum-ip-generic: on</span><br><span class="line">tx-checksum-ipv6: off [fixed]</span><br><span class="line">tx-checksum-fcoe-crc: off [fixed]</span><br><span class="line">tx-checksum-sctp: off [fixed]</span><br><span class="line">scatter-gather: on</span><br><span class="line">tx-scatter-gather: on</span><br><span class="line">tx-scatter-gather-fraglist: off [fixed]</span><br><span class="line">tcp-segmentation-offload: on</span><br><span class="line">tx-tcp-segmentation: on</span><br><span class="line">tx-tcp-ecn-segmentation: off [fixed]</span><br><span class="line">tx-tcp-mangleid-segmentation: off</span><br><span class="line">tx-tcp6-segmentation: on</span><br><span class="line">udp-fragmentation-offload: off</span><br><span class="line">generic-segmentation-offload: on</span><br><span class="line">generic-receive-offload: on</span><br><span class="line">large-receive-offload: off [fixed]</span><br><span class="line">rx-vlan-offload: on</span><br><span class="line">tx-vlan-offload: on</span><br><span class="line">ntuple-filters: off [fixed]</span><br><span class="line">receive-hashing: on</span><br><span class="line">highdma: on [fixed]</span><br><span class="line">rx-vlan-filter: off [fixed]</span><br><span class="line">vlan-challenged: off [fixed]</span><br><span class="line">tx-lockless: off [fixed]</span><br><span class="line">netns-local: off [fixed]</span><br><span class="line">tx-gso-robust: off [fixed]</span><br><span class="line">tx-fcoe-segmentation: off [fixed]</span><br><span class="line">tx-gre-segmentation: off [fixed]</span><br><span class="line">tx-gre-csum-segmentation: off [fixed]</span><br><span class="line">tx-ipxip4-segmentation: off [fixed]</span><br><span class="line">tx-ipxip6-segmentation: off [fixed]</span><br><span class="line">tx-udp_tnl-segmentation: off [fixed]</span><br><span class="line">tx-udp_tnl-csum-segmentation: off [fixed]</span><br><span class="line">tx-gso-partial: off [fixed]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="数据链路层优化-scaling技术"><a href="#数据链路层优化-scaling技术" class="headerlink" title="数据链路层优化-scaling技术"></a><strong>数据链路层优化-scaling技术</strong></h2><p>上面讲到的<code>offload</code>技术主要是针对数据传输(包括接收与发送)的优化, 这里说的<code>scaling</code>(伸缩，即具备弹性，随着系统的增大而性能不会收到影响)技术则主要是针对接收的优化, 其主要是用于增加多核CPU系统中网络并发处理能力, 改善网络性能. </p><p>了解Linux网络协议栈数据接收的流程(参考<a href="https://sniffer.site/2020/05/12/%E4%BB%8Enapi%E8%AF%B4%E4%B8%80%E8%AF%B4linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/">从NAPI说一说Linux内核数据的接收流程</a>, 我们知道, 网卡接收到数据后, 会以DMA的形式拷贝到内存, 然后发送中断告知CPU进行处理. 对于多核CPU系统来说, 有如下几个问题需要仔细考量:</p><ul><li>如何减少网络中断: 在高速网卡中, 可能有大量的中断产生, 过多的中断会影响CPU的性能, 进而影响网络吞吐量. Linux内核协议栈采用了<code>NAPI</code>技术来达到减少中断的目的; 除了<code>NAPI</code>技术, 很多网卡也会提供中断合并(<code>Interrupt Coalescence</code>)方法来减少中断数量, 简单来说, 中断合并是指网卡会等某个超时时间或者传送了某个数量的帧后才会向CPU发送一个数据接收的中断.</li><li>中断在哪个CPU上处理: 多队列网卡上, 每个队列都可能有自己的中断, 如何将中断均衡的分配到每个CPU上在一定程度上影响网络性能.</li><li>数据包要在哪个CPU上处理: 默认情况下, 数据包会发送给处理中断的CPU上, 但这对多队列网卡来说, 这会造成一定程度上的CPU负载不均衡, 从而影响系统性能.</li></ul><p>内核中的<code>scaling</code>技术就是针对这后面两个情况进行优化的. 常见的<code>scaling</code>技术有如下几种:</p><ul><li><strong>RSS</strong>(<code>Receive Side Scaling</code>):  对现在的网卡来说, 可能存在多个队列, 每个队列又会有一个中断; 如何把数据包均衡的分布到每个队列,  将多个网卡中断均衡发送到每个CPU上就是RSS需要解决的问题. 对于数据包的均衡,  需要通过网卡中的<code>indirection table</code>来实现; 中断均衡可以通过设置中断的CPU亲和性来实现.</li><li><strong>RPS</strong>(<code>Receive Packet Steering</code>): RPS可以看作是RSS的软件实现版, 区别在于RPS是在中断处理之后CPU处理数据包时进行. RPS旨在把网卡发送的数据包发送给给定的CPU进行处理, 从而实现数据包的均衡.相比RSS, RPS具有更好的灵活性, 可以适配任何网卡与协议, 并且不会增加物理设备的中断频率. </li><li><strong>RPS Flow Limit</strong>(<code>RFS</code>): 在某些情况下, 网络数据可能呈现不均衡的情况, 一些数据流可能更大, 从而造成小数据流处理慢的情况. 针对这个问题, RFS在某个CPU输入队列的数据长度超过限值(<code>net.core.netdev_max_backlog</code>)时, 新的数据包会被丢弃. RFS默认是关闭的.</li><li><strong>RFS</strong>(<code>Receive Flow Steering</code>): RPS只是根据包的哈希值来选择处理数据包的CPU, 但没有考虑数据包接收端的本地性(<code>application locality</code>), 就是说处理的CPU可能并不是用户进程接收数据包的CPU. RFS正是用于解决该问题, 确保处理数据包的与用户接收进程同在一个CPU上, 从而增强数据缓存命中率.</li><li><strong>aRFS</strong>(<code>Accelerated Receive Flow Steering</code>): aRFS之于RFS类似于RSS之于RPS; aRFS就是RFS的硬件实现, 需要网卡支持硬件加速功能才能实现. 在一定程度上, 由于数据包是直接发送给消费进程所在的本地CPU(进程同一CPU, 或对应缓存架构上应用线程本地的CPU), aRFS在性能上要优于RFS. </li><li><strong>XPS</strong>(<code>Transmit Packet Steering</code>): XPS是针对多队列网卡如何选择发送队列问题的优化策略. 开启XPS时, 内核会记录网卡队列与CPU之间的映射关系, 确保网卡的某个队列与固定的CPU之间绑定, 确保传输完成的中断由对应队列的CPU处理, 这样做一可以减少CPU在网卡队列上的等待时间; 一可以减少内存缓存缺失.</li></ul><p>综合来看, 无论是RSS&#x2F;RPS, 还是RFS&#x2F;XPS, 都是尝试在多CPU与多队列网卡之间的数据包处理上达成均衡分配的目的, 以减少CPU处理压力, 增加内存缓存命中率, 提高网卡的吞吐量. 接下来就来看看如何在Linux中配置<code>scaling</code>的优化方案.</p><ul><li><strong>RSS配置</strong>: 将数据包均匀的发送到不同CPU上可以减少网卡的队列长度, 希望优化网络延迟的情况下可以打开该配置. 如果网卡本身支持RSS, 可以尝试通过<code>ethtool</code>来设置; 对中断均衡, 可以通过配置网卡中断亲和性来确保RSS起作用, 比如<code>echo 0xff &gt; /proc/irq/&lt;irq_no&gt;/smp_affinity</code>.</li><li><strong>RPS配置</strong>: RPS需要内核配置<code>CONFIG_RPS</code>才会编译; 如果要开启, 还需要显式的指定网卡队列需要绑定的CPU: <code> /sys/class/net/&lt;dev&gt;/queues/rx-&lt;n&gt;/rps_cpus</code>, 如果这个值是0, RPS是关闭状态, 这时数据包会发送到处理中断的CPU. 如果网卡本身是多队列的, 并且每个队列都对应映射到每个CPU上, RPS可以不用配置; 但如果网卡队列数量少于CPU数量, RPS仍然是有益的.</li><li><strong>RPS Flow Limit配置</strong>: RPS限流内核配置(<code>CONFIG_NET_FLOW_LIMIT</code>)是默认打开的, 但是功能本身是关闭状态, 需要通过设置<code> /proc/sys/net/core/flow_limit_cpu_bitmap</code>(与<code>rps_cpus</code>设置一样)来开启该功能.</li><li><strong>RFS配置</strong>: RFS只有在<code>CONFIG_RPS</code>打开的情况下才可用, 该功能需要配置两个参数, 一个用于配置全局流表, <code>/proc/sys/net/core/rps_sock_flow_entries</code>;  一个是用于配置网卡每个队列的限流数量, <code> /sys/class/net/&lt;dev&gt;/queues/rx-&lt;n&gt;/rps_flow_cnt</code>.</li><li><strong>aRFS配置</strong>: aRFS需要使能内核配置<code>CONFIG_RFS_ACCEL</code>并且需要网卡本身支持. 有硬件加速功能个的网卡通常都实现了<code>ndo_rx_flow_steer</code>这个函数.</li><li><strong>XPS配置</strong>: XPS需要配置内核<code>CONFIG_XPS</code>, 如果要打开该功能, 配置CPU的位图即可<code>/sys/class/net/&lt;dev&gt;/queues/tx-&lt;n&gt;/xps_cpus</code>.</li></ul><p>有关上述网络优化方案的详细配置可以参考内核文档<code>Documentation/networking/scaling.txt</code>.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rfs">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rfs</a></li><li>Linux Documentation&#x2F;networking(scaling&#x2F;segmentation-offloads)</li><li><a href="https://www.linkedin.com/pulse/modern-high-speed-networking-techniques-hardware-john-velegrakis">https://www.linkedin.com/pulse/modern-high-speed-networking-techniques-hardware-john-velegrakis</a></li><li><a href="https://lwn.net/Articles/188489/">GSO: Generic Segmentation Offload</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-nic-offloads">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-nic-offloads</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在车内网络都开始内卷到&lt;code&gt;1Gbps&lt;/code&gt;了, 有同学给我反馈说以太网的吞吐量上不来, 跟理论带宽差距很大, 之前虽然优化了一波&lt;code&gt;TCP&lt;/code&gt;相关的参数, 但估计不能解决全部问题. 遂决定重新学习下网络优化, 从底层链路对开发平台上的网络进行改善. 趁着这个机会, 索性写一个系列文章-Linux网络优化, 用来总结下Linux网络优化的一些方法与技术, 目前计划从如下几篇文章展开(希望不要放飞了):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux网络优化之数据链路层优化: 数据链路层&lt;code&gt;L2&lt;/code&gt;的优化, 如何从收发两个方面优化网卡吞吐量，即本篇。&lt;/li&gt;
&lt;li&gt;Linux网络优化之TCP优化: &lt;a href=&quot;https://sniffer.site/2022/06/06/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8Btcp%E4%BC%98%E5%8C%96/&quot;&gt;以TCP协议为例, 说明&lt;code&gt;L3&lt;/code&gt;协议栈优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Linux网络优化之高速网络优化: &lt;a href=&quot;https://sniffer.site/2022/08/12/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8Bdpdk%E4%B8%8Exdp/&quot;&gt;基于&lt;code&gt;DPDK/XDP&lt;/code&gt;解决高速网络传输延迟问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Linux网络优化之AVB: &lt;a href=&quot;https://sniffer.site/2022/12/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BAVB-TSN/&quot;&gt;介绍以太网中用于音视频传输的低时延&lt;code&gt;TSN/AVB&lt;/code&gt;协议&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章主要讲第一个话题: Linux是如何在数据链路层&lt;code&gt;L2&lt;/code&gt;对网络数据的接收与发送进行优化的. &lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="Linux" scheme="https://sniffer.site/tags/Linux/"/>
    
    <category term="网络优化" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>重学C++</title>
    <link href="https://sniffer.site/2022/03/31/%E9%87%8D%E5%AD%A6C++/"/>
    <id>https://sniffer.site/2022/03/31/%E9%87%8D%E5%AD%A6C++/</id>
    <published>2022-03-31T06:58:15.000Z</published>
    <updated>2022-12-23T23:48:40.073Z</updated>
    
    <content type="html"><![CDATA[<p>断断续续看了Bjarne Stroustrup的’C++之旅(<code>a tour of C++</code>)’, 作者把很多原本看起来复杂的概念模型都讲的比较清晰, 也有不少好的代码示例, 有种拨云见雾的感觉. 于是想着写一篇文章来总结重新学习C++的一些经验, 主要阐述下现代C++(<code>&gt;=C++11</code>)中那些容易让人混淆而觉得陌生的技术.</p><p>了解C++历史的人都知道, <code>Bjarne Stroustrup</code>是在Bell实验室(就是Unix操作系统与C语言诞生的地方)发明了C++, 初衷是在C中加入类(class)的概念, 增强C语言在系统编程上的效率与灵活性, 也正式因为这个原因, C++在1979年最初的名字是<code>带类的C</code>(c with class), 直到1984年才改名为<code>C++</code>. 到今天, <code>C++</code>的发展历经了快40年历史, 但真正一次大的标准修改是在2011年, 这个版本也称为<code>C++11</code>, 也是目前很多公司在使用的版本.接下来我们就来一起来回顾下现代C++中那些曾经让人<code>头疼</code>的技术吧.</p><span id="more"></span><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/evolution_of_c%2B%2B.png" alt="history_of_cpp"></p><h2 id="constants"><a href="#constants" class="headerlink" title="constants"></a><strong>constants</strong></h2><p>除了<code>const</code>之外, C++还引入了<code>constexpr</code>这个关键字. <code>const</code>的意思是这个变量不会被修改, 编译器在编译的时候会确保这一点: 如果尝试修改<code>const</code>的赋值, 则会提示错误. 而<code>constexpr</code>是说这个表达式会在编译的时候进行判定(不用等到运行时):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vi)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;;  <span class="comment">//示例</span></span><br><span class="line"> <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">constexpr</span> <span class="type">double</span> m1 = <span class="number">1.6</span> * <span class="built_in">square</span>(im);</span><br><span class="line"><span class="comment">//constexpr double m2 = 1.6 * square(var); // 不允许使用非const变量</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vi = &#123;<span class="number">4</span>, <span class="number">58</span>, <span class="number">8</span> , <span class="number">9</span>&#125;; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> si = <span class="built_in">sum</span>(vi);</span><br><span class="line"><span class="comment">//constexpr int sii = sum(vi); // sum不是constexpr表达式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果一个函数要在<code>constexpr</code>表达式中使用, 则必须要以<code>constexpr</code>开头, 并且函数的实现需要足够简单: 只由一个返回值的表达式组成，且不能调用任何其他非<code>constexpr</code>的函数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于在编译时就完成了计算, 使用<code>constexpr</code>通常可以改善性能, 但据<code>c++ standar library: a tutorial and refernce</code>里边提到的, 引入<code>constexpr</code>是为了解决C++98<code>numeric_limits</code>标准库中的一个bug:<code>std::numeric_limits&lt;short&gt;::max()</code> 无法在常量表达式中使用.</p><h2 id="引用与右值"><a href="#引用与右值" class="headerlink" title="引用与右值"></a><strong>引用与右值</strong></h2><p>C++针对C中的指针引入了<code>引用(reference)</code>的概念, 引用类似于指针, 其通过<code>&amp;</code>进行声明, 但实际使用的时候无需在通过<code>*</code>来引用对象, 更重要的是引用一旦被初始化就不能再被修改, 引用其他的对象.</p><blockquote><p>引用类似指针，但非指针;引用只是对象的别名。引用与指针存在三个区别: 1) 没有空引用(<code>null reference</code>),就是说引用始终指向一个有效的对象 2) 所有引用需要初始化  3) 一个引用永远指向它初始化的那个对象</p></blockquote><p>引用对于不管理资源的对象来说, 一般不会有什么问题, 但涉及到大量的数据&#x2F;内存时(比如容器), 单纯的拷贝会变得低效. 有时, 我们只希望在不同对象之间<code>移动(move)</code>数据而不是拷贝, 以避免产生不必要的临时对象. 比如我们有一个<code>String</code>类, 包含了一个字符数组:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">String</span>(): <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>]) &#123;</span><br><span class="line"> data[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str): <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>]) &#123;</span><br><span class="line"> <span class="keyword">if</span> (str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"> <span class="built_in">strncpy</span>(data, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"> data[<span class="built_in">strlen</span>(str)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">String</span>(<span class="type">const</span> String&amp; str): <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">char</span>[str.<span class="built_in">size</span>() + <span class="number">1</span>]) &#123;</span><br><span class="line"> <span class="built_in">strncpy</span>(data, str.<span class="built_in">c_str</span>(), str.<span class="built_in">size</span>());</span><br><span class="line"> data[str.<span class="built_in">size</span>()] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> String&amp; <span class="keyword">operator</span>=(String &amp;rhs) &#123;</span><br><span class="line"> <span class="built_in">swap</span>(rhs);</span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">String</span>() &#123;</span><br><span class="line"> <span class="keyword">delete</span>[] data;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">strlen</span>(data);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> data;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(String &amp;rhs)</span> </span>&#123;</span><br><span class="line"> std::<span class="built_in">swap</span>(data, rhs.data);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如我们要往一个容器中插入对象, 那么每次实际容器中实际得到的都是一个拷贝的对象, 这就导致了不必要的内存拷贝, 如果对象本身很大(占用较大内存), 则拷贝会消耗更多的时间.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">String <span class="title">s</span><span class="params">(<span class="string">&quot;agaga&quot;</span>)</span></span>;</span><br><span class="line">std::set&lt;String&gt; ss;</span><br><span class="line">ss.<span class="built_in">insert</span>(s); <span class="comment">// get a copy of s</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>针对这种临时对象的拷贝, <code>C++11</code>中引入了<code>移动(move)</code>语义, 这样就可以支持对象之间数据的转移而不是拷贝了, 从而改善了程序的性能. 要让上述<code>String</code>对象支持<code>move</code>语义, 其实也很简单:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// move constructor</span></span><br><span class="line"><span class="built_in">String</span>(String &amp;&amp;str): <span class="built_in">data</span>(str.data) &#123;</span><br><span class="line"> str.data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// move assignment</span></span><br><span class="line">String&amp; <span class="keyword">operator</span>=(String&amp;&amp; rhs) &#123;</span><br><span class="line"> data = rhs.data;</span><br><span class="line"> rhs.data = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码中<code>&amp;&amp;</code>表示一个右值引用(<code>rval refernece</code>), 就是说该引用跟一个右值绑定, 这通常有别于左值(赋值语句的左边), 由于右值引用无法进行赋值, 因此我们可以<code>偷取</code>它的值与资源. C++标准库中也有一个<code>move</code>函数可以用于操作右值引用(头文件<code>utility</code>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;gaga&quot;</span>)</span></span>;</span><br><span class="line">String s2 = s1; <span class="comment">// copy</span></span><br><span class="line">String s3 = std::<span class="built_in">move</span>(s2); <span class="comment">// move</span></span><br><span class="line"></span><br><span class="line">std::set&lt;String&gt; ss;</span><br><span class="line">ss.<span class="built_in">insert</span>(std::<span class="built_in">move</span>(s1)); <span class="comment">// move</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要留意的时, 对于函数返回值不应该返回右值或使用<code>move()</code>要返回的值, 对于如下函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">String <span class="title">fcn</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">s</span><span class="params">(<span class="string">&quot;hi, move&quot;</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>C++会确保返回值按照如下规则进行:</p><ul><li>如果<code>String</code>有move构造函数或者赋值函数, 编译器可能会忽略拷贝对象, 这种技术被称为返回值优化(<code>returned value optimization</code>), 在C++11之前就有了.</li><li>否则就使用move构造函数返回对象</li><li>如果没有move构造函数, 则使用拷贝构造函数返回拷贝对象</li><li>否则就会抛出编译时异常</li></ul><p>有关更多右值引用、移动语义可以参考如下两篇文章:</p><ul><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#:~:text=Rvalue%20references%20is%20a%20small,performance%20and%20more%20robust%20libraries.">A Brief Introduction to Rvalue References</a></li><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">A Proposal to Add Move Semantics Support to the C++ Language</a></li></ul><h2 id="lamda表达式与函数对象"><a href="#lamda表达式与函数对象" class="headerlink" title="lamda表达式与函数对象"></a><strong>lamda表达式与函数对象</strong></h2><p>C++11引入了<code>lambda</code>表达式; <code>lambda</code>表达式可以用于创建简单的函数对象(<code>function object</code>), 构建匿名函数, 其返回的对象被称为闭包对象(<code>closure object</code>). 一般来说, <code>lambda</code>表达式由如下三个部分组成:</p><ul><li><p>捕获列表(<code>caputure list</code>): <code>[]</code> , 一个对象被捕获以后就可以在<code>lambda</code>函数内部使用(值复制或者引用的形式), <code>=</code>用于值的形式捕获所有本地变量;<code>&amp;</code>则表示以引用的形式捕获所有本地变量. 如果需要指定捕获的变量, 则需要在符号后面加上对应变量的名字, 如<code>=a</code>, <code>&amp;a</code>等. 不指定捕获符号则默认的捕获是值形式.</p></li><li><p>参数列表(<code>parameter list</code>): <code>()</code>, 参数列表与普通函数完全一致, 如果没有参数, 可以选择直接忽略表达式中的<code>()</code>(只有C++14以上的版本支持)</p></li><li><p>函数体(<code>function body</code>): <code>&#123;&#125;</code>表示函数体, 这与普通函数是一样的.</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[=(&amp;)] ()&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>lambda</code>表达式源自于<code>lambda calculus</code>, 是<code>Alonzo Church</code>在1930s用于研究逻辑与计算时使用的数学形式语言, 这也是函数式编程语言<code>LISP</code>的基础.</p></blockquote><p>比如实现判断一个数值是否大于<code>10</code>的<code>lamda</code>表达式, 可以这么做:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">[=a](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; a; &#125;;</span><br><span class="line"></span><br><span class="line">[&amp;a](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; a; &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认情况下, 未被显式指定捕获本地变量都无法在表达式函内使用, 但可以隐式的在函数体内捕获这些变量:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[=]() &#123; <span class="keyword">return</span> a + b; &#125;; <span class="comment">// a and b caputured by value</span></span><br><span class="line"></span><br><span class="line">[&amp;]() &#123; <span class="keyword">return</span> a + b; &#125;; <span class="comment">// a and b caputured by reference</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果同时使用了两种形式的捕获, 显式捕获会覆盖默认的捕获:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> a  = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">[=, &amp;b] () &#123;</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// Illegal, a is caputured by value and lamda is not mutable </span></span><br><span class="line">b = <span class="number">3</span>; <span class="comment">// OK , b is caputured by value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是, <code>lambda</code>表达式可以使用泛型参数, 这个在本质上是等同于函数式对象, 不妨来看个示例: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">auto</span> copy = [] (<span class="keyword">auto</span> x) &#123; <span class="keyword">return</span> x + x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">copy</span>(<span class="number">2</span>); <span class="comment">// i = 4</span></span><br><span class="line">std::string s = <span class="built_in">copy</span>(<span class="string">&quot;hi&quot;</span>); <span class="comment">// s = &quot;hihi&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述表达式可以写成如下形式的函数对象(标准库中很多算法广泛使用了函数对象来扩展实现, 如<code>for_each</code>, <code>bind</code>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CopyValue</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x + x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="智能指针-smart-pointers"><a href="#智能指针-smart-pointers" class="headerlink" title="智能指针(smart pointers)"></a><strong>智能指针(smart pointers)</strong></h2><p>长期以来, C被大家所诟病的一个缺陷就是指针引发的一系列内存管理问题, 比如空指针, 内存泄漏等, C++虽然通过引入了<code>引用(reference</code>)在一定程度上避免了指针带来内存管理的困扰, 但并没有从根源上解决指针所引发的资源管理问题. 现代C++普遍采用<a href="https://docs.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-170"><code>RAII(Resource Acquisition Is Initialization)</code></a>原则;从C++11开始, 标准库引入了智能指针(smart pointers)避免内存泄漏: <code>unique_ptr</code>&#x2F;<code>shared_ptr</code>, 用以替换之前的<code>auto_ptr</code>. </p><ul><li><code>unique_ptr</code>: 表示一个唯一的所属关系, 始终只有一个指针指向该对象</li><li><code>shared_ptr</code>: 表示一个共有的所属关系, 可以有多个指针共享对象资源</li></ul><p>标准库中提供了接口用于方便的创建<code>unique_ptr</code>&#x2F;<code>shared_ptr</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">std::unique_ptr&lt;X&gt; up &#123; <span class="keyword">new</span> X &#125;; <span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// since C++14</span></span><br><span class="line">std::unique_ptr&lt;X&gt; up = std::<span class="built_in">make_unique</span>&lt;X&gt;(); </span><br><span class="line"><span class="comment">// move unique_ptr to another</span></span><br><span class="line">std::unique_ptr&lt;X&gt; up1 = std::<span class="built_in">move</span>(up); <span class="comment">// now up is undefined</span></span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;X&gt; sp &#123;<span class="keyword">new</span> X&#125;; <span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// since C++14</span></span><br><span class="line">std::shared_ptr&lt;X&gt; sp = std::<span class="built_in">make_shared</span>&lt;X&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;X&gt; <span class="title">sp1</span><span class="params">(sp)</span></span>; <span class="comment">// shared with sp1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类型推断-auto-x2F-decltype"><a href="#类型推断-auto-x2F-decltype" class="headerlink" title="类型推断(auto&#x2F;decltype)"></a><strong>类型推断(auto&#x2F;decltype)</strong></h2><p>C++11引入了<code>auto</code>关键字用于告诉编译器对变量, 函数以及模板类进行推断, 从而避免让用户自己显式的声明类型. 比如, 相比写一堆嵌套的模板实例类型, 使用<code>auto</code>可以简化声明:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>,list&lt;string&gt;&gt;::iterator i = m.<span class="built_in">begin</span>(); <span class="comment">// C-style</span></span><br><span class="line"><span class="keyword">auto</span> i = m.<span class="built_in">begin</span>(); <span class="comment">// modern C++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//using auto to simplify code</span></span><br><span class="line"><span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::const_iterator itr = myvec.<span class="built_in">cbegin</span>(); itr != myvec.<span class="built_in">cend</span>(); ++itr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> itr = myvec.<span class="built_in">cbegin</span>(); itr != myvec.<span class="built_in">cend</span>(); ++itr)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外, C++11还增加了一个关键字<code>decltype</code>, 用于在编译的时候获取某个变量或者表达式的类型, 例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">decltype</span>(a) c = <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不过需要注意的是, <code>decltype</code>推断出来的类型与<code>auto</code>的实际类型可能有差异(示例来自<a href="%60https://en.wikipedia.org/wiki/C++11%60">wikipedia</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> a = v[<span class="number">0</span>];        <span class="comment">// a has type int</span></span><br><span class="line"><span class="keyword">decltype</span>(v[<span class="number">0</span>]) b = <span class="number">1</span>; <span class="comment">// b has type const int&amp;, the return type of</span></span><br><span class="line"><span class="comment">//   std::vector&lt;int&gt;::operator[](size_type) const</span></span><br><span class="line"><span class="keyword">auto</span> c = <span class="number">0</span>;           <span class="comment">// c has type int</span></span><br><span class="line"><span class="keyword">auto</span> d = c;           <span class="comment">// d has type int</span></span><br><span class="line"><span class="keyword">decltype</span>(c) e;        <span class="comment">// e has type int, the type of the entity named by c</span></span><br><span class="line"><span class="keyword">decltype</span>((c)) f = c;  <span class="comment">// f has type int&amp;, because (c) is an lvalue</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">0</span>) g;        <span class="comment">// g has type int, because 0 is an rvalue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a><strong>标准库</strong></h2><p>C++标准库中已经实现了大量通用的算法, 包括查找, 排序, 过滤以及随机算法等, 如果你正瞅着自己实现某个算法时, 可以直接看看标准模板库(<code>STL</code>, Stardard Template Libarary)的算法. 举几个例子:</p><ul><li><code>for_each</code>: 可以利用迭代器<code>iterator</code>很方便的对容器进行遍历操作</li><li><code>transform</code>: 对容器元素根据某个特定规则进行变换</li><li><code>find_if</code>: 根据某个函数对象对进行搜索查找</li><li><code>sort</code>&#x2F;<code>lower_bound</code>: 排序&#x2F;搜索算法</li></ul><p>标准模板库<code>STL</code>包含了三大组件：容器（<code>Container</code>）、算法（<code>Algorithm</code>）以及迭代器（<code>Interator</code>）。</p><ul><li>容器用于容纳&#x2F;组织对象，是一种数据结构的抽象，以类模板的方式实现</li><li>算法执行对象的操作，是一种函数的抽象，通过函数模板来实现</li><li>迭代器用于访问容器中的元素，为容器与算法提供一种协同工作的机制。</li></ul><p>更多有关标注库的算法可以参考<a href="https://book.douban.com/subject/10440485/">The C++ Standard Library, 2nd Edition</a>.</p><h2 id="转型操作符"><a href="#转型操作符" class="headerlink" title="转型操作符"></a><strong>转型操作符</strong></h2><p>C++中引入了很多类型转换（cast）操作，比如<code>const_cast</code>, <code>dynamic_cast</code>等，为转换操作提供了明确的语法表达。</p><ul><li><code>const_cast</code>： 去除类型中的const信息，只是去掉转型类型修饰符。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> Shape *sp = <span class="keyword">new</span> Shape</span><br><span class="line">Share *sp1 = <span class="built_in">const_cast</span>&lt;Shape *&gt;(sp)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>static_cast</code>: 用于相对而言可跨平台的移植的转型，最常的用于将一个基类指针或者引用，向下转型为一个派生类指针与引用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Shape *sp = <span class="keyword">new</span> Circle;</span><br><span class="line"></span><br><span class="line">Circle *cp = <span class="built_in">static_cast</span>&lt;Circle *&gt;(sp)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>dynamic_cast</code>: 基类指针向下（downcast）转型为派生类指针, 与static_cast不同的是， dynamic_cast仅用于多态类型的向下转型（就是说被转型的类型中，必须是一个指向带有虚函数的类类型的指针），并且会执行运行期的检查，确保了转型的正确。这也为<code>dynamic_cast</code>带来了额外的开销。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> Circle *cp = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Circle*&gt;(<span class="built_in">getNextShape</span>());</span><br><span class="line"><span class="keyword">if</span> (cp) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果转型失败，会抛出一个<code>std::bad_cast</code>的异常。</p><ul><li><code>reinterpret_cast</code>: 允许从<code>bit</code>位的角度重新看待一个对象，将其看做是完全不同的东西</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">char</span> *cp =  <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(<span class="number">0x00ff0000</span>);</span><br><span class="line"><span class="type">int</span> *ip = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span> *&gt;(cp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通常来说，<code>reinterpret_cast</code>并不具备可移植性，因此使用时需要谨慎。用于类类型转换时，注意其与<code>static_cast</code>的区别，<code>reinterpret_cast</code>只是将基类指针假装成一个派生类指针而不改变其值，而<code>static_cast</code>则会执行地址操作。</p><p>更多关于类型转换可以参考<a href="https://belaycpp.com/2021/10/14/history-of-c-the-genesis-of-casting/">The genesis of casting.</a>.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://book.douban.com/subject/25720141/">A Tour of C++</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?redirectedfrom=MSDN&view=msvc-170">Modern C++</a></li><li><a href="http://mindhacks.cn/2012/08/27/modern-cpp-practices/">C++11（及现代C++风格）和快速迭代式开发</a></li><li><a href="https://www.boost.org/doc/libs/1_78_0/libs/libraries.htm">Boost库参考资料</a></li><li><a href="https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list">C++必读书籍系列-从入门到高级</a></li><li><a href="http://www.parashift.com/c++-faq-lite/index.html">C++ FAQ系列</a></li><li><a href="http://norvig.com/21-days.html">Teach Yourself Programming in Ten Years</a></li><li><a href="https://isocpp.org/wiki/faq">C++ Super FAQ</a></li><li><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">Modern C++ Core Guidelines</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;断断续续看了Bjarne Stroustrup的’C++之旅(&lt;code&gt;a tour of C++&lt;/code&gt;)’, 作者把很多原本看起来复杂的概念模型都讲的比较清晰, 也有不少好的代码示例, 有种拨云见雾的感觉. 于是想着写一篇文章来总结重新学习C++的一些经验, 主要阐述下现代C++(&lt;code&gt;&amp;gt;=C++11&lt;/code&gt;)中那些容易让人混淆而觉得陌生的技术.&lt;/p&gt;
&lt;p&gt;了解C++历史的人都知道, &lt;code&gt;Bjarne Stroustrup&lt;/code&gt;是在Bell实验室(就是Unix操作系统与C语言诞生的地方)发明了C++, 初衷是在C中加入类(class)的概念, 增强C语言在系统编程上的效率与灵活性, 也正式因为这个原因, C++在1979年最初的名字是&lt;code&gt;带类的C&lt;/code&gt;(c with class), 直到1984年才改名为&lt;code&gt;C++&lt;/code&gt;. 到今天, &lt;code&gt;C++&lt;/code&gt;的发展历经了快40年历史, 但真正一次大的标准修改是在2011年, 这个版本也称为&lt;code&gt;C++11&lt;/code&gt;, 也是目前很多公司在使用的版本.接下来我们就来一起来回顾下现代C++中那些曾经让人&lt;code&gt;头疼&lt;/code&gt;的技术吧.&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://sniffer.site/categories/C/"/>
    
    
    <category term="C++" scheme="https://sniffer.site/tags/C/"/>
    
    <category term="编程语言" scheme="https://sniffer.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>如何用pktgen测试网卡性能?</title>
    <link href="https://sniffer.site/2022/03/18/%E4%BD%BF%E7%94%A8pktgen%E6%B5%8B%E8%AF%95%E7%BD%91%E5%8D%A1%E6%80%A7%E8%83%BD/"/>
    <id>https://sniffer.site/2022/03/18/%E4%BD%BF%E7%94%A8pktgen%E6%B5%8B%E8%AF%95%E7%BD%91%E5%8D%A1%E6%80%A7%E8%83%BD/</id>
    <published>2022-03-18T02:45:14.000Z</published>
    <updated>2022-03-23T08:52:44.144Z</updated>
    
    <content type="html"><![CDATA[<p>在优化网络性能时, 不可避免要对网络的带宽进行测试. 通常大家可能都会使用<code>iperf</code>来执行网络链路的吞吐量测试, 但<code>iperf</code>只能测试<code>TCP/IP</code>协议层的速度, 这个带宽数据跟<code>TCP/UDP</code>协议的参数配置以及应用层缓冲区的大小都有关系. 有时, 我们希望直接测试网卡本身的实际吞吐量, 看看网卡实际的发包能力. Linux内核提供了<code>pktgen</code>工具用以产生数据包, 向网卡注入<code>TCP/UDP</code>数据. 这里, 我们就来看下具体如何通过<code>pktgen</code>来测试网卡性能.</p><span id="more"></span><h2 id="模块配置-x2F-加载"><a href="#模块配置-x2F-加载" class="headerlink" title="模块配置&#x2F;加载"></a><strong>模块配置&#x2F;加载</strong></h2><p><code>pktgen</code>在内核中是以模块的形式编译的, 使用之前确保内核配置了<code>CONFIG_NET_PKTGEN</code>; 如果<code>CONFIG_NET_PKTGEN</code>配置为<code>m</code>, 则使用时需要<code>modprobe pktgen</code>先加载模块. 模块加载完成后, 我们可以在<code>/proc/net/pktgen</code>下面看到有如下几个目录: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">~<span class="meta"># ls -al /proc/net/pktgen/</span></span><br><span class="line">total <span class="number">0</span></span><br><span class="line">dr-xr-xr-x <span class="number">2</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> .</span><br><span class="line">dr-xr-xr-x <span class="number">6</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> ..</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> kpktgend_0</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> kpktgend_1</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> kpktgend_2</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> kpktgend_3</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> kpktgend_4</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> kpktgend_5</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> kpktgend_6</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> kpktgend_7</span><br><span class="line">-rw------- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">22</span> <span class="number">10</span>:<span class="number">57</span> pgctrl</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中<code>kpktgend_*</code>是内核数据包生产线程, 每个CPU都会启动一个相应的线程, 如果要添加某个测试网卡, 可以通过向该文件节点写入<code>add_device ethX</code>; <code>pgctrl</code>用于控制网卡性能测试状态需要在对应的线程执行网卡的吞吐量测试, 有<code>start</code>&#x2F;<code>stop</code>&#x2F;<code>reset</code>三种状态.</p><blockquote><p>更多<code>pktgen</code>的信息可以参考内核文档<code>pktgen.txt</code>以及源代码<code>pktgen.c</code></p></blockquote><h2 id="脚本测试"><a href="#脚本测试" class="headerlink" title="脚本测试"></a><strong>脚本测试</strong></h2><p>刚开始碰到<code>pktgen</code>测试网卡, 会被一堆参数搞得头晕, 好在内核的代码示例已经有了一些基本的脚本, 我们只需要根据自己的需要稍加改造就可以用起来了, 具体可以参考内核源码目录<code>samples/pktgen</code>. 下面贴了一段用于配置&#x2F;启动测试的脚本, 完整的代码示例可以参考<a href="https://github.com/runningforlife/CodingExamples/blob/main/shell/pktgen_test.sh">pktgen_test.sh</a>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pg_ctrl <span class="string">&quot;reset&quot;</span></span><br><span class="line"><span class="comment"># Config Start Here -------------------------------------</span></span><br><span class="line"><span class="keyword">for</span> (( thread = 0; thread &lt; <span class="variable">$THREADS</span>; ++thread )); <span class="keyword">do</span></span><br><span class="line">  PGDEV=<span class="variable">$&#123;DEV&#125;</span>@<span class="variable">$thread</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Removing all devices&quot;</span></span><br><span class="line">  pg_thread <span class="variable">$thread</span> <span class="string">&quot;rem_device_all&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Adding eth0&quot;</span></span><br><span class="line">  pg_thread <span class="variable">$thread</span> <span class="string">&quot;add_device <span class="variable">$PGDEV</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Notice config queue to map to cpu (mirrors smp_processor_id())</span></span><br><span class="line">    <span class="comment"># It is beneficial to map IRQ /proc/irq/*/smp_affinity 1:1 to CPU number</span></span><br><span class="line">    pg_set <span class="variable">$PGDEV</span> <span class="string">&quot;flag QUEUE_MAP_CPU&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># device config</span></span><br><span class="line">  CLONE_SKB=<span class="string">&quot;clone_skb 000000&quot;</span></span><br><span class="line">  <span class="comment">#PGDEV=/proc/net/pktgen/eth0</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Configuring <span class="variable">$PGDEV</span>&quot;</span></span><br><span class="line">  pg_set <span class="variable">$PGDEV</span> <span class="string">&quot;count 10000000&quot;</span></span><br><span class="line">  pg_set <span class="variable">$PGDEV</span> <span class="string">&quot;clone_skb 000000&quot;</span></span><br><span class="line">  pg_set <span class="variable">$PGDEV</span> <span class="string">&quot;pkt_size <span class="variable">$PKT_SIZE</span>&quot;</span></span><br><span class="line">  pg_set <span class="variable">$PGDEV</span> <span class="string">&quot;delay 0&quot;</span></span><br><span class="line">  pg_set <span class="variable">$PGDEV</span> <span class="string">&quot;dst <span class="variable">$DEST_IP</span>&quot;</span></span><br><span class="line">  pg_set <span class="variable">$PGDEV</span> <span class="string">&quot;dst_mac <span class="variable">$DEST_MAC</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time to run</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running... ctrl^C to stop&quot;</span></span><br><span class="line"><span class="built_in">trap</span> pg_stop SIGINT</span><br><span class="line"></span><br><span class="line">pg_ctrl <span class="string">&quot;start&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Done&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Print results</span></span><br><span class="line"><span class="keyword">for</span> ((thread = 0; thread &lt; <span class="variable">$THREADS</span>; thread++)); <span class="keyword">do</span></span><br><span class="line">    dev=<span class="variable">$&#123;DEV&#125;</span>@<span class="variable">$&#123;thread&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Device: <span class="variable">$dev</span>&quot;</span></span><br><span class="line">    <span class="built_in">cat</span> /proc/net/pktgen/<span class="variable">$dev</span> | grep -A2 <span class="string">&quot;Result:&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个脚本总体说来主要分为三个步骤:</p><ul><li><code>pg_ctrl &quot;reset&quot;</code>: 清除上一次测试状态</li><li><code>pg_thread $thread &quot;add_device $PGDEV&quot;</code>: 配置测试的网卡</li><li><code>pg_ctrl &quot;start&quot;</code>: 开启测试, 按<code>ctrl+C</code>后, 进程退出, 内核结束发包</li></ul><p>比如, 执行<code>./pktgen_test.sh -i enp0s31f6 -d 10.193.200.1 -m 31:b6:89:55:b3:8c -t 2</code>(使用两个内核线程发包), 测试结束后, 会打印出测试结果(实际查看<code>/proc/net/pktgen/enp0s31f6*</code>的结果会输出更多信息, 脚本里对输出做了过滤), 包括测试的时间&#x2F;是否出现错误以及吞吐量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Device: enp0s31f6@<span class="number">0</span></span><br><span class="line">Result: OK: <span class="number">1662287</span>(c1662114+d172) usec, <span class="number">89218</span> (<span class="number">1024b</span>yte,<span class="number">0f</span>rags)</span><br><span class="line">  <span class="number">53671</span>pps <span class="number">439</span>Mb/sec (<span class="number">439672832b</span>ps) errors: <span class="number">0</span></span><br><span class="line">Device: enp0s31f6@<span class="number">1</span></span><br><span class="line">Result: OK: <span class="number">1606214</span>(c1605962+d252) usec, <span class="number">108442</span> (<span class="number">1024b</span>yte,<span class="number">0f</span>rags)</span><br><span class="line">  <span class="number">67514</span>pps <span class="number">553</span>Mb/sec (<span class="number">553074688b</span>ps) errors: <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面可以看到, 网卡的<code>PPS</code>(<code>Packet Per Second</code>)大约在<code>121185</code>(1.2Mpps), 带宽在<code>992Mb/s</code>, 这个速度已经比较接近于千兆网卡的理论吞吐量<code>1.5Mpps</code>(1000bps&#x2F;((64 + 20)*8))了(这里64B为以太网数据帧的最小尺寸, <code>46(pad) + 14(dmac,smac,type) + 4(CRC)</code>, 20B 为以太网帧前导和帧间距的大小).</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li>内核文档<code>Documentation/networking/pktgen.txt</code></li><li><a href="https://github.com/torvalds/linux/blob/master/net/core/pktgen.c">pktgen内核源码</a></li><li><a href="https://github.com/torvalds/linux/tree/master/samples/pktgen">pktgen内核示例代码</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在优化网络性能时, 不可避免要对网络的带宽进行测试. 通常大家可能都会使用&lt;code&gt;iperf&lt;/code&gt;来执行网络链路的吞吐量测试, 但&lt;code&gt;iperf&lt;/code&gt;只能测试&lt;code&gt;TCP/IP&lt;/code&gt;协议层的速度, 这个带宽数据跟&lt;code&gt;TCP/UDP&lt;/code&gt;协议的参数配置以及应用层缓冲区的大小都有关系. 有时, 我们希望直接测试网卡本身的实际吞吐量, 看看网卡实际的发包能力. Linux内核提供了&lt;code&gt;pktgen&lt;/code&gt;工具用以产生数据包, 向网卡注入&lt;code&gt;TCP/UDP&lt;/code&gt;数据. 这里, 我们就来看下具体如何通过&lt;code&gt;pktgen&lt;/code&gt;来测试网卡性能.&lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="网络性能" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/"/>
    
    <category term="带宽测试" scheme="https://sniffer.site/tags/%E5%B8%A6%E5%AE%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="pktgen" scheme="https://sniffer.site/tags/pktgen/"/>
    
  </entry>
  
  <entry>
    <title>「置顶」收藏的学习资料</title>
    <link href="https://sniffer.site/2022/03/17/%E6%94%B6%E8%97%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    <id>https://sniffer.site/2022/03/17/%E6%94%B6%E8%97%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</id>
    <published>2022-03-17T01:14:38.000Z</published>
    <updated>2022-12-30T01:12:15.423Z</updated>
    
    <content type="html"><![CDATA[<p>以下是从事软件开发以来收藏的资料&#x2F;书籍&#x2F;网站, 欢迎推荐~</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a><strong>基础</strong></h2><ul><li><a href="https://akaedu.github.io/book/">Linux C一站式学习</a>: 收藏已久, 值得一看</li><li><a href="https://book.douban.com/subject/4822685/">Code: The Hidden Language of Computer Hardware and Software</a>: 最开始学单片机时就对CPU是如何执行代码, 如何解析代码并正常运营感到疑惑, <code>Code</code>这本书正是从零开始解释了计算机内部是如何工作的, 看了两遍, 感觉都很过瘾, 值得学习</li><li><a href="https://book.douban.com/subject/5333562/">Computer Systems: A Programmer’s Perspective</a>: 从计算机基础原理讲起, 阐述了计算机的原理, 内存&#x2F;网络都有涵盖, 想进入软件行业的入门比读书之一; 平时也可以作为参考书籍不时翻一翻.</li></ul><span id="more"></span><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a><strong>网络协议</strong></h2><ul><li><a href="http://www.tcpipguide.com/index.htm">TCP&#x2F;IP指南</a>: TCP&#x2F;IP协议很详细的介绍, 有很多绘制精美的流程图, 是学习TCP&#x2F;IP很好的网站</li><li><a href="http://www.embeddedlinux.org.cn/linux_net/">深入理解Linux网络协议栈</a>: 很好的内核协议的在线书籍, 从协议栈初始化到数据接收发送, 再到路由都有介绍, 是研究Linux内核协议不可多得的参考资料</li><li><a href="https://book.douban.com/subject/10510747/">计算机网络(第5版)</a>: 详尽的介绍了计算机网络相关的知识，从以太网到WIFI、蓝牙都有涉及，难度不高，很合适入门学习</li></ul><h2 id="LINUX开发"><a href="#LINUX开发" class="headerlink" title="LINUX开发"></a><strong>LINUX开发</strong></h2><ul><li><a href="https://book.douban.com/subject/1692629/">Advanced Programming in the UNIX Environment</a>: 熟悉Unix&#x2F;Linux系统开发的必读书之一, 对了解Unix类的操作系统工作原理很有帮助, 可以多看, 作为参考书常备.</li><li><a href="https://book.douban.com/subject/1500149/">Unix Network Programming</a>: 专门讲Unix类操作系统网络编程开发, 涵盖了网络编程的方方面面，软件开发人员必读书目.</li><li><a href="https://book.douban.com/subject/2287506/">深入理解LINUX内核</a>: 基于2.6版本的内核代码讲解Linux内核的具体实现原理, 内容翔实深入，是理解Linux内核的不可少的参考书之一.</li><li><a href="https://book.douban.com/subject/3652388/">程序员的自我修养</a>: 从库的加载与程序编译的角度讲解了Linux&#x2F;Windows下代码从编译到实际运行的具体过程, 对理解计算机代码的执行过程很有帮助, 可以作为参考书。</li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/performance_tuning_guide/index">Redhat系统优化手册</a>: 包含了Linux系统中内存&#x2F;IO&#x2F;网络相关的优化, 可以很好的将Linux系统与内核的知识串联在一起, 值得深入学习</li><li><a href="https://lwn.net/Kernel/">Linux内核周报</a>: Linux内核官方权威文档, 有很多值得一看的资料</li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a><strong>拓展</strong></h2><ul><li><a href="https://book.douban.com/subject/6021440/">黑客与画家</a>: 作者<code>Paul Graham</code>素有硅谷创业教父之称, 把计算机软件行业的各种问题都看得十分透彻, 值得多读</li><li><a href="https://book.douban.com/subject/10750155/">数学之美</a>: 吴军博士写的有关算法在互联网以及人工智能应用方面的科普类书籍，最近又看了一遍，值得学习。</li><li><a href="https://book.douban.com/subject/2243615/">Head First设计模式</a>: 再看一遍，是一本很不错的软件设计模式的书籍，深入浅出，还有很好的配图与案例，值得看看</li></ul><h2 id="大牛的网站"><a href="#大牛的网站" class="headerlink" title="大牛的网站"></a><strong>大牛的网站</strong></h2><ul><li><a href="https://coolshell.cn/">左耳朵耗子叔的个人网站</a></li><li><a href="http://mindhacks.cn/">刘未鹏</a></li><li><a href="http://www.ruanyifeng.com/home.html">阮一峰的个人网站</a></li><li><a href="http://blog.codingnow.com/">云风的BLOG</a></li><li><a href="https://blog.youxu.info/">4GSpace(徐宥)</a></li><li><a href="https://byvoid.com/zhs/blog/">Beyond The Void</a></li><li><a href="http://www.matrix67.com/blog/">matrix67</a></li><li><a href="https://www.joelonsoftware.com/">Joel On Software</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下是从事软件开发以来收藏的资料&amp;#x2F;书籍&amp;#x2F;网站, 欢迎推荐~&lt;/p&gt;
&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;&lt;strong&gt;基础&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://akaedu.github.io/book/&quot;&gt;Linux C一站式学习&lt;/a&gt;: 收藏已久, 值得一看&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/4822685/&quot;&gt;Code: The Hidden Language of Computer Hardware and Software&lt;/a&gt;: 最开始学单片机时就对CPU是如何执行代码, 如何解析代码并正常运营感到疑惑, &lt;code&gt;Code&lt;/code&gt;这本书正是从零开始解释了计算机内部是如何工作的, 看了两遍, 感觉都很过瘾, 值得学习&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/5333562/&quot;&gt;Computer Systems: A Programmer’s Perspective&lt;/a&gt;: 从计算机基础原理讲起, 阐述了计算机的原理, 内存&amp;#x2F;网络都有涵盖, 想进入软件行业的入门比读书之一; 平时也可以作为参考书籍不时翻一翻.&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="学习资料" scheme="https://sniffer.site/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>如何移植openssh到ARM开发板</title>
    <link href="https://sniffer.site/2022/02/16/%E5%A6%82%E4%BD%95%E7%A7%BB%E6%A4%8Dopenssh%E5%88%B0armv7%E7%B3%BB%E7%BB%9F/"/>
    <id>https://sniffer.site/2022/02/16/%E5%A6%82%E4%BD%95%E7%A7%BB%E6%A4%8Dopenssh%E5%88%B0armv7%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-02-16T06:54:00.000Z</published>
    <updated>2022-02-16T12:36:25.961Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为公司安全的需求, 要修改<code>openssh</code>的源码, 将其移植到一个ARM的嵌入式系统上, 替换原有的预编译的版本. 参考了网上的一些移植<code>openssh</code>的资料, 如<a href="https://wiki.openssl.org/index.php/Compilation_and_Installation">openssl官网编译安装说明</a>; <a href="https://www.cnblogs.com/TaXueWuYun/p/15314124.html">移植openssh到arm-linux</a>, 但是由于目标平台不一样, 实践起来并不能完全参考, 会有细微的差异. 这里把整个流程写下来, 总结一下, 方便后面移植相关开发工具.</p><span id="more"></span><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a><strong>下载源码</strong></h2><p><code>openssh</code>的编译依赖于<code>openssl</code>, <code>zlib</code>两个库, 因此编译的第一步是把所有这些源码都下载过来, 三个开源仓库下载路径如下:</p><ul><li><code>openssh</code>: git仓库以及各个release版本, <a href="https://www.openssh.com/portable.html">https://www.openssh.com/portable.html</a>; 由于release版本才有<code>Configure</code>脚本, 因此我直接下载了一个<code>v6.6p1</code>的稳定版本</li><li><code>openssl</code>: 包含github仓库以及文档说明, <a href="https://www.openssl.org/">https://www.openssl.org/</a>; github上的源码基本包含了历史分支信息, 因此可以直接通过<code>git clone</code>下载, 然后<code>checkout</code>到对应版本的分支(使用<code>v1.0.1</code>版本)</li><li><code>z-lib</code>: 官网上有下载链接, <a href="https://zlib.net/">https://zlib.net/</a>; github上也有仓库, 但是没有历史分支信息, 所以下载了版本<code>zlib-1.2.11</code>的源码.</li></ul><blockquote><p><code>openssh</code>的<code>INSTALL</code>文档中对所要求的<code>openssl</code>&#x2F;<code>z-lib</code>版本有具体说明, 可以参考.</p></blockquote><p>由于目标移植平台已有的<code>openssh</code>使用的版本是<code>OpenSSH_6.6p1</code>, 因此实际下载的源码版本信息如下:</p><ul><li><code>openssh</code>: Openssh_6.6p1</li><li><code>openssl</code>: OpenSSL_1_0_1-stable</li><li><code>z-lib</code>: zlib-1.2.11</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/usr/local/bin # ./ssh -V</span><br><span class="line">OpenSSH_6<span class="number">.6</span>p1, OpenSSL <span class="number">1.0</span><span class="number">.1</span>h <span class="number">5</span> Jun <span class="number">2014</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a><strong>编译源码</strong></h2><p>为了方便管理以及查看编译结果, 可以把三个软件包解压放到一个目录: <code>/data/wxn/openSSH</code>. 本地机器CPU是<code>x86_64</code>, 操作系统是Ubuntu16, 目标平台是<code>armv7</code>架构, 交叉编译使用的工具是<code>arm-none-linux-gnueabi-gcc</code>(gcc 4.6.2).</p><h3 id="编译zlib"><a href="#编译zlib" class="headerlink" title="编译zlib"></a><strong>编译zlib</strong></h3><p>进入<code>/data/wxn/openSSH/zlib-1.2.11</code>, 通过<code>./configure -h</code>查看编译配置说明:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">./configure -h</span><br><span class="line">usage:</span><br><span class="line">  configure [--<span class="type">const</span>] [--zprefix] [--prefix=PREFIX]  [--eprefix=EXPREFIX]</span><br><span class="line">    [--<span class="type">static</span>] [-<span class="number">-64</span>] [--libdir=LIBDIR] [--sharedlibdir=LIBDIR]</span><br><span class="line">    [--includedir=INCLUDEDIR] [--archs=<span class="string">&quot;-arch i386 -arch x86_64&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果只需要生成静态库, 就指定参数<code>--static</code>; 另外需要指定生成文件的路径:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">./configure --<span class="type">static</span> --prefix=/data/wxn/openSSH</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述指令生成编译的<code>Makefile</code>后, 修改其中的编译工具, 将其指向交叉编译工具所在的路径(需要修改<code>gcc</code>&#x2F;<code>ar</code>两个工具的路径): </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TOOL_PREFIX=/data/wxn/toolchainbin/arm-none-linux-gnueabi-</span><br><span class="line">CC=$(TOOL_PREFIX)gcc</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行<code>make;make install</code>, 在目录<code>/data/wxn/openSSH/lib</code>下可以看到生成了一个<code>libz.a</code>的静态库.</p><h3 id="编译openssl"><a href="#编译openssl" class="headerlink" title="编译openssl"></a><strong>编译openssl</strong></h3><p>编译<code>openssl</code>会稍微麻烦点. 同样查看<code>./Configure -h</code>可以看到, 需要配置目标平台的系统类型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">./Configure -h</span><br><span class="line">Configuring <span class="keyword">for</span></span><br><span class="line"> </span><br><span class="line">Usage: Configure [no-&lt;cipher&gt; ...] [enable-&lt;cipher&gt; ...] [experimental-&lt;cipher&gt; ...] [-Dxxx] [-lxxx] [-Lxxx] [-fxxx] [-Kxxx] [no-hw-xxx|no-hw] [[no-]threads] [[no-]shared] [[no-]zlib|zlib-dynamic] [no-<span class="keyword">asm</span>] [no-dso] [no-krb5] [sctp] [<span class="number">386</span>] [--prefix=DIR] [--openssldir=OPENSSLDIR] [--with-xxx[=vvv]] [--test-sanity] os/compiler[:flags]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译配置<code>Configure</code>中已经添加了很多平台类型(<code>./Configure LIST</code>可以查看已经支持的平台), 但是好像并没有发现<code>armv7</code>架构的平台, <a href="https://wiki.openssl.org/index.php/Compilation_and_Installation#ARM">openssl官网</a>建议自己手动添加一个配置, 但看了其他地方说可以使用相似平台的配置, 看配置列表跟arm相关的有<code>android-armv7</code>&#x2F;<code>linux-armv4</code>两个, 尝试了<code>armv4</code>发现是可以(<code>android-armv7</code>会出现编译错误):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">./Configure linux-armv4 --prefix=/data/wxn/openSSH</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改生成的<code>Makefile</code>, 按照之前的<code>zlib</code>配置, 将其中<code>gcc/nm/ar</code>的地方都指向交叉编译工具所在的目录, 执行<code>make; make install</code>, 即可看到<code>/data/wxn/openSSH</code>生成了<code>lib/bin</code>两个目录, <code>lib</code>目录包含了<code>libssl.a/libcrypto.a</code>静态库, <code>bin</code>下包含了<code>openssl</code>工具.</p><h3 id="编译openssh"><a href="#编译openssh" class="headerlink" title="编译openssh"></a><strong>编译openssh</strong></h3><p>编译<code>openssh</code>跟之前两个库的编译类似(具体可以参考<code>INSTALL</code>文档), 只不过需要指定生成的<code>openssl</code>&#x2F;<code>zlib</code>所在目录(进入代码根目录):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GCC=/data/wxn/toolchain/arm-none-linux-gnueabi-gcc</span><br><span class="line">AAR=/data/wxn/toolchain/arm-none-linux-gnueabi-ar</span><br><span class="line">./configure --host=arm-linux --prefix=/usr/local --with-zlib=/data/wxn/openSSH --with-ssl-dir=/data/wxn/openSSH --disable-etc-<span class="keyword">default</span>-login --disable-strip CC=$GCC AR=$AAR</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着执行<code>make</code>(不用执行安装指令<code>make install</code>), 可以看到根目录下多了<code>ssh/sshd/scp</code>等工具.将其拷贝到目标平台对应目录<code>/usr/local/bin</code>, 确认可以正常运行, 至此大功告成.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近因为公司安全的需求, 要修改&lt;code&gt;openssh&lt;/code&gt;的源码, 将其移植到一个ARM的嵌入式系统上, 替换原有的预编译的版本. 参考了网上的一些移植&lt;code&gt;openssh&lt;/code&gt;的资料, 如&lt;a href=&quot;https://wiki.openssl.org/index.php/Compilation_and_Installation&quot;&gt;openssl官网编译安装说明&lt;/a&gt;; &lt;a href=&quot;https://www.cnblogs.com/TaXueWuYun/p/15314124.html&quot;&gt;移植openssh到arm-linux&lt;/a&gt;, 但是由于目标平台不一样, 实践起来并不能完全参考, 会有细微的差异. 这里把整个流程写下来, 总结一下, 方便后面移植相关开发工具.&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://sniffer.site/categories/Linux/"/>
    
    
    <category term="openssh" scheme="https://sniffer.site/tags/openssh/"/>
    
    <category term="ARM嵌入式开发" scheme="https://sniffer.site/tags/ARM%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深度学习简介</title>
    <link href="https://sniffer.site/2022/01/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/"/>
    <id>https://sniffer.site/2022/01/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/</id>
    <published>2022-01-29T07:58:11.000Z</published>
    <updated>2022-03-23T03:27:46.227Z</updated>
    
    <content type="html"><![CDATA[<p>深度学习(<code>Deep Learning</code>)是近年来人工智能的热门研究领域, 广泛地应用在工业与商业领域, 如计算机视觉(<code>Computer Vision</code>), 语音识别(<code>Speech Recognition</code>), 自然语言处理(<code>Natural Language Processing</code>), 机器翻译(<code>Machine Translation</code>), 以及医学图像分析, 药物发现等领域都采用了深度学习方法. 从本质上来说, 深度学习属于机器学习(<code>Machine Learning</code>)的一个分支, 是一种从大规模数据进行学习然后能在新数据集进行推理泛化的数学模型.</p><p>相比人工智能, 深度学习只是最近十来年才出现的概念, 但为何会在在最近几年(2010开始)内出现井喷式的增长, 成为人工智能领域炙手可热的研究方向了? 总结来说主要有如下几个原因:</p><span id="more"></span><ul><li>数据集: 随着大型互联网公司的出现, 大规模的数据集变得触手可得</li><li>物理设备: 存储设备容量更大, 价格更便宜, 能够保存更多的数据; GPU等支持并行计算的专用处理器为深度学习模型的训练提供必要的物理基础, 让模型训练时间更短</li><li>Google&#x2F;Facebook等公司开源了<code>Tensorflow</code>&#x2F;<code>Caffe</code>&#x2F;<code>PyTorch</code>等开源了深度学习的框架, 为深度学习的应用与传播起到了重要的推动作用</li></ul><p>深度学习核心思想来自于人工神经网络(<code>Artificial Neural Network</code>), 但从结构上来说, 深度学习网络具有更多的层级, 网络结构更为复杂, 存在前馈&#x2F;循环以及深度生成对抗网络等多种形式, 因此并不与神经网络等价, 可以看作是神经网络的升级版. 从技术的范畴来说, 深度学习是机器学习的一个子集, 而机器学习是人工智能(<code>Artificial Inteligence</code>)的一个分支而已.</p><p align="center">    <img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/AI-ML-DL.svg.png" width=500 height=500></p><blockquote><p>这篇文章旨在对深度学习的历史以及基本概念做梳理, 可能有很多疏漏跟错误的地方, 感兴趣的同学可以自行参考文末的文献进行深入了解.</p></blockquote><h2 id="人工智能的发展历程"><a href="#人工智能的发展历程" class="headerlink" title="人工智能的发展历程"></a><strong>人工智能的发展历程</strong></h2><p>人工智能是人类尝试通过计算机模拟生物智能尤其是人类智能活动, 从而实现机器智能的目标. 人脑经历上千万年的进化才得以形成如此复杂的结构, 想要让机器具备人一样的智能, 机器需要拥有感知(计算机视觉, 语音识别), 学习(模式识别, 机器学习, 强化学习), 语言(自然语言处理), 决策(规划, 数据挖掘)等多种能力. 而这些都构成了人工智能的研究领域.</p><p>一般来说, 人工智能的研究领域大致可以分为如下几个部分:</p><ul><li>感知(<code>perception</code>): 模拟生物的感知能力,  对外部信息如视觉&#x2F;听觉进行处理加工, 主要研究领域包括计算机视觉和语音信息处理等</li><li>学习(<code>Learning</code>): 模拟生物的学习能力, 研究如何从已有数据集或从与环境的交互中进行学习, 研究领域包括监督学习(<code>Supervised Learning</code>), 无监督学习(<code>Unsupervised Learning</code>)以及强化学习(<code>Reinforcement Learning</code>)等</li><li>认知(<code>Cognition</code>): 模拟生物的认知能力, 研究领域包括知识表示, 自然语言理解, 推理&#x2F;规划&#x2F;决策等</li></ul><p>自人工智能诞生以来, 大致经历了三个重要的发展阶段:</p><p align="center">    <img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ai_history.png"></p><ul><li>推理期:  1956年达特茅斯的人工智能会议后, 相关的研究开始涌现出来. 研究者基于逻辑或者事实归纳出来一系列规则, 基于这些规则通过编程尝试让计算机完成某些特定的任务. 但当时的人们过于乐观, 也低估了人工智能系统实现的难度, 很多项目难以达到预期的目标. 人工智能的研究在之后的数年时间陷入了低谷, 很多研究项目被中止, 经费被削减.</li><li>知识期:  到20世纪70年代, 人们开始意识到知识对人工智能系统的重要性. 这一时期开始出现很多专家系统(<code>Expert System</code>), 并在特定的领域取得了很多成果. 专家系统一般采用知识表示和知识推理来完成由领域专家才能解决的问题. 为了解决这些问题, 人们开发出了Prolog(<code>Programming in Logic</code>)语言来构造专家系统&#x2F;知识库以及实现自然语言理解等.</li><li>学习期: 到这个阶段, 研究者尝试利用数据让机器自动学习, 即采用机器学习(<code>Machine Learning</code>)的方式让计算机从数据(经验)中学习并获得规律(模型), 然后再利用该模型在未知的数据集上进行预测推理.</li></ul><blockquote><p>参考<a href="https://nndl.github.io/">&lt;神经网络与深度学习&gt;</a></p></blockquote><p>人工智能的发展距今已经超过60年, 大数据与深度学习方法的结合让原本看来很困难的问题, 如图像识别, 语音识别, 机器翻译等变得更加容易, 甚至在某些特定的领域这些深度学习模型能够超越人类的表现. 但要想真正实现与人同样的智能程度, 还有很多的困难需要解决, 还有很长的路要走.</p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a><strong>机器学习</strong></h2><p>机器学习(<code>Machine Learning</code>)是指从有限的观测数据中学习出具有一般性的规律(找出数据中模式), 并利用这些规律对未知的数据进行预测的方法. 国际机器学习大会的创始人之一<code>Tom Mitchell</code>对机器学习的定义是：计算机程序从经验 <code>E</code> 中学习，解决某一任务<code>T</code>，进行某一性能度量<code>P</code>，通过<code>P</code>测定在<code>T</code>上的表现因经验<code>E</code>而提高.</p><p>要训练一个机器学习模型, 通常包含如下几个部分:</p><ul><li>数据(<code>data</code>):  用于训练模型与验证模型的数据集. 数据集由一个个样本(<code>sample</code>)组成, 大多数时候, 这些样本都遵循独立同分布(<code>Independently and Identcally Distributed</code>), 每个样本通常由一组特征(<code>features</code>, 也称为协变量-<code>covariables</code>)组成. 机器学习模型会根据这些属性进行预测.</li><li>模型(<code>model</code>): 模型是对给定数据集的抽象表示, 可以看作参数化的数学模型.</li><li>目标函数: 要想从数据中学习到某种规律(经验), 首先要有一种度量模型质量的方法, 在大多数情况下, 这个模型度量是可优化的, 我们称之为目标函数(<code>objective function</code>), 也称为损失函数(<code>loss function</code>&#x2F;<code>cost function</code>).  通常, 目标函数是根据模型参数定义的, 并取决于数据集. 为了确保模型在未知的数据上具备足够的泛化能力(<code>generalization</code>), 通常需要将数据集划分成训练集(<code>training set</code>)和测试集(<code>test set</code>)两个部分. 训练集用于训练模型, 而测试集用于验证模型的能力. 如果一个模型在训练集上表现很好, 但在测试集上却表现比较差, 我们称这种情况为模型过拟合(<code>over-fitting</code>); 有时在训练模型的过程中, 通常还需要将数据集分出一部分用于验证评估模型的质量, 这部分数据集就称为验证集(<code>validation set</code>).</li><li>模型优化算法: 模型训练的过程, 其实就是对模型参数进行搜索, 从而最小化目标函数. 比如常用的梯度下降(<code>gradient descent</code>)算法, 在每个步骤中, 会对每个参数沿着目标函数减小的方向(对应的梯度是下降的)进行调整, 直到目标函数达到某个局部最小点或者全局最小点.</li></ul><p>按类别来说, 机器学习一般来说分为监督学习, 非监督学习和强化学习三种:</p><p align="center">    <img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ml_types.png"></p><ul><li>监督学习(<code>supervised-learning</code>)是指在一组特征(faeture, 输入)与标签(label, 输出)的情况下对特定输入特征进行预测的一类算法, 常见的有回归, 分类, 以及序列学习等.</li></ul><p align="center">    <img src="https://zh-v2.d2l.ai/_images/supervised-learning.svg"></p><ul><li><p>无监督学习(<code>unsupervised learning</code>), 与监督学习不同的是, 只有输入特征, 却没有一个可以参考的输出标签; 需要从这些数据中找出特定的关系, 挖掘数据内在的联系. 比如在没有标签信息的情况下, 如何把一堆图标分类成风景, 动物, 婴儿等; 找到较少的参数来描述数据中的线性关系, 从不同的数据中找到相关性. 常见的有聚类分析, 主成分分析, 以及概率图模型&#x2F;生成对抗网络等.</p></li><li><p>强化学习(<code>reinforcement learning</code>): 上述两种方法都采用的是预先获取到的经验数据来训练模型, 并没有从外部环境交互中获取数据, 因此是离线学习(<code>offline learning</code>).  与此不同的是, 强化学习中的<code>agent</code>会通过观察者(<code>observation</code>)不断与环境进行交互, 然后从中获得奖励<code>reward</code>, <code>agent</code>根据奖励来调整自己的执行动作<code>action</code>, 以输出一个更好的策略.这个过程会随着系统与外界环境交互持续进行. 强化学习是一个十分强大的通用性学习框架, 打败世界围棋冠军的<code>AlphaGo</code>就是基于强化学习开发的.</p></li></ul><h2 id="人工神经网络与深度学习"><a href="#人工神经网络与深度学习" class="headerlink" title="人工神经网络与深度学习"></a><strong>人工神经网络与深度学习</strong></h2><p>说到深度学习, 就不得不提人工神经网络(<code>Artificial Neural Network</code>), 因为正是有了前期人工神经网络的技术积累, 尤其是多层网络的训练算法-反向传播算法(<code>backpropagation</code>),才有了深度学习今天的广泛应用.</p><p>人工神经网络基本的单元-人工神经元(<code>neuron</code>)本质上是模拟大脑的神经元构建出来的, 一般由三个部分组成: 输入(<code>inputs</code>), 激活函数(<code>activation function</code>)以及输出(<code>outpus</code>), 写成数学表达式如下:</p><p>$$y &#x3D; \varphi(\sum_{i&#x3D;1}^{m} w(i) * x(i) + b)$$</p><p align="center">    <img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/artificial-neuron.jpg" width="500"></p><p>人工神经网络是在单个神经元的基础上做了扩展, 引入了一个隐藏层(<code>hidden layer</code>), 从而形成一个多层的结构, 这个就类似于人脑的神经网络了: 网络通过从数据中获取知识, 每个神经元的权重值保存了学习到的知识. 人工神经网络具有较强的拟合能力, 可以看作一个通用的函数逼近器(一个两层的神经网络可以逼近任意函数). </p><p align="center">    <img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/multiple_layers_ann.png" width="600"></p><p>深度学习(<code>Deep Learning</code>)是在人工神经网络的基础上发展而来, 只是在网络结构上引入了更多的隐藏层, 网络的结构也更为多样复杂. 常见的网络结构有前馈网络, 记忆网络以及图网络:</p><ul><li>前馈网络(<code>feedforward neural network</code>): 各个神经元属于不同的层, 每一层可以接收上一层的输出为输入, 并产生信号输出到下一层. 网络的第0层为输入层, 最后一层为输出, 其他层均为隐藏层. 常见的前馈网络有卷积神经网络(<code>Convolutional Neural Network</code>)</li><li>记忆网络: 记忆网络也称为反馈网络(<code>feedback network</code>), 网络中的神经元不但可以接收来自上一层神经元的信息, 也可以接收来自自身的信息; 记忆网络中的神经元具有记忆功能, 在不同时刻具有不同状态. 常见的记忆网络有循环神经网络(<code>Recurrent Neural Network</code>), Hopfiled网络, 波尔兹曼机(<code>boltzmann machine </code>)等.</li><li>图网络: 前馈网络和记忆网络的输入都可以表示为向量或向量序列,但在实际应用中, 如知识图谱, 社交网络, 分子(molecular)网络等都是图结构的数据, 这类数据网络需要用图网络来学表达. 在图网络中, 每个节点由一个或一组神经元构成, 节点之间的连接可以是有向的, 也可以是无向的, 每个节点可以接收来自相邻节点或者自身的信息. 常见的图网络有图卷积网络(<code>Graph Convolutional Network</code>), 图注意力网络(<code>Graph Attention Network</code>)等.</li></ul><p align="center">    <img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/nn_types.png" width="600"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>深度学习从概念的出现到今天的大规模应用, 也不过20来年的历史, 但已经在图像识别, 语音识别, 自然语言处理等各个方面都取得了令人惊讶的成绩, 基于深度学习的AI模型不仅可以准确识别图像, 也可以在围棋上战胜人类冠军; 可以与人展开对话, 也可以执行自动驾驶的功能. 未来, 随着大数据与AI技术的发展, 深度学习会在更多的行业与领域得到更广泛的应用. 近年来, 基于多个机器学习模型的多模态技术(<code>multimodal machine learning</code>)的逐渐发展, 在很多领域都取得了不错的成果. 相信在不久的将来, 无论是手机终端, 还是汽车&#x2F;飞机都会有深度学习的身影, 在人类生活的各个方面都发挥至关重要的作用.未来会是一个基于大数据的智能化时代-一个大数据与深度学习等人工智能技术紧密结合的智能化时代.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://en.wikipedia.org/wiki/History_of_artificial_intelligence">AI的历史</a></li><li><a href="http://deeplearning.cs.cmu.edu/F21/index.html">CMU深度学习课程, 值得收藏学习</a></li><li><a href="https://en.wikipedia.org/wiki/Deep_learning">https://en.wikipedia.org/wiki/Deep_learning</a></li><li><a href="https://zh-v2.d2l.ai/chapter_introduction/index.html">动手学习深度学习, 实践与理论结合, 非常好的开源书籍</a></li><li><a href="http://neuralnetworksanddeeplearning.com/">国外大牛写的开源书籍</a></li><li><a href="https://nndl.github.io/">神经网络与深度学习, 国内大牛的开源书籍</a></li><li><a href="https://towardsdatascience.com/the-past-present-and-future-of-deep-learning-adb4d60eaf24">简要介绍深度学习的历史</a></li><li><a href="https://github.com/microsoft/ML-For-Beginners">微软开发的一个机器学习入门课程, 值得学习</a></li><li><a href="https://www.tensorflow.org/guide/basics">Tensorflow官网</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;深度学习(&lt;code&gt;Deep Learning&lt;/code&gt;)是近年来人工智能的热门研究领域, 广泛地应用在工业与商业领域, 如计算机视觉(&lt;code&gt;Computer Vision&lt;/code&gt;), 语音识别(&lt;code&gt;Speech Recognition&lt;/code&gt;), 自然语言处理(&lt;code&gt;Natural Language Processing&lt;/code&gt;), 机器翻译(&lt;code&gt;Machine Translation&lt;/code&gt;), 以及医学图像分析, 药物发现等领域都采用了深度学习方法. 从本质上来说, 深度学习属于机器学习(&lt;code&gt;Machine Learning&lt;/code&gt;)的一个分支, 是一种从大规模数据进行学习然后能在新数据集进行推理泛化的数学模型.&lt;/p&gt;
&lt;p&gt;相比人工智能, 深度学习只是最近十来年才出现的概念, 但为何会在在最近几年(2010开始)内出现井喷式的增长, 成为人工智能领域炙手可热的研究方向了? 总结来说主要有如下几个原因:&lt;/p&gt;</summary>
    
    
    
    <category term="人工智能" scheme="https://sniffer.site/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="人工智能" scheme="https://sniffer.site/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="机器学习" scheme="https://sniffer.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://sniffer.site/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Deep Learning" scheme="https://sniffer.site/tags/Deep-Learning/"/>
    
    <category term="Machine Learning" scheme="https://sniffer.site/tags/Machine-Learning/"/>
    
    <category term="AI" scheme="https://sniffer.site/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>感悟2021</title>
    <link href="https://sniffer.site/2021/12/31/%E6%84%9F%E6%82%9F2021/"/>
    <id>https://sniffer.site/2021/12/31/%E6%84%9F%E6%82%9F2021/</id>
    <published>2021-12-31T10:06:49.000Z</published>
    <updated>2022-02-28T10:27:54.750Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>天之道, 利而不害; 圣人之道, 为而不争</p><p>老子</p></blockquote><p><img src="https://images.unsplash.com/photo-1526772662000-3f88f10405ff?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1074&q=80" alt="A Thinking Man"></p><span id="more"></span><p>到了年终时刻, 面对新年的来临, 总免不了回想过去365天所发生的一些事情, 脑海里重放经历过的点点滴滴. 过去一年, 有成长, 有失落; 有痛苦, 有欢乐. 看了年初立下的flag, 有些实现了, 有些还没有, 总的说来差强人意.  感概, 领悟, 波折起伏之后方才懂得人生哪些事情是重要的, 需要用心用气力去呵护与完善; 哪些是不重要的, 不足挂齿, 发生了依然可以云淡风轻.</p><ul><li>2021年女儿两岁了,  变成了一个调皮捣蛋的小可爱, 每天都会粑粑粑粑的叫个不停. 女儿的成长让我这个缺乏耐心, 时不时发脾气的父亲变得更温和, 更有责任心与同理心, 也是我每天进步的动力.</li><li>工作上, 今年开始有所沉淀, 遇到什么问题都会深究与总结, 一年下来也写了快10篇博客; 下半年开始了解深度学习, 算摸到了机器学习的门, 这个也会是后面重点投入的方向.</li><li>由于公司开始了双休制度, 得以有时间开始锻炼身体, 周末打几个小时的羽毛球, 着实收获良多, 不仅人的精力更好, 精神状态也改善了不少.</li><li>看了不少书,  技术的有, 哲学的也有, 思维方式的也有, 有数量, 但是不够系统. 印象比较深刻的是混沌大学李善友的&lt;第一性原理&gt;与&lt;第二曲线创新&gt;, 吴军的&lt;智能时代-大数据智能革命&gt;以及日本哲学家饮茶写的&lt;了不起的哲学家&gt;. 希望今年能够开始系统性的学习研究某些方向, 争取有所输出, 而不是单纯的阅读.</li></ul><p>再细细想想, 2021年有几个感悟值得写下来, 共勉.</p><h2 id="从现实出发-与生活和解"><a href="#从现实出发-与生活和解" class="headerlink" title="从现实出发, 与生活和解"></a>从现实出发, 与生活和解</h2><p>现代人的生活繁忙而带着些许焦虑, 一周大部分时间都在忙着工作, 很少会有足够的时间静下来思考生活, 思考人生. 从小到大, 我们都被教育要争第一, 可是没有人告诉我们, 得到第一之后应该怎么做. 我们都在围绕着得到而努力, 为了获取而挣扎. 儿时, 如果得不到一个想要的玩具, 我们会伤心痛哭, 汪汪的流泪；长大后, 我们会为了金钱, 职称;大的房子, 好的车子不断奋斗, 一旦得不到就会难过痛苦. 在内心深处, 我们只是把财富&#x2F;功名&#x2F;车子&#x2F;房子这些外在的东西内化成了自己儿时的<code>玩具</code>, 把它们当成了自己的一部分, 所以没有得到或者失去这些东西会让我们伤心. 但, 我们却从来没有问自己, 得到这些外在的东西之后, 会怎么样? 应该怎么样?</p><p>换个角度, 如果我们把这些外在的物质与内心的真正需求切割开来, 会如何? 归根结底, 内心的富足与幸福跟这些外在的玩具没有什么必然的联系, 只是在成长过程中, 社会把这些价值观念在潜移默化中烙印在我们的心灵上, 而我们也不假思索的予以接纳罢了. 我们一直在向外需求幸福与快乐, 却得到的总是失落与痛苦, 而实际能让我们获得安宁与富足的是内心的强大与开放.</p><p>向内求而不是向外求. 这才是生活与快乐与幸福的源泉. 向外求, 依靠外在的财富与名利不断来达成人生的目标与自我价值的认可, 是一条失去自我的不归路-有钱了, 才会觉得安全, 一旦失去财富可能会让你难过痛苦; 有了各种名号, 才觉得被认可与尊重, 一旦得不到就失落而难以自处; 有了10万, 我们希望有100万, 有了一个房子, 我们希望有一个别墅. 这种无止境的追求外在的物质财富, 是让我们迷失自我, 丧失个人价值与幸福的根源. 我们已经忘了, 人生到头, 名利财富终究是一场空. 那些我们绞尽脑汁,日夜寻思的东西其实都是让我们失去自我的魔鬼. 佛教在很早之前就道出了这些真理, 所谓<code>色即是空, 空即是色</code>. 形形色色的物欲不但偷走了我们的时间精力, 也让我们丧失了内心的安宁. </p><p>但毕竟我们每个人都有无法从现实脱身的理由-有妻儿, 有父母, 有兄弟姐妹, 有朋友, 我们也很难做到像释迦牟尼一样从一个王子变成一个追寻信仰的修道者, 成为宗教领袖. 我们都是凡人, 都有凡身. 但依然, 我们可以选择, 在纷繁复杂的世界里, 我们依然可以有所作为. 基于现实, 向内求, 不要纠结一时的得失, 不要纠结名利, 要从更长远的角度来看待人生与生命的价值&#x2F;意义, 要与生活的一切和解, 理解, 包容, 温和, 有度, 在混沌中寻求内心的富足与安宁.</p><h2 id="享受成长的痛苦"><a href="#享受成长的痛苦" class="headerlink" title="享受成长的痛苦"></a>享受成长的痛苦</h2><p>向外求, 其实是容易的; 向内求更难. 向内求, 需要我们去感知内心, 尝试理解自己头脑中思维模式, 尝试找到一切困惑与苦恼的源头. 这种探索与寻求并不容易. 历史上的各路牛人, 释迦牟尼, 老子, 耶稣, 尼采; 牛顿, 爱因斯坦等在用不同的方式追问人生与宇宙的奥秘, 而天资平平的我们要依靠什么去追问内心的答案, 得到人生的真谛.</p><p>这注定是一条艰难的路. 思维与认知的转变好像总是伴随痛苦, 就好像母亲孕育一个新生命一样-十月怀胎, 呕吐难受, 没有几天踏实安静的日子; 等到要生产时, 几乎要将一个母亲脱胎换骨, 一个生命才会真正诞生. 一个人的成长其实是类似的,  若非有苦痛, 可能就像是温水里的青蛙, 自我感觉良好, 没有危机感, 感知不到外界的变化, 实际上只是在原地踏步, 并没有任何的长进. 真正的成长, 是认知冲突后带来的思维方式的变化, 总会伴随着阵痛与挣扎. 而要想获得突破, 我们也要适应这种内心的冲突, 不断的挑战与调整已有的认知, 保持好奇心, 主动去寻求与探索现有的边界.</p><p>那么, 对于个人来说, 如何做到拓展认知与思维的界限? 以个人经验来说, 大致有如下几个方法:</p><ul><li>建立系统性的思维框架: 不管是了解一个陌生还是一个熟悉的领域, 建立一套有效可行的思维框架都至关重要, 这也是初学者与专家的重要区别. 有了思维框架, 可以让我们对一个领域会有更深入全面的理解, 也为我们探索新的知识领域提供夯实的基础.</li><li>阅读, 多读经典: 所谓开卷有益, 养成阅读尤其是经典好书的习惯, 让大脑处于一个放空的模式-接收未曾了解过的新思路, 新方法. 有时, 即使是随便翻翻书, 也可能会有不一样的收获.</li><li>要有意识的进行输出: 如果没有将阅读与思考进行输出, 我们可能很难清晰的看到自己内心真正的想法是什么样子. 输出不仅是重新厘清大脑中认知的模糊地带, 也有助于建立自己的知识体系.</li><li>锻炼身体与磨砺心智一样重要: 虽然在哲学上, 关于心灵与肉体的统一尚有争论, 但无可否认, 一个健康的身体有利于大脑的良好运转, 让大脑处于一个更高效&#x2F;更有活力的状态. 不要忽略你的身体, 节制的饮食, 定时的锻炼都能帮助大脑运转的更好(大脑是否等同于心灵了, 暂且不论).</li></ul><p>2021已经成为永恒记忆的一部分了-一切过往,皆为序章. 2022, 你好.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;天之道, 利而不害; 圣人之道, 为而不争&lt;/p&gt;
&lt;p&gt;老子&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1526772662000-3f88f10405ff?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1074&amp;q=80&quot; alt=&quot;A Thinking Man&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="https://sniffer.site/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="成长" scheme="https://sniffer.site/tags/%E6%88%90%E9%95%BF/"/>
    
    <category term="个人总结" scheme="https://sniffer.site/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>理解Android eBPF</title>
    <link href="https://sniffer.site/2021/11/26/%E7%90%86%E8%A7%A3Android-eBPF/"/>
    <id>https://sniffer.site/2021/11/26/%E7%90%86%E8%A7%A3Android-eBPF/</id>
    <published>2021-11-26T07:34:45.000Z</published>
    <updated>2022-07-18T05:39:36.647Z</updated>
    
    <content type="html"><![CDATA[<p>Android从9.0版本开始全面支持eBPF(<code>extended Berkeley Packet Filters</code>), 其主要用在流量统计上, 也可以用来监控CPU&#x2F;IO&#x2F;内存等模块的状态.简单来说, <code>eBPF</code>可以与内核的<code>kprobe</code>&#x2F;<code>tracepoints</code>&#x2F;<code>skfilter</code>等模块相结合, 将eBPF的函数hook到内核事件从而监控相应的系统状态.</p><p>Android为eBPF提供了许多封装的库, 并提供了eBPF加载器<code>bpfloader</code>:</p><ul><li><code>bpfloader</code>: 位于<code>/system/bpf/bpfloader</code>, 系统启动时负责加载位于<code>/system/etc/bpf</code> 中的eBPF目标文件</li><li><code>libbpf_android</code>: 位于<code>/system/bpf/libbpf_android</code>提供创建bpf容器&#x2F;加载bpf目标文件的接口</li><li><code>libbpf</code>: 位于<code>/external/bcc</code>, 封装了bpf的系统调用, 提供如attach&#x2F;deattach程序的接口</li><li><code>libnetdbpf</code>: 位于<code>/system/netd/libnetdbpf</code>, 实现了netd流量统计功能的函数</li></ul><p>目前在Android(Q)上有两处eBPF的代码: 一个是<code>/system/netd/bpf_progs/netd.c</code>, 主要是用于流量统计；一个是<code>/system/bpfprogs/time_in_state.c</code>用于监控CPU运行频率以及上下文切换的耗时.</p><p>接下来我们就从三个部分来深入理解下Android是如何利用eBPF的:</p><ul><li>eBPF程序与目标文件格式</li><li>Android eBPF加载与执行流程</li><li>Android如何基于eBPF实现流量统计</li></ul><span id="more"></span><blockquote><p>有关BPF的介绍可以参考之前的文章<a href="https://sniffer.site/2019/11/07/bpf%E4%B8%8Eebpf/">BPF与eBPF</a></p></blockquote><h2 id="eBPF程序与目标文件的格式"><a href="#eBPF程序与目标文件的格式" class="headerlink" title="eBPF程序与目标文件的格式"></a><strong>eBPF程序与目标文件的格式</strong></h2><p>在Android中, 一个eBPF的c程序格式通常如下, 总的说来分为三个部分:</p><ul><li>通过<code>DEFINE_BPF_MAP</code>定义BPF数据容器的类型以及访问接口</li><li>声明代码段, 比如<code>SEC(&quot;cgroupsock/inet/create&quot;)</code></li><li>声明BPF段的证书类型,  一般是<code>GPL</code>或者跟GPL兼容的证书类型</li></ul><blockquote><p>看内核代码, 对于大部分的BPF容器类型可以是<code>GPL</code>的, 也可以是其他证书, 但对于<code>stackmap.c</code>则要求只能是<code>GPL</code>的.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf_helpers.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define one or more maps in the maps section, for example</span></span><br><span class="line"><span class="comment"> * define a map of type array int -&gt; uint32_t, with 10 entries</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DEFINE_BPF_MAP(name_of_my_map, ARRAY, <span class="type">int</span>, <span class="type">uint32_t</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* this will also define type-safe accessors:</span></span><br><span class="line"><span class="comment"> *   value * bpf_name_of_my_map_lookup_elem(&amp;key);</span></span><br><span class="line"><span class="comment"> *   int bpf_name_of_my_map_update_elem(&amp;key, &amp;value, flags);</span></span><br><span class="line"><span class="comment"> *   int bpf_name_of_my_map_delete_elem(&amp;key);</span></span><br><span class="line"><span class="comment"> * as such it is heavily suggested to use lowercase *_map names.</span></span><br><span class="line"><span class="comment"> * Also note that due to compiler deficiencies you cannot use a type</span></span><br><span class="line"><span class="comment"> * of &#x27;struct foo&#x27; but must instead use just &#x27;foo&#x27;.  As such structs</span></span><br><span class="line"><span class="comment"> * must not be defined as &#x27;struct foo &#123;&#125;&#x27; and must instead be</span></span><br><span class="line"><span class="comment"> * &#x27;typedef struct &#123;&#125; foo&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;PROGTYPE/PROGNAME&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">PROGFUNC</span><span class="params">(..args..)</span> &#123;</span><br><span class="line">   &lt;body-of-code</span><br><span class="line">    ... read or write to MY_MAPNAME</span><br><span class="line">    ... <span class="keyword">do</span> other things</span><br><span class="line">   &gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> _license[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>; <span class="comment">// or other license</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码中<code>PROGFUNC</code>定义了一个函数, 编译后会生成一个<code>PROGTYPE/PROGNAME</code>的段(section), 其中<code>PROGTYPE</code>是<code>eBPF</code>代码类型, (对Android来说)必须是下表中的名字:</p><table><thead><tr><th>事件类型</th><th>BPF代码类型</th><th>说明</th></tr></thead><tbody><tr><td>kprobe</td><td>BPF_PROG_TYPE_KPROBE</td><td>将ePBF函数hook到kprope上以探测内核事件, PROGNAME必须是内核中被kprobe监控的函数名</td></tr><tr><td>tracepoint</td><td>BPF_PROG_TYPE_TRACEPOINT</td><td>将eBPF函数hook到tracepoint事件上, PROGNAME必须是<code>SUBSYSTEM/EVENT</code>的格式, 例如用于监控上下文切换的段可以写成<code>SEC(tracepoint/sched/sched_switch</code>, 具体可以参考&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;events&#96;下面各个系统事件名</td></tr><tr><td>skfilter</td><td>BPF_PROG_TYPE_SOCKET_FILTER</td><td>将eBPF函数当作一个netfilter模块执行, 参考内核代码<code>xt_bpf.c</code></td></tr><tr><td>schedcls</td><td>BPF_PROG_TYPE_SCHED_CLS</td><td>将eBPF函数当作一个网络数据包的分类器(classifier), 参考内核代码<code>cls_bpf.c</code></td></tr><tr><td>cgroupskb&#x2F;cgroupsock</td><td>BPF_PROG_TYPE_CGROUP_SKB&#x2F;BPF_PROG_TYPE_CGROUP_SOCK</td><td>每当指定的cgroup上有数据传输(SKB); 创建<code>AF_INET/AF_INET6</code>的socket(SOCK)时就执行eBPF函数 ,参考<code>bpf-cgroup.h </code></td></tr></tbody></table><p>每个eBPF c语言程序都会通过LLVM编译成ELF(<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"><code>Executable-Link Format</code></a>目标文件, 我们可以通过linux中的<code>readelf</code>&#x2F;<code>objdump</code>工具来查看ELF文件. 比如利用<code>readelf -S netd.o</code>查看<code>netd.o</code>的段头信息, 从这里可以看到<code>netd.c</code>中定义的各个段:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/netdo_elf_sh.png" alt="netd.o sections"></p><h2 id="Android中eBPF加载流程"><a href="#Android中eBPF加载流程" class="headerlink" title="Android中eBPF加载流程"></a><strong>Android中eBPF加载流程</strong></h2><p>在系统启动阶段, Android会把位于<code>/system/etc/bpf/</code>的eBPF目标文件通过<code>bpfloader</code>这个服务加载到内核:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">service bpfloader /system/bin/bpfloader</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">capabilities</span> <span class="title">SYS_ADMIN</span></span></span><br><span class="line"><span class="class">    # <span class="title">Set</span> <span class="title">RLIMIT_MEMLOCK</span> <span class="title">to</span> 64<span class="title">MB</span> <span class="title">for</span> <span class="title">bpfloader</span></span></span><br><span class="line"><span class="class">    # <span class="title">Actually</span> <span class="title">only</span> 8<span class="title">MB</span> <span class="title">is</span> <span class="title">needed</span>, <span class="title">but</span> <span class="title">since</span> <span class="title">bpfloader</span> <span class="title">runs</span> <span class="title">as</span> <span class="title">root</span>, <span class="title">it</span> <span class="title">shares</span></span></span><br><span class="line"><span class="class">    # <span class="title">the</span> <span class="title">global</span> <span class="title">rlimit</span>. <span class="title">Once</span> <span class="title">bpfloader</span> <span class="title">is</span> <span class="title">running</span> <span class="title">as</span> <span class="title">its</span> <span class="title">own</span> <span class="title">user</span> <span class="title">in</span> <span class="title">the</span></span></span><br><span class="line"><span class="class">    # <span class="title">future</span>, <span class="title">it</span> <span class="title">will</span> <span class="title">have</span> <span class="title">dedicated</span> <span class="title">rlimit</span> <span class="title">to</span> <span class="title">itself</span> <span class="title">and</span> <span class="title">this</span> <span class="title">can</span> <span class="title">be</span> 8<span class="title">MB</span>.</span></span><br><span class="line"><span class="class">    <span class="title">rlimit</span> <span class="title">memlock</span> 67108864 67108864</span></span><br><span class="line"><span class="class">    <span class="title">oneshot</span></span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure><p>进入<code>BpfLoader.cpp</code>看下<code>main</code>函数, 实际是调用<code>loadAllElfObjects</code>加载各个ELF文件: 读取<code>/system/etc/bpf/</code>下面所有<code>.o</code>结束的文件, 然后加载到内核.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_PROG_PATH <span class="string">&quot;/system/etc/bpf/&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loadAllElfObjects</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    DIR* dir;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((dir = opendir(BPF_PROG_PATH)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> ((ent = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">string</span> s = ent-&gt;d_name;</span><br><span class="line">    <span class="keyword">if</span> (!EndsWith(s, <span class="string">&quot;.o&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> progPath = BPF_PROG_PATH + s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = android::bpf::loadProg(progPath.c_str());</span><br><span class="line">    ALOGI(<span class="string">&quot;Attempted load object: %s, ret: %s&quot;</span>, progPath.c_str(), <span class="built_in">std</span>::strerror(-ret));</span><br><span class="line">&#125;</span><br><span class="line">closedir(dir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数<code>loadProg</code>根据eBPF目标文件中的段创建容器类型, 并加载代码到内核:</p><ul><li>首先检查是否存在证书的段(<code>section</code>)</li><li><code>readCodeSections</code>:读取ELF文件中段信息, 生成代码段<code>CodeSection</code>的列表</li><li><code>createMaps</code>: 根据ELF目标文件中的<code>maps</code>段信息创建对应的容器对象</li><li><code>applyMapRelo</code>: 看代码应该是对BPF中的指令进行重定位(如何进行重定位?)</li><li><code>loadCodeSections</code>: 加载目标文件到内核, 并将加载后的fd固定到特定的路径</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">loadProg</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* elfPath)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; license;</span><br><span class="line">    <span class="built_in">vector</span>&lt;codeSection&gt; cs;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; mapFds;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ifstream <span class="title function_">elfFile</span><span class="params">(elfPath, ios::in | ios::binary)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!elfFile.is_open()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    ret = readSectionByName(<span class="string">&quot;license&quot;</span>, elfFile, license);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">       ALOGE(<span class="string">&quot;Couldn&#x27;t find license in %s\n&quot;</span>, elfPath);</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ALOGD(<span class="string">&quot;Loading ELF object %s with license %s\n&quot;</span>, elfPath, (<span class="type">char</span>*)license.data());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = readCodeSections(elfFile, cs);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">       ALOGE(<span class="string">&quot;Couldn&#x27;t read all code sections in %s\n&quot;</span>, elfPath);</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Just for future debugging */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) dumpAllCs(cs);</span><br><span class="line"></span><br><span class="line">    ret = createMaps(elfPath, elfFile, mapFds);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">       ALOGE(<span class="string">&quot;Failed to create maps: (ret=%d) in %s\n&quot;</span>, ret, elfPath);</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)mapFds.size(); i++)</span><br><span class="line">       ALOGD(<span class="string">&quot;map_fd found at %d is %d in %s\n&quot;</span>, i, mapFds[i], elfPath);</span><br><span class="line"></span><br><span class="line">    applyMapRelo(elfFile, mapFds, cs);</span><br><span class="line"></span><br><span class="line">    ret = loadCodeSections(elfPath, cs, <span class="built_in">string</span>(license.data()));</span><br><span class="line">    <span class="keyword">if</span> (ret) ALOGE(<span class="string">&quot;Failed to load programs, loadCodeSections ret=%d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面就分别来看下其中的几个关键步骤.</p><h3 id="生成代码段-创建map"><a href="#生成代码段-创建map" class="headerlink" title="生成代码段,创建map"></a><strong>生成代码段,创建map</strong></h3><p>函数<code>readCodeSections</code>读取ELF目标文件中的段头信息, 获取到每个BPF段的代码类型, 常见的有<code>BPF_PROG_TYPE_KPROBE</code>, <code>BPF_PROG_TYPE_SOCKET_FILTER</code>等(见上述表中的说明). 接着查看该段是否需要进行重定位.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">readCodeSections</span><span class="params">(ifstream&amp; elfFile, <span class="built_in">vector</span>&lt;codeSection&gt;&amp; cs)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Elf64_Shdr&gt; shTable;</span><br><span class="line">    <span class="type">int</span> entries, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = readSectionHeadersAll(elfFile, shTable);</span><br><span class="line">    <span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line">    entries = shTable.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; entries; i++) &#123;</span><br><span class="line">       <span class="built_in">string</span> name;</span><br><span class="line">       codeSection cs_temp;</span><br><span class="line">       cs_temp.type = BPF_PROG_TYPE_UNSPEC;</span><br><span class="line"></span><br><span class="line">       ret = getSymName(elfFile, shTable[i].sh_name, name);</span><br><span class="line">       <span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">       <span class="class"><span class="keyword">enum</span> <span class="title">bpf_prog_type</span> <span class="title">ptype</span> =</span> getSectionType(name);</span><br><span class="line">       <span class="keyword">if</span> (ptype != BPF_PROG_TYPE_UNSPEC) &#123;</span><br><span class="line">           deslash(name);</span><br><span class="line">           cs_temp.type = ptype;</span><br><span class="line">           cs_temp.name = name;</span><br><span class="line"></span><br><span class="line">           ret = readSectionByIdx(elfFile, i, cs_temp.data);</span><br><span class="line">           <span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line">           ALOGD(<span class="string">&quot;Loaded code section %d (%s)\n&quot;</span>, i, name.c_str());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Check for rel section */</span></span><br><span class="line">       <span class="keyword">if</span> (cs_temp.data.size() &gt; <span class="number">0</span> &amp;&amp; i &lt; entries) &#123;</span><br><span class="line">           ret = getSymName(elfFile, shTable[i + <span class="number">1</span>].sh_name, name);</span><br><span class="line">           <span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (isRelSection(cs_temp, name)) &#123;</span><br><span class="line">               ret = readSectionByIdx(elfFile, i + <span class="number">1</span>, cs_temp.rel_data);</span><br><span class="line">               <span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line">               ALOGD(<span class="string">&quot;Loaded relo section %d (%s)\n&quot;</span>, i, name.c_str());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (cs_temp.data.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           cs.push_back(cs_temp);</span><br><span class="line">           ALOGD(<span class="string">&quot;Adding section %d to cs list\n&quot;</span>, i);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着根据<code>CodeSection</code>列表创建内核的map对象(用于保存内核事件结果, 常见的有<code>arraymap</code>, <code>hashmap</code>等几种类型):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">createMaps</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* elfPath, ifstream&amp; elfFile, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; mapFds)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret, fd;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; mdData;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_def</span>&gt;</span> md;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; mapNames;</span><br><span class="line">    <span class="built_in">string</span> fname = pathToFilename(<span class="built_in">string</span>(elfPath), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    ret = readSectionByName(<span class="string">&quot;maps&quot;</span>, elfFile, mdData);</span><br><span class="line">    <span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line">    md.resize(mdData.size() / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bpf_map_def));</span><br><span class="line">    <span class="built_in">memcpy</span>(md.data(), mdData.data(), mdData.size());</span><br><span class="line"></span><br><span class="line">    ret = getMapNames(elfFile, mapNames);</span><br><span class="line">    <span class="keyword">if</span> (ret) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    mapFds.resize(mapNames.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)mapNames.size(); i++) &#123;</span><br><span class="line">       <span class="comment">// Format of pin location is /sys/fs/bpf/map_&lt;filename&gt;_&lt;mapname&gt;</span></span><br><span class="line">       <span class="built_in">string</span> mapPinLoc;</span><br><span class="line">       <span class="type">bool</span> reuse = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       mapPinLoc = <span class="built_in">string</span>(BPF_FS_PATH) + <span class="string">&quot;map_&quot;</span> + fname + <span class="string">&quot;_&quot;</span> + <span class="built_in">string</span>(mapNames[i]);</span><br><span class="line">       <span class="keyword">if</span> (access(mapPinLoc.c_str(), F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">           fd = bpf_obj_get(mapPinLoc.c_str());</span><br><span class="line">           ALOGD(<span class="string">&quot;bpf_create_map reusing map %s, ret: %d\n&quot;</span>, mapNames[i].c_str(), fd);</span><br><span class="line">           reuse = <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           fd = bpf_create_map(md[i].type, mapNames[i].c_str(), md[i].key_size, md[i].value_size,</span><br><span class="line">                               md[i].max_entries, md[i].map_flags);</span><br><span class="line">           ALOGD(<span class="string">&quot;bpf_create_map name %s, ret: %d\n&quot;</span>, mapNames[i].c_str(), fd);</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!reuse) &#123;</span><br><span class="line">           ret = bpf_obj_pin(fd, mapPinLoc.c_str());</span><br><span class="line">           <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mapFds[i] = fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了避免map对象在<code>bpfloader</code>服务退出之后被销毁, 最后都会通过<code>bpf_obj_pin</code>把这些对象固定到<code>/sys/fs/bpf</code>文件节点.</p><h3 id="加载代码到内核"><a href="#加载代码到内核" class="headerlink" title="加载代码到内核"></a><strong>加载代码到内核</strong></h3><p>要监听到内核事件, eBPF的ELF目标文件首先需要加载到内核, 然后在内核发生对应事件后触发对应的eBPF代码逻辑(内核的bpf虚拟机在执行代码之前会对目标文件代码进行校验, 以确保代码没有死循环等逻辑错误). </p><ul><li><code>bpf_prog_load</code>: 加载bpf程序到内核</li><li><code>bpf_obj_pin</code>: 将bpf程序固定到<code>/sys/fs/bpf</code>文件节点, 确保服务退出后, bpf程序依然可以正常执行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">loadCodeSections</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* elfPath, <span class="built_in">vector</span>&lt;codeSection&gt;&amp; cs, <span class="type">const</span> <span class="built_in">string</span>&amp; license)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret, fd, kvers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((kvers = getMachineKvers()) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> fname = pathToFilename(<span class="built_in">string</span>(elfPath), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)cs.size(); i++) &#123;</span><br><span class="line">       <span class="built_in">string</span> progPinLoc;</span><br><span class="line">       <span class="type">bool</span> reuse = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Format of pin location is</span></span><br><span class="line">       <span class="comment">// /sys/fs/bpf/prog_&lt;filename&gt;_&lt;mapname&gt;</span></span><br><span class="line">       progPinLoc = <span class="built_in">string</span>(BPF_FS_PATH) + <span class="string">&quot;prog_&quot;</span> + fname + <span class="string">&quot;_&quot;</span> + cs[i].name;</span><br><span class="line">       <span class="keyword">if</span> (access(progPinLoc.c_str(), F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">           fd = bpf_obj_get(progPinLoc.c_str());</span><br><span class="line">           ALOGD(<span class="string">&quot;New bpf prog load reusing prog %s, ret: %d\n&quot;</span>, cs[i].name.c_str(), fd);</span><br><span class="line">           reuse = <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt; log_buf(BPF_LOAD_LOG_SZ, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">           fd = bpf_prog_load(cs[i].type, cs[i].name.c_str(), (<span class="keyword">struct</span> bpf_insn*)cs[i].data.data(), cs[i].data.size(), license.c_str(), kvers, <span class="number">0</span>, log_buf.data(), log_buf.size());</span><br><span class="line">           ALOGD(<span class="string">&quot;New bpf core prog_load for %s (%s) returned: %d\n&quot;</span>, elfPath, cs[i].name.c_str(),fd);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (fd &lt;= <span class="number">0</span>)</span><br><span class="line">               ALOGE(<span class="string">&quot;bpf_prog_load: log_buf contents: %s\n&quot;</span>, (<span class="type">char</span> *)log_buf.data());</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!reuse) &#123;</span><br><span class="line">           ret = bpf_obj_pin(fd, progPinLoc.c_str());</span><br><span class="line">           <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       cs[i].prog_fd = fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这一步, eBPF完成了初始化, 目标文件也load到了内核, 此时只要内核有相应事件发生, 都会把结果保存到对应的map对象中. 用户进程只需要通过bpf的系统调用<code>BPF_MAP_LOOKUP_ELEM</code>等指令获取map对象中的数据.</p><h2 id="Android如何使用eBPF统计流量"><a href="#Android如何使用eBPF统计流量" class="headerlink" title="Android如何使用eBPF统计流量"></a><strong>Android如何使用eBPF统计流量</strong></h2><p>Android系统支持多种粒度的流量统计, 比如统计每个网卡的流量, 每个用户使用的流量, 有关Android流量统计的细节可以参考之前的博文<a href="https://sniffer.site/2020/04/01/%E8%AF%B4%E8%AF%B4android%E4%B8%AD%E7%9A%84%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1/">Android是如何实现流量统计的</a>. 这里我们主要看下如何基于eBPF来实现对网卡以及每个用户的流量统计.</p><p>Android中有一个<code>netd</code>进程负责网络管理, 流量统计等功能, 在启动的时候会初始化一个<code>TrafficController</code>的类, 这个类就是负责流量统计功能的, 其在初始化的时候会创建几个<code>BpfMap</code>(实际是一个key-value的容器模板)对象, 用于保存不同流量统计的结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TrafficController::initMaps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">guard</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(mAppUidStatsMap.<span class="built_in">init</span>(APP_UID_STATS_MAP_PATH));</span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(<span class="built_in">changeOwnerAndMode</span>(APP_UID_STATS_MAP_PATH, AID_NET_BW_STATS, <span class="string">&quot;AppUidStatsMap&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(mStatsMapA.<span class="built_in">init</span>(STATS_MAP_A_PATH));</span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(<span class="built_in">changeOwnerAndMode</span>(STATS_MAP_A_PATH, AID_NET_BW_STATS, <span class="string">&quot;StatsMapA&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(mStatsMapB.<span class="built_in">init</span>(STATS_MAP_B_PATH));</span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(<span class="built_in">changeOwnerAndMode</span>(STATS_MAP_B_PATH, AID_NET_BW_STATS, <span class="string">&quot;StatsMapB&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(mIfaceIndexNameMap.<span class="built_in">init</span>(IFACE_INDEX_NAME_MAP_PATH);</span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(<span class="built_in">changeOwnerAndMode</span>(IFACE_INDEX_NAME_MAP_PATH, AID_NET_BW_STATS,<span class="string">&quot;IfaceIndexNameMap&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(mIfaceStatsMap.<span class="built_in">init</span>(IFACE_STATS_MAP_PATH));</span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(<span class="built_in">changeOwnerAndMode</span>(IFACE_STATS_MAP_PATH, AID_NET_BW_STATS, <span class="string">&quot;IfaceStatsMap&quot;</span>,<span class="literal">false</span>));</span><br><span class="line">       ...</span><br><span class="line">    <span class="keyword">return</span> netdutils::status::ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看<code>BpfMap</code>模板(在<code>BpfMap.h</code>中定义)中的<code>init</code>函数可以知道, <code>mAppUidStatsMap.init/mIfaceStatsMap.init</code>实际是获取到固定在<code>/sys/fs/bpf</code>目录下的各个map对象节点文件描述符, 然后就可以通过该描述符来操作对应的map对象了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">netdutils::Status BpfMap&lt;Key, Value&gt;::<span class="built_in">init</span>(<span class="type">const</span> <span class="type">char</span>* path) &#123;</span><br><span class="line">    mMapFd = base::<span class="built_in">unique_fd</span>(<span class="built_in">mapRetrieve</span>(path, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (mMapFd == <span class="number">-1</span>) &#123;</span><br><span class="line">       <span class="built_in">reset</span>();</span><br><span class="line">       <span class="keyword">return</span> netdutils::<span class="built_in">statusFromErrno</span>(</span><br><span class="line">               errno,</span><br><span class="line">               base::<span class="built_in">StringPrintf</span>(<span class="string">&quot;pinned map not accessible or does not exist: (%s)\n&quot;</span>, path));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> netdutils::status::ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于<code>cgroupskb</code>类型的bpf程序, 还需要通过<code>BPF_PROG_ATTACH</code>命令把固定到<code>/sys/fs/bpf</code>的代码附着到对应的cgroup上(这样我们就可以监控特定cgroup上的进程的网络状态了):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Status <span class="title">initPrograms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string cg2_path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CgroupGetControllerPath</span>(CGROUPV2_CONTROLLER_NAME, &amp;cg2_path)) &#123;</span><br><span class="line">       <span class="type">int</span> ret = errno;</span><br><span class="line">       <span class="built_in">ALOGE</span>(<span class="string">&quot;Failed to find cgroup v2 root&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">statusFromErrno</span>(ret, <span class="string">&quot;Failed to find cgroup v2 root&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">unique_fd <span class="title">cg_fd</span><span class="params">(open(cg2_path.c_str(), O_DIRECTORY | O_RDONLY | O_CLOEXEC))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (cg_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">       <span class="type">int</span> ret = errno;</span><br><span class="line">       <span class="built_in">ALOGE</span>(<span class="string">&quot;Failed to open the cgroup directory: %s&quot;</span>, <span class="built_in">strerror</span>(ret));</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">statusFromErrno</span>(ret, <span class="string">&quot;Open the cgroup directory failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(<span class="built_in">attachProgramToCgroup</span>(BPF_EGRESS_PROG_PATH, cg_fd, BPF_CGROUP_INET_EGRESS));</span><br><span class="line">    <span class="built_in">RETURN_IF_NOT_OK</span>(<span class="built_in">attachProgramToCgroup</span>(BPF_INGRESS_PROG_PATH, cg_fd, BPF_CGROUP_INET_INGRESS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For the devices that support cgroup socket filter, the socket filter</span></span><br><span class="line">    <span class="comment">// should be loaded successfully by bpfloader. So we attach the filter to</span></span><br><span class="line">    <span class="comment">// cgroup if the program is pinned properly.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> delete the if statement once all devices should support cgroup</span></span><br><span class="line">    <span class="comment">// socket filter (ie. the minimum kernel version required is 4.14).</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access</span>(CGROUP_SOCKET_PROG_PATH, F_OK)) &#123;</span><br><span class="line">         <span class="built_in">RETURN_IF_NOT_OK</span>(</span><br><span class="line">        <span class="built_in">attachProgramToCgroup</span>(CGROUP_SOCKET_PROG_PATH, cg_fd, BPF_CGROUP_INET_SOCK_CREATE));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> netdutils::status::ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>cgroup是linux管理系统资源的资源分配与隔离方案, 在同一个cgroup的进程共享同样的CPU, 内存以及网络资源.</p></blockquote><p>更多的实现细节可以参考<code>BpfMap.h</code>以及<code>TrafficController.cpp</code>.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这篇文章主要将了Android中eBPF程序的格式, 以及如何加载eBPF程序, 最后阐述了Android上如何利用eBPF来实现流量统计的功能. 对eBPF的逻辑与流程理清楚后, 在Android上开发自己的eBPF功能也就不是什么难事了.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://blogs.oracle.com/linux/post/bpf-a-tour-of-program-types">详细介绍了BPF程序类型</a></li><li><a href="https://source.android.com/devices/architecture/kernel/bpf">Android中如何支持eBPF</a></li><li><a href="https://source.android.com/devices/tech/datausage/ebpf-traffic-monitor">如何使用eBPF进行流量统计</a></li><li><a href="https://www.netronome.com/blog/bpf-ebpf-xdp-and-bpfilter-what-are-these-things-and-what-do-they-mean-enterprise/">https://www.netronome.com/blog/bpf-ebpf-xdp-and-bpfilter-what-are-these-things-and-what-do-they-mean-enterprise/</a></li><li><a href="https://lwn.net/Articles/750845/">Accelerating networking with AF_XDP</a></li><li><a href="https://www.kernel.org/doc/Documentation/networking/filter.txt">https://www.kernel.org/doc/Documentation/networking/filter.txt</a></li><li><a href="http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html">http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html</a></li><li><a href="https://linux.cn/article-9507-1.html">eBPF的阅读清单</a></li><li><a href="https://lwn.net/Articles/132196/">https://lwn.net/Articles/132196/</a></li><li><a href="https://www.ferrisellis.com/content/ebpf_syscall_and_maps/">eBPF的系统调用与容器类型</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Android从9.0版本开始全面支持eBPF(&lt;code&gt;extended Berkeley Packet Filters&lt;/code&gt;), 其主要用在流量统计上, 也可以用来监控CPU&amp;#x2F;IO&amp;#x2F;内存等模块的状态.简单来说, &lt;code&gt;eBPF&lt;/code&gt;可以与内核的&lt;code&gt;kprobe&lt;/code&gt;&amp;#x2F;&lt;code&gt;tracepoints&lt;/code&gt;&amp;#x2F;&lt;code&gt;skfilter&lt;/code&gt;等模块相结合, 将eBPF的函数hook到内核事件从而监控相应的系统状态.&lt;/p&gt;
&lt;p&gt;Android为eBPF提供了许多封装的库, 并提供了eBPF加载器&lt;code&gt;bpfloader&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bpfloader&lt;/code&gt;: 位于&lt;code&gt;/system/bpf/bpfloader&lt;/code&gt;, 系统启动时负责加载位于&lt;code&gt;/system/etc/bpf&lt;/code&gt; 中的eBPF目标文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;libbpf_android&lt;/code&gt;: 位于&lt;code&gt;/system/bpf/libbpf_android&lt;/code&gt;提供创建bpf容器&amp;#x2F;加载bpf目标文件的接口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;libbpf&lt;/code&gt;: 位于&lt;code&gt;/external/bcc&lt;/code&gt;, 封装了bpf的系统调用, 提供如attach&amp;#x2F;deattach程序的接口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;libnetdbpf&lt;/code&gt;: 位于&lt;code&gt;/system/netd/libnetdbpf&lt;/code&gt;, 实现了netd流量统计功能的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前在Android(Q)上有两处eBPF的代码: 一个是&lt;code&gt;/system/netd/bpf_progs/netd.c&lt;/code&gt;, 主要是用于流量统计；一个是&lt;code&gt;/system/bpfprogs/time_in_state.c&lt;/code&gt;用于监控CPU运行频率以及上下文切换的耗时.&lt;/p&gt;
&lt;p&gt;接下来我们就从三个部分来深入理解下Android是如何利用eBPF的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eBPF程序与目标文件格式&lt;/li&gt;
&lt;li&gt;Android eBPF加载与执行流程&lt;/li&gt;
&lt;li&gt;Android如何基于eBPF实现流量统计&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://sniffer.site/categories/Linux/"/>
    
    <category term="Android" scheme="https://sniffer.site/categories/Linux/Android/"/>
    
    
    <category term="Android" scheme="https://sniffer.site/tags/Android/"/>
    
    <category term="extended Berkeley Packet Filters" scheme="https://sniffer.site/tags/extended-Berkeley-Packet-Filters/"/>
    
    <category term="eBPF" scheme="https://sniffer.site/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>什么是GARP</title>
    <link href="https://sniffer.site/2021/10/09/%E4%BB%80%E4%B9%88%E6%98%AFGARP/"/>
    <id>https://sniffer.site/2021/10/09/%E4%BB%80%E4%B9%88%E6%98%AFGARP/</id>
    <published>2021-10-09T07:30:19.000Z</published>
    <updated>2021-10-09T08:37:38.778Z</updated>
    
    <content type="html"><![CDATA[<p><code>ARP(Address Resolution Protocol)</code>即地址解析协议, 用于将网络层L3的IP地址转换成数据链路层的L2地址(MAC地址), 常用在诸如以太网, 无线网络等局域网中, 但对如点对点(P2P)网络, 组播与多播IP地址, 都无需使用<code>ARP</code>协议.</p><p>一般来说, L3-L2地址的转换通常被成为邻区协议(<code>neighboring protocol</code>), 这种发现邻居节点(<code>neighbor</code>)的协议被统称为邻居发现协议(<code>Neighbor Discovery Protocol</code>, <code>ND</code>). <code>ARP</code>可以看作是<code>ND</code>的ipv4版本(参考<a href="https://www.rfc-editor.org/rfc/rfc826.txt">RFC826</a>), 在ipv6中则直接称为<code>ND</code>(参考<a href="https://www.rfc-editor.org/rfc/rfc4861">RFC4861</a>).</p><blockquote><p>邻居节点(<code>neighbor</code>)指的是跟主机在同一局域网(<code>LAN</code>)的其他节点</p></blockquote><p><code>ND</code>协议有两种消息类型:</p><ul><li><code>Solicitation Request</code>(也称为<code>Neighbor Solicitation</code>): 用于主机发送消息到网络中查询是否有主机拥有某个L3的IP地址, 该消息可以是单播, 组播或者广播形式.</li><li><code>Solicitation Reply</code>(又称为<code>Neighbor Advertisement</code>): 收到<code>Solicitation Request</code>包时发出的回应包(有可能是HOST本身发出的, 也有可能是<code>ARP</code>代理服务器发送的)</li></ul><p>那么, 什么是<code>Gratuitous ARP</code>(简称<code>GARP</code>, 免费ARP)了? 简单来说, <code>GARP</code>是一种用于告知网络中其他节点某些特定信息的ARP请求包, 但无须其他节点发送回应包, 常用于如下<a href="http://www.embeddedlinux.org.cn/linux_net/0596002556/understandlni-CHP-28-SECT-3.html#understandlni-CHP-28-SECT-3">三种情况</a>:</p><span id="more"></span><ul><li>检测局域网内的IP地址冲突(参考<a href="https://datatracker.ietf.org/doc/html/rfc5227">RFC5227</a>)</li><li>L2地址(MAC地址)发生变化时</li><li>虚拟IP(<code>virtual IP</code>), 用于服务器的冗余</li></ul><p>接下来就看看<code>GARP</code>在这三种场景的具体应用.</p><h2 id="IP冲突检测"><a href="#IP冲突检测" class="headerlink" title="IP冲突检测"></a><strong>IP冲突检测</strong></h2><p>当局域网中采用静态IP与动态(基于<code>DHCP</code>)IP配置结合的方式时, 有可能两个节点之间的IP会相同;这时需要使用<code>GARP</code>来检测IP冲突: 网络节点在配置IP时, 发送一个<code>GARP</code>到其他节点, 如果有节点的IP与之相同, 则会回应一个<code>ARP</code>包, 告诉该IP已经有节点使用了; 如果该IP没有被使用, 则不会收到任何<code>ARP</code>的回应.</p><h2 id="MAC地址变更"><a href="#MAC地址变更" class="headerlink" title="MAC地址变更"></a><strong>MAC地址变更</strong></h2><p>当某个网络节点的L2地址(MAC地址)发生变化时, 网络中的其他节点是无法知道的, 因此需要一个协议来同步这个变化, 以便于其他的节点及时更新<code>ARP</code>缓存. 这样比每个节点自己主动更新会来的更省事方便(也不会导致短暂的网络黑洞, 参见上一篇文章<a href="https://sniffer.site/2021/09/28/%E4%B8%80%E4%B8%AAarp-cache%E4%B8%8D%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/">ARP cache不更新导致的网络问题</a>)</p><h2 id="服务器冗余"><a href="#服务器冗余" class="headerlink" title="服务器冗余"></a><strong>服务器冗余</strong></h2><p>在某些情况下, 为了实现在多个服务器之间的故障恢复(<code>failover</code>), 通常会使用<code>GARP</code>来到达服务器冗余(<code>redundancy</code>)的目的, 这时两个服务器会共享IP或MAC地址, 当某个服务器发生故障(死机, 物理故障等)时, 服务器群里的各个机器通过心跳机制来定时侦测故障, 当备用服务器侦测到与其共享IP的服务器故障时, 会发送一个<code>GARP</code>包, 告诉各个服务器更新对应的ARP缓存, 确保服务能快速恢复.</p><p>下面我们就来看一看Linux内核(4.14)是如何处理<code>GARP</code>的.</p><h2 id="Linux如何处理GARP"><a href="#Linux如何处理GARP" class="headerlink" title="Linux如何处理GARP"></a><strong>Linux如何处理GARP</strong></h2><p>Linux提供了<code>ARP/GARP</code>相关的配置选项, 在<code>/proc/sys/net/ipv4/conf/</code>中有如下几个节点(参考Linux文档<code>ip-sysctl.txt</code>):</p><ul><li><code>arp_announce</code>: 控制<code>ARP</code>请求时发送的本地网卡源IP地址的类型, <code>0</code>(默认)表示可以使用任何本地IP地址, <code>1</code>表示只使用同一子网内的IP地址, <code>2</code>表示只使用网卡的首要IP地址(<code>primary ip</code>)</li><li><code>arp_igonre</code>: 控制收到<code>ARP</code>请求后发送回包时的目标IP地址类型: <code>0</code>(默认)表示发送任何本地的IP地址, <code>1</code>只发送当前收到<code>ARP</code>包网卡的本地地址, <code>2</code>只回送接收<code>ARP</code>包的网卡与<code>ARP</code>请求方在同一子网的IP地址, <code>3</code>回送域(scope)为<code>global/link</code>的地址, 不回送<code>host</code>的地址; <code>4-7</code>保留值, <code>8</code>表示不回送任何地址</li><li><code>arp_notify</code>: 网卡状态变化时是否发送<code>GARP</code>, <code>0</code>表示什么都不做, <code>1</code>表示设备UP或MAC地址变化时发送<code>GARP</code></li><li><code>arp_accept</code>: 收到<code>GARP</code>时是否创建<code>ARP</code>缓存, <code>0</code>不创建, <code>1</code>表示创建(如果<code>ARP</code>缓存已经包含了<code>GARP</code>包的IP地址, 不管是否开启该选项, 都会更新<code>ARP</code>缓存)</li><li><code>drop_gratuitous_arp</code>: 丢弃所有<code>GARP</code>包, 默认是<code>0</code>(关闭)</li></ul><p>最后, 不妨看下内核是如何实现<code>GARP</code>的发送的.</p><p>当网卡UP或者MAC地址发生变化时(前提是<code>arp_notify</code>处于开启状态)会发送<code>GARP</code>, 设备驱动也可以通过发送<code>NETDEV_NOTIFY_PEERS</code>事件来触发<code>GARP</code>告知其他节点状态的变化:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//dev.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_set_mac_address</span><span class="params">(<span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> sockaddr *sa)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> *<span class="title">ops</span> =</span> dev-&gt;netdev_ops;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ops-&gt;ndo_set_mac_address)</span><br><span class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">    <span class="keyword">if</span> (sa-&gt;sa_family != dev-&gt;type)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!netif_device_present(dev))</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    err = ops-&gt;ndo_set_mac_address(dev, sa);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    dev-&gt;addr_assign_type = NET_ADDR_SET;</span><br><span class="line">    <span class="comment">//MAC地址发生变化, 发送事件通知其他模块</span></span><br><span class="line">    call_netdevice_notifiers(NETDEV_CHANGEADDR, dev);</span><br><span class="line">    add_device_randomness(dev-&gt;dev_addr, dev-&gt;addr_len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(dev_set_mac_address);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>内核初始化时注册的通知回调<code>inetdev_event</code>在接收到事件通知后, 就会发送<code>GARP</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//devinet.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">inetdev_event</span><span class="params">(<span class="keyword">struct</span> notifier_block *this, <span class="type">unsigned</span> <span class="type">long</span> event,</span></span><br><span class="line"><span class="params">            <span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> netdev_notifier_info_to_dev(ptr);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_device</span> *<span class="title">in_dev</span> =</span> __in_dev_get_rtnl(dev);</span><br><span class="line"></span><br><span class="line">    ASSERT_RTNL();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_dev) &#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">    <span class="keyword">case</span> NETDEV_REGISTER:</span><br><span class="line">        pr_debug(<span class="string">&quot;%s: bug\n&quot;</span>, __func__);</span><br><span class="line">        RCU_INIT_POINTER(dev-&gt;ip_ptr, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NETDEV_UP:</span><br><span class="line">        <span class="keyword">if</span> (!inetdev_valid_mtu(dev-&gt;mtu))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;flags &amp; IFF_LOOPBACK) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">in_ifaddr</span> *<span class="title">ifa</span> =</span> inet_alloc_ifa();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ifa) &#123;</span><br><span class="line">                INIT_HLIST_NODE(&amp;ifa-&gt;hash);</span><br><span class="line">                ifa-&gt;ifa_local =</span><br><span class="line">                ifa-&gt;ifa_address = htonl(INADDR_LOOPBACK);</span><br><span class="line">                ifa-&gt;ifa_prefixlen = <span class="number">8</span>;</span><br><span class="line">                ifa-&gt;ifa_mask = inet_make_mask(<span class="number">8</span>);</span><br><span class="line">                in_dev_hold(in_dev);</span><br><span class="line">                ifa-&gt;ifa_dev = in_dev;</span><br><span class="line">                ifa-&gt;ifa_scope = RT_SCOPE_HOST;</span><br><span class="line">                <span class="built_in">memcpy</span>(ifa-&gt;ifa_label, dev-&gt;name, IFNAMSIZ);</span><br><span class="line">                set_ifa_lifetime(ifa, INFINITY_LIFE_TIME,</span><br><span class="line">                        INFINITY_LIFE_TIME);</span><br><span class="line">                ipv4_devconf_setall(in_dev);</span><br><span class="line">                neigh_parms_data_state_setall(in_dev-&gt;arp_parms);</span><br><span class="line">                inet_insert_ifa(ifa);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ip_mc_up(in_dev);</span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line">    <span class="keyword">case</span> NETDEV_CHANGEADDR:</span><br><span class="line">        <span class="comment">// `arp_notify`如果关闭, 则不会发送GARP包</span></span><br><span class="line">        <span class="keyword">if</span> (!IN_DEV_ARP_NOTIFY(in_dev))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line">    <span class="keyword">case</span> NETDEV_NOTIFY_PEERS:</span><br><span class="line">        <span class="comment">/* Send gratuitous ARP to notify of link change */</span></span><br><span class="line">        inetdev_send_gratuitous_arp(dev, in_dev);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> NOTIFY_DONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当收到<code>GARP</code>包是内核是如何处理的, 可以参考<code>net/ipv4/arp.c</code>中的函数<code>arp_process</code>.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="http://www.embeddedlinux.org.cn/linux_net">http://www.embeddedlinux.org.cn/linux_net</a></li><li><a href="https://www.practicalnetworking.net/series/arp/gratuitous-arp/">https://www.practicalnetworking.net/series/arp/gratuitous-arp/</a></li><li><a href="http://www.embeddedlinux.org.cn/linux_net/0596002556/understandlni-CHP-28-SECT-3.html">http://www.embeddedlinux.org.cn/linux_net/0596002556/understandlni-CHP-28-SECT-3.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;ARP(Address Resolution Protocol)&lt;/code&gt;即地址解析协议, 用于将网络层L3的IP地址转换成数据链路层的L2地址(MAC地址), 常用在诸如以太网, 无线网络等局域网中, 但对如点对点(P2P)网络, 组播与多播IP地址, 都无需使用&lt;code&gt;ARP&lt;/code&gt;协议.&lt;/p&gt;
&lt;p&gt;一般来说, L3-L2地址的转换通常被成为邻区协议(&lt;code&gt;neighboring protocol&lt;/code&gt;), 这种发现邻居节点(&lt;code&gt;neighbor&lt;/code&gt;)的协议被统称为邻居发现协议(&lt;code&gt;Neighbor Discovery Protocol&lt;/code&gt;, &lt;code&gt;ND&lt;/code&gt;). &lt;code&gt;ARP&lt;/code&gt;可以看作是&lt;code&gt;ND&lt;/code&gt;的ipv4版本(参考&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc826.txt&quot;&gt;RFC826&lt;/a&gt;), 在ipv6中则直接称为&lt;code&gt;ND&lt;/code&gt;(参考&lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc4861&quot;&gt;RFC4861&lt;/a&gt;).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;邻居节点(&lt;code&gt;neighbor&lt;/code&gt;)指的是跟主机在同一局域网(&lt;code&gt;LAN&lt;/code&gt;)的其他节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;ND&lt;/code&gt;协议有两种消息类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Solicitation Request&lt;/code&gt;(也称为&lt;code&gt;Neighbor Solicitation&lt;/code&gt;): 用于主机发送消息到网络中查询是否有主机拥有某个L3的IP地址, 该消息可以是单播, 组播或者广播形式.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Solicitation Reply&lt;/code&gt;(又称为&lt;code&gt;Neighbor Advertisement&lt;/code&gt;): 收到&lt;code&gt;Solicitation Request&lt;/code&gt;包时发出的回应包(有可能是HOST本身发出的, 也有可能是&lt;code&gt;ARP&lt;/code&gt;代理服务器发送的)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么, 什么是&lt;code&gt;Gratuitous ARP&lt;/code&gt;(简称&lt;code&gt;GARP&lt;/code&gt;, 免费ARP)了? 简单来说, &lt;code&gt;GARP&lt;/code&gt;是一种用于告知网络中其他节点某些特定信息的ARP请求包, 但无须其他节点发送回应包, 常用于如下&lt;a href=&quot;http://www.embeddedlinux.org.cn/linux_net/0596002556/understandlni-CHP-28-SECT-3.html#understandlni-CHP-28-SECT-3&quot;&gt;三种情况&lt;/a&gt;:&lt;/p&gt;</summary>
    
    
    
    
    <category term="ARP" scheme="https://sniffer.site/tags/ARP/"/>
    
    <category term="Address Resolution Protocol" scheme="https://sniffer.site/tags/Address-Resolution-Protocol/"/>
    
    <category term="GARP" scheme="https://sniffer.site/tags/GARP/"/>
    
  </entry>
  
  <entry>
    <title>ARP cache不更新导致的网络问题</title>
    <link href="https://sniffer.site/2021/09/28/%E4%B8%80%E4%B8%AAARP-cache%E4%B8%8D%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://sniffer.site/2021/09/28/%E4%B8%80%E4%B8%AAARP-cache%E4%B8%8D%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-09-28T06:35:36.000Z</published>
    <updated>2021-10-09T07:50:34.973Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到了一个很奇怪的问题, Android系统(Linux内核4.15)唤醒后, SoC(高通平台)跟TBox(Telematics Box)TCP的连接会偶发变慢, 需要等超过10s才能连接上. 发送ping包给TBox, 通过<code>strace</code>看进程一直提示<code>EAGAIN</code>的错误.从字面意义来说<code>EAGAIN</code>(<code>Resource temporarily unavailable</code>)是内核告知ping进程当前没有可用的数据包可以接收. 可是, 问题来了:</p><ul><li>为什么ping一直会收到<code>EAGAIN</code>的错误? 内核在什么时候会返回该错误?</li><li>为什么ping收不到数据包, TBox回包到底去了哪里?</li></ul><p>幸亏好这个问题比较容易重现, 折腾了两天才最终把问题的的来龙去脉搞清楚. 接下来就来看看这个问题的现象以及背后发生的根因, 最后给出几个相应的对策.</p><span id="more"></span><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a><strong>问题现象</strong></h2><p>发生问题的网络框架图大致如下. SoC(Android系统)通过基于USB的RNDIS(参考<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/network/overview-of-remote-ndis--rndis-">MSFT Overview of RNDIS</a>)与TBox进行连接, SoC对应的网卡<code>usb0</code>的IP地址为<code>192.168.1.3</code>, 而TBox与SoC相对应的网口名字是<code>rndis0</code>, 实际该网口的数据都是通过桥接口<code>bridge0</code>(对应IP地址为<code>192.168.1.1</code>)转发给外部网络.</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tbox_diagram.png" alt="network diagram"></p><p>问题具体现象是, SoC短暂休眠唤醒后, 在不到5s内识别到了TBox, 并且<code>usb0</code>都正常配置了IP地址, 网卡也处于UP状态.但发送ping包, 跟建立TCP连接都会发生概率性的延迟, 比正常的时候慢了接近20s, 而另一方面通过<code>arping</code>向TBox发送ARP包正常得到了响应. 这个就说明, 物理层肯定是没有问题. 那问题只能出现在上层了. 那么, 究竟是IP网络层还是数据链路层出问题了? 我们就一起来看看这个问题.</p><h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a><strong>抓包分析</strong></h2><p>网络问题第一步就是要抓到对应的<code>tcpdump</code>包, 因为<code>packets donot lie</code>, 数据包里有所有数据传输的原始信息.在系统唤醒后网卡UP时执行<code>tcpdump -i usb0 -s 0 -n -w /data/test.pcap</code>, 打开<code>test.pcap</code>看ping包有正常发送接收了, 但ping进程却一直收到的是<code>EAGAIN</code>的错误, 没有收到任何ICMP的回应:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/arp_issue_ping_pcap_mod.png" alt="ping pcap"></p><p>TCP连接有点类似: SoC发了<code>SYN</code>包, TBox也回送了<code>SYN-ACK</code>包, 但TCP传输层却没有收到任何的<code>SYN-ACK</code>, 所以在超时时间后立刻进行<code>SYN</code>的重传, 由于TBox没有收到SoC的<code>ACK</code>包同样重传了<code>SYN-ACK</code>, 三次握手一直没有正常完成.</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/arp_issue_tcp_capture_mod.png" alt="TCP pcap"></p><p>为什么会用户进程没有收到数据包, 而TCP传输层的三次握手为什么没法完成了? 那么, 这些数据包究竟去了哪里? 是在内核某个地方被丢弃了吗?点击看每个包, IP地址跟校验码都是正常.难道是IP网络层(L3)的路由发生问题, 导致数据一直没法正常路由到TCP层吗? 又或者是L2(数据链路层)的把数据包直接丢了? 但是通过<code>tcpdump</code>抓包为何有了? 只能一步步看内核代码了. 这么一看, 才发现忽略了一个重要的信息. 这个先按下不表.</p><p>我们先来看下内核代码为何ping会收到<code>EAGAIN</code>的错误码.</p><h2 id="EGAIN错误从何而来"><a href="#EGAIN错误从何而来" class="headerlink" title="EGAIN错误从何而来"></a><strong>EGAIN错误从何而来</strong></h2><p>对于ping来说, 使用的是<code>icmp</code>协议, 内核在初始化的时候会注册一个<code>struct proto ping_prot</code>的ping协议接口, 用户进程通过<code>rcvmsg</code>系统调用接收ping数据回包时最终会调用到<code>ping_prot-&gt;recvmsg</code>这里.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// af_inet.c</span></span><br><span class="line">   &#123;</span><br><span class="line">       .type =       SOCK_DGRAM,</span><br><span class="line">       .protocol =   IPPROTO_ICMP,</span><br><span class="line">       .prot =       &amp;ping_prot,</span><br><span class="line">       .ops =        &amp;inet_sockraw_ops,</span><br><span class="line">       .flags =      INET_PROTOSW_REUSE,</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">rc = proto_register(&amp;ping_prot, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">ping_prot</span> =</span> &#123;</span><br><span class="line">       .name =<span class="string">&quot;PING&quot;</span>,</span><br><span class="line">       .owner =THIS_MODULE,</span><br><span class="line">       .init =ping_init_sock,</span><br><span class="line">       .close =ping_close,</span><br><span class="line">       .connect =ip4_datagram_connect,</span><br><span class="line">       .disconnect =__udp_disconnect,</span><br><span class="line">       .setsockopt =ip_setsockopt,</span><br><span class="line">       .getsockopt =ip_getsockopt,</span><br><span class="line">       .sendmsg =ping_v4_sendmsg,</span><br><span class="line">       .recvmsg =ping_recvmsg,</span><br><span class="line">       .bind =ping_bind,</span><br><span class="line">       .backlog_rcv =ping_queue_rcv_skb,</span><br><span class="line">       .release_cb =ip4_datagram_release_cb,</span><br><span class="line">       .hash =ping_hash,</span><br><span class="line">       .unhash =ping_unhash,</span><br><span class="line">       .get_port =ping_get_port,</span><br><span class="line">       .obj_size =<span class="keyword">sizeof</span>(<span class="keyword">struct</span> inet_sock),</span><br><span class="line">   &#125;;</span><br><span class="line">   EXPORT_SYMBOL(ping_prot);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ping_rcvmsg</code>首先调用<code>skb_recv_datagram</code>尝试获取<code>sock</code>上接收到的数据包, 收到包后调用<code>skb_copy_datagram_msg</code>拷贝到数据到<code>struct msghdr</code>消息体上:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ping.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ping_recvmsg</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> msghdr *msg, <span class="type">size_t</span> len, <span class="type">int</span> noblock, <span class="type">int</span> flags, <span class="type">int</span> *addr_len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">isk</span> =</span> inet_sk(sk);</span><br><span class="line">    <span class="type">int</span> family = sk-&gt;sk_family;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">    <span class="type">int</span> copied, err;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;ping_recvmsg(sk=%p,sk-&gt;num=%u)\n&quot;</span>, isk, isk-&gt;inet_num);</span><br><span class="line"></span><br><span class="line">    err = -EOPNOTSUPP;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MSG_OOB)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MSG_ERRQUEUE)</span><br><span class="line">        <span class="keyword">return</span> inet_recv_error(sk, msg, len, addr_len);</span><br><span class="line"></span><br><span class="line">    skb = skb_recv_datagram(sk, flags, noblock, &amp;err);</span><br><span class="line">    <span class="keyword">if</span> (!skb)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    copied = skb-&gt;len;</span><br><span class="line">    <span class="keyword">if</span> (copied &gt; len) &#123;</span><br><span class="line">        msg-&gt;msg_flags |= MSG_TRUNC;</span><br><span class="line">        copied = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t bother checking the checksum */</span></span><br><span class="line">    err = skb_copy_datagram_msg(skb, <span class="number">0</span>, msg, copied);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    sock_recv_timestamp(msg, sk, skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy the address and add cmsg data. */</span></span><br><span class="line">    <span class="keyword">if</span> (family == AF_INET) &#123;</span><br><span class="line">        DECLARE_SOCKADDR(<span class="keyword">struct</span> sockaddr_in *, <span class="built_in">sin</span>, msg-&gt;msg_name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sin</span>) &#123;</span><br><span class="line">            <span class="built_in">sin</span>-&gt;sin_family = AF_INET;</span><br><span class="line">            <span class="built_in">sin</span>-&gt;sin_port = <span class="number">0</span> <span class="comment">/* skb-&gt;h.uh-&gt;source */</span>;</span><br><span class="line">            <span class="built_in">sin</span>-&gt;sin_addr.s_addr = ip_hdr(skb)-&gt;saddr;</span><br><span class="line">            <span class="built_in">memset</span>(<span class="built_in">sin</span>-&gt;sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>-&gt;sin_zero));</span><br><span class="line">            *addr_len = <span class="keyword">sizeof</span>(*<span class="built_in">sin</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isk-&gt;cmsg_flags)</span><br><span class="line">            ip_cmsg_recv(msg, skb);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(ping_recvmsg);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>skb_recv_datagram</code>最后会调用<code>__skb_recv_datagram</code>: 如果ping进程通过阻塞方式接收数据, 并且尝试接收数据时返回了<code>EAGAIN</code>的错误(socket没有设置接收超时时间的话, 超时时间就是LONG的最大值), 则会一直等待来自网络层的数据.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// core/datagram.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">skb_recv_datagram</span>(<span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">void</span> (*<span class="title">destructor</span>)(<span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>,</span></span><br><span class="line"><span class="class">    <span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>), <span class="title">int</span> *<span class="title">peeked</span>, <span class="title">int</span> *<span class="title">off</span>, <span class="title">int</span> *<span class="title">err</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, *<span class="title">last</span>;</span></span><br><span class="line">    <span class="type">long</span> timeo;</span><br><span class="line"></span><br><span class="line">    timeo = sock_rcvtimeo(sk, flags &amp; MSG_DONTWAIT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        skb = __skb_try_recv_datagram(sk, flags, destructor, peeked,</span><br><span class="line">                        off, err, &amp;last);</span><br><span class="line">        <span class="keyword">if</span> (skb)</span><br><span class="line">            <span class="keyword">return</span> skb;</span><br><span class="line">        <span class="comment">//如果错误码是EAGAIN, 则一直尝试</span></span><br><span class="line">        <span class="keyword">if</span> (*err != -EAGAIN)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (timeo &amp;&amp;</span><br><span class="line">        !__skb_wait_for_more_packets(sk, err, &amp;timeo, last));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__skb_recv_datagram);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数<code>__skb_try_recv_datagram</code>在接收队列<code>sk_receive_queue</code>没有数据时就会返回<code>EAGAGIN</code>的错误. 这正是用户空间接收到这个错误码的来源了.就是说用户进程确实是没有收到任何数据. 也就是说,从TBox来的数据很可能是在网络层L3之下就丢掉了, 所以一直没有数据发送给用户进程.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// core/datagram.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">skb_try_recv_datagram</span>(<span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">void</span> (*<span class="title">destructor</span>)(<span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>,</span></span><br><span class="line"><span class="class">                            <span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>),</span></span><br><span class="line"><span class="class">                    <span class="title">int</span> *<span class="title">peeked</span>, <span class="title">int</span> *<span class="title">off</span>, <span class="title">int</span> *<span class="title">err</span>,</span></span><br><span class="line"><span class="class">                    <span class="keyword">struct</span> <span class="title">sk_buff</span> **<span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> *<span class="title">queue</span> =</span> &amp;sk-&gt;sk_receive_queue;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cpu_flags;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Caller is allowed not to check sk-&gt;sk_err before skb_recv_datagram()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> error = sock_error(sk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> no_packet;</span><br><span class="line"></span><br><span class="line">    *peeked = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* Again only user level code calls this function, so nothing</span></span><br><span class="line"><span class="comment">        * interrupt level will suddenly eat the receive_queue.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * Look at current nfs client by the way...</span></span><br><span class="line"><span class="comment">        * However, this function was correct in any case. 8)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        spin_lock_irqsave(&amp;<span class="built_in">queue</span>-&gt;lock, cpu_flags);</span><br><span class="line">        skb = __skb_try_recv_from_queue(sk, <span class="built_in">queue</span>, flags, destructor,</span><br><span class="line">                        peeked, off, &amp;error, last);</span><br><span class="line">        spin_unlock_irqrestore(&amp;<span class="built_in">queue</span>-&gt;lock, cpu_flags);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> no_packet;</span><br><span class="line">        <span class="keyword">if</span> (skb)</span><br><span class="line">            <span class="keyword">return</span> skb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sk_can_busy_loop(sk))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        sk_busy_loop(sk, flags &amp; MSG_DONTWAIT);</span><br><span class="line">    &#125; <span class="keyword">while</span> (READ_ONCE(sk-&gt;sk_receive_queue.prev) != *last);</span><br><span class="line"></span><br><span class="line">    error = -EAGAIN;</span><br><span class="line"></span><br><span class="line">no_packet:</span><br><span class="line">    *err = error;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__skb_try_recv_datagram);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ARP-cache才是罪魁祸首"><a href="#ARP-cache才是罪魁祸首" class="headerlink" title="ARP cache才是罪魁祸首"></a><strong>ARP cache才是罪魁祸首</strong></h2><p>明确了ping数据包在L3层丢弃的这个事实, 那不妨来追查下问题的真正原因.从<code>tcpdump</code>抓的包来看, 可以找到Tbox的ping回包的, 就是说TBox的数据肯定是传到了网口, 也就是说物理层L1跟数据链路层L2是能正常接收到数据的, 否则<code>tcpdump</code>是无法抓取到任何数据的, 因为<code>tcpdump</code>接收数据就是在所有数据传递给网络层L3之前的(参考<code>core/dev.c</code>的函数<code>__netif_receive_skb_core</code>)发送给<code>tcpdump</code>用户进程的.</p><p>那ping回包究竟为何被丢弃? 代码看了好几遍, 也在关键路径加了日志, 但还是毫无头绪.最终在一次重现问题的时候, 偶然发现, 只要发生出现的时候, 在TBox侧通过<code>arping</code>发送ARP包, 网络瞬间就畅通了. 这无疑为问题的定位找到了关键的线索. </p><p>问题应该就出现在TBox的ARP状态上. 继续重现, 同步看下SoC跟TBox的网卡与ARP状态:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tbox_arp_cache_mismatch_mod.png" alt="tbox arp cache mismatch"></p><p>图中上半部分是<code>ifconfig usb0</code>获取到的SoC网卡的状态, 下半部分是<code>cat /proc/net/arp</code>得到TBox的ARP cache状态, 可以看到TBox的桥接口<code>bridge0</code>并没有正常更新SoC网卡<code>192.168.1.3</code>对应的MAC地址.就是说, TBox使用了错误的(旧的)MAC地址进行数据的传输, 自然这些数据没法到达SoC的协议栈了.</p><p>再回来看之前测试抓到的<code>tcpdump</code>数据, SoC发的ping请求包的源MAC地址与TBox的ping回包的目标MAC地址是不一样的:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ping_combine.png" alt="ping request/reply"></p><p>为什么TBox的ARP cache数据会更新慢了? 原因主要有两个:</p><ul><li>SoC的rndis网卡每次休眠唤醒的时候都会随机生成一个MAC地址, 而SoC并没有正常通知MAC地址的变化</li><li>正常情况都是SoC给TBox发送数据, TBox ARP cache只有在TBox向SoC发送数据时才会更新</li></ul><p>到这里, 还有一个谜底没有揭开: 内核是在什么地方判断MAC地址的不匹配并丢掉该数据包的了? 不妨再看看代码.</p><h2 id="ping回包丢弃之谜"><a href="#ping回包丢弃之谜" class="headerlink" title="ping回包丢弃之谜"></a><strong>ping回包丢弃之谜</strong></h2><p>看内核源码, 数据从链路层L2传到网络层L3的入口是<code>ip_rcv</code>(参考<code>af_inet.c</code>), 协议栈初始化的时候会把这个接口传递给数据链路层(参考<code>dev.c</code>的函数<code>dev_add_pack</code>):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//af_inet.c</span></span><br><span class="line">dev_add_pack(&amp;ip_packet_type);</span><br><span class="line"></span><br><span class="line">   <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> <span class="title">ip_packet_type</span> __<span class="title">read_mostly</span> =</span> &#123;</span><br><span class="line">       .type = cpu_to_be16(ETH_P_IP),</span><br><span class="line">       .func = ip_rcv,</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看<code>ip_rcv</code>这个函数, 可以看到, 如果包本身的类型是<code>PACKET_OTHERHOST</code>就会直接丢弃, 就是说很可能来自TBox的数据包因为MAC地址不匹配被标记为其他主机的包而被丢弃了. 而从加的日志来看, TBox的回包没有继续往下传. 那内核究竟是在何时标记了<code>sk_buff-&gt;pkt_type</code>包类型?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt, </span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> net_device *orig_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line">    u32 len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When the interface is in promisc. mode, drop all the crap</span></span><br><span class="line"><span class="comment">    * that it receives, do not try to analyse it.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;pkt_type == PACKET_OTHERHOST)</span><br><span class="line">        <span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    net = dev_net(dev);</span><br><span class="line">    __IP_UPD_PO_STATS(net, IPSTATS_MIB_IN, skb-&gt;len);</span><br><span class="line"></span><br><span class="line">    skb = skb_share_check(skb, GFP_ATOMIC);</span><br><span class="line">    <span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">        __IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pskb_may_pull(skb, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr)))</span><br><span class="line">        <span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *RFC1122: 3.2.1.2 MUST silently discard any IP frame that fails the checksum.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *Is the datagram acceptable?</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *1.Length at least the size of an ip header</span></span><br><span class="line"><span class="comment">    *2.Version of 4</span></span><br><span class="line"><span class="comment">    *3.Checksums correctly. [Speed optimisation for later, skip loopback checksums]</span></span><br><span class="line"><span class="comment">    *4.Doesn&#x27;t have a bogus length</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iph-&gt;ihl &lt; <span class="number">5</span> || iph-&gt;version != <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line">    BUILD_BUG_ON(IPSTATS_MIB_ECT1PKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_ECT_1);</span><br><span class="line">    BUILD_BUG_ON(IPSTATS_MIB_ECT0PKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_ECT_0);</span><br><span class="line">    BUILD_BUG_ON(IPSTATS_MIB_CEPKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_CE);</span><br><span class="line">    __IP_ADD_STATS(net,</span><br><span class="line">            IPSTATS_MIB_NOECTPKTS + (iph-&gt;tos &amp; INET_ECN_MASK),</span><br><span class="line">            <span class="type">max_t</span>(<span class="type">unsigned</span> <span class="type">short</span>, <span class="number">1</span>, skb_shinfo(skb)-&gt;gso_segs));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pskb_may_pull(skb, iph-&gt;ihl*<span class="number">4</span>))</span><br><span class="line">        <span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(ip_fast_csum((u8 *)iph, iph-&gt;ihl)))</span><br><span class="line">        <span class="keyword">goto</span> csum_error;</span><br><span class="line"></span><br><span class="line">    len = ntohs(iph-&gt;tot_len);</span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;len &lt; len) &#123;</span><br><span class="line">        __IP_INC_STATS(net, IPSTATS_MIB_INTRUNCATEDPKTS);</span><br><span class="line">        <span class="keyword">goto</span> drop;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt; (iph-&gt;ihl*<span class="number">4</span>))</span><br><span class="line">        <span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Our transport medium may have padded the buffer out. Now we know it</span></span><br><span class="line"><span class="comment">    * is IP we can trim to the true length of the frame.</span></span><br><span class="line"><span class="comment">    * Note this now means skb-&gt;len holds ntohs(iph-&gt;tot_len).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (pskb_trim_rcsum(skb, len)) &#123;</span><br><span class="line">        __IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);</span><br><span class="line">        <span class="keyword">goto</span> drop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line">    skb-&gt;transport_header = skb-&gt;network_header + iph-&gt;ihl*<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove any debris in the socket control block */</span></span><br><span class="line">    <span class="built_in">memset</span>(IPCB(skb), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> inet_skb_parm));</span><br><span class="line">    IPCB(skb)-&gt;iif = skb-&gt;skb_iif;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Must drop socket now because of tproxy. */</span></span><br><span class="line">    skb_orphan(skb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,</span><br><span class="line">            net, <span class="literal">NULL</span>, skb, dev, <span class="literal">NULL</span>,</span><br><span class="line">            ip_rcv_finish);</span><br><span class="line"></span><br><span class="line">csum_error:</span><br><span class="line">    __IP_INC_STATS(net, IPSTATS_MIB_CSUMERRORS);</span><br><span class="line">inhdr_error:</span><br><span class="line">    __IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);</span><br><span class="line">drop:</span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接去内核代码搜索<code>PACKET_OTHERHOST</code>,可以看到对于以太网类型, 有一个函数<code>eth_type_trans</code>正是用来确定数据包类型的: 确认这个包是广播还是组播类型的, 同时返回数据链路层对应的协议类型.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__be16 <span class="title function_">eth_type_trans</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> _service_access_point;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *sap;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span>;</span></span><br><span class="line"></span><br><span class="line">    skb-&gt;dev = dev;</span><br><span class="line">    skb_reset_mac_header(skb);</span><br><span class="line"></span><br><span class="line">    eth = (<span class="keyword">struct</span> ethhdr *)skb-&gt;data;</span><br><span class="line">    skb_pull_inline(skb, ETH_HLEN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(is_multicast_ether_addr_64bits(eth-&gt;h_dest))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ether_addr_equal_64bits(eth-&gt;h_dest, dev-&gt;broadcast))</span><br><span class="line">            skb-&gt;pkt_type = PACKET_BROADCAST;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            skb-&gt;pkt_type = PACKET_MULTICAST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// MAC地址不一匹配, 则标记该包为其他目标主机的</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(!ether_addr_equal_64bits(eth-&gt;h_dest,</span><br><span class="line">                        dev-&gt;dev_addr)))</span><br><span class="line">        skb-&gt;pkt_type = PACKET_OTHERHOST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Some variants of DSA tagging don&#x27;t have an ethertype field</span></span><br><span class="line"><span class="comment">    * at all, so we check here whether one of those tagging</span></span><br><span class="line"><span class="comment">    * variants has been configured on the receiving interface,</span></span><br><span class="line"><span class="comment">    * and if so, set skb-&gt;protocol without looking at the packet.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(netdev_uses_dsa(dev)))</span><br><span class="line">        <span class="keyword">return</span> htons(ETH_P_XDSA);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(eth_proto_is_802_3(eth-&gt;h_proto)))</span><br><span class="line">        <span class="keyword">return</span> eth-&gt;h_proto;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *      This is a magic hack to spot IPX packets. Older Novell breaks</span></span><br><span class="line"><span class="comment">    *      the protocol design and runs IPX over 802.3 without an 802.2 LLC</span></span><br><span class="line"><span class="comment">    *      layer. We look for FFFF which isn&#x27;t a used 802.2 SSAP/DSAP. This</span></span><br><span class="line"><span class="comment">    *      won&#x27;t work for fault tolerant netware but does for the rest.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sap = skb_header_pointer(skb, <span class="number">0</span>, <span class="keyword">sizeof</span>(*sap), &amp;_service_access_point);</span><br><span class="line">    <span class="keyword">if</span> (sap &amp;&amp; *sap == <span class="number">0xFFFF</span>)</span><br><span class="line">        <span class="keyword">return</span> htons(ETH_P_802_3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *      Real 802.2 LLC</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> htons(ETH_P_802_2);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(eth_type_trans);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面说道, SoC使用的是基于USB的rndis网卡驱动, 直接去usb网卡驱动下面找调用这个函数的地方(<code>drivers/net/usb</code>),会发现在<code>usbnet.c</code>的函数<code>usbnet_skb_return</code>中, 数据包往上层协议栈发送的时候会调用<code>eth_type_trans</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Passes this packet up the stack, updating its accounting.</span></span><br><span class="line"><span class="comment">* Some link protocols batch packets, so their rx_fixup paths</span></span><br><span class="line"><span class="comment">* can return clones as well as just modify the original skb.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usbnet_skb_return</span> <span class="params">(<span class="keyword">struct</span> usbnet *dev, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcpu_sw_netstats</span> *<span class="title">stats64</span> =</span> this_cpu_ptr(dev-&gt;stats64);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span>status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">now</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (test_bit(EVENT_RX_PAUSED, &amp;dev-&gt;flags)) &#123;</span><br><span class="line">        dbg_log_string(<span class="string">&quot;skb %pK added to pause list&quot;</span>, skb);</span><br><span class="line">        skb_queue_tail(&amp;dev-&gt;rxq_pause, skb);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* only update if unset to allow minidriver rx_fixup override */</span></span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;protocol == <span class="number">0</span>)</span><br><span class="line">        skb-&gt;protocol = eth_type_trans (skb, dev-&gt;net);</span><br><span class="line"></span><br><span class="line">    flags = u64_stats_update_begin_irqsave(&amp;stats64-&gt;syncp);</span><br><span class="line">    stats64-&gt;rx_packets++;</span><br><span class="line">    dev-&gt;net-&gt;stats.rx_packets++;</span><br><span class="line">    stats64-&gt;rx_bytes += skb-&gt;len;</span><br><span class="line">    dev-&gt;net-&gt;stats.rx_bytes += skb-&gt;len;</span><br><span class="line">    u64_stats_update_end_irqrestore(&amp;stats64-&gt;syncp, flags);</span><br><span class="line"></span><br><span class="line">    netif_dbg(dev, rx_status, dev-&gt;net, <span class="string">&quot;&lt; rx, len %zu, type 0x%x\n&quot;</span>,</span><br><span class="line">        skb-&gt;len + <span class="keyword">sizeof</span> (<span class="keyword">struct</span> ethhdr), skb-&gt;protocol);</span><br><span class="line">    <span class="built_in">memset</span> (skb-&gt;cb, <span class="number">0</span>, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> skb_data));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skb_defer_rx_timestamp(skb))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    getnstimeofday64(&amp;now);</span><br><span class="line">    dbg_log_string(<span class="string">&quot;skb %pK, time %lu.%09lu&quot;</span>, skb, now.tv_sec, now.tv_nsec);</span><br><span class="line">    status = netif_rx (skb);</span><br><span class="line">    <span class="keyword">if</span> (status != NET_RX_SUCCESS)</span><br><span class="line">        netif_dbg(dev, rx_err, dev-&gt;net,</span><br><span class="line">            <span class="string">&quot;netif_rx status %d\n&quot;</span>, status);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(usbnet_skb_return);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此, 我们总算揭开了TBox数据包被丢弃的谜底, 也把整个问题的来龙去脉理清楚了. 那么, 问题要如何解决?</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><p>回头看, 问题的表面现象是TBox的ARP cache更新慢了, 但是为什么更新慢了? 总结下有两个方面的原因:</p><ul><li>SoC侧每次休眠唤醒MAC地址会随机变化, 但是又没有ARP通知到TBox, 所以TBox ARP不会更新</li><li>TBox不会向SoC侧发送数据包, 所以不会更新ARP cache(内核在发送数据的时候会生成新的cache)</li></ul><p>这么来看问题的对策可以有这么几个:</p><ol><li>TBox在网卡UP的时候发送ARP包或者ping包给SoC这边, 主动更新ARP cache</li><li>SoC把USB网卡的MAC地址修改成固定值, 这样ARP cache始终不会发生变化了</li><li>SoC在USB网卡UP时主动发送一个GARP(<code>Gratuitous ARP</code>)给TBox(参考<code>devinet.c</code>函数<code>inetdev_send_gratuitous_arp</code>)(下篇文章就来介绍下<code>GARP</code>)</li></ol><p>对局域网来说, USB的rndis网卡修改成固定值看起来更为合理, 而且修改的代码量是最少的, 只需要把<code>rndis_host.c</code>中网卡随机生成的逻辑去掉即可:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">--- a/drivers/net/usb/rndis_host.c</span><br><span class="line">+++ b/drivers/net/usb/rndis_host.c</span><br><span class="line">@@ <span class="number">-430</span>,<span class="number">10</span> +<span class="number">430</span>,<span class="number">7</span> @@ generic_rndis_bind(<span class="keyword">struct</span> usbnet *dev, <span class="keyword">struct</span> usb_interface *intf, <span class="type">int</span> flags)</span><br><span class="line">        <span class="keyword">goto</span> halt_fail_and_release;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-<span class="keyword">if</span> (bp[<span class="number">0</span>] &amp; <span class="number">0x02</span>)</span><br><span class="line">-eth_hw_addr_random(net);</span><br><span class="line">-<span class="keyword">else</span></span><br><span class="line">-ether_addr_copy(net-&gt;dev_addr, bp);</span><br><span class="line">+ether_addr_copy(net-&gt;dev_addr, bp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set a nonzero filter to enable data transfers */</span></span><br><span class="line">    <span class="built_in">memset</span>(u.<span class="built_in">set</span>, <span class="number">0</span>, <span class="keyword">sizeof</span> *u.<span class="built_in">set</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这个问题本身其实并不算困难, 但是由于一开始就忽略了<code>packets donot lie</code>这个原则, 没有认真看<code>tcpdump</code>的数据包, 忽略了MAC地址不匹配重要的事实, 导致问题定位走了弯路. 总的说来, 网络问题首先要抓到数据包, 再基于对TCP&#x2F;IP协议的理解, 认真梳理linux内核协议栈的流程, 疑难杂症就没有什么可怕的了.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://elixir.bootlin.com/linux/v4.14.249/source">https://elixir.bootlin.com/linux/v4.14.249/source</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近碰到了一个很奇怪的问题, Android系统(Linux内核4.15)唤醒后, SoC(高通平台)跟TBox(Telematics Box)TCP的连接会偶发变慢, 需要等超过10s才能连接上. 发送ping包给TBox, 通过&lt;code&gt;strace&lt;/code&gt;看进程一直提示&lt;code&gt;EAGAIN&lt;/code&gt;的错误.从字面意义来说&lt;code&gt;EAGAIN&lt;/code&gt;(&lt;code&gt;Resource temporarily unavailable&lt;/code&gt;)是内核告知ping进程当前没有可用的数据包可以接收. 可是, 问题来了:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么ping一直会收到&lt;code&gt;EAGAIN&lt;/code&gt;的错误? 内核在什么时候会返回该错误?&lt;/li&gt;
&lt;li&gt;为什么ping收不到数据包, TBox回包到底去了哪里?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;幸亏好这个问题比较容易重现, 折腾了两天才最终把问题的的来龙去脉搞清楚. 接下来就来看看这个问题的现象以及背后发生的根因, 最后给出几个相应的对策.&lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="TCP/IP" scheme="https://sniffer.site/tags/TCP-IP/"/>
    
    <category term="ARP" scheme="https://sniffer.site/tags/ARP/"/>
    
    <category term="Address Resolution Protocol" scheme="https://sniffer.site/tags/Address-Resolution-Protocol/"/>
    
    <category term="MAC" scheme="https://sniffer.site/tags/MAC/"/>
    
    <category term="Media Access Control" scheme="https://sniffer.site/tags/Media-Access-Control/"/>
    
  </entry>
  
  <entry>
    <title>怎么招聘SRE工程师-看看Google是如何招人</title>
    <link href="https://sniffer.site/2021/07/16/%E6%80%8E%E4%B9%88%E6%8B%9B%E8%81%98SRE%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%9C%8B%E7%9C%8BGoogle%E6%98%AF%E5%A6%82%E4%BD%95%E6%8B%9B%E4%BA%BA%E7%9A%84-%E8%AF%91/"/>
    <id>https://sniffer.site/2021/07/16/%E6%80%8E%E4%B9%88%E6%8B%9B%E8%81%98SRE%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%9C%8B%E7%9C%8BGoogle%E6%98%AF%E5%A6%82%E4%BD%95%E6%8B%9B%E4%BA%BA%E7%9A%84-%E8%AF%91/</id>
    <published>2021-07-16T07:03:07.000Z</published>
    <updated>2021-08-11T06:51:22.171Z</updated>
    
    <content type="html"><![CDATA[<p>看到左耳朵耗子的一篇文章<a href="https://coolshell.cn/articles/20977.html">程序员如何把控自己的职业</a>, 里边提到了Google SRE的评分卡, 用于招聘时软件工程师对自己技能水平的评估, 总共分为11个等级:</p><ol start="0"><li>You are unfamiliar with the subject area.</li></ol><ul><li>对相关的技术领域还不熟悉</li></ul><ol><li>You can read&#x2F;understand the most fundamental aspects of the subject area.</li></ol><ul><li>能够读懂相关领域相关的基础知识</li></ul><ol start="2"><li>Ability to implement small changes, understand basic principles and able to figure out additional details with minimal help.</li></ol><ul><li>可以实现一些小的改动，清楚基本的原理，并能够在简单的指导下自己找到更多的细节</li></ul><ol start="3"><li>Basic proficiency in a subject area without relying on help.</li></ol><ul><li>基本精通一个技术领域, 完全不需要别人的帮助</li></ul><span id="more"></span><ol start="4"><li>You are comfirtable with the subject area and all routine work on it: For software areas - ability to develop medium programs using all basic language features w&#x2F;o book, awareness of more esoteric feature(with book).<br>For systems areas - understanding of many fundamentals of networking and systems administration, ability to run a small network of system including recovery, debugging and nontrivial troubleshooting that relies on the knowledge of internals.</li></ol><ul><li>对这个技术领域非常的熟悉和舒适，可以应对和完成所有的日常工作<ul><li>对于软件领域 – 有能力开发中等规模的程序，能够熟练和掌握并使用所有的语言特性，而不是需要翻书，并且能够找到所有的冷知识</li><li>对于系统领域 – 掌握网络和系统管理的很多基础知识，并能够掌握一些内核知识以运维一个小型的网络系统，包括恢复、调试和能解决一些不常见的故障。</li></ul></li></ul><ol start="5"><li>An even lower degree of reliance on reference materials. Deeper skills in a field or specific technology in the subject area.</li></ol><ul><li>对于该技术领域有非常底层的了解和深入的技能</li></ul><ol start="6"><li>Ability to develop large programs and systems from scratch. Understanding of low level details and internals. Ability to design &#x2F; deploy most large, distributed systems from scratch.</li></ol><ul><li>能够从零开发大型程序和系统。理解底层和内部细节。能够从零设计和部署大型分布式系统</li></ul><ol start="7"><li>You understand and make use of most lesser known language features, technologies, and associated internals. Ability to automate significant amounts of systems administration.</li></ol><ul><li>理解并能利用高级技术，以及相关的内在原理，并可以从根本上自动化大量的系统管理和运维工作</li></ul><ol start="8"><li>Deep understanding of corner cases, esoteric features, protocols and systems including “theory of operation”. Demonstrated ability to design, deploy and own very critical or large infrastructure, build accompanying automation.</li></ol><ul><li>对于一些边角和晦涩的技术、协议和系统工作原理有很深入的理解和经验。能够设计，部署并负责非常关键以及规模很大的基础设施，并能够构建相应的自动化设施</li></ul><ol start="9"><li>Could have written the book about the subject area but didn’t; works with standards committees on defining new standards and methodologies.</li></ol><ul><li>能够在该技术领域出一本经典的书。并和标准委员会的人一起工作制定相关的技术标准和方法</li></ul><ol start="10"><li>Wrote the book on the subject area(there actually has to be a book). Recognized industry expert in the field, might have invented it</li></ol><ul><li>在该领域写过一本书，被业内尊为专家，并是该技术的发明人</li></ul><p>SRE自评涉及到的技术领域主要有如下这些:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">– TCP/IP Networking (OSI stack, DNS etc)</span><br><span class="line">– Unix/Linux internals</span><br><span class="line">– Unix/Linux Systems administration</span><br><span class="line">– Algorithms and Data Structures</span><br><span class="line">– C/C++</span><br><span class="line">– Python</span><br><span class="line">– Java</span><br><span class="line">– Perl</span><br><span class="line">– Go</span><br><span class="line">– Shell Scripting (sh, Bash, ksh, csh)</span><br><span class="line">– SQL and/or Database Admin</span><br><span class="line">– Scripting language of your choice (not already mentioned)</span><br><span class="line">– People Management</span><br><span class="line">– Project Management</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到这个自评表, 对照下自己的技能水平, 瞬间感觉路途慢慢了. 需要提升学习的东西太多了. </p><p>SRE(Site Reliability Engineering), 直译过来就是现场可靠性工程, 最开始由Google发起的运维大型分布式系统一整套流程与方法, 有点类似于云服务运维中的DevOps, 目前有很多大公司如Facebook&#x2F;Netflix等都在使用. </p><p>说到SRE, 这里有一篇十分值得一看的文章, 里边大概描述了什么是SRE以及Google是如何招聘SRE工程师: 什么样的人才是Google需要的; 如何面试；如何做出招聘的决策, 文章讲了很多方法与流程, 最终的目的就是要招聘到符合Google要求的人才, 为Google的发展注入动力. Google始终秉承着”宁可不招人, 也不要招错人”, “新招聘的候选人需要比已有团队的员工能力要更突出”的要求, 在人才的储备上下了很多功夫. 整篇文章看下来, 不得不佩服顶级互联网公司在人才培养方面的用心用力, 也正是这种严格高标准的人才招聘才不断的推动Google公司的业务发展.</p><blockquote><p>原文链接:<a href="https://www.usenix.org/system/files/login/articles/login_june_07_jones.pdf">Hiring Site Reliability Engineers</a></p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://sre.google/">https://sre.google/</a></li><li><a href="https://www.usenix.org/system/files/login/articles/login_june_07_jones.pdf">https://www.usenix.org/system/files/login/articles/login_june_07_jones.pdf</a></li><li><a href="https://cloud.kapostcontent.net/pub/1418185e-b325-49d3-b65c-de338e45cb6f/ebook-10-essential-skills-of-a-site-reliability-engineer-sre.pdf">SRE工程师需要具备的10个基本技能</a></li><li><a href="https://coolshell.cn/articles/20977.html">程序员如何把控自己的职业</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;看到左耳朵耗子的一篇文章&lt;a href=&quot;https://coolshell.cn/articles/20977.html&quot;&gt;程序员如何把控自己的职业&lt;/a&gt;, 里边提到了Google SRE的评分卡, 用于招聘时软件工程师对自己技能水平的评估, 总共分为11个等级:&lt;/p&gt;
&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;You are unfamiliar with the subject area.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对相关的技术领域还不熟悉&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;You can read&amp;#x2F;understand the most fundamental aspects of the subject area.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;能够读懂相关领域相关的基础知识&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Ability to implement small changes, understand basic principles and able to figure out additional details with minimal help.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;可以实现一些小的改动，清楚基本的原理，并能够在简单的指导下自己找到更多的细节&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Basic proficiency in a subject area without relying on help.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;基本精通一个技术领域, 完全不需要别人的帮助&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="软件工程" scheme="https://sniffer.site/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="SRE" scheme="https://sniffer.site/tags/SRE/"/>
    
    <category term="Site Reliability Engineering" scheme="https://sniffer.site/tags/Site-Reliability-Engineering/"/>
    
    <category term="Google" scheme="https://sniffer.site/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>一个SMMU内存访问异常的问题</title>
    <link href="https://sniffer.site/2021/06/22/%E4%B8%80%E4%B8%AASMMU%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/"/>
    <id>https://sniffer.site/2021/06/22/%E4%B8%80%E4%B8%AASMMU%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-22T10:09:05.000Z</published>
    <updated>2021-08-11T07:02:35.322Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到棘手的问题: 以太网进行iperf测试时, 发生了SMMU (System Memory Management Unit)访问异常导致内核崩溃. 原本只是内部测试发现, 后面在试验车上也概率性的出现. 问题发生的概率还不小. 很严重. 只能先从头把一些基本概念与流程梳理清楚. 好在最后还是找到了原因并解决了. 松了口气, 才有时间把整个问题的来龙去脉细细的总结下, 算是一个SMMU相关问题的案例.</p><p>首先来看看问题的发生的背景.</p><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a><strong>问题背景</strong></h2><p>问题发生在利用<code>iperf</code>做网络性能测试的时候, 测试系统(采用高通8155平台, 内置一个EMAC芯片, 最高支持1Gbps速率)作为客户端:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">iperf -c <span class="number">172.20</span><span class="number">.2</span><span class="number">.33</span> -p <span class="number">8989</span> -f m -R</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里加<code>-R</code>参数表示客户端作为数据接收方(奇怪的是, 测试不加<code>-R</code>参数就不会有问题, 这也说明只有在接收数据的过程才会出现问题), 而服务端是发送方:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">iperf -s -p <span class="number">8989</span> -f m </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这么测试几十个小时就很快出现了, 抓取到的问题堆栈如下. 前面的日志是SMMU相关的寄存器状态打印, 后面是内核调用堆栈.</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="number">53480.526297</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: FAR    = <span class="number">0x00000000a2a2a000</span></span><br><span class="line">[<span class="number">53480.533192</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: PAR    = <span class="number">0x0000000000000000</span></span><br><span class="line">[<span class="number">53480.540466</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: FSR    = <span class="number">0x40000402</span> [TF W SS ]</span><br><span class="line">[<span class="number">53480.547750</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: TTBR0  = <span class="number">0x000f00035bbaa000</span></span><br><span class="line">[<span class="number">53480.554990</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: TTBR1  = <span class="number">0x000f000000000000</span></span><br><span class="line">[<span class="number">53480.562192</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: SCTLR  = <span class="number">0x00c000e7</span> ACTLR  = <span class="number">0x00000000</span></span><br><span class="line">[<span class="number">53480.570572</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: CBAR  = <span class="number">0x0001f300</span></span><br><span class="line">[<span class="number">53480.576741</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: MAIR0   = <span class="number">0xf404ff44</span> MAIR1   = <span class="number">0x00000000</span></span><br><span class="line">[<span class="number">53480.585071</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: Unhandled context fault: iova=<span class="number">0xa2a2a000</span>, cb=<span class="number">14</span>, fsr=<span class="number">0x40000402</span>, fsynr0=<span class="number">0x7e0013</span>, fsynr1=<span class="number">0x0</span></span><br><span class="line">[<span class="number">53480.597668</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: soft iova-to-phys=<span class="number">0x0000000000000000</span></span><br><span class="line">[<span class="number">53480.605440</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: SOFTWARE TABLE WALK FAILED! Looks like <span class="number">15000000.</span>apps-smmu accessed an unmapped address!</span><br><span class="line">[<span class="number">53480.617935</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: hard iova-to-phys (ATOS) failed</span><br><span class="line">[<span class="number">53480.625147</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: SID=<span class="number">0x3c0</span></span><br><span class="line">[<span class="number">53480.630332</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: Unhandled arm-smmu context fault!</span><br><span class="line">[<span class="number">53480.638310</span>] ------------[ cut here ]------------</span><br><span class="line">[<span class="number">53480.638324</span>] kernel BUG at /home/jenkins/.jenkins/workspace/SourceCode/kernel/msm<span class="number">-4.14</span>/drivers/iommu/arm-smmu.c:<span class="number">1762</span>!</span><br><span class="line">[<span class="number">53480.649128</span>] [KERN Warning] ERROR/WARN forces debug_lock off!</span><br><span class="line">[<span class="number">53480.649135</span>] [KERN Warning] check backtrace:</span><br><span class="line">[<span class="number">53480.649151</span>] CPU: <span class="number">0</span> PID: <span class="number">319</span> Comm: irq/<span class="number">386</span>-arm-smm Tainted: G S         O    <span class="number">4.14</span><span class="number">.170</span>+ #<span class="number">2</span></span><br><span class="line">[<span class="number">53480.649160</span>] Hardware name: Qualcomm Technologies, Inc. SA8155P v2 PM8150 ADP-STAR model-D55 (DT)</span><br><span class="line">[<span class="number">53480.649171</span>] Call trace:</span><br><span class="line">[<span class="number">53480.649215</span>]  dump_backtrace+<span class="number">0x0</span>/<span class="number">0x1f4</span></span><br><span class="line">[<span class="number">53480.649226</span>]  show_stack+<span class="number">0x20</span>/<span class="number">0x2c</span></span><br><span class="line">[<span class="number">53480.649241</span>]  dump_stack+<span class="number">0xe4</span>/<span class="number">0x134</span></span><br><span class="line">[<span class="number">53480.649255</span>]  debug_locks_off+<span class="number">0x54</span>/<span class="number">0x88</span></span><br><span class="line">[<span class="number">53480.649268</span>]  oops_enter+<span class="number">0x14</span>/<span class="number">0x20</span></span><br><span class="line">[<span class="number">53480.649275</span>]  die+<span class="number">0x38</span>/<span class="number">0x16c</span></span><br><span class="line">[<span class="number">53480.649284</span>]  bug_handler+<span class="number">0x50</span>/<span class="number">0x88</span></span><br><span class="line">[<span class="number">53480.649293</span>]  brk_handler+<span class="number">0x6c</span>/<span class="number">0xb4</span></span><br><span class="line">[<span class="number">53480.649301</span>]  do_debug_exception+<span class="number">0x7c</span>/<span class="number">0x114</span></span><br><span class="line">[<span class="number">53480.649309</span>]  el1_dbg+<span class="number">0x18</span>/<span class="number">0x74</span></span><br><span class="line">[<span class="number">53480.649321</span>]  arm_smmu_context_fault+<span class="number">0x8e0</span>/<span class="number">0x944</span></span><br><span class="line">[<span class="number">53480.649332</span>]  irq_thread_fn+<span class="number">0x2c</span>/<span class="number">0x70</span></span><br><span class="line">[<span class="number">53480.649340</span>]  irq_thread+<span class="number">0xc0</span>/<span class="number">0x144</span></span><br><span class="line">[<span class="number">53480.649350</span>]  kthread+<span class="number">0x128</span>/<span class="number">0x138</span></span><br><span class="line">[<span class="number">53480.649357</span>]  ret_from_fork+<span class="number">0x10</span>/<span class="number">0x18</span></span><br><span class="line">[<span class="number">53480.649367</span>] Internal error: Oops - BUG: <span class="number">0</span> [#<span class="number">1</span>] PREEMPT SMP</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从堆栈来看大致可以了解到, 这是由于SMMU监测到某个模块非法的访问DMA地址后, 引起了内核崩溃. 那么, 为何有这个错误SMMU访问错误? 这个错误又是哪个模块导致的? 是在什么情况下引起的SMMU内存错误了?  这不得不从SMMU本身说起.</p><h2 id="什么是SMMU"><a href="#什么是SMMU" class="headerlink" title="什么是SMMU"></a><strong>什么是SMMU</strong></h2><p>简单来说, SMMU(System Memory Management Unit)是ARM为外设访问系统RAM提供了一种类似于MMU的虚拟内存访问机制, 外设可以通过DMA直接访问RAM, 而无需CPU的干预. 如此, 外设可以通过一个虚拟的地址即可访问物理地址(可以不连续), 做到了不同外设之间IO地址空间的彼此独立与隔离. 因此, SMMU也通常被称为IOMMU(Input&#x2F;Output MMU).</p><p>下图是从ARM SMMU Spec手册里的一张SMMU简图: SMMU为设备与RAM之间构建了一个设备虚拟地址(IOVA)与物理地址之间的映射关系, 每次执行DMA数据传输的时候, 都要通过SMMU将IOVA地址翻译成对应的物理地址.</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/arm_smmu_diagram.png" alt="ARM SMMU Diagram"></p><p>那么对于设备驱动来说, 如何使用SMMU了? 不妨来看下SMMU相关的API. </p><ul><li><code>arm_iommu_create_mapping</code>: 配置设备所要使用的VA(Virtual Address, 虚拟地址)的范围</li><li><code>arm_iommu_attach_device</code>: 将分配好的VA地址范围与设备绑定, 并开启SMMU地址转换</li><li><code>dma_map_single/dma_unmap_single</code>: 分配&#x2F;去除某个DMA地址, 这种方式是异步的, 常用于一次性传输的场景(传输完成后DMA的映射即解除了) </li><li><code>dma_alloc_coherent/dma_free_coherent</code>: 一致性(consistent), 同步(synchronous)的DMA内存分配方法, 确保CPU与设备的数据始终是同步的, 一般用于需要常驻内存的一些数据</li></ul><p>这里不对IOMMU的代码做深入分析了. 有关IOMMU相关的流程可以参考内核代码:</p><ul><li><code>kernel/drivers/iommu</code>: SMMU驱动, 用于配置SMMU, 为设备驱动提供接口</li><li><code>kernel/arch/arm64/mm</code>: 与平台相关的SMMU的页表分配的实现</li></ul><p>有了这些SMMU的基础知识, 我们就来分析下最开始那个问题.</p><h2 id="SMMU访问异常问题分析"><a href="#SMMU访问异常问题分析" class="headerlink" title="SMMU访问异常问题分析"></a><strong>SMMU访问异常问题分析</strong></h2><p>继续来看下问题的日志. 堆栈的前面一部分是有关SMMU的状态寄存器:</p><ul><li>FSR(<code>Fault Status Register</code>)表示SMMU错误的类型(转换&#x2F;权限等), 这里的值<code>0x40000402 [TF W SS ]</code>, 说明是一个写操作时引起的页表访问错误</li><li>FAR(<code>Fault Address Register)</code>: 表示发生错误的IO虚拟地址</li><li>PAR(<code>Physical Address Register</code>): 发生错误时查找到的物理地址, 这里是全0, 说明相应的IOVA地址没有映射</li><li>TTBRm(<code>Translation Table Base Address</code>):<ul><li>TTBR0: 保存Translation Table0的基地址</li><li>TTBR1: 保存Translation Table1的基地址</li></ul></li></ul><p>重点看下如下两行日志, 我们可以知道发生内存映射异常的IOVA地址是<code>0xa2a2a000</code>, 对应的SID是<code>0x3c0</code>(SID是对应设备使用SMMU映射内存时的标识),SID一般在设备树DTS的配置中指定的. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[53480.585071] arm-smmu 15000000.apps-smmu: Unhandled context fault: iova=0xa2a2a000, cb=14, fsr=0x40000402, fsynr0=0x7e0013, fsynr1=0x0</span><br><span class="line"> ....</span><br><span class="line">[53480.625147] arm-smmu 15000000.apps-smmu: SID=0x3c0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看内核的DTS配置, <code>iommus</code>这个对应了设备节点SMMU的配置;可以看到发生问题的设备正是以太网:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">emac_emb_smmu: emac_emb_smmu &#123;</span><br><span class="line">compatible = <span class="string">&quot;qcom,emac-smmu-embedded&quot;</span>;</span><br><span class="line">iommus = &lt;&amp;apps_smmu <span class="number">0x3C0</span> <span class="number">0x0</span>&gt;;</span><br><span class="line">qcom,iova-mapping = &lt;<span class="number">0x80000000</span> <span class="number">0x40000000</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>理清楚这些SMMU的日志只是第一步, 但是对于为何会发生SMMU访问异常还是毫无头绪. 这个只能通过阅读驱动源代码弄清楚以太网网卡数据的接收流程才能一步步揭开迷雾了. </p><p>对于目前的以太网网卡来说, 一般采用ring buffer(环形缓冲区)的形式来接收数据; 驱动在初始化的时候为网卡的ring buffer预分配DMA内存, 用于接收数据. 总体来收, 网卡的数据接收流程有如下三个步骤:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/arm_SMMU_architecture.png" alt="EMAC DMA Process"></p><ul><li>网卡需要传数据时, 获取到当前的缓冲区对应的DMA内存地址(IOVA)后, 通过SMMU向对应的RAM地址传输数据</li><li>发送完成后, 通过中断告知驱动有数据需要接收</li><li>CPU接收到中断后, 驱动会把DMA的映射解除, 数据交由CPU处理; 接着驱动把对应的数据发送到协议栈继续处理</li></ul><p>那么, 问题来了, SMMU是何时收到DMA访问异常错误的了? 是在第三个步骤, 驱动解除DMA地址映射后, 有地方再次尝试使用该DMA地址导致的吗? 从驱动的逻辑来看, 每次传送完成, DMA地址与RAM地址解除映射后, 没有地方会再次尝试获取该DMA地址了(对应buffer的DMA地址已经置空). 退一步说, 如果是驱动使用的时候发生的问题, 那么异常的堆栈应该会打印出来, 但是现在只有SMMU相关的日志.</p><p>所以, 问题的源头只能是在网卡通过SMMU往对应的DMA地址发送数据的时候, 就是说如果网卡给DMA传输数据的大小超过了预分配的buffer的大小的话, SMMU会发现对应的DMA地址没有映射到物理地址, 从而报错. 解决问题的办法也很简单, 只需要把buffer大小由原来的1538修改为2048(2kb)就可以了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-<span class="meta">#<span class="keyword">define</span> DWC_ETH_QOS_ETH_FRAME_LEN (ETH_FRAME_LEN + ETH_FCS_LEN + VLAN_HLEN + PADDING_ISSUE)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DWC_ETH_QOS_ETH_FRAME_LEN (1&lt;&lt;11)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改后再次验证, 问题不再出现. 但这里有个问题, DMA的buffer大小为何设置成2kb而不是其他如4kb了?  这个实际跟以太网网卡(EMAC)本身的设计有关, 一般以太网的一帧数据是一个MTU(一般是1500, 如果有VLAN数据, 则会多4个字节), 但为何网卡传输的一帧数据会超过设定的MTU大小, 这个目前咨询了供应商仍然没有得到答案(供应商怀疑是发送端给到的一帧数据超过了最大的MTU 1538, 这个结论仍然值得怀疑).</p><p>从高通给的一些问题案例来说, 一般SMMU都是由于需要传输的数据大小与实际的buf大小不一致导致的. 总的说来, SMMU的问题看起来十分棘手, 但只要把基本的概念与原理弄清楚, 把代码流程梳理完整, 解决这类问题并不是件十分困难的事情.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://developer.arm.com/documentation/ihi0070/latest">ARM SMMU spec</a></li><li><a href="https://www.kernel.org/doc/Documentation/DMA-API-HOWTO.txt">https://www.kernel.org/doc/Documentation/DMA-API-HOWTO.txt</a></li><li><a href="https://www.ti.com/lit/ug/spruhh1/spruhh1.pdf?ts=1624513771099&ref_url=https%253A%252F%252Fwww.google.com.hk%252F">TI EMAC design</a></li><li><a href="https://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-get.cgi/2015/MSC/MSC-2015-10.pdf">rethinking IOMMU</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近碰到棘手的问题: 以太网进行iperf测试时, 发生了SMMU (System Memory Management Unit)访问异常导致内核崩溃. 原本只是内部测试发现, 后面在试验车上也概率性的出现. 问题发生的概率还不小. 很严重. 只能先从头把一些基本概念与流程梳理清楚. 好在最后还是找到了原因并解决了. 松了口气, 才有时间把整个问题的来龙去脉细细的总结下, 算是一个SMMU相关问题的案例.&lt;/p&gt;
&lt;p&gt;首先来看看问题的发生的背景.&lt;/p&gt;
&lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;问题发生在利用&lt;code&gt;iperf&lt;/code&gt;做网络性能测试的时候, 测试系统(采用高通8155平台, 内置一个EMAC芯片, 最高支持1Gbps速率)作为客户端:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iperf -c &lt;span class=&quot;number&quot;&gt;172.20&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.2&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.33&lt;/span&gt; -p &lt;span class=&quot;number&quot;&gt;8989&lt;/span&gt; -f m -R&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这里加&lt;code&gt;-R&lt;/code&gt;参数表示客户端作为数据接收方(奇怪的是, 测试不加&lt;code&gt;-R&lt;/code&gt;参数就不会有问题, 这也说明只有在接收数据的过程才会出现问题), 而服务端是发送方:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iperf -s -p &lt;span class=&quot;number&quot;&gt;8989&lt;/span&gt; -f m &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这么测试几十个小时就很快出现了, 抓取到的问题堆栈如下. 前面的日志是SMMU相关的寄存器状态打印, 后面是内核调用堆栈.&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://sniffer.site/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://sniffer.site/tags/Linux/"/>
    
    <category term="Kernel" scheme="https://sniffer.site/tags/Kernel/"/>
    
    <category term="SMMU" scheme="https://sniffer.site/tags/SMMU/"/>
    
    <category term="MMU" scheme="https://sniffer.site/tags/MMU/"/>
    
  </entry>
  
  <entry>
    <title>从Wifi热点功能说一说Android Wifi框架</title>
    <link href="https://sniffer.site/2021/04/29/%E4%BB%8EWifi%E7%83%AD%E7%82%B9%E5%8A%9F%E8%83%BD%E8%AF%B4%E4%B8%80%E8%AF%B4Android-Wifi%E6%A1%86%E6%9E%B6/"/>
    <id>https://sniffer.site/2021/04/29/%E4%BB%8EWifi%E7%83%AD%E7%82%B9%E5%8A%9F%E8%83%BD%E8%AF%B4%E4%B8%80%E8%AF%B4Android-Wifi%E6%A1%86%E6%9E%B6/</id>
    <published>2021-04-29T02:18:23.000Z</published>
    <updated>2022-02-16T07:05:54.506Z</updated>
    
    <content type="html"><![CDATA[<p>之前帮着解决了项目中WIFI相关的问题, 一直想梳理下WIFI的框架, 方便后续代码阅读以及问题的解决. 恰好年初修改了车机上WIFI热点相关的一些代码, 重新看了下Android 10(Q)的逻辑, 于是想通过WIFI热点相关的功能作为切入点, 完整的梳理下Android WIFI的整体框架.</p><p>先不多说, 看下Android WIFI的大致框架:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/android_wifi_fw.png" alt="android wifi framwork"></p><span id="more"></span><p>从上至下, 对应的代码路径如下:</p><ul><li>应用层: <code>/packages/apps/Settings</code></li><li>框架层<ul><li><code>/framework/opt/net/wifi/</code>: wifiservice的核心逻辑</li><li><code>/framework/base/wifi</code>: 公共接口部分</li><li><code>/framework/base/services/core/java/com/android/server/connectivity</code>: 热点共享实现</li></ul></li><li>native层<ul><li><code>/hardware/interface/wifi</code>: HAL层接口</li><li><code>/external/wpa_supplicant_8</code>: 主要包括AP(access point)和STA(Station) 身份验证与数据加密的实现, 分为<code>hostapd</code>与<code>wpa_supplicant</code>两个部分</li><li><code>/system/connectivity/wificond</code>: wifi控制通道代码, 负责创建网口以及获取扫描结果等</li><li><code>/system/netd</code>:  网络管理的守护进程, 负责路由&#x2F;流量统计等相关的配置</li></ul></li></ul><p>接下来就来看下通过WIFI来分享热点时的具体代码流程.</p><h2 id="开启热点"><a href="#开启热点" class="headerlink" title="开启热点"></a><strong>开启热点</strong></h2><p>Android除了支持通过热点共享网络之外, 还支持通过USB&#x2F;蓝牙的方式共享数据连接. 热点共享的接口都通过<code>ConnectivityManager</code>提供:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">tether</span><span class="params">(String iface)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">pkgName</span> <span class="operator">=</span> mContext.getOpPackageName();</span><br><span class="line">           Log.i(TAG, <span class="string">&quot;tether caller:&quot;</span> + pkgName);</span><br><span class="line">           <span class="keyword">return</span> mService.tether(iface, pkgName);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="meta">@SystemApi</span></span><br><span class="line"><span class="meta">@RequiresPermission(android.Manifest.permission.TETHER_PRIVILEGED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startTethering</span><span class="params">(<span class="type">int</span> type, <span class="type">boolean</span> showProvisioningUi,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> OnStartTetheringCallback callback)</span> &#123;</span><br><span class="line">startTethering(type, showProvisioningUi, callback, <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@SystemApi</span></span><br><span class="line">   <span class="meta">@RequiresPermission(android.Manifest.permission.TETHER_PRIVILEGED)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startTethering</span><span class="params">(<span class="type">int</span> type, <span class="type">boolean</span> showProvisioningUi,</span></span><br><span class="line"><span class="params">           <span class="keyword">final</span> OnStartTetheringCallback callback, Handler handler)</span> &#123;</span><br><span class="line">       Preconditions.checkNotNull(callback, <span class="string">&quot;OnStartTetheringCallback cannot be null.&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">ResultReceiver</span> <span class="variable">wrappedCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultReceiver</span>(handler) &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onReceiveResult</span><span class="params">(<span class="type">int</span> resultCode, Bundle resultData)</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (resultCode == TETHER_ERROR_NO_ERROR) &#123;</span><br><span class="line">                   callback.onTetheringStarted();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   callback.onTetheringFailed();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">pkgName</span> <span class="operator">=</span> mContext.getOpPackageName();</span><br><span class="line">           Log.i(TAG, <span class="string">&quot;startTethering caller:&quot;</span> + pkgName);</span><br><span class="line">           mService.startTethering(type, wrappedCallback, showProvisioningUi, pkgName);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">           Log.e(TAG, <span class="string">&quot;Exception trying to start tethering.&quot;</span>, e);</span><br><span class="line">           wrappedCallback.send(TETHER_ERROR_SERVICE_UNAVAIL, <span class="literal">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ConnectivityManager</code>实际调用了<code>ConnectivityService</code>的接口, 这里看下<code>startTethering</code>这个接口的实现: 首先判断下是否支持热点共享, 然后调用<code>mTethering.startTethering</code>发起热点共享.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startTethering</span><span class="params">(<span class="type">int</span> type, ResultReceiver receiver, <span class="type">boolean</span> showProvisioningUi,</span></span><br><span class="line"><span class="params">        String callerPkg)</span> &#123;</span><br><span class="line">    ConnectivityManager.enforceTetherChangePermission(mContext, callerPkg);</span><br><span class="line">    <span class="keyword">if</span> (!isTetheringSupported()) &#123;</span><br><span class="line">        receiver.send(ConnectivityManager.TETHER_ERROR_UNSUPPORTED, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mTethering.startTethering(type, receiver, showProvisioningUi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个<code>mTethering</code>实际是在系统初始化<code>ConnectivityService</code>的时候创建的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">       mTethering = makeTethering();</span><br><span class="line">       ....</span><br><span class="line"><span class="keyword">protected</span> Tethering <span class="title function_">makeTethering</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Move other elements into @Overridden getters.</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">TetheringDependencies</span> <span class="variable">deps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TetheringDependencies</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTetheringSupported</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ConnectivityService.<span class="built_in">this</span>.isTetheringSupported();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> NetworkRequest <span class="title function_">getDefaultNetworkRequest</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mDefaultRequest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tethering</span>(mContext, mNMS, mStatsService, mPolicyManager,</span><br><span class="line">IoThread.get().getLooper(), <span class="keyword">new</span> <span class="title class_">MockableSystemProperties</span>(),</span><br><span class="line">deps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看<code>Tethering.java</code>(代码位于<code>/frameworks/base/services/core/java/com/android/server</code>)的代码实现, 可以知道这部分主要起中介的作用: </p><ul><li>首先要根据热点共享的类型创建对应的网络, 比如通过WIFI共享的话需要先打开WIFI热点</li><li>其次是要监听需要共享的网络连接(比如4G网络&#x2F;以太网连接等), 将两个网络进行数据的转发配置</li></ul><p><code>startTethering</code>实际最后调用了一个内部实现<code>enableTetheringInternal</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enableTetheringInternal</span><span class="params">(<span class="type">int</span> type, <span class="type">boolean</span> enable, ResultReceiver receiver)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> TETHERING_WIFI:</span><br><span class="line">            result = setWifiTethering(enable);</span><br><span class="line">            sendTetherResult(receiver, result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TETHERING_USB:</span><br><span class="line">            result = setUsbTethering(enable);</span><br><span class="line">            sendTetherResult(receiver, result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TETHERING_BLUETOOTH:</span><br><span class="line">            setBluetoothTethering(enable, receiver);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TETHERING_P2P:</span><br><span class="line">            result = setP2pTethering(enable);</span><br><span class="line">            sendTetherResult(receiver, result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;Invalid tether type.&quot;</span>);</span><br><span class="line">            sendTetherResult(receiver, TETHER_ERROR_UNKNOWN_IFACE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里会根据热点类型来创建对应的网络, 对于WIFI热点会调用<code>setWifiTethering</code>来开启WIFI热点:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">setWifiTethering</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> enable)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPublicSync) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">WifiManager</span> <span class="variable">mgr</span> <span class="operator">=</span> getWifiManager();</span><br><span class="line">            <span class="keyword">if</span> (mgr == <span class="literal">null</span>) &#123;</span><br><span class="line">                mLog.e(<span class="string">&quot;setWifiTethering: failed to get WifiManager!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> TETHER_ERROR_SERVICE_UNAVAIL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((enable &amp;&amp; mgr.startSoftAp(<span class="literal">null</span> <span class="comment">/* use existing wifi config */</span>)) ||</span><br><span class="line">                (!enable &amp;&amp; mgr.stopSoftAp())) &#123;</span><br><span class="line">                mWifiTetherRequested = enable;</span><br><span class="line">                <span class="keyword">return</span> TETHER_ERROR_NO_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(ident);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TETHER_ERROR_MASTER_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里, 就完成了第一步, 把WIFI热点开起来了. 再来看下WIFI热点的创建流程. 这个才是整个流程的关键步骤.</p><h2 id="创建WIFI热点"><a href="#创建WIFI热点" class="headerlink" title="创建WIFI热点"></a><strong>创建WIFI热点</strong></h2><p>为了更清晰的看到WIFI AP的流程, 这里分为两个部分来阐述具体的代码: </p><ul><li>Java Framework的逻辑</li><li>Native的代码逻辑</li></ul><h3 id="创建WIFI热点-Framework流程"><a href="#创建WIFI热点-Framework流程" class="headerlink" title="创建WIFI热点-Framework流程"></a><em><strong>创建WIFI热点-Framework流程</strong></em></h3><p><code>WifiManager</code>(代码位于<code>/framework/base/wifi</code>)的<code>startSoftAp</code>实际就是调用了<code>WifiService</code>的接口而已, 我们直接看下<code>WifiService</code>的实现逻辑<code>WifiServiceImpl</code>(<code>/framework/opt/net/wifi</code>):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startSoftAp</span><span class="params">(WifiConfiguration wifiConfig)</span> &#123;</span><br><span class="line">    <span class="comment">// NETWORK_STACK is a signature only permission.</span></span><br><span class="line">    enforceNetworkStackPermission();</span><br><span class="line">    <span class="comment">// If we&#x27;re in crypt debounce, ignore any wifi state change APIs.</span></span><br><span class="line">    <span class="keyword">if</span> (mFrameworkFacade.inStorageManagerCryptKeeperBounce()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLog.info(<span class="string">&quot;startSoftAp uid=%&quot;</span>).c(Binder.getCallingUid()).flush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLocalOnlyHotspotRequests) &#123;</span><br><span class="line">        <span class="comment">// If a tethering request comes in while we have an existing tethering session, return</span></span><br><span class="line">        <span class="comment">// error.</span></span><br><span class="line">        <span class="keyword">if</span> (mIfaceIpModes.contains(WifiManager.IFACE_IP_MODE_TETHERED)) &#123;</span><br><span class="line">            mLog.err(<span class="string">&quot;Tethering is already active.&quot;</span>).flush();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If a tethering request comes in while we have LOHS running (or requested), call stop</span></span><br><span class="line">        <span class="comment">// for softap mode and restart softap with the tethering config.</span></span><br><span class="line">        <span class="keyword">if</span> (!isConcurrentLohsAndTetheringSupported() &amp;&amp; !mLocalOnlyHotspotRequests.isEmpty()) &#123;</span><br><span class="line">            stopSoftApInternal(WifiManager.IFACE_IP_MODE_LOCAL_ONLY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> startSoftApInternal(wifiConfig, WifiManager.IFACE_IP_MODE_TETHERED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个函数首先会判断是否有本地热点(Local Only Hotspot, 就是无法使用网络连接的热点, 只用于两个设备之间通讯), 如果有的话, 就开启一个非共享的热点, 否则开启一个有共享的热点. 这里只看下有共享的流程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">startSoftApInternal</span><span class="params">(WifiConfiguration wifiConfig, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">    mLog.trace(<span class="string">&quot;startSoftApInternal uid=% mode=%&quot;</span>)</span><br><span class="line">            .c(Binder.getCallingUid()).c(mode).flush();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// null wifiConfig is a meaningful input for CMD_SET_AP</span></span><br><span class="line">    <span class="keyword">if</span> (wifiConfig == <span class="literal">null</span> || WifiApConfigStore.validateApWifiConfiguration(wifiConfig)) &#123;</span><br><span class="line">        <span class="type">SoftApModeConfiguration</span> <span class="variable">softApConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftApModeConfiguration</span>(mode, wifiConfig);</span><br><span class="line">        mWifiController.sendMessage(CMD_SET_AP, <span class="number">1</span>, <span class="number">0</span>, softApConfig);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Slog.e(TAG, <span class="string">&quot;Invalid WifiConfiguration&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于Wifi Framework的代码涉及到STA&#x2F;AP两个模式, 有不少的状态机代码；在查看具体代码流程之前, 先抛出一个具体的代码流程方便跟踪:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">WifiServiceImpl --&gt; WifiController --&gt; ActiveModeWarden --&gt; SoftApManager --&gt; WifiNative --&gt; HostapdHal</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>WifiController</code>是一个用于管控Wifi内部状态的状态机, 其有如下几个状态:</p><ul><li>默认状态<code>DefaultState</code>:  其他状态的父状态</li><li>STA开启状态<code>StaEnabledState</code>: Wifi打开, 处于STA模式, 这个时候会进行热点扫描</li><li>STA关闭状态<code>StaDisabledState</code>: Wifi关闭, STA模式关闭, 无法进行扫描</li><li>STA关闭可扫描状态<code>StaDisabledWithScanState</code>: STA模式关闭, 但WIFI会进入扫描模式</li><li>ECM状态<code>EcmState</code>: 紧急呼叫状态(如手机终端正在进行紧急呼叫等)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">DefaultState</span> <span class="variable">mDefaultState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultState</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">StaEnabledState</span> <span class="variable">mStaEnabledState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaEnabledState</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">StaDisabledState</span> <span class="variable">mStaDisabledState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaDisabledState</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">StaDisabledWithScanState</span> <span class="variable">mStaDisabledWithScanState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaDisabledWithScanState</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">EcmState</span> <span class="variable">mEcmState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EcmState</span>();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一般来说, WifiService启动时的初始状态为<code>StaDisabledState</code>, 如果默认WIFI是开的, 则会进入<code>StaEnabledState</code>状态, 这里假定系统初始状态为<code>StaDisabledState</code>. 从上面的流程可以看到, WifiService实际向<code>WifiController</code>发送了一个消息:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mWifiController.sendMessage(CMD_SET_AP, <span class="number">1</span>, <span class="number">0</span>, softApConfig);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时, <code>StaDisabledState</code>状态机会把消息丢给<code>DefaultState</code>处理(返回了<code>NOT_HANDLED</code>):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaDisabledState</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mDeferredEnableSerialNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mHaveDeferredEnable</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mDisabledTimestamp;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enter</span><span class="params">()</span> &#123;</span><br><span class="line">        mActiveModeWarden.disableWifi();</span><br><span class="line">        <span class="comment">// Supplicant can&#x27;t restart right away, so note the time we switched off</span></span><br><span class="line">        mDisabledTimestamp = SystemClock.elapsedRealtime();</span><br><span class="line">        mDeferredEnableSerialNumber++;</span><br><span class="line">        mHaveDeferredEnable = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> CMD_WIFI_TOGGLED:</span><br><span class="line">                <span class="keyword">if</span> (mSettingsStore.isWifiToggleEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (doDeferEnable(msg)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mHaveDeferredEnable) &#123;</span><br><span class="line">                            <span class="comment">//  have 2 toggles now, inc serial number and ignore both</span></span><br><span class="line">                            mDeferredEnableSerialNumber++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        mHaveDeferredEnable = !mHaveDeferredEnable;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    transitionTo(mStaEnabledState);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkScanOnlyModeAvailable()) &#123;</span><br><span class="line">                    <span class="comment">// only go to scan mode if we aren&#x27;t in airplane mode</span></span><br><span class="line">                    <span class="keyword">if</span> (mSettingsStore.isAirplaneModeOn()) &#123;</span><br><span class="line">                        transitionTo(mStaDisabledWithScanState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                ....</span><br><span class="line">            <span class="keyword">case</span> CMD_SET_AP:</span><br><span class="line">                <span class="keyword">if</span> (msg.arg1 == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// remember that we were disabled, but pass the command up to start softap</span></span><br><span class="line">                    mSettingsStore.setWifiSavedState(WifiSettingsStore.WIFI_DISABLED);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> NOT_HANDLED;</span><br><span class="line">                ....</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> NOT_HANDLED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>DefaultState</code>状态收到<code>CMD_SET_AP</code>的消息后会尝试调用<code>ActiveModeWarden.enterSoftAPMode</code>开启AP:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultState</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">case</span> CMD_SET_AP:</span><br><span class="line">                <span class="comment">// note: CMD_SET_AP is handled/dropped in ECM mode - will not start here</span></span><br><span class="line">                <span class="keyword">if</span> (msg.arg1 == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="type">SoftApModeConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> (SoftApModeConfiguration) msg.obj;</span><br><span class="line">                    mActiveModeWarden.enterSoftAPMode((SoftApModeConfiguration) msg.obj);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mActiveModeWarden.stopSoftAPMode(msg.arg2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CMD_AIRPLANE_TOGGLED:</span><br><span class="line">                <span class="keyword">if</span> (mSettingsStore.isAirplaneModeOn()) &#123;</span><br><span class="line">                    log(<span class="string">&quot;Airplane mode toggled, shutdown all modes&quot;</span>);</span><br><span class="line">                    mActiveModeWarden.shutdownWifi();</span><br><span class="line">                    transitionTo(mStaDisabledState);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;Airplane mode disabled, determine next state&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (mSettingsStore.isWifiToggleEnabled()) &#123;</span><br><span class="line">                        transitionTo(mStaEnabledState);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkScanOnlyModeAvailable()) &#123;</span><br><span class="line">                        transitionTo(mStaDisabledWithScanState);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// wifi should remain disabled, do not need to transition</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CMD_EMERGENCY_CALL_STATE_CHANGED:</span><br><span class="line">            <span class="keyword">case</span> CMD_EMERGENCY_MODE_CHANGED:</span><br><span class="line">                <span class="keyword">if</span> (msg.arg1 == <span class="number">1</span>) &#123;</span><br><span class="line">                    transitionTo(mEcmState);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CMD_AP_STOPPED:</span><br><span class="line">                log(<span class="string">&quot;SoftAp mode disabled, determine next state&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (mSettingsStore.isWifiToggleEnabled()) &#123;</span><br><span class="line">                    transitionTo(mStaEnabledState);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkScanOnlyModeAvailable()) &#123;</span><br><span class="line">                    transitionTo(mStaDisabledWithScanState);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// wifi should remain disabled, do not need to transition</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;WifiController.handleMessage &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ActiveModeWarden</code>这个类的主要作用是负责WIFI不同操作模式的切换, 比如从STA模式切换到扫描模式, 从AP切换到STA等等:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterSoftAPMode</span><span class="params">(<span class="meta">@NonNull</span> SoftApModeConfiguration wifiConfig)</span> &#123;</span><br><span class="line">    mHandler.post(() -&gt; &#123;</span><br><span class="line">        startSoftAp(wifiConfig);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startSoftAp</span><span class="params">(SoftApModeConfiguration softapConfig)</span> &#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;Starting SoftApModeManager&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">WifiConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> softapConfig.getWifiConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (config != <span class="literal">null</span> &amp;&amp; config.SSID != <span class="literal">null</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Passing config to SoftApManager! &quot;</span> + config);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        config = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">SoftApCallbackImpl</span> <span class="variable">callback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftApCallbackImpl</span>(softapConfig.getTargetMode());</span><br><span class="line">    <span class="type">ActiveModeManager</span> <span class="variable">manager</span> <span class="operator">=</span> mWifiInjector.makeSoftApManager(callback, softapConfig);</span><br><span class="line">    callback.setActiveModeManager(manager);</span><br><span class="line">    manager.start();</span><br><span class="line">    mActiveModeManagers.add(manager);</span><br><span class="line">    updateBatteryStatsWifiState(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>makeSoftApManager</code>实际构造了一个<code>SoftApManager</code>对象实例, 然后调用<code>start</code>启动AP的创建. 这里<code>mStateMachine</code>是<code>SoftApManager</code>内部的一个状态机<code>SoftApStateMachine</code>, 其有两个状态: <code>IdleState</code>&#x2F;<code>StartedState</code>, 其初始状态为<code>Idle</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Start soft AP with the supplied config.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">       mStateMachine.sendMessage(SoftApStateMachine.CMD_START, mApConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部状态机</span></span><br><span class="line">SoftApStateMachine(Looper looper) &#123;</span><br><span class="line">    <span class="built_in">super</span>(TAG, looper);</span><br><span class="line"></span><br><span class="line">    addState(mIdleState);</span><br><span class="line">    addState(mStartedState);</span><br><span class="line"></span><br><span class="line">    setInitialState(mIdleState);</span><br><span class="line">    start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>IdleState</code>在收到<code>CMD_START</code>的消息后,  主要做了如下几件事情:</p><ul><li>首先通过<code>WifiNative</code>创建一个AP的网口</li><li>调用<code>startSoftAp</code>执行AP的开启: 比如设置WIFI的国家码(不同地区有不同的5G频段)</li><li>进入<code>StartedState</code>状态, 等待AP开启</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">IdleState</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enter</span><span class="params">()</span> &#123;</span><br><span class="line">        mApInterfaceName = <span class="literal">null</span>;</span><br><span class="line">        mIfaceIsUp = <span class="literal">false</span>;</span><br><span class="line">        mIfaceIsDestroyed = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processMessage</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> CMD_START:</span><br><span class="line">            ....</span><br><span class="line">                mApInterfaceName = mWifiNative.setupInterfaceForSoftApMode(</span><br><span class="line">                        mWifiNativeInterfaceCallback);</span><br><span class="line">                <span class="keyword">if</span> (TextUtils.isEmpty(mApInterfaceName)) &#123;</span><br><span class="line">                    Log.e(TAG, <span class="string">&quot;setup failure when creating ap interface.&quot;</span>);</span><br><span class="line">                    updateApState(WifiManager.WIFI_AP_STATE_FAILED,</span><br><span class="line">                            WifiManager.WIFI_AP_STATE_DISABLED,</span><br><span class="line">                            WifiManager.SAP_START_FAILURE_GENERAL);</span><br><span class="line">                    mWifiMetrics.incrementSoftApStartResult(</span><br><span class="line">                            <span class="literal">false</span>, WifiManager.SAP_START_FAILURE_GENERAL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                updateApState(WifiManager.WIFI_AP_STATE_ENABLING,</span><br><span class="line">                        WifiManager.WIFI_AP_STATE_DISABLED, <span class="number">0</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> startSoftAp((WifiConfiguration) message.obj);</span><br><span class="line">                <span class="keyword">if</span> (result != SUCCESS) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">failureReason</span> <span class="operator">=</span> WifiManager.SAP_START_FAILURE_GENERAL;</span><br><span class="line">                    <span class="keyword">if</span> (result == ERROR_NO_CHANNEL) &#123;</span><br><span class="line">                        failureReason = WifiManager.SAP_START_FAILURE_NO_CHANNEL;</span><br><span class="line">                    &#125;</span><br><span class="line">                    updateApState(WifiManager.WIFI_AP_STATE_FAILED,</span><br><span class="line">                                  WifiManager.WIFI_AP_STATE_ENABLING,</span><br><span class="line">                                  failureReason);</span><br><span class="line">                    stopSoftAp();</span><br><span class="line">                    mWifiMetrics.incrementSoftApStartResult(<span class="literal">false</span>, failureReason);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                transitionTo(mStartedState);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// Ignore all other commands.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此, 最后AP的创建都是通过WifiNative调用Native的接口来实现热点的创建:</p><ul><li>首先是通过<code>WifiNative.setupInterfaceForSoftApMode</code>创建AP网口, 并启动<code>hostapd</code></li><li>然后通过<code>WifiNative.startSoftAp</code>启动AP, 准备接受来自客户端的连接请求</li></ul><p>接下来就看看这两个流程对应的Native代码.</p><h3 id="创建WIFI热点-Native流程"><a href="#创建WIFI热点-Native流程" class="headerlink" title="创建WIFI热点-Native流程"></a><em><strong>创建WIFI热点-Native流程</strong></em></h3><p>WIFI热点的创建在Native层主要依赖两个服务来完成:</p><ul><li><code>WifiCond</code>: 负责创建AP的网口<code>wlan0</code>, 并获取当前的热点数量等信息</li><li><code>Hostapd</code>: 负责热点连接的管理以及身份验证等</li></ul><p>接着上面的流程,  <code>WifiNative.setupInterfaceForSoftApMode</code>这个方法的首先会尝试启动<code>Hostapd</code>守护进程, 接着调用<code>WifiCondControl.setupInterfaceForSoftApMode</code>来创建一个AP接口.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">setupInterfaceForSoftApMode</span><span class="params">(<span class="meta">@NonNull</span> InterfaceCallback interfaceCallback)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!startHal()) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Failed to start Hal&quot;</span>);</span><br><span class="line">            mWifiMetrics.incrementNumSetupSoftApInterfaceFailureDueToHal();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!startHostapd()) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Failed to start hostapd&quot;</span>);</span><br><span class="line">            mWifiMetrics.incrementNumSetupSoftApInterfaceFailureDueToHostapd();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Iface</span> <span class="variable">iface</span> <span class="operator">=</span> mIfaceMgr.allocateIface(Iface.IFACE_TYPE_AP);</span><br><span class="line">        <span class="keyword">if</span> (iface == <span class="literal">null</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Failed to allocate new AP iface&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iface.externalListener = interfaceCallback;</span><br><span class="line">        iface.name = createApIface(iface);</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(iface.name)) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Failed to create AP iface in vendor HAL&quot;</span>);</span><br><span class="line">            mIfaceMgr.removeIface(iface.id);</span><br><span class="line">            mWifiMetrics.incrementNumSetupSoftApInterfaceFailureDueToHal();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用HAL接口创建AP网口</span></span><br><span class="line">        <span class="keyword">if</span> (mWificondControl.setupInterfaceForSoftApMode(iface.name) == <span class="literal">null</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Failed to setup iface in wificond on &quot;</span> + iface);</span><br><span class="line">            teardownInterface(iface.name);</span><br><span class="line">            mWifiMetrics.incrementNumSetupSoftApInterfaceFailureDueToWificond();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iface.networkObserver = <span class="keyword">new</span> <span class="title class_">NetworkObserverInternal</span>(iface.id);</span><br><span class="line">        <span class="keyword">if</span> (!registerNetworkObserver(iface.networkObserver)) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Failed to register network observer on &quot;</span> + iface);</span><br><span class="line">            teardownInterface(iface.name);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Just to avoid any race conditions with interface state change callbacks,</span></span><br><span class="line">        <span class="comment">// update the interface state before we exit.</span></span><br><span class="line">        onInterfaceStateChanged(iface, isInterfaceUp(iface.name));</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;Successfully setup &quot;</span> + iface);</span><br><span class="line"></span><br><span class="line">        iface.featureSet = getSupportedFeatureSetInternal(iface.name);</span><br><span class="line">        <span class="keyword">return</span> iface.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里, 实际就是调用<code>IWifiCond</code>这个HAL接口来创建AP的网口. <code>WifiCond</code>这个服务在系统启动的时候加载的. 我们不妨直接跳到<code>/system/connectivity/wificond</code>来看下WifiCond服务的实现逻辑.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// WifiCondControl</span></span><br><span class="line"><span class="keyword">public</span> IApInterface <span class="title function_">setupInterfaceForSoftApMode</span><span class="params">(<span class="meta">@NonNull</span> String ifaceName)</span> &#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;Setting up interface for soft ap mode&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!retrieveWificondAndRegisterForDeath()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">IApInterface</span> <span class="variable">apInterface</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        apInterface = mWificond.createApInterface(ifaceName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e1) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Failed to get IApInterface due to remote exception&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    Binder.allowBlocking(apInterface.asBinder());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Refresh Handlers</span></span><br><span class="line">    mApInterfaces.put(ifaceName, apInterface);</span><br><span class="line">    <span class="keyword">return</span> apInterface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>IWifiCond</code>的实现都在<code>Server.cpp</code>中, <code>createApInterface</code>这个函数实际创建一个接口, 并返回<code>IApInterface</code>的远程调用接口给到上层使用.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Server.cpp</span></span><br><span class="line"><span class="function">Status <span class="title">Server::createApInterface</span><span class="params">(<span class="type">const</span> std::string&amp; iface_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                         sp&lt;IApInterface&gt;* created_interface)</span> </span>&#123;</span><br><span class="line">  InterfaceInfo interface;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">SetupInterface</span>(iface_name, &amp;interface)) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">ok</span>();  <span class="comment">// Logging was done internally</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">unique_ptr&lt;ApInterfaceImpl&gt; <span class="title">ap_interface</span><span class="params">(<span class="keyword">new</span> ApInterfaceImpl(</span></span></span><br><span class="line"><span class="params"><span class="function">      interface.name,</span></span></span><br><span class="line"><span class="params"><span class="function">      interface.index,</span></span></span><br><span class="line"><span class="params"><span class="function">      interface.is_bridge,</span></span></span><br><span class="line"><span class="params"><span class="function">      netlink_utils_,</span></span></span><br><span class="line"><span class="params"><span class="function">      if_tool_.get()))</span></span>;</span><br><span class="line">  *created_interface = ap_interface-&gt;<span class="built_in">GetBinder</span>();</span><br><span class="line">  <span class="built_in">BroadcastApInterfaceReady</span>(ap_interface-&gt;<span class="built_in">GetBinder</span>());</span><br><span class="line">  ap_interfaces_[iface_name] = std::<span class="built_in">move</span>(ap_interface);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">ok</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里, 热点的创建算是完成了第一步. 等到<code>WifiCond</code>创建完成之后, <code>wlanx</code>的网口UP之后, 会将状态回调给<code>SoftApManager</code>, 在这里会发送一个热点已经开启成功的广播, <code>Tethering</code>服务收到该广播之后, 就会为该网口分配IP, 并启动DHCP相关的进程, 这样就可以愉快的接受来自客户端的连接请求了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// SoftApManager</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onUpChanged</span><span class="params">(<span class="type">boolean</span> isUp)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUp == mIfaceIsUp) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// no change</span></span><br><span class="line">    &#125;</span><br><span class="line">    mIfaceIsUp = isUp;</span><br><span class="line">    <span class="keyword">if</span> (isUp) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;SoftAp is ready for use&quot;</span>);</span><br><span class="line">        updateApState(WifiManager.WIFI_AP_STATE_ENABLED,</span><br><span class="line">                WifiManager.WIFI_AP_STATE_ENABLING, <span class="number">0</span>);</span><br><span class="line">        mWifiMetrics.incrementSoftApStartResult(<span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            mCallback.onNumClientsChanged(mNumAssociatedStations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// the interface was up, but goes down</span></span><br><span class="line">        sendMessage(CMD_INTERFACE_DOWN);</span><br><span class="line">    &#125;</span><br><span class="line">    mWifiMetrics.addSoftApUpChangedEvent(isUp, mMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateApState</span><span class="params">(<span class="type">int</span> newState, <span class="type">int</span> currentState, <span class="type">int</span> reason)</span> &#123;</span><br><span class="line">    mCallback.onStateChanged(newState, reason);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//send the AP state change broadcast</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(WifiManager.WIFI_AP_STATE_CHANGED_ACTION);</span><br><span class="line">    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);</span><br><span class="line">    intent.putExtra(WifiManager.EXTRA_WIFI_AP_STATE, newState);</span><br><span class="line">    intent.putExtra(WifiManager.EXTRA_PREVIOUS_WIFI_AP_STATE, currentState);</span><br><span class="line">    <span class="keyword">if</span> (newState == WifiManager.WIFI_AP_STATE_FAILED) &#123;</span><br><span class="line">        <span class="comment">//only set reason number when softAP start failed</span></span><br><span class="line">        intent.putExtra(WifiManager.EXTRA_WIFI_AP_FAILURE_REASON, reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    intent.putExtra(WifiManager.EXTRA_WIFI_AP_INTERFACE_NAME, mApInterfaceName);</span><br><span class="line">    intent.putExtra(WifiManager.EXTRA_WIFI_AP_MODE, mMode);</span><br><span class="line">    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="网络配置与DHCP服务的启动"><a href="#网络配置与DHCP服务的启动" class="headerlink" title="网络配置与DHCP服务的启动"></a><strong>网络配置与DHCP服务的启动</strong></h2><p>上面说到, WIFI热点的网口UP之后, 会发送一个<code>WIFI_AP_STATE_CHANGED_ACTION</code>的广播, 而<code>Tethering</code>服务在启动的时候就监听了该广播:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">StateReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context content, Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (action.equals(UsbManager.ACTION_USB_STATE)) &#123;</span><br><span class="line">            handleUsbAction(intent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(CONNECTIVITY_ACTION)) &#123;</span><br><span class="line">            handleConnectivityAction(intent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(WifiManager.WIFI_AP_STATE_CHANGED_ACTION)) &#123;</span><br><span class="line">            handleWifiApAction(intent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)) &#123;</span><br><span class="line">            handleWifiP2pAction(intent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) &#123;</span><br><span class="line">            mLog.log(<span class="string">&quot;OBSERVED configuration changed&quot;</span>);</span><br><span class="line">            updateConfiguration();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里对应就会调用<code>handleWifiApAction</code>: 根据AP的状态来执行对应的动作.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleWifiApAction</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">curState</span> <span class="operator">=</span> intent.getIntExtra(EXTRA_WIFI_AP_STATE, WIFI_AP_STATE_DISABLED);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ifname</span> <span class="operator">=</span> intent.getStringExtra(EXTRA_WIFI_AP_INTERFACE_NAME);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ipmode</span> <span class="operator">=</span> intent.getIntExtra(EXTRA_WIFI_AP_MODE, IFACE_IP_MODE_UNSPECIFIED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (Tethering.<span class="built_in">this</span>.mPublicSync) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (curState) &#123;</span><br><span class="line">            <span class="keyword">case</span> WifiManager.WIFI_AP_STATE_ENABLING:</span><br><span class="line">                <span class="comment">// We can see this state on the way to both enabled and failure states.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WifiManager.WIFI_AP_STATE_ENABLED:</span><br><span class="line">                enableWifiIpServingLocked(ifname, ipmode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WifiManager.WIFI_AP_STATE_DISABLED:</span><br><span class="line">            <span class="keyword">case</span> WifiManager.WIFI_AP_STATE_DISABLING:</span><br><span class="line">            <span class="keyword">case</span> WifiManager.WIFI_AP_STATE_FAILED:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                disableWifiIpServingLocked(ifname, curState);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据热点开启模式(共享还是本地)开启IP配置流程:</p><ul><li><code>maybeTrackNewInterfaceLocked</code>: 开启一个<code>IpServer</code>的状态机用于配置热点IP以及启动DHCP服务</li><li><code>changeInterfaceState</code>:  让<code>IpServer</code>进入热点共享状态, 等待客户端请求以及上游网络连接(比如4G)</li></ul><p>到这里, 我们大致可以看到, 热点共享功能还需要如下3个步骤才能最终完成:</p><ul><li>配置<code>wlanx</code>网口IP地址</li><li>启动DHCP服务</li><li>如果发现当前系统有可用的网络连接, 则将热点的数据口<code>wlanx</code>转发到对应的网口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enableWifiIpServingLocked</span><span class="params">(String ifname, <span class="type">int</span> wifiIpMode)</span> &#123;</span><br><span class="line">    <span class="comment">// Map wifiIpMode values to IpServer.Callback serving states, inferring</span></span><br><span class="line">    <span class="comment">// from mWifiTetherRequested as a final &quot;best guess&quot;.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> ipServingMode;</span><br><span class="line">    <span class="keyword">switch</span> (wifiIpMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> IFACE_IP_MODE_TETHERED:</span><br><span class="line">            ipServingMode = IpServer.STATE_TETHERED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IFACE_IP_MODE_LOCAL_ONLY:</span><br><span class="line">            ipServingMode = IpServer.STATE_LOCAL_ONLY;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            mLog.e(<span class="string">&quot;Cannot enable IP serving in unknown WiFi mode: &quot;</span> + wifiIpMode);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(ifname)) &#123;</span><br><span class="line">        maybeTrackNewInterfaceLocked(ifname, TETHERING_WIFI);</span><br><span class="line">        changeInterfaceState(ifname, ipServingMode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLog.e(String.format(</span><br><span class="line">               <span class="string">&quot;Cannot enable IP serving in mode %s on missing interface name&quot;</span>,</span><br><span class="line">               ipServingMode));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上<code>IpServer</code>就是一个状态机, 其有<code>InitialState</code>&#x2F;<code>LocalHotspotState</code>&#x2F;<code>TetheredState</code>&#x2F;<code>UnavailableState</code>这么四个状态, 其初始状态为<code>InitialState</code>; 在状态机收到消息<code>CMD_TETHER_REQUESTED</code>后, 就会进入<code>TetheredState</code>状态.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">maybeTrackNewInterfaceLocked</span><span class="params">(<span class="keyword">final</span> String iface, <span class="type">int</span> interfaceType)</span> &#123;</span><br><span class="line">    <span class="comment">// If we have already started a TISM for this interface, skip.</span></span><br><span class="line">    <span class="keyword">if</span> (mTetherStates.containsKey(iface)) &#123;</span><br><span class="line">        mLog.log(<span class="string">&quot;active iface (&quot;</span> + iface + <span class="string">&quot;) reported as added, ignoring&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLog.log(<span class="string">&quot;adding TetheringInterfaceStateMachine for: &quot;</span> + iface);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">TetherState</span> <span class="variable">tetherState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TetherState</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">IpServer</span>(iface, mLooper, interfaceType, mLog, mNMService, mStatsService,</span><br><span class="line">                         makeControlCallback(), mConfig.enableLegacyDhcpServer,</span><br><span class="line">                         mDeps.getIpServerDependencies()));</span><br><span class="line">    mTetherStates.put(iface, tetherState);</span><br><span class="line">    tetherState.ipServer.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>IpServer</code>在进入<code>TetheredState</code>之后主要是配置IP&#x2F;路由以及启动DHCP；需要说明的是, Android Q实际使用了两套DHCP逻辑,一个是通过<code>dnsmasq</code>来实现(LegacyDhcpServer); 一个是通过一个Java进程来实现. 目前默认使用的是通过Java进程(<code>/packages/modules/networkstack</code>)来实现的. 有兴趣的可以自行看下具体的代码实现.</p><p><code>IpServer</code>中的<code>TetheredState</code>继承了<code>BaseServingState</code>, 因此实际进入<code>TetheredState</code>时就会做如下几个事情:</p><ul><li><code>startIPv4</code>: 配置网口IP地址, 启动DHCP服务</li><li><code>mNMService.tetherInterface</code>: 添加路由信息</li><li><code>startIPv6</code>: 启动IPv6路由广播(Route Advertisement)守护进程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseServingState</span> <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!startIPv4()) &#123;</span><br><span class="line">            mLastError = ConnectivityManager.TETHER_ERROR_IFACE_CFG_ERROR;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mNMService.tetherInterface(mIfaceName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            mLog.e(<span class="string">&quot;Error Tethering: &quot;</span> + e);</span><br><span class="line">            mLastError = ConnectivityManager.TETHER_ERROR_TETHER_IFACE_ERROR;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!startIPv6()) &#123;</span><br><span class="line">            mLog.e(<span class="string">&quot;Failed to startIPv6&quot;</span>);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Make this a fatal error once Bluetooth IPv6 is sorted.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里, 热点共享功能也算启动完成了, 对于非本地功能的热点, 还需要完成最后一件事情: 监听系统当前默认网络连接(具备上网功能), 然后热点网口数据转发到默认数据网口, 这样连接过来的热点就可以访问外网了. 这里只是来看下<code>IpServer</code>在收到默认网络可用时的处理流程, 具体是如何监听系统当前的网络状态, 可以参考<code>Tethering.java/UpStreamNetworkMonitor.java</code>这两个文件中代码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">TetheredState</span> <span class="keyword">extends</span> <span class="title class_">BaseServingState</span> &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enter</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="built_in">super</span>.enter();</span><br><span class="line">           <span class="keyword">if</span> (mLastError != ConnectivityManager.TETHER_ERROR_NO_ERROR) &#123;</span><br><span class="line">               transitionTo(mInitialState);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (DBG) Log.d(TAG, <span class="string">&quot;Tethered &quot;</span> + mIfaceName);</span><br><span class="line">           sendInterfaceState(STATE_TETHERED);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processMessage</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">super</span>.processMessage(message)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">           logMessage(<span class="built_in">this</span>, message.what);</span><br><span class="line">           <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">               <span class="keyword">case</span> CMD_TETHER_REQUESTED:</span><br><span class="line">                   mLog.e(<span class="string">&quot;CMD_TETHER_REQUESTED while already tethering.&quot;</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 上游网络连接可用</span></span><br><span class="line">               <span class="keyword">case</span> CMD_TETHER_CONNECTION_CHANGED:</span><br><span class="line">                   <span class="keyword">final</span> <span class="type">InterfaceSet</span> <span class="variable">newUpstreamIfaceSet</span> <span class="operator">=</span> (InterfaceSet) message.obj;</span><br><span class="line">                   <span class="keyword">if</span> (noChangeInUpstreamIfaceSet(newUpstreamIfaceSet)) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (VDBG) Log.d(TAG, <span class="string">&quot;Connection changed noop - dropping&quot;</span>);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (newUpstreamIfaceSet == <span class="literal">null</span>) &#123;</span><br><span class="line">                       cleanupUpstream();</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span> (String removed : upstreamInterfacesRemoved(newUpstreamIfaceSet)) &#123;</span><br><span class="line">                       cleanupUpstreamInterface(removed);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">final</span> Set&lt;String&gt; added = upstreamInterfacesAdd(newUpstreamIfaceSet);</span><br><span class="line">                   <span class="comment">// This makes the call to cleanupUpstream() in the error</span></span><br><span class="line">                   <span class="comment">// path for any interface neatly cleanup all the interfaces.</span></span><br><span class="line">                   mUpstreamIfaceSet = newUpstreamIfaceSet;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span> (String ifname : added) &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           mNMService.enableNat(mIfaceName, ifname);</span><br><span class="line">                           mNMService.startInterfaceForwarding(mIfaceName, ifname);</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                           mLog.e(<span class="string">&quot;Exception enabling NAT: &quot;</span> + e);</span><br><span class="line">                           cleanupUpstream();</span><br><span class="line">                           mLastError = ConnectivityManager.TETHER_ERROR_ENABLE_NAT_ERROR;</span><br><span class="line">                           transitionTo(mInitialState);</span><br><span class="line">                           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       ....</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Android WIFI模块设计的代码量比较大, 涉及到的模块也比较多, 要吃透其中的流程, 首先要建立一个整体的代码框架, 其次要通过某个具体的应用场景一步步梳理, 才能做到阅读代码时心中有数.</p><ul><li><a href="https://wireless.wiki.kernel.org/en/users/documentation">https://wireless.wiki.kernel.org/en/users/documentation</a></li><li><a href="https://source.android.com/devices/tech/connect/wifi-overview">Android Open Source Code Project</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前帮着解决了项目中WIFI相关的问题, 一直想梳理下WIFI的框架, 方便后续代码阅读以及问题的解决. 恰好年初修改了车机上WIFI热点相关的一些代码, 重新看了下Android 10(Q)的逻辑, 于是想通过WIFI热点相关的功能作为切入点, 完整的梳理下Android WIFI的整体框架.&lt;/p&gt;
&lt;p&gt;先不多说, 看下Android WIFI的大致框架:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/android_wifi_fw.png&quot; alt=&quot;android wifi framwork&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://sniffer.site/categories/Android/"/>
    
    
    <category term="Android" scheme="https://sniffer.site/tags/Android/"/>
    
    <category term="Framework" scheme="https://sniffer.site/tags/Framework/"/>
    
    <category term="Wifi" scheme="https://sniffer.site/tags/Wifi/"/>
    
  </entry>
  
</feed>
