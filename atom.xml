<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasonWang&#39;s Blog</title>
  
  <subtitle>本色做人，角色做事</subtitle>
  <link href="https://sniffer.site/atom.xml" rel="self"/>
  
  <link href="https://sniffer.site/"/>
  <updated>2025-01-03T06:41:37.367Z</updated>
  <id>https://sniffer.site/</id>
  
  <author>
    <name>Jason Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>龙年年终总结</title>
    <link href="https://sniffer.site/2024/12/31/%E9%BE%99%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://sniffer.site/2024/12/31/%E9%BE%99%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2024-12-31T09:01:05.000Z</published>
    <updated>2025-01-03T06:41:37.367Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当人类对自己的理性有致命自负的时候，也就走向了奴役之路</p><p>冯-哈耶克    </p></blockquote><p><img src="https://unsplash.com/photos/Y2pzmNYinu0/download?ixid=M3wxMjA3fDB8MXxhbGx8fHx8fHx8fHwxNzM1NzM4MjQzfA&auto=format&fit=crop&w=1920&q=80" alt="new year-2025"></p><span id="more"></span><p>要写年终总结时，才发现24年是龙年，也是我的本命年，一眨眼间研究生毕业都十年了。十年里，从孑然一身到如今上有老、下有小，经历了不少事情，但很多东西好像并没有想的非常清楚，还是停留在一个模糊的阶段，没有一个清晰的思路，比如对于财务的规划，对于如何处理好与亲朋好友的关系，对于生命的终结，都没有深入的想过，完全是凭借自己的内心的初衷与本能在应对，所以真正碰到问题的时候才发现有些捉襟见肘。今年，面对内心的困惑与迷茫，系统的看了一些书籍，也算有点收获，但书看的越多，才恍然发现以前的很多想法其实非常的经不起考验、推敲，存在很多缺漏的地方；简单来说，还是书读的有点少了，无知的地方太多，没有保持足够的好奇心，内心有点封闭，导致很多观念与想法常年没有刷新，停留在初始的阶段，没有真正落到执行层面；以为自己懂了，明白了，实际上还停留在朦胧看不清楚的阶段。</p><p>真正的理解与懂，是知行合一，是把想法与观念转变成为生活、现实中的实践与行为的标准，并以此不断向前探索。立足现在，看向未来，总结几点，算是对未来的期许。</p><h2 id="保持好奇心"><a href="#保持好奇心" class="headerlink" title="保持好奇心"></a><strong>保持好奇心</strong></h2><p>观察5岁的女儿，她的脑袋里总会时不时冒出很多稀奇古怪的想法，表达方式上也跟大人有明显的区别，跟她相比，我的很多想法就显得非常循规蹈矩；我早就习惯了很多身边的事情，习以为常，无论是在思维模式，还是行为方式上都固定可循，难以跳出现有的套路。寻根究底，是因为在长年累月的社会化过程中，大脑里的思维模式（神经网络的物理结构）已经逐渐固定，对很多事物见多了，认知都渐渐固化，加上每日忙着生计、需要保持自己作为某个身份的权威形象，对这些已有的观念都很少去点检，也懒得去质疑与思考了。</p><p>渐渐地，大脑会建立一个明显的认知边界，对于自己不感兴趣的，无法理解的，会产生自然的排斥，不假思索的排斥，就好像人体的免疫系统对外来无法识别细胞的产生自然免疫反应一般，大脑会抗拒<code>认知</code>范围之外的观念与想法。这给人造成一种认知上的安全感，让人觉得非常安逸舒服，但实际上只是给自己的大脑制造了一个坚固的牢笼而已。在这个牢笼之下，面对汹涌的信息输入，我们也只是被动的接收，没法真正的批判吸收。</p><p>怎么办？大脑需要放空，需要把那些固有的观念清空，把自然、不假思索的观念检点一遍，反思，用新的观念挑战自我；遇到跟自己不一样、让人不舒服，有点抗拒的想法，应当想一想，为什么对方会这么想？对自己无法理解的想法或者新鲜观点，保持好奇心，保持开放的心态，想办法追根溯源，系统性的学习思考。如果头脑中的想法少，新鲜的观点少，那就不断地去阅读，看各个行业的牛人是怎么思考、学习的；读一本不懂，没关系，持续下去，继续阅读，不断地输入，大脑中的想法就会被冲刷，那些固有、陈旧的观念会不断刷新，像海水不断冲刷沙滩一样，最后新的观念就会涌现。涌现，这个就是chatGPT在吸收、萃取了大量数据之后出现的能力，人的大脑也可以通过类似、大量有用的输入训练得到重塑。</p><h2 id="健康第一"><a href="#健康第一" class="headerlink" title="健康第一"></a><strong>健康第一</strong></h2><p>前段时间跟前同事聊天，之前的部门领导因为重疾不治，不到半年时间人就去世了，让人慨然而伤感；还记得几年前在公司时，他还十分意气风发，很有干劲，待人也温和有礼。没料到才几年的时间，人就没有了，听说家里还有两个小孩，让人感慨万千，充满着无奈。生老病死，谁都没法逃过，到生命结束后，谁又记得那些过往？就像风一样，消失得无影无踪，悄无声息。但内心里还是希望每一个生命能逃过意外的劫难，在结束时，能绽放的更加精彩、完全。</p><p>IT行业，常年竞争压力大，加班、996都是常态，很多人都因为工作太忙而忽视了健康，没有时间去锻炼身体。长期来看，这无疑杀鸡取卵，让自己的身体面临着巨大的风险；很多公司也完全没有意识到，员工的身体健康对于企业的发展有多重要的价值。说到底，无论是对于个人还是企业，市场竞争都是一个持久的战役，不太可能依靠短期的投入就能赢得胜利。我们需要构建一个可持续的发展路径，而健康的身体是可持续竞争力的基础。</p><p>保持健康，不仅仅是一个口号，更需要我们自爱、自律。坚持锻炼，即使再忙也要花时间运动；定期体检，身体有任何的不适都需要重视，咨询专业医师的意见。</p><h2 id="不要试图改变一个成年人"><a href="#不要试图改变一个成年人" class="headerlink" title="不要试图改变一个成年人"></a><strong>不要试图改变一个成年人</strong></h2><p>今年在新的职位上，负有领导的责任，在跟人沟通上，遇到了一些困难与矛盾。开始，我一直试图去纠正、改变对方的某些观念，证明对方的想法有问题，彼此完全不在同一个立场、角度思考问题，自说自话，互相无法说服对方，结果可想而知，两方都会很累，难以达成一致。我感到很难受，明明对方的想法不靠谱、站不住脚，为什么他还如此坚持了？即便事后证明，对方的观点有问题，是错误的，他依然一副若无其事，淡定坦然的样子。这个让我有点迷惑。但认真想一想，我自身的做法就有问题，我犯了一个很严重的错误，就是试图改变一个人，尤其是成年人。</p><p>曾经听过一个说法，<code>成年人不能被影响、改变，只能被筛选</code>；所以，如果你认为某个人的观点有问题，或者价值观不一致，最好的办法不是去尝试改变或者影响他，而是什么都不要做，只是纯粹的进行表达、陈述事实与观点即可，如果对方具备很好的自我意识，能进行个人观念的反思与点检，那么他自然会理解；相反，如果对方缺乏内省的能力，没法自我观察，没有自我驱动力，你即便让释迦牟尼或者耶稣进行说教，也无法奏效。</p><p>一个缺乏内省与反思能力的成年人，他的思维模式恐怕早就固化，大脑的神经回路已经很难再去调优，外部的驱动力已经很难对他的观念进行刷新，所以不要试图改变他，更不用与其争执、吵闹，淡然一笑，让时间去证明一切即可。</p><p>新年快乐，2025年从心出发。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;当人类对自己的理性有致命自负的时候，也就走向了奴役之路&lt;/p&gt;
&lt;p&gt;冯-哈耶克
    &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://unsplash.com/photos/Y2pzmNYinu0/download?ixid=M3wxMjA3fDB8MXxhbGx8fHx8fHx8fHwxNzM1NzM4MjQzfA&amp;auto=format&amp;fit=crop&amp;w=1920&amp;q=80&quot; alt=&quot;new year-2025&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="https://sniffer.site/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="成长" scheme="https://sniffer.site/tags/%E6%88%90%E9%95%BF/"/>
    
    <category term="探索" scheme="https://sniffer.site/tags/%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Android进程冻结</title>
    <link href="https://sniffer.site/2024/12/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E8%BF%9B%E7%A8%8B%E5%86%BB%E7%BB%93/"/>
    <id>https://sniffer.site/2024/12/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E8%BF%9B%E7%A8%8B%E5%86%BB%E7%BB%93/</id>
    <published>2024-12-24T11:02:29.000Z</published>
    <updated>2024-12-24T12:18:11.891Z</updated>
    
    <content type="html"><![CDATA[<p><code>Google</code>从<code>Android11</code>系统开始支持应用冻结功能，可以将后台长时间未运行的任务暂缓执行，通过将对应的进程迁移到对应的<code>cgroup</code>分组来冻结对应的后台缓存应用，这样可以减少如CPU、内存等资源占用，减少业务在后台的不当行为，尽可能减少功耗。本文将对<code>Android</code>的进程冻结的实现原理、冻结策略进行详细的介绍与阐述，争取把相关的策略与机制都讲述清楚，主要分为以下几个部分 :</p><ul><li><code>Android</code>进程冻结的大致框架：主要介绍进程冻结的总体框架与思路</li><li><code>Android</code>进程冻结的实现原理：介绍<code>Android</code>如何实现进程冻结</li><li><code>Android</code>进程冻结的冻结策略：进程冻结的具体策略</li></ul><span id="more"></span><h2 id="Android进程冻结整体框架"><a href="#Android进程冻结整体框架" class="headerlink" title="Android进程冻结整体框架"></a>Android进程冻结整体框架</h2><p><code>Android</code>中每个应用都有一个<code>oom_adj(out of memory ajustment)</code>值，用来标记应用的优先级状态；在应用创建、前后台切换、广播接收、服务绑定以及进程崩溃等事件（具体可以参考如下调整的原因）时，<a href="https://gityuan.com/2018/05/19/android-process-adj/">会触发<code>oom_adj</code>的变化</a>，<code>oom_adj</code>的变化会导致<code>Android</code>系统执行某些特定的策略，比如调整进程所在的<code>cgroup</code>分组，回收应用或者系统内存，或者执行进程冻结，以减少CPU、内存的占用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># OomAdjuster.java OOM_ADJ调整的原因</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OOM_ADJ_REASON_METHOD</span> <span class="operator">=</span> <span class="string">&quot;updateOomAdj&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OOM_ADJ_REASON_NONE</span> <span class="operator">=</span> OOM_ADJ_REASON_METHOD + <span class="string">&quot;_meh&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OOM_ADJ_REASON_ACTIVITY</span> <span class="operator">=</span> OOM_ADJ_REASON_METHOD + <span class="string">&quot;_activityChange&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OOM_ADJ_REASON_FINISH_RECEIVER</span> <span class="operator">=</span> OOM_ADJ_REASON_METHOD + <span class="string">&quot;_finishReceiver&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OOM_ADJ_REASON_START_RECEIVER</span> <span class="operator">=</span> OOM_ADJ_REASON_METHOD + <span class="string">&quot;_startReceiver&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OOM_ADJ_REASON_BIND_SERVICE</span> <span class="operator">=</span> OOM_ADJ_REASON_METHOD + <span class="string">&quot;_bindService&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OOM_ADJ_REASON_UNBIND_SERVICE</span> <span class="operator">=</span> OOM_ADJ_REASON_METHOD + <span class="string">&quot;_unbindService&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OOM_ADJ_REASON_START_SERVICE</span> <span class="operator">=</span> OOM_ADJ_REASON_METHOD + <span class="string">&quot;_startService&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OOM_ADJ_REASON_GET_PROVIDER</span> <span class="operator">=</span> OOM_ADJ_REASON_METHOD + <span class="string">&quot;_getProvider&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OOM_ADJ_REASON_REMOVE_PROVIDER</span> <span class="operator">=</span> OOM_ADJ_REASON_METHOD + <span class="string">&quot;_removeProvider&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OOM_ADJ_REASON_UI_VISIBILITY</span> <span class="operator">=</span> OOM_ADJ_REASON_METHOD + <span class="string">&quot;_uiVisibility&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OOM_ADJ_REASON_ALLOWLIST</span> <span class="operator">=</span> OOM_ADJ_REASON_METHOD + <span class="string">&quot;_allowlistChange&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OOM_ADJ_REASON_PROCESS_BEGIN</span> <span class="operator">=</span> OOM_ADJ_REASON_METHOD + <span class="string">&quot;_processBegin&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OOM_ADJ_REASON_PROCESS_END</span> <span class="operator">=</span> OOM_ADJ_REASON_METHOD + <span class="string">&quot;_processEnd&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Android</code>系统进程的冻结主要通过内核中<code>cgroup</code>冻结(<code>freezer</code>)子系统来实现的，对应是下述框图中的右侧区域；如果冻结的进程提供了<code>binder</code>接口，首先需要通过<code>binder</code>接口设置当前服务进程处于冻结状态，这样客户端调用相关的接口时，主动返回错误，而不至于阻塞客户端进程。</p><ul><li><code>ActivityManagerService(AMS)</code>系统的核心服务，主要负责应用的创建与状态管理，<code>AMS</code>会通过<code>OomAjduster</code>的接口来调整进程的优先级状态</li><li><code>OomAjduster</code>主要用来计算、调整进程的状态与优先级，为内存回收、进程冻结提供参考依据</li><li><code>CachedAppOptimizer</code>提供内存回收与进程冻结的能力，对长时间处于后台的应用进行相应的优化处理</li><li><code>Process</code>用于管理应用进程，提供如进程创建，进程优先级调整，进程分组等接口</li></ul><p>进程冻结实际会分为两个具体的步骤：</p><ul><li>首先通过<code>freezeBinder</code>发送命令给<code>binder</code>驱动尝试冻结服务端的进程，<code>binder</code>驱动会冻结对应<code>pid</code>的服务，后续请求都会直接返回一个错误</li><li><code>binder</code>服务冻结后，需要通过<code>cgroup</code>冻结子系统执行冻结；进程冻结完成后，进程状态变为<code>S</code>，执行的路径会阻塞在<code>do_freezer_trap</code></li></ul><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/android-process-freezer-flow.png" alt="Android进程冻结流程"></p><h2 id="Android进程冻结实现原理"><a href="#Android进程冻结实现原理" class="headerlink" title="Android进程冻结实现原理"></a>Android进程冻结实现原理</h2><h3 id="进程冻结分组挂载"><a href="#进程冻结分组挂载" class="headerlink" title="进程冻结分组挂载"></a>进程冻结分组挂载</h3><p><code>Android</code>冻结的核心原理是基于<code>cgroup</code>中的冻结子系统来完成任务的冻结与解冻；<code>cgroup</code>是最开始是<code>Google</code>工程师引入，是内核用于控制资源比如<code>CPU</code>，内存，<code>IO</code>等的一种非常有效的手段。在<code>Android</code>初始化过程中，会通过解析系统中的<code>cgroups.json</code>文件，将常用的分组挂载到系统中：</p><ul><li>进程冻结分组<code>freezer</code>会挂载到<code>/sys/fs/cgroup</code>节点</li><li><code>cpu</code>关联的分组有两个，一个是<code>/dev/cpuctl</code>，主要用于控制<code>CPU</code>的调度，一个是<code>/dev/cpuset</code>，主要用于控制<code>CPU</code>的亲和性、大小核绑定</li><li><code>memory</code>对应的分组是<code>/dev/memcg</code>，主要用于控制<code>内存</code>的分配</li><li><code>io</code>对应的分组是<code>/dev/blkio</code>，主要用于控制<code>IO</code>的调度</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SecondStageMain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class="line">        InstallRebootSignalHandlers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boot_clock::time_point start_time = boot_clock::now();</span><br><span class="line"></span><br><span class="line">    trigger_shutdown = [](<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; command) &#123; shutdown_state.TriggerShutdown(command); &#125;;</span><br><span class="line"></span><br><span class="line">    SetStdioToDevNull(argv);</span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">&quot;init second stage started!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update $PATH in the case the second stage init is newer than first stage init, where it is</span></span><br><span class="line">    <span class="comment">// first set.</span></span><br><span class="line">    <span class="keyword">if</span> (setenv(<span class="string">&quot;PATH&quot;</span>, _PATH_DEFPATH, <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">&quot;Could not set $PATH to &#x27;&quot;</span> &lt;&lt; _PATH_DEFPATH &lt;&lt; <span class="string">&quot;&#x27; in second stage&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Init should not crash because of a dependence on any other process, therefore we ignore</span></span><br><span class="line">    <span class="comment">// SIGPIPE and handle EPIPE at the call site directly.  Note that setting a signal to SIG_IGN</span></span><br><span class="line">    <span class="comment">// is inherited across exec, but custom signal handlers are not.  Since we do not want to</span></span><br><span class="line">    <span class="comment">// ignore SIGPIPE for child processes, we set a no-op function for the signal handler instead.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span> =</span> &#123;.sa_flags = SA_RESTART&#125;;</span><br><span class="line">        action.sa_handler = [](<span class="type">int</span>) &#123;&#125;;</span><br><span class="line">        sigaction(SIGPIPE, &amp;action, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set init and its forked children&#x27;s oom_adj.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result =</span><br><span class="line">                WriteFile(<span class="string">&quot;/proc/1/oom_score_adj&quot;</span>, StringPrintf(<span class="string">&quot;%d&quot;</span>, DEFAULT_OOM_SCORE_ADJUST));</span><br><span class="line">        !result.ok()) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">&quot;Unable to write &quot;</span> &lt;&lt; DEFAULT_OOM_SCORE_ADJUST</span><br><span class="line">                   &lt;&lt; <span class="string">&quot; to /proc/1/oom_score_adj: &quot;</span> &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up a session keyring that all processes will have access to. It</span></span><br><span class="line">    <span class="comment">// will hold things like FBE encryption keys. No process should override</span></span><br><span class="line">    <span class="comment">// its session keyring.</span></span><br><span class="line">    keyctl_get_keyring_ID(KEY_SPEC_SESSION_KEYRING, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Indicate that booting is in progress to background fw loaders, etc.</span></span><br><span class="line">    close(open(<span class="string">&quot;/dev/.booting&quot;</span>, O_WRONLY | O_CREAT | O_CLOEXEC, <span class="number">0000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if need to load debug props to allow adb root, when the device is unlocked.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* force_debuggable_env = getenv(<span class="string">&quot;INIT_FORCE_DEBUGGABLE&quot;</span>);</span><br><span class="line">    <span class="type">bool</span> load_debug_prop = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (force_debuggable_env &amp;&amp; AvbHandle::IsDeviceUnlocked()) &#123;</span><br><span class="line">        load_debug_prop = <span class="string">&quot;true&quot;</span>s == force_debuggable_env;</span><br><span class="line">    &#125;</span><br><span class="line">    unsetenv(<span class="string">&quot;INIT_FORCE_DEBUGGABLE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Umount the debug ramdisk so property service doesn&#x27;t read .prop files from there, when it</span></span><br><span class="line">    <span class="comment">// is not meant to.</span></span><br><span class="line">    <span class="keyword">if</span> (!load_debug_prop) &#123;</span><br><span class="line">        UmountDebugRamdisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PropertyInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Umount second stage resources after property service has read the .prop files.</span></span><br><span class="line">    UmountSecondStageRes();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将SetupCgroupsAction添加到队列中，用于初始化cgroup</span></span><br><span class="line">    am.QueueBuiltinAction(SetupCgroupsAction, <span class="string">&quot;SetupCgroups&quot;</span>);</span><br><span class="line">    am.QueueBuiltinAction(SetKptrRestrictAction, <span class="string">&quot;SetKptrRestrict&quot;</span>);</span><br><span class="line">    am.QueueBuiltinAction(TestPerfEventSelinuxAction, <span class="string">&quot;TestPerfEventSelinux&quot;</span>);</span><br><span class="line">    am.QueueEventTrigger(<span class="string">&quot;early-init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span></span><br><span class="line">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class="string">&quot;wait_for_coldboot_done&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger all the boot actions to get us started.</span></span><br><span class="line">    am.QueueEventTrigger(<span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t mount filesystems or start core system services in charger mode.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootmode = GetProperty(<span class="string">&quot;ro.bootmode&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (bootmode == <span class="string">&quot;charger&quot;</span>) &#123;</span><br><span class="line">        am.QueueEventTrigger(<span class="string">&quot;charger&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        am.QueueEventTrigger(<span class="string">&quot;late-init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Android</code>系统中，<code>cgroups.json</code>文件位于<code>/system/etc/cgroups.json</code>，文件内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Cgroups&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blkio&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/dev/blkio&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0755&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;UID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;GID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/dev/cpuctl&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0755&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;UID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;GID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpuset&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/dev/cpuset&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0755&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;UID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;GID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;memory&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/dev/memcg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0700&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;UID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;root&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;GID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Optional&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Cgroups2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/sys/fs/cgroup&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0755&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;UID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;GID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Controllers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      </span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;freezer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0755&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;UID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;GID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>cgroup</code>挂载完成后，通过<code>adb</code>的指令<code>mount</code>可以查看挂载的<code>cgroup</code>信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># mount -t cgroup</span></span><br><span class="line">none on /dev/blkio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">none on /sys/fs/cgroup <span class="built_in">type</span> cgroup2 (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">none on /dev/cpuctl <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpu)</span><br><span class="line">none on /dev/cpuset <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuset,noprefix,release_agent=/sbin/cpuset_release_agent)</span><br><span class="line">none on /dev/memcg <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>后续在应用启动创建进程的过程中，<code>AMS</code>会调用<code>ProcessList.startProcess</code>通过<code>Process.createProcessGroup</code>的接口来创建对应用户<code>UID</code>的冻结<code>cgroup</code>分组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> Process.ProcessStartResult <span class="title function_">startProcess</span><span class="params">(HostingRecord hostingRecord, String entryPoint,</span></span><br><span class="line"><span class="params">        ProcessRecord app, <span class="type">int</span> uid, <span class="type">int</span>[] gids, <span class="type">int</span> runtimeFlags, <span class="type">int</span> zygotePolicyFlags,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> mountExternal, String seInfo, String requiredAbi, String instructionSet,</span></span><br><span class="line"><span class="params">        String invokeWith, <span class="type">long</span> startTime)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;Start proc: &quot;</span> +</span><br><span class="line">                app.processName);</span><br><span class="line">        checkSlow(startTime, <span class="string">&quot;startProcess: asking zygote to start proc&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isTopApp</span> <span class="operator">=</span> hostingRecord.isTopApp();</span><br><span class="line">        <span class="keyword">if</span> (isTopApp) &#123;</span><br><span class="line">            <span class="comment">// Use has-foreground-activities as a temporary hint so the current scheduling</span></span><br><span class="line">            <span class="comment">// group won&#x27;t be lost when the process is attaching. The actual state will be</span></span><br><span class="line">            <span class="comment">// refreshed when computing oom-adj.</span></span><br><span class="line">            app.mState.setHasForegroundActivities(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Pair&lt;String, Long&gt;&gt; pkgDataInfoMap;</span><br><span class="line">        Map&lt;String, Pair&lt;String, Long&gt;&gt; allowlistedAppDataInfoMap;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">bindMountAppStorageDirs</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">bindMountAppsData</span> <span class="operator">=</span> mAppDataIsolationEnabled</span><br><span class="line">                &amp;&amp; (UserHandle.isApp(app.uid) || UserHandle.isIsolated(app.uid))</span><br><span class="line">                &amp;&amp; mPlatformCompat.isChangeEnabled(APP_DATA_DIRECTORY_ISOLATION, app.info);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get all packages belongs to the same shared uid. sharedPackages is empty array</span></span><br><span class="line">        <span class="comment">// if it doesn&#x27;t have shared uid.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">PackageManagerInternal</span> <span class="variable">pmInt</span> <span class="operator">=</span> mService.getPackageManagerInternal();</span><br><span class="line">        <span class="keyword">final</span> String[] sharedPackages = pmInt.getSharedUserPackagesForPackage(</span><br><span class="line">                app.info.packageName, app.userId);</span><br><span class="line">        <span class="keyword">final</span> String[] targetPackagesList = sharedPackages.length == <span class="number">0</span></span><br><span class="line">                ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;app.info.packageName&#125; : sharedPackages;</span><br><span class="line"></span><br><span class="line">        pkgDataInfoMap = getPackageAppDataInfoMap(pmInt, targetPackagesList, uid);</span><br><span class="line">        <span class="keyword">if</span> (pkgDataInfoMap == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// TODO(b/152760674): Handle inode == 0 case properly, now we just give it a</span></span><br><span class="line">            <span class="comment">// tmp free pass.</span></span><br><span class="line">            bindMountAppsData = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If it&#x27;s an isolated process, it should not even mount its own app data directories,</span></span><br><span class="line">        <span class="comment">// since it has no access to them anyway.</span></span><br><span class="line">        <span class="keyword">if</span> (app.isolated) &#123;</span><br><span class="line">            pkgDataInfoMap = <span class="literal">null</span>;</span><br><span class="line">            allowlistedAppDataInfoMap = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Process.ProcessStartResult startResult;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">regularZygote</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (hostingRecord.usesWebviewZygote()) &#123;</span><br><span class="line">            startResult = startWebView(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, <span class="literal">null</span>, app.info.packageName,</span><br><span class="line">                    app.getDisabledCompatChanges(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;PROC_START_SEQ_IDENT + app.getStartSeq()&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hostingRecord.usesAppZygote()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">AppZygote</span> <span class="variable">appZygote</span> <span class="operator">=</span> createAppZygoteForProcessIfNeeded(app);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can&#x27;t isolate app data and storage data as parent zygote already did that.</span></span><br><span class="line">            startResult = appZygote.getProcess().start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, <span class="literal">null</span>, app.info.packageName,</span><br><span class="line">                    <span class="comment">/*zygotePolicyFlags=*/</span> ZYGOTE_POLICY_FLAG_EMPTY, isTopApp,</span><br><span class="line">                    app.getDisabledCompatChanges(), pkgDataInfoMap, allowlistedAppDataInfoMap,</span><br><span class="line">                    <span class="literal">false</span>, <span class="literal">false</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;PROC_START_SEQ_IDENT + app.getStartSeq()&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            regularZygote = <span class="literal">true</span>;</span><br><span class="line">            startResult = Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, invokeWith, app.info.packageName, zygotePolicyFlags,</span><br><span class="line">                    isTopApp, app.getDisabledCompatChanges(), pkgDataInfoMap,</span><br><span class="line">                    allowlistedAppDataInfoMap, bindMountAppsData, bindMountAppStorageDirs,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;PROC_START_SEQ_IDENT + app.getStartSeq()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!regularZygote) &#123;</span><br><span class="line">            <span class="comment">// 创建进程分组</span></span><br><span class="line">            <span class="comment">// webview and app zygote don&#x27;t have the permission to create the nodes</span></span><br><span class="line">            <span class="keyword">if</span> (Process.createProcessGroup(uid, startResult.pid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Slog.e(ActivityManagerService.TAG, <span class="string">&quot;Unable to create process group for &quot;</span></span><br><span class="line">                        + app.processName + <span class="string">&quot; (&quot;</span> + startResult.pid + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This runs after Process.start() as this method may block app process starting time</span></span><br><span class="line">        <span class="comment">// if dir is not cached. Running this method after Process.start() can make it</span></span><br><span class="line">        <span class="comment">// cache the dir asynchronously, so zygote can use it without waiting for it.</span></span><br><span class="line">        <span class="keyword">if</span> (bindMountAppStorageDirs) &#123;</span><br><span class="line">            storageManagerInternal.prepareStorageDirs(userId, pkgDataInfoMap.keySet(),</span><br><span class="line">                    app.processName);</span><br><span class="line">        &#125;</span><br><span class="line">        checkSlow(startTime, <span class="string">&quot;startProcess: returned from zygote!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> startResult;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Process.createProcessGroup</code>实际是一个<code>native</code>方法，<code>android_os_Process_createProcessGroup</code>方法最终调用<code>processgroup.cpp</code>中的<code>createProcessGroupInternal</code>函数，这个函数最终做两件事情：</p><ul><li>根据进程的<code>uid</code>与<code>pid</code>在<code>/sys/fs/cgroup/</code>目录下创建对应的<code>cgroup</code>分组</li><li>将进程的<code>pid</code>写入到<code>cgroup</code>分组的<code>procs</code>文件中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">createProcessGroupInternal</span><span class="params">(<span class="type">uid_t</span> uid, <span class="type">int</span> initialPid, <span class="built_in">std</span>::<span class="built_in">string</span> cgroup)</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> uid_path = ConvertUidToPath(cgroup.c_str(), uid);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">cgroup_stat</span>;</span></span><br><span class="line">    <span class="type">mode_t</span> cgroup_mode = <span class="number">0750</span>;</span><br><span class="line">    <span class="type">gid_t</span> cgroup_uid = AID_SYSTEM;</span><br><span class="line">    <span class="type">uid_t</span> cgroup_gid = AID_SYSTEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stat(cgroup.c_str(), &amp;cgroup_stat) == <span class="number">1</span>) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">&quot;Failed to get stats for &quot;</span> &lt;&lt; cgroup;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cgroup_mode = cgroup_stat.st_mode;</span><br><span class="line">        cgroup_uid = cgroup_stat.st_uid;</span><br><span class="line">        cgroup_gid = cgroup_stat.st_gid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!MkdirAndChown(uid_path, cgroup_mode, cgroup_uid, cgroup_gid)) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">&quot;Failed to make and chown &quot;</span> &lt;&lt; uid_path;</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> uid_pid_path = ConvertUidPidToPath(cgroup.c_str(), uid, initialPid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!MkdirAndChown(uid_pid_path, cgroup_mode, cgroup_uid, cgroup_gid)) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">&quot;Failed to make and chown &quot;</span> &lt;&lt; uid_pid_path;</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> uid_pid_procs_file = uid_pid_path + PROCESSGROUP_CGROUP_PROCS_FILE;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!WriteStringToFile(<span class="built_in">std</span>::to_string(initialPid), uid_pid_procs_file)) &#123;</span><br><span class="line">        ret = -errno;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">&quot;Failed to write &#x27;&quot;</span> &lt;&lt; initialPid &lt;&lt; <span class="string">&quot;&#x27; to &quot;</span> &lt;&lt; uid_pid_procs_file;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>等系统正常启动完成后，我们可以到<code>/sys/fs/cgroup/</code>目录下查看对应的<code>cgroup</code>分组状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rk3588m_car:/sys/fs/cgroup <span class="comment"># ls -al</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 47 system system 0 2024-12-16 19:11 .</span><br><span class="line">drwxr-xr-x 11 root   root   0 1970-01-01 08:00 ..</span><br><span class="line">-rwxr-xr-x  1 system system 0 1970-01-01 08:00 cgroup.controllers</span><br><span class="line">-rwxr-xr-x  1 system system 0 1970-01-01 08:00 cgroup.max.depth</span><br><span class="line">-rwxr-xr-x  1 system system 0 1970-01-01 08:00 cgroup.max.descendants</span><br><span class="line">-rwxr-xr-x  1 system system 0 1970-01-01 08:00 cgroup.procs</span><br><span class="line">-rwxr-xr-x  1 system system 0 1970-01-01 08:00 cgroup.stat</span><br><span class="line">-rwxr-xr-x  1 system system 0 1970-01-01 08:00 cgroup.subtree_control</span><br><span class="line">-rwxr-xr-x  1 system system 0 1970-01-01 08:00 cgroup.threads</span><br><span class="line">-rwxr-xr-x  1 system system 0 1970-01-01 08:00 cpu.pressure</span><br><span class="line">-rwxr-xr-x  1 system system 0 1970-01-01 08:00 cpu.stat</span><br><span class="line">-rwxr-xr-x  1 system system 0 1970-01-01 08:00 io.pressure</span><br><span class="line">-rwxr-xr-x  1 system system 0 1970-01-01 08:00 memory.pressure</span><br><span class="line">drwxr-xr-x 29 system system 0 2024-12-16 19:31 uid_0</span><br><span class="line">drwxr-xr-x 98 system system 0 2024-12-16 19:11 uid_1000</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:10 uid_10004</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:11 uid_10005</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:11 uid_10007</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:11 uid_10009</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:11 uid_10010</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:11 uid_10011</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:11 uid_10012</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:11 uid_1002</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:11 uid_10020</span><br><span class="line">...</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:11 uid_10029</span><br><span class="line">drwxr-xr-x  2 system system 0 2024-12-16 19:10 uid_1003</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:10 uid_10033</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:11 uid_10037</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:11 uid_10038</span><br><span class="line">drwxr-xr-x  4 system system 0 2024-12-16 19:10 uid_1010</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:10 uid_1020</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:11 uid_1036</span><br><span class="line">drwxr-xr-x  2 system system 0 2024-12-16 19:10 uid_1037</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:10 uid_1040</span><br><span class="line">drwxr-xr-x  6 system system 0 2024-12-16 19:10 uid_1041</span><br><span class="line">drwxr-xr-x  7 system system 0 2024-12-16 19:10 uid_1046</span><br><span class="line">drwxr-xr-x  3 system system 0 2024-12-16 19:10 uid_1047</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="进程冻结实现原理"><a href="#进程冻结实现原理" class="headerlink" title="进程冻结实现原理"></a>进程冻结实现原理</h3><p>在文章开始我们提到<code>Android</code>进程冻结的核心原理是基于<code>cgroup</code>中的冻结子系统来完成任务的冻结与解冻；具体来说，<code>Android</code>进程冻结分为两个步骤：</p><ul><li>首先通过<code>IPCThreadState.freeze</code>发送命令给<code>binder</code>驱动尝试冻结服务端的进程，<code>binder</code>驱动会冻结对应<code>pid</code>的服务，后续请求都会直接返回一个错误</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">status_t</span> <span class="title function_">IPCThreadState::freeze</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">bool</span> enable, <span class="type">uint32_t</span> timeout_ms)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_freeze_info</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    info.pid = pid;</span><br><span class="line">    info.enable = enable;</span><br><span class="line">    info.timeout_ms = timeout_ms;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(self()-&gt;mProcess-&gt;mDriverFD, BINDER_FREEZE, &amp;info) &lt; <span class="number">0</span>)</span><br><span class="line">        ret = -errno;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// ret==-EAGAIN indicates that transactions have not drained.</span></span><br><span class="line">    <span class="comment">// Call again to poll for completion.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>binder</code>驱动接收到冻结指令<code>BINDER_FREEZE</code>后，会将对应的<code>binder</code>服务进程设置为<code>frozen</code>状态，后续请求都会直接返回一个<code>BR_FROZEN_REPLY</code>错误码，表示<code>binder</code>服务已经被冻结；如果设置了<code>timeout_ms</code>，则需要等待<code>binder</code>服务完成所有客户端的请求后再返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_ioctl_freeze</span><span class="params">(<span class="keyword">struct</span> binder_freeze_info *info,</span></span><br><span class="line"><span class="params">       <span class="keyword">struct</span> binder_proc *target_proc)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!info-&gt;enable) &#123;</span><br><span class="line">binder_inner_proc_lock(target_proc);</span><br><span class="line">target_proc-&gt;sync_recv = <span class="literal">false</span>;</span><br><span class="line">target_proc-&gt;async_recv = <span class="literal">false</span>;</span><br><span class="line">target_proc-&gt;is_frozen = <span class="literal">false</span>;</span><br><span class="line">binder_inner_proc_unlock(target_proc);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Freezing the target. Prevent new transactions by</span></span><br><span class="line"><span class="comment"> * setting frozen state. If timeout specified, wait</span></span><br><span class="line"><span class="comment"> * for transactions to drain.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">binder_inner_proc_lock(target_proc);</span><br><span class="line">target_proc-&gt;sync_recv = <span class="literal">false</span>;</span><br><span class="line">target_proc-&gt;async_recv = <span class="literal">false</span>;</span><br><span class="line">target_proc-&gt;is_frozen = <span class="literal">true</span>;</span><br><span class="line">binder_inner_proc_unlock(target_proc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (info-&gt;timeout_ms &gt; <span class="number">0</span>)</span><br><span class="line">ret = wait_event_interruptible_timeout(</span><br><span class="line">target_proc-&gt;freeze_wait,</span><br><span class="line">(!target_proc-&gt;outstanding_txns),</span><br><span class="line">msecs_to_jiffies(info-&gt;timeout_ms));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check pending transactions that wait for reply */</span></span><br><span class="line"><span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">binder_inner_proc_lock(target_proc);</span><br><span class="line"><span class="keyword">if</span> (binder_txns_pending_ilocked(target_proc))</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line">binder_inner_proc_unlock(target_proc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">binder_inner_proc_lock(target_proc);</span><br><span class="line">target_proc-&gt;is_frozen = <span class="literal">false</span>;</span><br><span class="line">binder_inner_proc_unlock(target_proc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>binder</code>服务冻结后，需要通过<code>android_os_Process_setProcessFrozen</code>接口通过<code>cgroup</code>冻结子系统执行冻结；进程冻结完成后，进程状态变为<code>S</code>，执行的路径会阻塞在<code>do_freezer_trap</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// android_os_Process_setProcessFrozen</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">android_os_Process_setProcessFrozen</span><span class="params">(</span></span><br><span class="line"><span class="params">        JNIEnv *env, jobject clazz, jint pid, jint uid, jboolean freeze)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (freeze) &#123;</span><br><span class="line">        success = SetProcessProfiles(uid, pid, &#123;<span class="string">&quot;Frozen&quot;</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        success = SetProcessProfiles(uid, pid, &#123;<span class="string">&quot;Unfrozen&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        signalExceptionForGroupError(env, EINVAL, pid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Android</code>进程<code>cgroup</code>相关的配置文件有两个：一个是<code>controller</code>相关的<code>cgroups.json</code>，另一个是<code>profiles</code>相关的<code>task_profiles.json</code>。在<code>task_profiles.json</code>中，<code>Frozen</code>与<code>Unfrozen</code>两个<code>profiles</code>分别对应<code>FreezerState</code>的<code>1</code>与<code>0</code>，而<code>FreezerState</code>对应的是控制器<code>freezer</code>的<code>cgroup.freeze</code>文件。</p><blockquote><p>有关<code>cgroup</code>的详细介绍可以参考<a href="https://sniffer.site/2024/04/15/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8cgroup%E4%BC%98%E5%8C%96android%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD">深入理解Android进程冻结</a></p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//task_profiles.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LowCapacityCPUs&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpuset&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;File&quot;</span><span class="punctuation">:</span> <span class="string">&quot;background/cpus&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FreezerState&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;freezer&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;File&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cgroup.freeze&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;Profiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HighEnergySaving&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Actions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JoinCgroup&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Params&quot;</span><span class="punctuation">:</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;background&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Frozen&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Actions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SetAttribute&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Params&quot;</span><span class="punctuation">:</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FreezerState&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Unfrozen&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Actions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SetAttribute&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Params&quot;</span><span class="punctuation">:</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FreezerState&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;AggregateProfiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SCHED_SP_BACKGROUND&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Profiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;HighEnergySaving&quot;</span><span class="punctuation">,</span> <span class="string">&quot;LowIoPriority&quot;</span><span class="punctuation">,</span> <span class="string">&quot;TimerSlackHigh&quot;</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SCHED_SP_FOREGROUND&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Profiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;HighPerformance&quot;</span><span class="punctuation">,</span> <span class="string">&quot;HighIoPriority&quot;</span><span class="punctuation">,</span> <span class="string">&quot;TimerSlackNormal&quot;</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SCHED_SP_TOP_APP&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Profiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;MaxPerformance&quot;</span><span class="punctuation">,</span> <span class="string">&quot;MaxIoPriority&quot;</span><span class="punctuation">,</span> <span class="string">&quot;TimerSlackNormal&quot;</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>SetProcessProfiles</code>调用<code>TaskProfiles.SetProcessProfiles</code>函数来完成进程的冻结:<code>SetProcessProfiles</code>函数首先遍历系统中存在的所有<code>profiles</code>,找到对应名字为<code>Frozen</code>的<code>profile</code>，然后调用<code>TaskProfile.ExecuteForProcess</code>来完成进程的冻结。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//processgroup.cpp</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SetProcessProfiles</span><span class="params">(<span class="type">uid_t</span> uid, <span class="type">pid_t</span> pid, <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; profiles)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> TaskProfiles::GetInstance().SetProcessProfiles(uid, pid, profiles, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//task_profiles.cpp</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TaskProfiles::SetProcessProfiles</span><span class="params">(<span class="type">uid_t</span> uid, <span class="type">pid_t</span> pid,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; profiles, <span class="type">bool</span> use_fd_cache)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; name : profiles) &#123;</span><br><span class="line">        TaskProfile* profile = GetProfile(name);</span><br><span class="line">        <span class="keyword">if</span> (profile != nullptr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (use_fd_cache) &#123;</span><br><span class="line">                profile-&gt;EnableResourceCaching(ProfileAction::RCT_PROCESS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!profile-&gt;ExecuteForProcess(uid, pid)) &#123;</span><br><span class="line">                PLOG(WARNING) &lt;&lt; <span class="string">&quot;Failed to apply &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; process profile&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PLOG(WARNING) &lt;&lt; <span class="string">&quot;Failed to find &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;process profile&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ExecuteForTask</code>首先需要通过对应的<code>ProfileAttribute</code>获取到对应的<code>cgroup</code>路径，然后通过<code>WriteStringToFile</code>将<code>FreezerState</code>的值写入到对应的<code>cgroup.freeze</code>文件中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//task_profile.cpp</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SetAttributeAction::ExecuteForTask</span><span class="params">(<span class="type">int</span> tid)</span> <span class="type">const</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!attribute_-&gt;GetPathForTask(tid, &amp;path)) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">&quot;Failed to find cgroup for tid &quot;</span> &lt;&lt; tid;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!WriteStringToFile(value_, path)) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">&quot;Failed to write &#x27;&quot;</span> &lt;&lt; value_ &lt;&lt; <span class="string">&quot;&#x27; to &quot;</span> &lt;&lt; path;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>GetPathForTask</code>函数通过<code>controller()-&gt;GetTaskGroup</code>获取到对应的<code>cgroup</code>路径，然后通过<code>StringPrintf</code>将<code>cgroup.freeze</code>文件的路径拼接起来，最终对应的路径为<code>/sys/fs/cgroup/&lt;uid&gt;/&lt;pid&gt;/cgroup.freeze</code>: 在该路径下写入<code>1</code>表示进程被冻结，写入<code>0</code>表示进程被解冻。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//task_profile.cpp</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ProfileAttribute::GetPathForTask</span><span class="params">(<span class="type">int</span> tid, <span class="built_in">std</span>::<span class="built_in">string</span>* path)</span> <span class="type">const</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> subgroup;</span><br><span class="line">    <span class="keyword">if</span> (!controller()-&gt;GetTaskGroup(tid, &amp;subgroup)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path == nullptr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subgroup.empty()) &#123;</span><br><span class="line">        *path = StringPrintf(<span class="string">&quot;%s/%s&quot;</span>, controller()-&gt;path(), file_name_.c_str());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *path = StringPrintf(<span class="string">&quot;%s/%s/%s&quot;</span>, controller()-&gt;path(), subgroup.c_str(),</span><br><span class="line">                             file_name_.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>GetTaskGroup</code>首先根据进程<code>pid</code>找到对应的<code>cgroup</code>所属的分组信息：冻结分组比较特殊，以<code>0::</code>开头，其余分组的则通过<code>1:</code>的形式开头。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CgroupController::GetTaskGroup</span><span class="params">(<span class="type">int</span> tid, <span class="built_in">std</span>::<span class="built_in">string</span>* group)</span> <span class="type">const</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> file_name = StringPrintf(<span class="string">&quot;/proc/%d/cgroup&quot;</span>, tid);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> content;</span><br><span class="line">    <span class="keyword">if</span> (!android::base::ReadFileToString(file_name, &amp;content)) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">&quot;Failed to read &quot;</span> &lt;&lt; file_name;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if group is null and tid exists return early because</span></span><br><span class="line">    <span class="comment">// user is not interested in cgroup membership</span></span><br><span class="line">    <span class="keyword">if</span> (group == nullptr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> cg_tag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (version() == <span class="number">2</span>) &#123;</span><br><span class="line">        cg_tag = <span class="string">&quot;0::&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cg_tag = StringPrintf(<span class="string">&quot;:%s:&quot;</span>, name());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> start_pos = content.find(cg_tag);</span><br><span class="line">    <span class="keyword">if</span> (start_pos == <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start_pos += cg_tag.length() + <span class="number">1</span>;  <span class="comment">// skip &#x27;/&#x27;</span></span><br><span class="line">    <span class="type">size_t</span> end_pos = content.find(<span class="string">&#x27;\n&#x27;</span>, start_pos);</span><br><span class="line">    <span class="keyword">if</span> (end_pos == <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        *group = content.substr(start_pos, <span class="built_in">std</span>::<span class="built_in">string</span>::npos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *group = content.substr(start_pos, end_pos - start_pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写入<code>cgroup.freeze</code>文件后，对应调用到内核函数<code>cgroup_freeze_write</code>，实际通过<code>cgroup_freeze</code>将该分组下面的搜友子分组对应的所有任务都设置为<code>FROZEN</code>状态:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cgroup_freeze_write</span><span class="params">(<span class="keyword">struct</span> kernfs_open_file *of,</span></span><br><span class="line"><span class="params">   <span class="type">char</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">loff_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup</span> *<span class="title">cgrp</span>;</span></span><br><span class="line"><span class="type">ssize_t</span> ret;</span><br><span class="line"><span class="type">int</span> freeze;</span><br><span class="line"></span><br><span class="line">ret = kstrtoint(strstrip(buf), <span class="number">0</span>, &amp;freeze);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (freeze &lt; <span class="number">0</span> || freeze &gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> -ERANGE;</span><br><span class="line"></span><br><span class="line">cgrp = cgroup_kn_lock_live(of-&gt;kn, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (!cgrp)</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">cgroup_freeze(cgrp, freeze);</span><br><span class="line"></span><br><span class="line">cgroup_kn_unlock(of-&gt;kn);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nbytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于单个任务的冻结，都是通过函数<code>cgroup_freeze_task</code>来完成，该函数通过设置<code>task-&gt;jobctl</code>的<code>JOBCTL_TRAP_FREEZE</code>位来完成任务的冻结，通过清除<code>task-&gt;jobctl</code>的<code>JOBCTL_TRAP_FREEZE</code>位来完成任务的解冻。可以看到，内核实现任务的冻结并没有直接通过向对应的任务发送信号，而是首先设置一个<code>JOBCTL_TRAP_FREEZE</code>位；并通过<code>set_tsk_thread_flag</code>来标记当前任务有需要处理的信号，然后通过<code>signal_wake_up</code>函数唤醒对应的任务。任务唤醒后会返回到用户空间，然后在返回的路径上处理任务阻塞的信号，最终调用到<code>get_signal</code>函数来完成进程的冻结。</p><blockquote><p>详细的内核冻结流程可以参考<a href="https://kernel.meizu.com/2024/07/12/sub-system-cgroup-freezer-in-Linux-kernel/">深入探究 Linux 内核中的 cgroup freezer 子系统</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//kernel/cgroup/freezer.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Freeze or unfreeze the task by setting or clearing the JOBCTL_TRAP_FREEZE</span></span><br><span class="line"><span class="comment"> * jobctl bit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cgroup_freeze_task</span><span class="params">(<span class="keyword">struct</span> task_struct *task, <span class="type">bool</span> freeze)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the task is about to die, don&#x27;t bother with freezing it. */</span></span><br><span class="line"><span class="keyword">if</span> (!lock_task_sighand(task, &amp;flags))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (freeze) &#123;</span><br><span class="line">task-&gt;jobctl |= JOBCTL_TRAP_FREEZE;</span><br><span class="line">signal_wake_up(task, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">task-&gt;jobctl &amp;= ~JOBCTL_TRAP_FREEZE;</span><br><span class="line">wake_up_process(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unlock_task_sighand(task, &amp;flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>get_signal</code>函数会检查当前进程是否需要处理信号，并检查<code>JOBCTL_TRAP_FREEZE</code>标志位，如果任务设置了该标志位，则调用<code>do_freezer_trap</code>函数来完成进程的冻结，这个函数也是冻结的任务最后执行的函数，在进程冻结后，我们可以通过查看进程的堆栈来确认这一点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">get_signal</span><span class="params">(<span class="keyword">struct</span> ksignal *ksig)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span> =</span> current-&gt;sighand;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span> =</span> current-&gt;signal;</span><br><span class="line"><span class="type">int</span> signr;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> *<span class="title">ka</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(current-&gt;jobctl &amp; JOBCTL_STOP_PENDING) &amp;&amp;</span><br><span class="line">    do_signal_stop(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(current-&gt;jobctl &amp;</span><br><span class="line">     (JOBCTL_TRAP_MASK | JOBCTL_TRAP_FREEZE))) &#123;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;jobctl &amp; JOBCTL_TRAP_MASK) &#123;</span><br><span class="line">do_jobctl_trap();</span><br><span class="line">spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">            <span class="comment">//执行进程冻结的函数</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;jobctl &amp; JOBCTL_TRAP_FREEZE)</span><br><span class="line">do_freezer_trap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the task is leaving the frozen state, let&#x27;s update</span></span><br><span class="line"><span class="comment"> * cgroup counters and reset the frozen bit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(cgroup_task_frozen(current))) &#123;</span><br><span class="line">spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">cgroup_leave_frozen(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">goto</span> relock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ksig-&gt;sig &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>do_freezer_trap</code>实际就做了这么三件事情：</p><ul><li>将当前任务的状态设置为<code>TASK_INTERRUPTIBLE</code>，并清除<code>TIF_SIGPENDING</code>标志位</li><li>调用<code>cgroup_enter_frozen</code>设置当前任务为<code>FROZEN</code>状态，并更新对应分组的状态</li><li>调用<code>freezable_schedule</code>启动调度，冻结的任务会移除调度队列，任务处于睡眠状态，切换其他任务执行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * do_freezer_trap - handle the freezer jobctl trap</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_freezer_trap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">__<span class="title function_">releases</span><span class="params">(&amp;current-&gt;sighand-&gt;siglock)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now we&#x27;re sure that there is no pending fatal signal and no</span></span><br><span class="line"><span class="comment"> * pending traps. Clear TIF_SIGPENDING to not get out of schedule()</span></span><br><span class="line"><span class="comment"> * immediately (if there is a non-fatal signal pending), and</span></span><br><span class="line"><span class="comment"> * put the task into sleep.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">clear_thread_flag(TIF_SIGPENDING);</span><br><span class="line">spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">cgroup_enter_frozen();</span><br><span class="line">freezable_schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进程完全冻结后，我们通过<code>ps -A</code>命令查看进程状态，可以看到进程的状态为<code>S</code>，任务的等待通道（<code>wait channel</code>）为<code>do_freezer_trap</code>；查看进程的堆栈，可以看到进程确实是通过信号处理函数进入了冻结状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#ps -A|grep -i rknn</span></span><br><span class="line">root           873     1 10972640  3448 do_freezer_trap     0 S rknn_server</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /proc/873/stack</span></span><br><span class="line">[&lt;0&gt;] __switch_to+0x118/0x148</span><br><span class="line">[&lt;0&gt;] do_freezer_trap+0x64/0xbc</span><br><span class="line">[&lt;0&gt;] get_signal+0x370/0x77c</span><br><span class="line">[&lt;0&gt;] do_signal+0xa0/0x298</span><br><span class="line">[&lt;0&gt;] do_notify_resume+0xac/0x218</span><br><span class="line">[&lt;0&gt;] work_pending+0xc/0x76c</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Android进程冻结策略"><a href="#Android进程冻结策略" class="headerlink" title="Android进程冻结策略"></a>Android进程冻结策略</h2><p><code>Android</code>系统会在进程启动、服务绑定、应用前后台切换、发送&#x2F;接收广播等场景会主动更新系统所有应用的<code>adj</code>值，<code>adj</code>值越小，表示进程优先级越高，对应的存活时间越久，越不容易被系统杀死。一个应用处于后台，如果长时间没有活动，系统会调整<code>adj</code>值，在系统资源紧张（比如内存不足时），会主动清理（冻结或者杀死）这些<code>adj</code>值较大（<code>CACHED_APP_MIN_ADJ(900)&lt;=adj&lt;=CACHED_APP_MAX_ADJ(999)</code>）的进程。</p><p>应用调整<code>adj</code>值的核心逻辑都在<code>OomAdjuster</code>类中实现；更新完所有应用的<code>adj</code>值后，如果发现该进程的<code>adj</code>值大于<code>CACHED_APP_MIN_ADJ</code>，则会尝试调用<code>CachedAppOptimizer.freezeAppAsyncLSP</code>冻结该进程。其调用的链路大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//OomAdjuster.java</span></span><br><span class="line">updateOomAdjLocked -&gt; updateOomAdjLSP -&gt; performUpdateOomAdjLSP </span><br><span class="line">-&gt; updateOomAdjInnerLSP -&gt; updateAndTrimProcessLSP -&gt; applyOomAdjLSP</span><br><span class="line">-&gt; updateAppFreezeStateLSP</span><br><span class="line"><span class="comment">//CachedAppOptimizer.java</span></span><br><span class="line">-&gt; freezeAppAsyncLSP</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>updateAppFreezeStateLSP</code>函数首先会判断系统是否开启了进程冻结功能，该功能默认是开启的，具体的值可以通过设置两个配置项来开关（全局数据库的配置优先级更高）：</p><ul><li>全局数据库<code>Settings.Global.CACHED_APPS_FREEZER_ENABLED</code>：存放在系统数据库中的开关项，比如<code>adb shell settings put global cached_apps_freezer 1</code></li><li>设备配置<code>DeviceConfig</code>中的<code>use_freezer</code>项来设置，比如<code>adb shell device_config put activity_manager_native_boot use_freezer true</code></li></ul><p>如果未两个配置项都未开启，则说明系统不支持进程冻结，直接返回；否则如果进程的<code>adj</code>值大于等于<code>CACHED_APP_MIN_ADJ</code>且未被冻结过，则调用<code>freezeAppAsyncLSP</code>函数来冻结进程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//CachedAppOptimizer.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateAppFreezeStateLSP</span><span class="params">(ProcessRecord app)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mCachedAppOptimizer.useFreezer()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app.mOptRecord.isFreezeExempt()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ProcessCachedOptimizerRecord</span> <span class="variable">opt</span> <span class="operator">=</span> app.mOptRecord;</span><br><span class="line">    <span class="comment">// if an app is already frozen and shouldNotFreeze becomes true, immediately unfreeze</span></span><br><span class="line">    <span class="keyword">if</span> (opt.isFrozen() &amp;&amp; opt.shouldNotFreeze()) &#123;</span><br><span class="line">        mCachedAppOptimizer.unfreezeAppLSP(app);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ProcessStateRecord</span> <span class="variable">state</span> <span class="operator">=</span> app.mState;</span><br><span class="line">    <span class="comment">// Use current adjustment when freezing, set adjustment when unfreezing.</span></span><br><span class="line">    <span class="keyword">if</span> (state.getCurAdj() &gt;= ProcessList.CACHED_APP_MIN_ADJ &amp;&amp; !opt.isFrozen()</span><br><span class="line">            &amp;&amp; !opt.shouldNotFreeze()) &#123;</span><br><span class="line">        mCachedAppOptimizer.freezeAppAsyncLSP(app);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.getSetAdj() &lt; ProcessList.CACHED_APP_MIN_ADJ) &#123;</span><br><span class="line">        mCachedAppOptimizer.unfreezeAppLSP(app);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>freezeAppAsyncLSP</code>并不会立即执行进程的冻结，而是通过<code>mFreezeHandler</code>发送一个延迟<code>10</code>分钟的<code>SET_FROZEN_PROCESS_MSG</code>消息，如果在此期间，系统的<code>adj</code>没有变小，则执行进程的冻结。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//CachedAppOptimizer.java   </span></span><br><span class="line"><span class="meta">@GuardedBy(&#123;&quot;mAm&quot;, &quot;mProcLock&quot;&#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">freezeAppAsyncLSP</span><span class="params">(ProcessRecord app)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ProcessCachedOptimizerRecord</span> <span class="variable">opt</span> <span class="operator">=</span> app.mOptRecord;</span><br><span class="line">    <span class="keyword">if</span> (opt.isPendingFreeze()) &#123;</span><br><span class="line">        <span class="comment">// Skip redundant DO_FREEZE message</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFreezeHandler.sendMessageDelayed(</span><br><span class="line">            mFreezeHandler.obtainMessage(</span><br><span class="line">                SET_FROZEN_PROCESS_MSG, DO_FREEZE, <span class="number">0</span>, app),</span><br><span class="line">            mFreezerDebounceTimeout);</span><br><span class="line">    opt.setPendingFreeze(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_FREEZER) &#123;</span><br><span class="line">        Slog.d(TAG_AM, <span class="string">&quot;Async freezing &quot;</span> + app.getPid() + <span class="string">&quot; &quot;</span> + app.processName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>进程冻结的核心目标是在<code>Android</code>内存紧张时，主动冻结长时间不活动的后台应用，释放内存资源，从而节省功耗，提升系统性能。但目前来说，<code>Android</code>进程冻结的实现并不完善，还存在一些可以改善的地方，比如：</p><ul><li>进程冻结只考虑到了内存资源情况，没有考虑到如CPU、IO等其他系统资源的占用情况</li><li>进程冻结目前只支持<code>Java</code>层的应用，对于<code>Native</code>的进程并不支持冻结</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://gityuan.com/2018/05/19/android-process-adj/">https://gityuan.com/2018/05/19/android-process-adj/</a></li><li><a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/OomAdjuster.md">https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/OomAdjuster.md</a></li><li><a href="https://sniffer.site/2024/04/15/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8cgroup%E4%BC%98%E5%8C%96android%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD">https://sniffer.site/2024/04/15/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8cgroup%E4%BC%98%E5%8C%96android%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD</a></li><li><a href="https://kernel.meizu.com/2024/07/12/sub-system-cgroup-freezer-in-Linux-kernel/">https://kernel.meizu.com/2024/07/12/sub-system-cgroup-freezer-in-Linux-kernel/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Google&lt;/code&gt;从&lt;code&gt;Android11&lt;/code&gt;系统开始支持应用冻结功能，可以将后台长时间未运行的任务暂缓执行，通过将对应的进程迁移到对应的&lt;code&gt;cgroup&lt;/code&gt;分组来冻结对应的后台缓存应用，这样可以减少如CPU、内存等资源占用，减少业务在后台的不当行为，尽可能减少功耗。本文将对&lt;code&gt;Android&lt;/code&gt;的进程冻结的实现原理、冻结策略进行详细的介绍与阐述，争取把相关的策略与机制都讲述清楚，主要分为以下几个部分 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Android&lt;/code&gt;进程冻结的大致框架：主要介绍进程冻结的总体框架与思路&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Android&lt;/code&gt;进程冻结的实现原理：介绍&lt;code&gt;Android&lt;/code&gt;如何实现进程冻结&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Android&lt;/code&gt;进程冻结的冻结策略：进程冻结的具体策略&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Android" scheme="https://sniffer.site/categories/Android/"/>
    
    
    <category term="Android" scheme="https://sniffer.site/tags/Android/"/>
    
    <category term="进程冻结" scheme="https://sniffer.site/tags/%E8%BF%9B%E7%A8%8B%E5%86%BB%E7%BB%93/"/>
    
    <category term="cgroup" scheme="https://sniffer.site/tags/cgroup/"/>
    
  </entry>
  
  <entry>
    <title>Linux实时调度踩到的那些坑</title>
    <link href="https://sniffer.site/2024/11/25/Linux%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E8%B8%A9%E5%9D%91%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88/"/>
    <id>https://sniffer.site/2024/11/25/Linux%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E8%B8%A9%E5%9D%91%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88/</id>
    <published>2024-11-25T11:03:31.000Z</published>
    <updated>2024-12-04T12:32:05.528Z</updated>
    
    <content type="html"><![CDATA[<p>早期Linux内核的调度更多考虑的是系统调度的公平与吞吐量，对于实时性的支持并不友好。为了改善系统的响应时间，降低某些场景下实时任务的调度延迟，从<code>2.6</code>版本开始支持了实时调度与抢占功能，开发人员为此专门建立了一个<a href="https://wiki.linuxfoundation.org/realtime/start">实时Linux的网站</a>，上面提供了实时内核的一些历史状态与补丁信息。实时调度对于音视频、UI渲染等对时间非常敏感的任务来说，非常必要。比如对于<code>Android</code>平台，会将音频、渲染相关的一些核心任务的调度策略设置为实时调度，这样可以减少系统调度延迟与任务抢占带来的延时。Linux内核中的实时调度主要有两种调度策略：</p><ul><li><code>SCHED_FIFO</code>: 先入先出，即优先级高的任务优先执行，不会被其他任务抢占，直到对应的任务阻塞或者主动释放CPU</li><li><code>SCHED_RR</code>: 轮询（也称随机轮盘）调度，相同优先级的任务轮流执行相同的时间片，时间片用完后会调度其他的任务</li></ul><blockquote><p>本文基于Linux内核5.10版本分析</p></blockquote><span id="more"></span><p>我们可以通过<code>top -H</code>命令查看系统实时任务的情况，其中<code>PR</code>列为<code>RT</code>的即为实时调度的任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1216 audioserver  RT   0 119M  62M  10M S  4.6   0.5   0:08.70 DSP00Task0      android.hardware.audio.service</span><br><span class="line">226 root         RT   0    0    0    0 S  1.3   0.0   0:03.86 irq/135-asm330l [irq/135-asm330l]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尽管实时调度对于一些时间敏感的任务来说非常合适，但是对于一个多任务系统来说，如果系统中存在很多的进程，负载比较高，有可能会出现一些负面的效应；比较常见的问题有如下两类：</p><ul><li>实时进程会抢占其他非实时任务的CPU，长时间占据CPU，导致系统吞吐量下降，引起性能问题</li><li>由于优先级设置不当，高优先级的实时任务会抢占低优先级实时任务的CPU，导致某些任务处理延迟</li></ul><p>接下来我们就一起来看看这两类问题的表现，以及如何在实际开发中避免。在此之前，首先来简要的看一看Linux内核中实时调度策略的实现。</p><h2 id="Linux内核的实时调度"><a href="#Linux内核的实时调度" class="headerlink" title="Linux内核的实时调度"></a>Linux内核的实时调度</h2><p>除了常规的公平调度<code>CFS(Complete Fair Scheduling)</code>之外，Linux内核还支持两类实时调度类型：</p><ul><li>随机轮盘调度(<code>Round-robin</code>， <code>SCHED_RR</code>)：该调度策略的事实任务有固定的时间片（默认是<code>100ms</code>）,任务执行完一段时间后，时间片减少；时间片用完后，进程换出，会放入到运行队列末尾，等待下一轮调度；这样确保相同优先级的任务可以轮流执行</li><li>先进先出调度（<code>First-In, First-Out</code>, <code>SCHED_FIFO</code>）：该调度策略没有时间片的限制，一旦调度执行会一直占用CPU；如果该任务的代码有问题导致阻塞，就可能出现CPU被长时间占用而无法换出的问题。</li></ul><p>从内核代码可以看到，内核执行任务调度时，从高优先级调度类开始选择任务，再到低优先级调度类-实时调度类<code>rt_sched_class</code>高于公平调度类（<code>SCHED_NORMAL</code>）<code>fair_sched_class</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// vmlinux.lds.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The order of the sched class addresses are important, as they are</span></span><br><span class="line"><span class="comment"> * used to determine the order of the priority of each sched class in</span></span><br><span class="line"><span class="comment"> * relation to each other.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_DATA\</span></span><br><span class="line"><span class="meta">STRUCT_ALIGN();\</span></span><br><span class="line"><span class="meta">__begin_sched_classes = .;\</span></span><br><span class="line"><span class="meta">*(__idle_sched_class)\</span></span><br><span class="line"><span class="meta">*(__fair_sched_class)\</span></span><br><span class="line"><span class="meta">*(__rt_sched_class)\</span></span><br><span class="line"><span class="meta">*(__dl_sched_class)\</span></span><br><span class="line"><span class="meta">*(__stop_sched_class)\</span></span><br><span class="line"><span class="meta">__end_sched_classes = .;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sched_class_highest (__end_sched_classes - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sched_class_lowest  (__begin_sched_classes - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_class(class) \</span></span><br><span class="line"><span class="meta">for_class_range(class, sched_class_highest, sched_class_lowest)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Linux内核调度为每个调度类型都提供了一个关键的调度类，实时调度类如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DEFINE_SCHED_CLASS(rt) = &#123;</span><br><span class="line"></span><br><span class="line">.enqueue_task= enqueue_task_rt,</span><br><span class="line">.dequeue_task= dequeue_task_rt,</span><br><span class="line">.yield_task= yield_task_rt,</span><br><span class="line"></span><br><span class="line">.check_preempt_curr= check_preempt_curr_rt,</span><br><span class="line"></span><br><span class="line">.pick_next_task= pick_next_task_rt,</span><br><span class="line">.put_prev_task= put_prev_task_rt,</span><br><span class="line">.set_next_task          = set_next_task_rt,</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">.balance= balance_rt,</span><br><span class="line">.select_task_rq= select_task_rq_rt,</span><br><span class="line">.set_cpus_allowed       = set_cpus_allowed_common,</span><br><span class="line">.rq_online              = rq_online_rt,</span><br><span class="line">.rq_offline             = rq_offline_rt,</span><br><span class="line">.task_woken= task_woken_rt,</span><br><span class="line">.switched_from= switched_from_rt,</span><br><span class="line">.find_lock_rq= find_lock_lowest_rq,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">.task_tick= task_tick_rt,</span><br><span class="line"></span><br><span class="line">.get_rr_interval= get_rr_interval_rt,</span><br><span class="line"></span><br><span class="line">.prio_changed= prio_changed_rt,</span><br><span class="line">.switched_to= switched_to_rt,</span><br><span class="line"></span><br><span class="line">.update_curr= update_curr_rt,</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_UCLAMP_TASK</span></span><br><span class="line">.uclamp_enabled= <span class="number">1</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实时调度的调度队列是一个双向链表，所有优先级相同的任务都放入到<code>active.queue[prio]</code>这个队列里（实时调度的最大优先级<code>MAX_RT_PRIO</code>），<code>active.bitmap</code>用于记录哪个优先级对应的队列有任务；对实时调度实现原理感兴趣的可以研究下内核的代码<code>kernel/sched/rt.c</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_prio_array</span> &#123;</span></span><br><span class="line">  DECLARE_BITMAP(bitmap, MAX_RT_PRIO+<span class="number">1</span>); <span class="comment">/* include 1 bit for delimiter */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue</span>[<span class="title">MAX_RT_PRIO</span>];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rt_prio_array</span> <span class="title">active</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实时调度坑之一-实时任务长时间占据CPU"><a href="#实时调度坑之一-实时任务长时间占据CPU" class="headerlink" title="实时调度坑之一-实时任务长时间占据CPU"></a>实时调度坑之一-实时任务长时间占据CPU</h2><p>之前在一个项目开发过程中碰到一个问题：系统中一个跟摄像头相关的实时任务长时间占用了<code>CPU0</code>，持续运行了<code>100ms+</code>，而音频相关的软中断恰好也在<code>CPU0</code>上处理（物理中断默认绑定在<code>CPU0</code>上，对应的软中断会跟物理中断在同一个CPU上处理），导致音频的软中断无法抢占到<code>CPU</code>，发生响应延迟，导致音频卡顿。</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/linux-rt-process-long-run.jpg" alt="RT线程执行时间过长"></p><p>那么，软中断为啥没能竞争过用户空间的实时任务了？根因在于内核中的软中断<code>softirqd</code>线程创建时默认使用<code>SCHED_NORMAL</code>公平调度策略，因此优先级是低于实时调度(<code>RT</code>)的，这也能解释为为什么软中断无法抢占到<code>CPU</code>，导致音频卡顿。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"># kthread.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kthread</span><span class="params">(<span class="type">void</span> *_create)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> =</span> &#123; .sched_priority = <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">/* Copy data: it&#x27;s on kthread&#x27;s stack */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> *<span class="title">create</span> =</span> _create;</span><br><span class="line">    <span class="type">int</span> (*threadfn)(<span class="type">void</span> *data) = create-&gt;threadfn;</span><br><span class="line">    <span class="type">void</span> *data = create-&gt;data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">done</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kthread</span> *<span class="title">self</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    self = to_kthread(current);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Release the structure when caller killed by a fatal signal. */</span></span><br><span class="line">    done = xchg(&amp;create-&gt;done, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">        kfree(create-&gt;full_name);</span><br><span class="line">        kfree(create);</span><br><span class="line">        kthread_exit(-EINTR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self-&gt;full_name = create-&gt;full_name;</span><br><span class="line">    self-&gt;threadfn = threadfn;</span><br><span class="line">    self-&gt;data = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The new thread inherited kthreadd&#x27;s priority and CPU mask. Reset</span></span><br><span class="line"><span class="comment">     * back to default in case they have been changed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sched_setscheduler_nocheck(current, SCHED_NORMAL, &amp;param);</span><br><span class="line">    set_cpus_allowed_ptr(current, housekeeping_cpumask(HK_TYPE_KTHREAD));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* OK, tell user we&#x27;re spawned, wait for stop or wakeup */</span></span><br><span class="line">    __set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">    create-&gt;result = current;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread is going to call schedule(), do not preempt it,</span></span><br><span class="line"><span class="comment">     * or the creator may spend more time in wait_task_inactive().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    preempt_disable();</span><br><span class="line">    complete(done);</span><br><span class="line">    schedule_preempt_disabled();</span><br><span class="line">    preempt_enable();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这类问题要解决有两个方法，一个是直接将用户空间的线程调度策略设置为普通公平调度，一个是开启物理中断的<code>CPU</code>亲和性，确保软中断处理不绑定到特定的<code>CPU</code>上，从而错开与实时调度任务的执行，也可以将软中断设置为实时调度策略（这个影响较大，不推荐）。</p><h2 id="实时调度坑之二-优先级设置不当"><a href="#实时调度坑之二-优先级设置不当" class="headerlink" title="实时调度坑之二-优先级设置不当"></a>实时调度坑之二-优先级设置不当</h2><p>与问题一不一样的是，问题二是两个实时任务的竞争引起的音频卡顿的问题（<code>Android</code>中大部分的实时调度任务都是音频）：一个应用进入前台后（Android中前台进程是<code>top-app</code>，绑定<code>CPU0~3</code>，我们开启了Android的一个特定<code>sys.use_fifo_ui</code>，会使得应用的<code>UI</code>线程使用实时调度策略），会偶现音频播放出现杂音。通过复现抓到的<code>trace</code>可以看到，内核音频线程(<code>297</code>)有好几处长时间的(大于<code>13ms</code>以上)休眠，此时同一个<code>CPU0</code>上运行的就是前台的任务的主线程<code>6600</code>，可以看到只有等主线程执行完成释放<code>CPU0</code>，音频内核线程<code>297</code>才会唤醒，而此时音频可能已经出现了丢帧，从而出现杂音的问题。</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/rt-task-cpu-contention.jpg" alt="RT实时任务竞争CPU"></p><p>那么，为啥同样是实时调度的任务，内核的音频线程没法抢占到<code>CPU</code>呢？从实时调度的原理来看，可以推测是内核实时线程的优先级低于前台任务的主线程，实际在设备确认发现，音频线程的优先级与主线程优先级恰好相等，都是<code>98</code>(实时线程的最大优先级是<code>100</code>)。</p><p>与上一个问题类似，要解决问题二，要么关闭<code>Android</code>的主线程优化<code>sys.use_fifo_ui</code>，将其设置为<code>0</code>，从而避开与内核音频线程的竞争；要么提高内核音频线程的优先级，在创建线程时将内核线程的<code>nice</code>值降低（优先级提高）。实测发现方案二有效，最终我们也采用了方案二来解决问题。</p><h2 id="如何限制实时任务的执行时间"><a href="#如何限制实时任务的执行时间" class="headerlink" title="如何限制实时任务的执行时间"></a>如何限制实时任务的执行时间</h2><p>从实时调度的调度策略来看，如果实时进程的代码存在问题，就很有可能导致CPU长时间被占用，系统卡住。内核为了解决该问题，针对实时任务的执行时间进行限定。在<code>proc</code>目录下有两个参数：</p><ul><li><code>sched_rt_period_us</code>： 表示最大的调度时长（可以理解为100%的CPU带宽），大小范围从<code>-1</code>到<code>INT_MAX-1</code>，默认是1s，</li><li><code>sched_rt_runtime_us</code>: 表示实时任务最大可运行时长，默认是0.95s,表示实时任务可以使用0.95s的CPU时间，而其他调度类的进程可以使用余下的0.05s</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># cat /proc/sys/kernel/sched_rt_period_us</span></span><br><span class="line">1000000</span><br><span class="line"><span class="comment"># cat /proc/sys/kernel/sched_rt_runtime_us</span></span><br><span class="line">950000</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过调节这两个参数，我们可以限制实时类调度任务的时间片分配，从而确保其他任务可以执行。除此之外，通过设定<code>cgroup</code>的配置<code>CONFIG_RT_GROUP_SCHED</code>，也可以通过控制分组来限定某些分组的实时任务占用的时间片；启动该配置后，在对应的cgroup目录可以看到如下配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cpu.rt_period_us</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过设定该参数，可以在不同的分组采用不一样的实时任务分配策略，确保某些分组比如后台的实时任务不长时间占用CPU，从而解决其他任务无法抢占到CPU的问题</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对<code>Linux</code>这种通用的操作系统来说，进程的调度要考虑的因素非常多：既要考虑到低延迟的任务处理，降低响应延时，比如音频、UI的渲染，同时要考虑并发处理多个任务，保持系统的高吞吐量，这两个目标通常是相互冲突的，需要在仔细权衡。在使用实时调度策略的时候，我们还是要谨慎处理，避免实时任务竞争<code>CPU</code>引起的问题。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://wiki.linuxfoundation.org/realtime/documentation/technical_basics/sched_rt_throttling">https://wiki.linuxfoundation.org/realtime/documentation/technical_basics/sched_rt_throttling</a></li><li><a href="https://www.kernel.org/doc/Documentation/scheduler/sched-rt-group.txt">https://www.kernel.org/doc/Documentation/scheduler/sched-rt-group.txt</a></li><li><a href="https://wiki.linuxfoundation.org/realtime/start">https://wiki.linuxfoundation.org/realtime/start</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;早期Linux内核的调度更多考虑的是系统调度的公平与吞吐量，对于实时性的支持并不友好。为了改善系统的响应时间，降低某些场景下实时任务的调度延迟，从&lt;code&gt;2.6&lt;/code&gt;版本开始支持了实时调度与抢占功能，开发人员为此专门建立了一个&lt;a href=&quot;https://wiki.linuxfoundation.org/realtime/start&quot;&gt;实时Linux的网站&lt;/a&gt;，上面提供了实时内核的一些历史状态与补丁信息。实时调度对于音视频、UI渲染等对时间非常敏感的任务来说，非常必要。比如对于&lt;code&gt;Android&lt;/code&gt;平台，会将音频、渲染相关的一些核心任务的调度策略设置为实时调度，这样可以减少系统调度延迟与任务抢占带来的延时。Linux内核中的实时调度主要有两种调度策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SCHED_FIFO&lt;/code&gt;: 先入先出，即优先级高的任务优先执行，不会被其他任务抢占，直到对应的任务阻塞或者主动释放CPU&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SCHED_RR&lt;/code&gt;: 轮询（也称随机轮盘）调度，相同优先级的任务轮流执行相同的时间片，时间片用完后会调度其他的任务&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;本文基于Linux内核5.10版本分析&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://sniffer.site/categories/Linux/"/>
    
    
    <category term="Kernel" scheme="https://sniffer.site/tags/Kernel/"/>
    
    <category term="实时调度" scheme="https://sniffer.site/tags/%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6/"/>
    
    <category term="进程优先级" scheme="https://sniffer.site/tags/%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>高通QNX平台DCVS介绍</title>
    <link href="https://sniffer.site/2024/07/24/%E9%AB%98%E9%80%9AQNX%E5%B9%B3%E5%8F%B0DCVS%E4%BB%8B%E7%BB%8D/"/>
    <id>https://sniffer.site/2024/07/24/%E9%AB%98%E9%80%9AQNX%E5%B9%B3%E5%8F%B0DCVS%E4%BB%8B%E7%BB%8D/</id>
    <published>2024-07-24T11:17:15.000Z</published>
    <updated>2024-07-25T03:57:20.671Z</updated>
    
    <content type="html"><![CDATA[<p>目前智能座舱领域的方案中，高通的两大平台<code>8155</code>&#x2F;<code>8295</code>占据了大部分的市场份额，这两个硬件平台都是基于<code>QNX</code>系统的虚拟化方案实现的，就是说中控域与仪表域都跑在一个系统上了-座舱通常是Android系统，实际是QNX上的一个虚拟机；而仪表通常是运行在QNX侧。跟传统的单Android系统比较来看，<code>QNX</code>虚拟化平台有很多的变化，比如很多物理驱动与系统服务都跑在了QNX上，而Android上看到的只是一个虚拟的设备，或者压根就去掉了，比如本文要讲到的动态调频与调压功能<code>DCVS(Dynamic Clock and Voltage Scaling)</code>就是一个例子，这个功能在Android上已经没有了，所有的调频与调压功能都在QNX上实现。</p><blockquote><p><code>DCVS</code>也可将其称为<code>DVFS(Dynamic Voltage and Frequency Scaling)</code>实际都是根据系统负载动态调整CPU&#x2F;GPU&#x2F;DDR等工作频率与电压，从而减少功耗</p></blockquote><p>接下来，我们就一起看看高通QNX平台的<code>DCVS</code>功能是如何实现的，以及如何在QNX平台查看<code>CPU, GPU，UFS，DDR</code>的频率。</p> <span id="more"></span><h2 id="QNX的DCVS实现原理"><a href="#QNX的DCVS实现原理" class="headerlink" title="QNX的DCVS实现原理"></a><strong>QNX的DCVS实现原理</strong></h2><h3 id="CPU-DCVS"><a href="#CPU-DCVS" class="headerlink" title="CPU DCVS"></a><strong>CPU DCVS</strong></h3><p><code>DCVS</code>是一种电源管理的策略，用于根据系统负载状态动态的调整系统核心频率，以减少功耗，节省电能，这个在如手机这样的移动平台使用的最为广泛。下图是<code>CPU DCVS</code>的的原理框图，其核心的功能都是在一个后台服务<code>dcvs_service</code>中实现的，该服务负责与其他模块如<code>kernel</code>, <code>qcore</code>和<code>io_service</code>进行交互：</p><ul><li>根据系统负载来选择相应频率的算法是在QNX内核实现的；一旦决定选择某个频率，内核会发送请求给<code>qcore</code>进程来进行频率的设定</li><li>如果系统负载过高导致触发高温保护，此时调频策略完全由<code>LMH(Limit Management Hardware)</code>模块负责执行；而等到系统温度降低到设定的阈值，则<code>DCVS</code>重新交由内核进行处理；<code>dcvs_service</code>服务注册热管理模块(<code>Thermal LMH</code>)的事件回调；在收到开启与关闭事件回调的时间窗口内，会关闭内核的动态调频功能，由<code>LMH</code>硬件负责管理<code>CPU</code>的频率</li><li><code>QNX</code>内核中包含一个负责调皮策略的管理者(<code>governor</code>), 其负责监控系统负载，一旦某个CPU簇(<code>cluster</code>, 8285上有两个簇，对应大小两个核心)的负载在一定的时间内持续超过了设定的阈值-高负载(<code>overflow</code>)或者低负载(<code>underflow</code>)，内核的管理者就会触发一个事件；<code>DCVS</code>服务收到该事件后，会主动将频率调整为内核推荐的频率</li></ul><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/qcom-qnx-dcvs.png" alt="qnx-dcvs"></p><blockquote><ul><li>qcore是QNX上的电源管理核心服务</li><li>DLPMP(Dynamic power performance levels and multiprocessor control)：动态调整性能模式</li><li>LMH(Limit Management Hardware): 用于系统高低温保护</li></ul></blockquote><h3 id="如何进行DCVS参数设定"><a href="#如何进行DCVS参数设定" class="headerlink" title="如何进行DCVS参数设定"></a><strong>如何进行DCVS参数设定</strong></h3><p>以<code>8295</code>平台为例，有两个<code>CPU</code>簇(分别有4个大核，4个小核)，每个簇的频率共有10个等级（如下表所示）:</p><table><thead><tr><th>SA8295 clusters</th><th>Levels</th></tr></thead><tbody><tr><td>cluster0</td><td>10(1017MHZ~2131MHZ)</td></tr><tr><td>cluster1</td><td>10(1280MHZ~2380MHZ)</td></tr></tbody></table><p><code>QNX</code>提供了<code>pdbg</code>接口用于<code>DCVS</code>的参数设定，每个频点主要有如下4个重要的参数:</p><ul><li><code>up_pct_thr</code>: 当前频率的CPU使用率上限阈值，对<code>freq10</code>来说，默认值是<code>90</code></li><li><code>up_time_thr_ms</code>: 当前频率的CPU使用率（持续）时间上限阈值，对<code>freq10</code>来说，默认值是<code>100(ms)</code></li><li><code>down_pct_thr</code>: 当前频率的CPU使用率下限阈值，对<code>freq10</code>来说，默认值是<code>10</code></li><li><code>down_time_thr_ms</code>: 当前频率的CPU使用率（持续）时间下限阈值，对<code>freq10</code>来说，默认值是<code>200(ms)</code></li></ul><p>如果想要更好的性能，尽量将<code>up_pct_thr</code>的阈值降低点，确保系统负载超过该阈值后可以快速调频；反之，如果更多的考虑是节省功耗，则应该将<code>down_pct_thr</code>的阈值提高一点，这样可以在系统负载降低时能触发降频，减少能耗。例如，在车载上更多的考虑是性能，我们可以适当提升<code>CPU</code>调频的上限阈值:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 80 &gt; /dev/pdbg/qcore/dcvs/kdcvs/cluster0/freq10/up_pct_thr</span><br><span class="line"><span class="built_in">echo</span> 80 &gt; /dev/pdbg/qcore/dcvs/kdcvs/cluster1/freq10/up_pct_thr</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果要关闭<code>DCVS</code>功能，将<code>CPU</code>设定在最高或者最低的频点，可以通过如下接口设定:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 设置为最高频</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /dev/pdbg/qcore/dcvs/force_max_freqency</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为最低频</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /dev/pdbg/qcore/dcvs/force_min_freqency</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外，在分析问题时，可以通过<code>slog2info</code>查看<code>DCVS</code>的日志信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># slog2info -w |grep dcvs</span></span><br><span class="line">Jan 01 08:00:26.274                frpc_lib.233538             frpc_lib  16135  cdsp_service[fastrpc_farf.c:409]: CDSP:fastrpc_kpower.c:1440:0xdc:6: fastrpc_kpower_set: Request = HAP_power_set_DCVS_v2, Client ID = 15, Client ID <span class="keyword">for</span> adsp dcvs = 7</span><br><span class="line">Jan 01 08:00:26.279                frpc_lib.233538             frpc_lib  16135  cdsp_service[fastrpc_farf.c:409]: CDSP:fastrpc_kpower.c:1440:0xdc:6: fastrpc_kpower_set: Request = HAP_power_set_DCVS_v2, Client ID = 14, Client ID <span class="keyword">for</span> adsp dcvs = 6</span><br><span class="line">Jan 01 08:00:26.279                frpc_lib.233538             frpc_lib  16135  cdsp_service[fastrpc_farf.c:409]: CDSP:fastrpc_kpower.c:1440:0xdc:6: fastrpc_kpower_set: Request = HAP_power_set_DCVS_v2, Client ID = 15, Client ID <span class="keyword">for</span> adsp dcvs = 7</span><br><span class="line">Jan 01 08:00:26.298                frpc_lib.233538             frpc_lib  16135  cdsp_service[fastrpc_farf.c:409]: CDSP:fastrpc_kpower.c:1440:0xdc:6: fastrpc_kpower_set: Request = HAP_power_set_DCVS_v2, Client ID = 14, Client ID <span class="keyword">for</span> adsp dcvs = 6</span><br><span class="line">Jan 01 08:00:26.298                frpc_lib.233538             frpc_lib  16135  cdsp_service[fastrpc_farf.c:409]: CDSP:fastrpc_kpower.c:1440:0xdc:6: fastrpc_kpower_set: Request = HAP_power_set_DCVS_v2, Client ID = 15, Client ID <span class="keyword">for</span> adsp dcvs = 7</span><br><span class="line">Jan 01 08:00:26.322                frpc_lib.233538             frpc_lib  16135  cdsp_service[fastrpc_farf.c:409]: CDSP:fastrpc_kpower.c:1440:0xdc:6: fastrpc_kpower_set: Request = HAP_power_set_DCVS_v2, Client ID = 14, Client ID <span class="keyword">for</span> adsp dcvs = 6</span><br><span class="line">Jan 01 08:00:26.322                frpc_lib.233538             frpc_lib  16135  cdsp_service[fastrpc_farf.c:409]: CDSP:fastrpc_kpower.c:1440:0xdc:6: fastrpc_kpower_set: Request = HAP_power_set_DCVS_v2, Client ID = 15, Client ID <span class="keyword">for</span> adsp dcvs = 7</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="GPU-DCVS"><a href="#GPU-DCVS" class="headerlink" title="GPU DCVS"></a><strong>GPU DCVS</strong></h3><p><code>GPU</code>的<code>DCVS</code>主要是通过一个工作队列线程来获取<code>GPU</code>负载信息从而实施<code>DCVS</code>动态调频-通过当前的负载信息来调整GPU的核心工作频率。与<code>CPU</code>的频点类似，<code>GPU</code>的工作频率也分位好几个档次，如<code>SA8155</code>平台对应的<code>GPU</code>工作频率有7个档次:</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/8155-gpu-freq-levels.jpeg" alt="8155 gpu frequency levels"></p><p>对<code>GPU</code>的<code>DCVS</code>来说都是通过内部的算法完成调频策略执行，无需进行调优；不过，<code>QNX</code>提供了开关<code>DCVS</code>的接口:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># enable performance governor</span></span><br><span class="line"><span class="built_in">echo</span> gpu_perf_governor 1 &gt; /dev/kgsl-control</span><br><span class="line"></span><br><span class="line"><span class="comment"># disable performance governor</span></span><br><span class="line"><span class="built_in">echo</span> gpu_perf_governor 0 &gt; /dev/kgsl-control</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以选择将<code>GPU</code>频点设定在指定的档次：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 设置GPU频率为500MHZ(level 3)</span></span><br><span class="line"><span class="built_in">echo</span> gpu_perf_governor 1 &gt; /dev/kgsl-control</span><br><span class="line"><span class="built_in">echo</span> gpu_gfx_core_clock_level 3 &gt; /dev/kgsl-control</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果需要实时查看当前<code>GPU</code>的工作频率与负载，可以通过设定日志等级，然后通过<code>slog2info</code>查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 设置GPU日志等级</span></span><br><span class="line"><span class="built_in">echo</span> gpu_set_log_level 4 &gt; /dev/kgsl-control</span><br><span class="line"><span class="built_in">echo</span> gpubusystats 100 &gt; /dev/kgsl-control</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看GPU实时负载</span></span><br><span class="line">slog2info -w |grep -i gsl</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="QNX中查看系统工作频率"><a href="#QNX中查看系统工作频率" class="headerlink" title="QNX中查看系统工作频率"></a><strong>QNX中查看系统工作频率</strong></h2><p>高通平台的<code>QNX</code>系统中有一个<code>clock.sh</code>脚本，可以用来读取、设定系统核心的工作频率，比如<code>CPU</code>, <code>GPU</code>, <code>DDR</code>, <code>UFS</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># clock.sh -h</span></span><br><span class="line">clock debug tool</span><br><span class="line">usage: clock.sh &lt;<span class="built_in">command</span>&gt; &lt;[arg]&gt; [options]</span><br><span class="line"></span><br><span class="line">Provides an interface to the qcore clock driver. Results are stored</span><br><span class="line"><span class="keyword">in</span> /tmp/clockdebug_log, <span class="built_in">which</span> is <span class="keyword">then</span> printed to stdout.</span><br><span class="line"></span><br><span class="line">global options:</span><br><span class="line">  -b,--batch   <span class="built_in">enable</span> batch commands</span><br><span class="line"></span><br><span class="line">commands:</span><br><span class="line">  <span class="built_in">enable</span>       &lt;clock || powerdomain || dcvs || avs&gt;</span><br><span class="line">  <span class="built_in">disable</span>      &lt;clock || powerdomain || dcvs&gt; [--force]</span><br><span class="line">  getfreq      &lt;clock&gt; </span><br><span class="line">  setfreq      &lt;clock&gt; &lt;frequency (min KHz)&gt;</span><br><span class="line">  setdiv       &lt;clock&gt; &lt;div&gt;</span><br><span class="line">  setflags     &lt;clock || powerdomain || top&gt; &lt;mask&gt;</span><br><span class="line">  setlimit     &lt;clock&gt; [--min, --max (default)] &lt;frequency (KHz)&gt;</span><br><span class="line">  config       &lt;clock&gt; &lt;val&gt;</span><br><span class="line">  reset        &lt;clock&gt; [--assert, --deassert, --pulse (default)]</span><br><span class="line">  info         &lt;clock || powerdomain || top || list&gt; [--enabled, --on, --ref, --xovote, --cached]</span><br><span class="line">  freqplan     &lt;clock&gt; </span><br><span class="line">  maxperf      &lt;cluster_name&gt; </span><br><span class="line">  minperf      &lt;cluster_name&gt; </span><br><span class="line">  perfinfo     &lt;cluster_name&gt; </span><br><span class="line">  gpio         [--off]</span><br><span class="line">  debugmux     &lt;clocck_name&gt;</span><br><span class="line">  getrefcount  &lt;clock_name&gt;</span><br><span class="line">  <span class="built_in">log</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体查看各个系统的频率的方法如下，这个可以看到所有系统核心域的频率信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># cpu</span></span><br><span class="line">clock.sh info|grep apcs</span><br><span class="line"></span><br><span class="line"><span class="comment"># gpu</span></span><br><span class="line">clock.sh info|grep gpu</span><br><span class="line"></span><br><span class="line"><span class="comment"># ufs</span></span><br><span class="line">clock.sh info|grep ufs</span><br><span class="line"></span><br><span class="line"><span class="comment"># ufs</span></span><br><span class="line">clock.sh info|grep ddr</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果我们要查看某个具体系统时钟的频率信息，可以通过如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># clock.sh info gpu_cc_gx_gfx3d_clk</span></span><br><span class="line">Clock               State      Freq (Hz)    EN  RST Flags              VDD_CX/MMCX                      Sources</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">gpu_cc_gx_gfx3d_clk ON (0)     730995848    1   n/a 0x0                OFF                              /pmic/client/xo</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前智能座舱领域的方案中，高通的两大平台&lt;code&gt;8155&lt;/code&gt;&amp;#x2F;&lt;code&gt;8295&lt;/code&gt;占据了大部分的市场份额，这两个硬件平台都是基于&lt;code&gt;QNX&lt;/code&gt;系统的虚拟化方案实现的，就是说中控域与仪表域都跑在一个系统上了-座舱通常是Android系统，实际是QNX上的一个虚拟机；而仪表通常是运行在QNX侧。跟传统的单Android系统比较来看，&lt;code&gt;QNX&lt;/code&gt;虚拟化平台有很多的变化，比如很多物理驱动与系统服务都跑在了QNX上，而Android上看到的只是一个虚拟的设备，或者压根就去掉了，比如本文要讲到的动态调频与调压功能&lt;code&gt;DCVS(Dynamic Clock and Voltage Scaling)&lt;/code&gt;就是一个例子，这个功能在Android上已经没有了，所有的调频与调压功能都在QNX上实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;DCVS&lt;/code&gt;也可将其称为&lt;code&gt;DVFS(Dynamic Voltage and Frequency Scaling)&lt;/code&gt;实际都是根据系统负载动态调整CPU&amp;#x2F;GPU&amp;#x2F;DDR等工作频率与电压，从而减少功耗&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来，我们就一起看看高通QNX平台的&lt;code&gt;DCVS&lt;/code&gt;功能是如何实现的，以及如何在QNX平台查看&lt;code&gt;CPU, GPU，UFS，DDR&lt;/code&gt;的频率。&lt;/p&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://sniffer.site/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="QNX" scheme="https://sniffer.site/tags/QNX/"/>
    
    <category term="DCVS" scheme="https://sniffer.site/tags/DCVS/"/>
    
    <category term="高通" scheme="https://sniffer.site/tags/%E9%AB%98%E9%80%9A/"/>
    
  </entry>
  
  <entry>
    <title>生命与宇宙-看《时间简史》的感想</title>
    <link href="https://sniffer.site/2024/07/18/%E7%94%9F%E5%91%BD-%E6%97%B6%E9%97%B4%E4%B8%8E%E5%AE%87%E5%AE%99/"/>
    <id>https://sniffer.site/2024/07/18/%E7%94%9F%E5%91%BD-%E6%97%B6%E9%97%B4%E4%B8%8E%E5%AE%87%E5%AE%99/</id>
    <published>2024-07-18T11:42:51.000Z</published>
    <updated>2024-08-20T01:37:54.190Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们发现自己处于令人困惑的世界中。我们要理解周围所看到的一切的含义，并且询问：宇宙的本质是什么？我们在其中的位置如何，以及宇宙和我们从何而来？宇宙为何是这个样子？</p><pre><code>    史蒂芬-霍金</code></pre></blockquote><p> <img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/Corona-black-hole.webp" alt="black-hole"></p> <span id="more"></span><p>大学的时候，就开始对大脑的奥秘、宇宙的起源还有人类的诞生特别感兴趣，也一直尝试看相关的书籍，认识并不深。最近断断续续看完了史蒂芬-霍金的《时间简史》，有一种很久未曾有过的震撼-这种感觉还是好多年前在看《追寻记忆的痕迹》才有过。霍金用直白简洁的语言阐述了宇宙的起源与历史，看起来十分让人着迷。书中的部分内容理解起来有点吃力，但好像是打开了一扇窗口，让人看到了全新的世界。</p><p>时间，宇宙，人类，这些命题无法让人看得清晰，有时觉得理解了一点，有时却又变得非常陌生，始终带着模糊而朦胧的美。看完全书，不得不感叹相比起宇宙的浩瀚无边，人类还是太过渺小了；但人类本身就带着神迹，本身就是一种奇迹般的存在，是偶然中诞生的上帝的化身，有兽性，也有光辉的人性。人要睁眼看清宇宙，也要睁眼看看自己；人类努力发现宇宙深处的奥秘，想要在短暂的生命时光中探索到真谛，想要努力摆脱自身的枷锁，尝试下自由的滋味，究竟太难了。宇宙本身只是一个存在，无言无语的存在，而人类却要努力去探索这个存在的价值与意义，去探索宇宙的本质，去发现存在的真理。</p><p>实在是太难。也只有这些伟大的人物才能真正有勇气、有毅力去探求这些灼热人心的奥秘，而芸芸众生不过是得过且过，尝试在世俗的生活里找到一点乐趣与快乐，然后赋予它们以价值与意义。我们太会自我安慰，所以大部分时候都会陷入到日常生活里无可自拔-欲望，享乐，权力，地位，财富，长相，年龄，穿着，这些东西消耗了我们太多的时间与精力，让我们陷入了一种自我陶醉而迷恋的状态。几百年来，人类社会高速发展，历史的车轮从未像现在这样急速的运转-人作为地球之王，已经早就忘了自己来自何方，成为没有家乡的孤魂野鬼。我们在数字网络的世界里，努力找到一点心灵的慰藉，尝试通过感官的愉悦掩盖内心深处的焦虑不安。欲望太多了，已经把整个人都包围的水泄不通；终日疲于奔命，不明白自己要去哪里。我们想要通过食色性来刺激自己的肉体，尝试获取一点昙花一现的自由，甘之如饴，实际不过多一个枷锁而已。</p><p>我们能否获取到自由？很难。人类自诞生起就没有自由过。我们只不过一直受欲望驱使，是欲望的奴隶而已。那所谓的自由只是我们构建的虚幻。可是，是不是我们没有了欲望，真正的自由就来了吗？有肉身，我们就会有欲望，除非我们的肉身彻底死亡，否则欲望会一直存在。我们注定要与内心的欲望度过一生，这就是人的命运，无法摆脱。但纵然如此，还是可以选择，可以尝试与欲望为友，认识它，而不是被它冲昏了头脑。只有真正把握了藏在肉体里的欲望，藏在内心的渴求，我们才有可能真正地获得些许自由，虽然不一定是真正的自由，但也能称得上一种无限逼近自由的状态。</p><p>不要逃避欲望，不要害怕。不要让欲望成为枷锁，而是成为一种探索内心自由的助推器，成为开启智慧的源泉。要自我克制，要懂得敬畏。克制意味着，我们要学会控制欲望的度，不要让任何一种欲望成为控制自我的枷锁，成为摧毁内心的魔鬼；敬畏意味着，我们要懂得谦卑，不要自我放纵，不要无所畏惧，不要肆无忌惮。我们既然带着神性，带着神迹，那么我们就要对被赋予的一切满怀感激。人能否安度一生，能否健康、快乐、富足过完一生，首先就是要认清自己内心的欲望，看清楚自己真正想要的东西。这样我们方才有动力真正去追寻到内心的安宁。</p><p>但如果只是纯有欲望而没有能力达成这些欲望，恐怕只会给自己增添苦恼，说不定还要带来无妄之灾。因此，欲望之外，更重要的其实是个人的能力，要有证明自我价值的能力。如果没有过人的天赋与天资，那就老老实实的去看书、学习，去探索智慧吧。依靠长期的积累，点滴的成长，不断的自我提升，或许我们还是无法做到五年就达到牛人的水准，但是或许十年后人就脱胎换骨了，这时我们就能发挥更大的价值，带来更多的影响。纵然，我们依然无法真正达成自己设定的目标，但至少可以让我们摆脱内心的焦虑与茫然，让自己成为一个真正内心平静与安宁的人，一个有智慧面对人生困难与挑战的人。这就够了。</p><p>归根结底，快乐与幸福需要我们内心有足够的智慧，能让我们平衡自己内心的欲望与个人的能力，让我们可以回归初心，找到生命本来的模样-不焦虑，不茫然，不懈怠。如果我们在能力不足的时候，学会放下内心过度的欲望，舍弃部分自我渴求，或许我们能更轻松，更淡定、安然；如果我们有足够的能力，那么要懂得克制，保持适度，而不是一味的被欲望所吞噬，让欲望成为自设的枷锁。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;我们发现自己处于令人困惑的世界中。我们要理解周围所看到的一切的含义，并且询问：宇宙的本质是什么？我们在其中的位置如何，以及宇宙和我们从何而来？宇宙为何是这个样子？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    史蒂芬-霍金
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt; &lt;img src=&quot;https://md-files.oss-cn-shenzhen.aliyuncs.com/Corona-black-hole.webp&quot; alt=&quot;black-hole&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://sniffer.site/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="生命" scheme="https://sniffer.site/tags/%E7%94%9F%E5%91%BD/"/>
    
    <category term="宇宙" scheme="https://sniffer.site/tags/%E5%AE%87%E5%AE%99/"/>
    
    <category term="时间" scheme="https://sniffer.site/tags/%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>Android如何使用PSI管理内存</title>
    <link href="https://sniffer.site/2024/06/25/Android%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PSI%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98/"/>
    <id>https://sniffer.site/2024/06/25/Android%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PSI%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98/</id>
    <published>2024-06-25T09:46:33.000Z</published>
    <updated>2024-07-19T07:08:46.693Z</updated>
    
    <content type="html"><![CDATA[<p>早前，<code>Android</code>使用内核中的<code>lowmemorykiller</code>驱动模块来监控系统内存，在内存不足时会主动杀掉某些非关键性的进程或者应用，从而减少系统的内存压力；自从内核版本<code>4.12</code>之后，<code>lowmemorykiller</code>从内核中移除了，因此<code>Android</code>增加一个<code>lmkd(Low Memory Killer Daemon)</code>来替代内核驱动用以监控系统内存状态，在系统处于内存高压状态时，主动清理部分内存，确保内存水位处于可接受的状态。那么，<code>LMKD</code>又是如何获取系统内存压力状态的了？这个就要说到<code>PSI(Pressure stall information)</code>这个内核模块了。</p><span id="more"></span><p><code>Android10</code>开始在<code>LMKD</code>中引入了<code>PSI</code>（压力失速信息）来检测内存压力，简单来说，<code>PSI</code>通过检测由于内存不足导致的任务延迟，这些延迟可以用来表示系统内存压力状态；并提供了接口来给用户进程获取这些状态信息；早期<code>Android</code>的版本则使用<code>vmpressure</code>模块来获取系统内存压力状态。</p><p>这篇文章我们主要看看<code>Android</code>如何使用<code>PSI</code>来管理内存，在出现内存压力如何释放内存。</p><h2 id="PSI简介"><a href="#PSI简介" class="headerlink" title="PSI简介"></a>PSI简介</h2><p><code>PSI(Pressure stall information)</code>是内核中的一个模块，用来监控系统中CPU、内存、IO资源压力状态，目的是衡量系统整体的资源健康情况；当系统出现资源压力时（由于CPU、内存或IO资源的不足而导致的任务延迟），系统的运行效率会降低。通过<code>PSI</code>的接口，我们可以获取系统资源的压力状态，可以选择对应的资源管理策略进行调优，从而提升系统的效率。</p><p>要获取到<code>PSI</code>状态，可以通过<code>/proc/pressure</code>中的文件来查看，对应有三个接口:</p><ul><li><code>/proc/pressure/cpu</code>: 查看系统CPU压力状态</li><li><code>/proc/pressure/memory</code>: 查看系统内存压力状态</li><li><code>/proc/pressure/io</code>： 查看系统IO压力状态</li></ul><p>对应输出的数据都是统一的格式，具体来说，第一行<code>some</code>表示当前系统有一个或者多个进程有出现压力；第二行<code>full</code>表示所有的进程都出现了资源压力。<code>avg10</code>表示10s的平均值，<code>avg60</code>表示60s的平均值，<code>avg300</code>表示300s的平均值，<code>total</code>表示累计延迟的总时间（以ms为单位）。</p><blockquote><p>对CPU来说，不存在<code>full</code>状态，因为系统中始终存在一个可运行的进程</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">some avg10=0.77 avg60=0.23 avg300=0.14 total=117592248</span><br><span class="line">full avg10=0.00 avg60=0.00 avg300=0.00 total=0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下图为列，有两个进程执行的情况下，由于出现内存压力，导致<code>B</code>进程等待了30s; <code>A</code>进程正常执行没有延迟, 则<code>some</code>的值对应50%（0.5）；因此<code>some</code>从某种程度上表示了系统资源压力带来的延迟；</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/psi-some.png" alt="some crop"></p><p>类似地，如下图，两个进程<code>A</code>与<code>B</code>都因为内存压力出现了延迟等待，<code>A</code>等待了<code>10s</code>, <code>B</code>等待了<code>30s</code>，则此时<code>some</code>为<code>50%</code>, 而<code>full</code>为<code>16.67%</code>; 高<code>full</code>值表示由于系统资源压力导致的总吞吐量的损失。</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/psi-full.png" alt="full crop"></p><blockquote><p>打开<code>PSI</code>需要开启内核配置<code>CONFIG_PSI</code>，<code>CONFIG_PSI_LMKD</code>和<code>CONFIG_PSI_SYSCALL</code>三个配置项，默认都是开启的。</p></blockquote><p>内核一般会在系统发生进程切换或者内存分配发生回收时时主动通知<code>PSI</code>模块，从而统计当前资源的压力,对应的内核接口都可以在<code>linux/psi.h</code>中找到，主要用这么几个接口:</p><ul><li><code>psi_init</code>: 初始化<code>PSI</code>模块</li><li><code>psi_task_change</code>: 任务状态发生变化时通知<code>PSI</code>模块，更新统计数据</li><li><code>psi_task_switch</code>: 任务切换时通知<code>PSI</code>模块，更新统计数据</li><li><code>psi_memstall_tick</code>: 定时器中断产生时通知<code>PSI</code>模块，更新内存压力统计数据</li><li><code>psi_memstall_enter</code>: 内存分配出现压力开始时通知<code>PSI</code>模块，更新内存压力统计数据</li><li><code>psi_memstall_leave</code>: 内存分配压力结束时通知<code>PSI</code>模块，更新内存压力统计数据</li></ul><p>以内存为例，内核会在主要的几个内存路径， 如内存回收、内存整理等都会调用，<code>psi_memstall_enter</code>&#x2F;<code>psi_memstall_leave</code>函数，用于统计内存压力状态。比如在内存分配路径如果由于内存碎片化，启动了内存整理，则会告知<code>PSI</code>模块，统计内存碎片化整理带来的延迟：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// page_alloc.c</span></span><br><span class="line"></span><br><span class="line">* Try memory compaction <span class="keyword">for</span> high-order allocations before reclaim */</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_direct_compact</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class"><span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>, <span class="title">const</span> <span class="keyword">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>,</span></span><br><span class="line"><span class="class"><span class="title">enum</span> <span class="title">compact_priority</span> <span class="title">prio</span>, <span class="title">enum</span> <span class="title">compact_result</span> *<span class="title">compact_result</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pflags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> noreclaim_flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!order)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始内存整理</span></span><br><span class="line">psi_memstall_enter(&amp;pflags);</span><br><span class="line">noreclaim_flag = memalloc_noreclaim_save();</span><br><span class="line"></span><br><span class="line">*compact_result = try_to_compact_pages(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">prio, &amp;page);</span><br><span class="line"></span><br><span class="line">memalloc_noreclaim_restore(noreclaim_flag);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 结束内存整理</span></span><br><span class="line">psi_memstall_leave(&amp;pflags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * At least in one zone compaction wasn&#x27;t deferred or skipped, so let&#x27;s</span></span><br><span class="line"><span class="comment"> * count a compaction stall</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">count_vm_event(COMPACTSTALL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Prep a captured page if available */</span></span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line">prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try get a page from the freelist if available */</span></span><br><span class="line"><span class="keyword">if</span> (!page)</span><br><span class="line">page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (page) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span> =</span> page_zone(page);</span><br><span class="line"></span><br><span class="line">zone-&gt;compact_blockskip_flush = <span class="literal">false</span>;</span><br><span class="line">compaction_defer_reset(zone, order, <span class="literal">true</span>);</span><br><span class="line">count_vm_event(COMPACTSUCCESS);</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * It&#x27;s bad if compaction run occurs and fails. The most likely reason</span></span><br><span class="line"><span class="comment"> * is that pages exist, but not enough to satisfy watermarks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">count_vm_event(COMPACTFAIL);</span><br><span class="line"></span><br><span class="line">cond_resched();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多的技术细节可以参考<code>linux/stats.h</code>(CPU调度)以及<code>kernel/mm</code>(内存管理)相关的代码。下面我们就来看看<code>Android</code>中如何利用<code>PSI</code>来管理系统的内存，并在低内存状态时如何回收内存的。</p><h2 id="LMKD如何使用PSI监控内存状态"><a href="#LMKD如何使用PSI监控内存状态" class="headerlink" title="LMKD如何使用PSI监控内存状态"></a>LMKD如何使用PSI监控内存状态</h2><p>下图是<code>LMKD</code>内存管理服务的架构图，<code>LMKD</code>主要是为了解决低内存时系统内存回收的问题，通过<code>PSI</code>的信息获取到系统内存压力状态后，只要内存压力超过一定的水位，<code>LMKD</code>会主动选择杀掉一个低优先级任务（根据进程的<code>oom_score</code>的值），释放部分内存，确保系统内存达到正常水位。</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/lmkd-psi-architecture.png" alt="lmkd-psi-architecture"></p><p><code>LMKD</code>低内存管理服务在启动时，会主动注册一个内核事件，用于监听<code>PSI</code>内存压力状态(<code>Android10</code>以后默认使用<code>PSI</code>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">init_monitors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Try to use psi monitor first if kernel has it */</span></span><br><span class="line">    use_psi_monitors = <span class="built_in">GET_LMK_PROPERTY</span>(<span class="type">bool</span>, <span class="string">&quot;use_psi&quot;</span>, <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">init_psi_monitors</span>();</span><br><span class="line">    <span class="comment">/* Fall back to vmpressure */</span></span><br><span class="line">    <span class="keyword">if</span> (!use_psi_monitors &amp;&amp;</span><br><span class="line">        (!<span class="built_in">init_mp_common</span>(VMPRESS_LEVEL_LOW) ||</span><br><span class="line">        !<span class="built_in">init_mp_common</span>(VMPRESS_LEVEL_MEDIUM) ||</span><br><span class="line">        !<span class="built_in">init_mp_common</span>(VMPRESS_LEVEL_CRITICAL))) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Kernel does not support memory pressure events or in-kernel low memory killer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (use_psi_monitors) &#123;</span><br><span class="line">        <span class="built_in">ALOGI</span>(<span class="string">&quot;Using psi monitors for memory pressure detection&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ALOGI</span>(<span class="string">&quot;Using vmpressure for memory pressure detection&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始化<code>PSI</code>监听模块会根据内存压力阈值进行初始化：内存压力分为<code>low</code>，<code>medium</code>和<code>critical</code>三个阈值，实际只使用了<code>VMPRESS_LEVEL_MEDIUM</code>与<code>VMPRESS_LEVEL_CRITICAL</code>两个值， 对应<code>PSI</code>中的<code>some</code>与<code>full</code>两种状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">init_psi_monitors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When PSI is used on low-ram devices or on high-end devices without memfree levels</span></span><br><span class="line"><span class="comment">     * use new kill strategy based on zone watermarks, free swap and thrashing stats</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> use_new_strategy =</span><br><span class="line">        <span class="built_in">GET_LMK_PROPERTY</span>(<span class="type">bool</span>, <span class="string">&quot;use_new_strategy&quot;</span>, low_ram_device || !use_minfree_levels);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In default PSI mode override stall amounts using system properties */</span></span><br><span class="line">    <span class="keyword">if</span> (use_new_strategy) &#123;</span><br><span class="line">        <span class="comment">/* Do not use low pressure level */</span></span><br><span class="line">        psi_thresholds[VMPRESS_LEVEL_LOW].threshold_ms = <span class="number">0</span>;</span><br><span class="line">        psi_thresholds[VMPRESS_LEVEL_MEDIUM].threshold_ms = psi_partial_stall_ms;</span><br><span class="line">        psi_thresholds[VMPRESS_LEVEL_CRITICAL].threshold_ms = psi_complete_stall_ms;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">init_mp_psi</span>(VMPRESS_LEVEL_LOW, use_new_strategy)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">init_mp_psi</span>(VMPRESS_LEVEL_MEDIUM, use_new_strategy)) &#123;</span><br><span class="line">        <span class="built_in">destroy_mp_psi</span>(VMPRESS_LEVEL_LOW);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">init_mp_psi</span>(VMPRESS_LEVEL_CRITICAL, use_new_strategy)) &#123;</span><br><span class="line">        <span class="built_in">destroy_mp_psi</span>(VMPRESS_LEVEL_MEDIUM);</span><br><span class="line">        <span class="built_in">destroy_mp_psi</span>(VMPRESS_LEVEL_LOW);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数<code>mp_event_psi</code>最终会通过<code>PSI</code>的接口监听内存压力状态（<code>PSI</code>接口可以支持<code>poll</code>&#x2F;<code>epoll</code>等通用的方式进行监听），并注册一个监听的回调，在有状态变化时会调用<code>mp_event_psi</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">init_mp_psi</span><span class="params">(<span class="keyword">enum</span> vmpressure_level level, <span class="type">bool</span> use_new_strategy)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do not register a handler if threshold_ms is not set */</span></span><br><span class="line">    <span class="keyword">if</span> (!psi_thresholds[level].threshold_ms) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">init_psi_monitor</span>(psi_thresholds[level].stall_type,</span><br><span class="line">        psi_thresholds[level].threshold_ms * US_PER_MS,</span><br><span class="line">        PSI_WINDOW_SIZE_MS * US_PER_MS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vmpressure_hinfo[level].handler = use_new_strategy ? mp_event_psi : mp_event_common;</span><br><span class="line">    vmpressure_hinfo[level].data = level;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">register_psi_monitor</span>(epollfd, fd, &amp;vmpressure_hinfo[level]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">destroy_psi_monitor</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxevents++;</span><br><span class="line">    mpevfd[level] = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注册<code>psi</code>接口的核心函数<code>init_psi_monitor</code>, 主要功能是打开<code>/proc/pressure/memory</code>, 然后按照标准格式写入一个配置文件，用于设定内存压力阈值和监听时间窗口，并返回一个文件描述符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># &lt;some|full&gt; &lt;stall amount in us&gt; &lt;time window in us&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init_psi_monitor</span><span class="params">(<span class="keyword">enum</span> psi_stall_type stall_type,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">int</span> threshold_us, <span class="type">int</span> window_us)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">open</span>(PSI_PATH_MEMORY, O_WRONLY | O_CLOEXEC));</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;No kernel psi monitor support (errno=%d)&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (stall_type) &#123;</span><br><span class="line">    <span class="built_in">case</span> (PSI_SOME):</span><br><span class="line">    <span class="built_in">case</span> (PSI_FULL):</span><br><span class="line">        res = <span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%s %d %d&quot;</span>,</span><br><span class="line">            stall_type_name[stall_type], threshold_us, window_us);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Invalid psi stall type: %d&quot;</span>, stall_type);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res &gt;= (<span class="type">ssize_t</span>)<span class="built_in">sizeof</span>(buf)) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;%s line overflow for psi stall type &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">            PSI_PATH_MEMORY, stall_type_name[stall_type]);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;%s write failed for psi stall type &#x27;%s&#x27;; errno=%d&quot;</span>,</span><br><span class="line">            PSI_PATH_MEMORY, stall_type_name[stall_type], errno);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>内核一旦触发内存压力事件，会通过<code>mp_event_psi</code>注册的回调函数进行处理：首先根据当前设定的内存水位，判断系统是否处于低内存状态（剩余内存少或交换内存zram不足），如果是，则找出后台的低优先级任务，然后选择其中一个杀掉，释放部分内存。</p><blockquote><p>内存水位是根据每个内存区域的配置(<code>/proc/zoneinfo</code>)来判断的，有三个配置：<code>WMARK_MIN</code>、<code>WMARK_LOW</code> 和 <code>WMARK_HIGH</code>,分别对应内存压力的阈值，越低表示内存压力越大</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mp_event_psi</span><span class="params">(<span class="type">int</span> data, <span class="type">uint32_t</span> events, <span class="keyword">struct</span> polling_params *poll_params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">reclaim_state</span> &#123;</span><br><span class="line">        NO_RECLAIM = <span class="number">0</span>,</span><br><span class="line">        KSWAPD_RECLAIM,</span><br><span class="line">        DIRECT_RECLAIM,</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">clock_gettime</span>(CLOCK_MONOTONIC_COARSE, &amp;curr_tm) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Failed to get current time&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">record_wakeup_time</span>(&amp;curr_tm, events ? Event : Polling, &amp;wi);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> kill_pending = <span class="built_in">is_kill_pending</span>();</span><br><span class="line">    <span class="keyword">if</span> (kill_pending &amp;&amp; (kill_timeout_ms == <span class="number">0</span> ||</span><br><span class="line">        <span class="built_in">get_time_diff_ms</span>(&amp;last_kill_tm, &amp;curr_tm) &lt; <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(kill_timeout_ms))) &#123;</span><br><span class="line">        <span class="comment">/* Skip while still killing a process */</span></span><br><span class="line">        wi.skipped_wakeups++;</span><br><span class="line">        <span class="keyword">goto</span> no_kill;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Process is dead or kill timeout is over, stop waiting. This has no effect if pidfds are</span></span><br><span class="line"><span class="comment">     * supported and death notification already caused waiting to stop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">stop_wait_for_proc_kill</span>(!kill_pending);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vmstat_parse</span>(&amp;vs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Failed to parse vmstat!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Starting 5.9 kernel workingset_refault vmstat field was renamed workingset_refault_file */</span></span><br><span class="line">    workingset_refault_file = vs.field.workingset_refault ? : vs.field.workingset_refault_file;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">meminfo_parse</span>(&amp;mi) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Failed to parse meminfo!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset states after process got killed */</span></span><br><span class="line">    <span class="keyword">if</span> (killing) &#123;</span><br><span class="line">        killing = <span class="literal">false</span>;</span><br><span class="line">        cycle_after_kill = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/* Reset file-backed pagecache size and refault amounts after a kill */</span></span><br><span class="line">        base_file_lru = vs.field.nr_inactive_file + vs.field.nr_active_file;</span><br><span class="line">        init_ws_refault = workingset_refault_file;</span><br><span class="line">        thrashing_reset_tm = curr_tm;</span><br><span class="line">        prev_thrash_growth = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check free swap levels */</span></span><br><span class="line">    <span class="keyword">if</span> (swap_free_low_percentage) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!swap_low_threshold) &#123;</span><br><span class="line">            swap_low_threshold = mi.field.total_swap * swap_free_low_percentage / <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap_is_low = mi.field.free_swap &lt; swap_low_threshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Identify reclaim state */</span></span><br><span class="line">    <span class="keyword">if</span> (vs.field.pgscan_direct &gt; init_pgscan_direct) &#123;</span><br><span class="line">        init_pgscan_direct = vs.field.pgscan_direct;</span><br><span class="line">        init_pgscan_kswapd = vs.field.pgscan_kswapd;</span><br><span class="line">        reclaim = DIRECT_RECLAIM;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vs.field.pgscan_kswapd &gt; init_pgscan_kswapd) &#123;</span><br><span class="line">        init_pgscan_kswapd = vs.field.pgscan_kswapd;</span><br><span class="line">        reclaim = KSWAPD_RECLAIM;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (workingset_refault_file == prev_workingset_refault) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Device is not thrashing and not reclaiming, bail out early until we see these stats</span></span><br><span class="line"><span class="comment">         * changing</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">goto</span> no_kill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prev_workingset_refault = workingset_refault_file;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * It&#x27;s possible we fail to find an eligible process to kill (ex. no process is</span></span><br><span class="line"><span class="comment">     * above oom_adj_min). When this happens, we should retry to find a new process</span></span><br><span class="line"><span class="comment">     * for a kill whenever a new eligible process is available. This is especially</span></span><br><span class="line"><span class="comment">     * important for a slow growing refault case. While retrying, we should keep</span></span><br><span class="line"><span class="comment">     * monitoring new thrashing counter as someone could release the memory to mitigate</span></span><br><span class="line"><span class="comment">     * the thrashing. Thus, when thrashing reset window comes, we decay the prev thrashing</span></span><br><span class="line"><span class="comment">     * counter by window counts. If the counter is still greater than thrashing limit,</span></span><br><span class="line"><span class="comment">     * we preserve the current prev_thrash counter so we will retry kill again. Otherwise,</span></span><br><span class="line"><span class="comment">     * we reset the prev_thrash counter so we will stop retrying.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    since_thrashing_reset_ms = <span class="built_in">get_time_diff_ms</span>(&amp;thrashing_reset_tm, &amp;curr_tm);</span><br><span class="line">    <span class="keyword">if</span> (since_thrashing_reset_ms &gt; THRASHING_RESET_INTERVAL_MS) &#123;</span><br><span class="line">        <span class="type">long</span> windows_passed;</span><br><span class="line">        <span class="comment">/* Calculate prev_thrash_growth if we crossed THRASHING_RESET_INTERVAL_MS */</span></span><br><span class="line">        prev_thrash_growth = (workingset_refault_file - init_ws_refault) * <span class="number">100</span></span><br><span class="line">                            / (base_file_lru + <span class="number">1</span>);</span><br><span class="line">        windows_passed = (since_thrashing_reset_ms / THRASHING_RESET_INTERVAL_MS);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Decay prev_thrashing unless over-the-limit thrashing was registered in the window we</span></span><br><span class="line"><span class="comment">         * just crossed, which means there were no eligible processes to kill. We preserve the</span></span><br><span class="line"><span class="comment">         * counter in that case to ensure a kill if a new eligible process appears.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (windows_passed &gt; <span class="number">1</span> || prev_thrash_growth &lt; thrashing_limit) &#123;</span><br><span class="line">            prev_thrash_growth &gt;&gt;= windows_passed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Record file-backed pagecache size when crossing THRASHING_RESET_INTERVAL_MS */</span></span><br><span class="line">        base_file_lru = vs.field.nr_inactive_file + vs.field.nr_active_file;</span><br><span class="line">        init_ws_refault = workingset_refault_file;</span><br><span class="line">        thrashing_reset_tm = curr_tm;</span><br><span class="line">        thrashing_limit = thrashing_limit_pct;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Calculate what % of the file-backed pagecache refaulted so far */</span></span><br><span class="line">        thrashing = (workingset_refault_file - init_ws_refault) * <span class="number">100</span> / (base_file_lru + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Add previous cycle&#x27;s decayed thrashing amount */</span></span><br><span class="line">    thrashing += prev_thrash_growth;</span><br><span class="line">    <span class="keyword">if</span> (max_thrashing &lt; thrashing) &#123;</span><br><span class="line">        max_thrashing = thrashing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Refresh watermarks once per min in case user updated one of the margins.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> b/140521024 replace this periodic update with an API for AMS to notify LMKD</span></span><br><span class="line"><span class="comment">     * that zone watermarks were changed by the system software.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (watermarks.high_wmark == <span class="number">0</span> || <span class="built_in">get_time_diff_ms</span>(&amp;wmark_update_tm, &amp;curr_tm) &gt; <span class="number">60000</span>) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">zoneinfo</span> zi;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">zoneinfo_parse</span>(&amp;zi) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Failed to parse zoneinfo!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">calc_zone_watermarks</span>(&amp;zi, &amp;watermarks);</span><br><span class="line">        wmark_update_tm = curr_tm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find out which watermark is breached if any */</span></span><br><span class="line">    wmark = <span class="built_in">get_lowest_watermark</span>(&amp;mi, &amp;watermarks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">psi_parse_mem</span>(&amp;psi_data)) &#123;</span><br><span class="line">        critical_stall = psi_data.mem_stats[PSI_FULL].avg10 &gt; (<span class="type">float</span>)stall_limit_critical;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> move this logic into a separate function</span></span><br><span class="line"><span class="comment">     * Decide if killing a process is necessary and record the reason</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (cycle_after_kill &amp;&amp; wmark &lt; WMARK_LOW) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Prevent kills not freeing enough memory which might lead to OOM kill.</span></span><br><span class="line"><span class="comment">         * This might happen when a process is consuming memory faster than reclaim can</span></span><br><span class="line"><span class="comment">         * free even after a kill. Mostly happens when running memory stress tests.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        kill_reason = PRESSURE_AFTER_KILL;</span><br><span class="line">        <span class="built_in">strncpy</span>(kill_desc, <span class="string">&quot;min watermark is breached even after kill&quot;</span>, <span class="built_in">sizeof</span>(kill_desc));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level == VMPRESS_LEVEL_CRITICAL &amp;&amp; events != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Device is too busy reclaiming memory which might lead to ANR.</span></span><br><span class="line"><span class="comment">         * Critical level is triggered when PSI complete stall (all tasks are blocked because</span></span><br><span class="line"><span class="comment">         * of the memory congestion) breaches the configured threshold.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        kill_reason = NOT_RESPONDING;</span><br><span class="line">        <span class="built_in">strncpy</span>(kill_desc, <span class="string">&quot;device is not responding&quot;</span>, <span class="built_in">sizeof</span>(kill_desc));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (swap_is_low &amp;&amp; thrashing &gt; thrashing_limit_pct) &#123;</span><br><span class="line">        <span class="comment">/* Page cache is thrashing while swap is low */</span></span><br><span class="line">        kill_reason = LOW_SWAP_AND_THRASHING;</span><br><span class="line">        <span class="built_in">snprintf</span>(kill_desc, <span class="built_in">sizeof</span>(kill_desc), <span class="string">&quot;device is low on swap (%&quot;</span> PRId64</span><br><span class="line">            <span class="string">&quot;kB &lt; %&quot;</span> PRId64 <span class="string">&quot;kB) and thrashing (%&quot;</span> PRId64 <span class="string">&quot;%%)&quot;</span>,</span><br><span class="line">            mi.field.free_swap * page_k, swap_low_threshold * page_k, thrashing);</span><br><span class="line">        <span class="comment">/* Do not kill perceptible apps unless below min watermark or heavily thrashing */</span></span><br><span class="line">        <span class="keyword">if</span> (wmark &gt; WMARK_MIN &amp;&amp; thrashing &lt; thrashing_critical_pct) &#123;</span><br><span class="line">            min_score_adj = PERCEPTIBLE_APP_ADJ + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        check_filecache = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (swap_is_low &amp;&amp; wmark &lt; WMARK_HIGH) &#123;</span><br><span class="line">        <span class="comment">/* Both free memory and swap are low */</span></span><br><span class="line">        kill_reason = LOW_MEM_AND_SWAP;</span><br><span class="line">        <span class="built_in">snprintf</span>(kill_desc, <span class="built_in">sizeof</span>(kill_desc), <span class="string">&quot;%s watermark is breached and swap is low (%&quot;</span></span><br><span class="line">            PRId64 <span class="string">&quot;kB &lt; %&quot;</span> PRId64 <span class="string">&quot;kB)&quot;</span>, wmark &lt; WMARK_LOW ? <span class="string">&quot;min&quot;</span> : <span class="string">&quot;low&quot;</span>,</span><br><span class="line">            mi.field.free_swap * page_k, swap_low_threshold * page_k);</span><br><span class="line">        <span class="comment">/* Do not kill perceptible apps unless below min watermark or heavily thrashing */</span></span><br><span class="line">        <span class="keyword">if</span> (wmark &gt; WMARK_MIN &amp;&amp; thrashing &lt; thrashing_critical_pct) &#123;</span><br><span class="line">            min_score_adj = PERCEPTIBLE_APP_ADJ + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wmark &lt; WMARK_HIGH &amp;&amp; swap_util_max &lt; <span class="number">100</span> &amp;&amp;</span><br><span class="line">               (swap_util = <span class="built_in">calc_swap_utilization</span>(&amp;mi)) &gt; swap_util_max) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Too much anon memory is swapped out but swap is not low.</span></span><br><span class="line"><span class="comment">         * Non-swappable allocations created memory pressure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        kill_reason = LOW_MEM_AND_SWAP_UTIL;</span><br><span class="line">        <span class="built_in">snprintf</span>(kill_desc, <span class="built_in">sizeof</span>(kill_desc), <span class="string">&quot;%s watermark is breached and swap utilization&quot;</span></span><br><span class="line">            <span class="string">&quot; is high (%d%% &gt; %d%%)&quot;</span>, wmark &lt; WMARK_LOW ? <span class="string">&quot;min&quot;</span> : <span class="string">&quot;low&quot;</span>,</span><br><span class="line">            swap_util, swap_util_max);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wmark &lt; WMARK_HIGH &amp;&amp; thrashing &gt; thrashing_limit) &#123;</span><br><span class="line">        <span class="comment">/* Page cache is thrashing while memory is low */</span></span><br><span class="line">        kill_reason = LOW_MEM_AND_THRASHING;</span><br><span class="line">        <span class="built_in">snprintf</span>(kill_desc, <span class="built_in">sizeof</span>(kill_desc), <span class="string">&quot;%s watermark is breached and thrashing (%&quot;</span></span><br><span class="line">            PRId64 <span class="string">&quot;%%)&quot;</span>, wmark &lt; WMARK_LOW ? <span class="string">&quot;min&quot;</span> : <span class="string">&quot;low&quot;</span>, thrashing);</span><br><span class="line">        cut_thrashing_limit = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/* Do not kill perceptible apps unless thrashing at critical levels */</span></span><br><span class="line">        <span class="keyword">if</span> (thrashing &lt; thrashing_critical_pct) &#123;</span><br><span class="line">            min_score_adj = PERCEPTIBLE_APP_ADJ + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        check_filecache = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reclaim == DIRECT_RECLAIM &amp;&amp; thrashing &gt; thrashing_limit) &#123;</span><br><span class="line">        <span class="comment">/* Page cache is thrashing while in direct reclaim (mostly happens on lowram devices) */</span></span><br><span class="line">        kill_reason = DIRECT_RECL_AND_THRASHING;</span><br><span class="line">        <span class="built_in">snprintf</span>(kill_desc, <span class="built_in">sizeof</span>(kill_desc), <span class="string">&quot;device is in direct reclaim and thrashing (%&quot;</span></span><br><span class="line">            PRId64 <span class="string">&quot;%%)&quot;</span>, thrashing);</span><br><span class="line">        cut_thrashing_limit = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/* Do not kill perceptible apps unless thrashing at critical levels */</span></span><br><span class="line">        <span class="keyword">if</span> (thrashing &lt; thrashing_critical_pct) &#123;</span><br><span class="line">            min_score_adj = PERCEPTIBLE_APP_ADJ + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        check_filecache = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (check_filecache) &#123;</span><br><span class="line">        <span class="type">int64_t</span> file_lru_kb = (vs.field.nr_inactive_file + vs.field.nr_active_file) * page_k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (file_lru_kb &lt; filecache_min_kb) &#123;</span><br><span class="line">            <span class="comment">/* File cache is too low after thrashing, keep killing background processes */</span></span><br><span class="line">            kill_reason = LOW_FILECACHE_AFTER_THRASHING;</span><br><span class="line">            <span class="built_in">snprintf</span>(kill_desc, <span class="built_in">sizeof</span>(kill_desc),</span><br><span class="line">                <span class="string">&quot;filecache is low (%&quot;</span> PRId64 <span class="string">&quot;kB &lt; %&quot;</span> PRId64 <span class="string">&quot;kB) after thrashing&quot;</span>,</span><br><span class="line">                file_lru_kb, filecache_min_kb);</span><br><span class="line">            min_score_adj = PERCEPTIBLE_APP_ADJ + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* File cache is big enough, stop checking */</span></span><br><span class="line">            check_filecache = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Kill a process if necessary */</span></span><br><span class="line">    <span class="keyword">if</span> (kill_reason != NONE) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">kill_info</span> ki = &#123;</span><br><span class="line">            .kill_reason = kill_reason,</span><br><span class="line">            .kill_desc = kill_desc,</span><br><span class="line">            .thrashing = (<span class="type">int</span>)thrashing,</span><br><span class="line">            .max_thrashing = max_thrashing,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Allow killing perceptible apps if the system is stalled */</span></span><br><span class="line">        <span class="keyword">if</span> (critical_stall) &#123;</span><br><span class="line">            min_score_adj = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">psi_parse_io</span>(&amp;psi_data);</span><br><span class="line">        <span class="built_in">psi_parse_cpu</span>(&amp;psi_data);</span><br><span class="line">        <span class="type">int</span> pages_freed = <span class="built_in">find_and_kill_process</span>(min_score_adj, &amp;ki, &amp;mi, &amp;wi, &amp;curr_tm, &amp;psi_data);</span><br><span class="line">        <span class="keyword">if</span> (pages_freed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            killing = <span class="literal">true</span>;</span><br><span class="line">            max_thrashing = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (cut_thrashing_limit) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Cut thrasing limit by thrashing_limit_decay_pct percentage of the current</span></span><br><span class="line"><span class="comment">                 * thrashing limit until the system stops thrashing.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                thrashing_limit = (thrashing_limit * (<span class="number">100</span> - thrashing_limit_decay_pct)) / <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://source.android.com/docs/core/perf/lmkd?hl=zh-cn">https://source.android.com/docs/core/perf/lmkd?hl=zh-cn</a></li><li><a href="https://docs.kernel.org/accounting/psi.html">https://docs.kernel.org/accounting/psi.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;早前，&lt;code&gt;Android&lt;/code&gt;使用内核中的&lt;code&gt;lowmemorykiller&lt;/code&gt;驱动模块来监控系统内存，在内存不足时会主动杀掉某些非关键性的进程或者应用，从而减少系统的内存压力；自从内核版本&lt;code&gt;4.12&lt;/code&gt;之后，&lt;code&gt;lowmemorykiller&lt;/code&gt;从内核中移除了，因此&lt;code&gt;Android&lt;/code&gt;增加一个&lt;code&gt;lmkd(Low Memory Killer Daemon)&lt;/code&gt;来替代内核驱动用以监控系统内存状态，在系统处于内存高压状态时，主动清理部分内存，确保内存水位处于可接受的状态。那么，&lt;code&gt;LMKD&lt;/code&gt;又是如何获取系统内存压力状态的了？这个就要说到&lt;code&gt;PSI(Pressure stall information)&lt;/code&gt;这个内核模块了。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://sniffer.site/categories/Android/"/>
    
    
    <category term="PSI" scheme="https://sniffer.site/tags/PSI/"/>
    
    <category term="内存管理" scheme="https://sniffer.site/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="LMKD" scheme="https://sniffer.site/tags/LMKD/"/>
    
  </entry>
  
  <entry>
    <title>如何利用cgroups优化Android系统性能</title>
    <link href="https://sniffer.site/2024/04/15/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8cgroup%E4%BC%98%E5%8C%96Android%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD/"/>
    <id>https://sniffer.site/2024/04/15/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8cgroup%E4%BC%98%E5%8C%96Android%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD/</id>
    <published>2024-04-15T08:45:56.000Z</published>
    <updated>2024-06-07T09:14:43.868Z</updated>
    
    <content type="html"><![CDATA[<p><code>cgroups(Control Groups)</code>即控制分组，是<code>Linux</code>中的一种进程资源分组访问控制机制，用于将系统中的进程划分为不同的分组(形成一种树状层级的结构)，利用不同的分组可以实现对各个进程的资源使用，如CPU、IO、内存、网络等系统资源进行优先级管理，可以确保在系统资源紧张的情况下，高优先级的进程可以获得更多的系统资源。简单来说，通过<code>cgroups</code>，我们可以实现对系统资源的分配、访问优先级、访问限制以及管理、监控等更精细的控制，从而提升系统的性能。本文主要介绍<code>Android</code>系统如何利用<code>cgroups</code>来改善系统性能，主要分为以下几个部分：</p><ul><li>简单介绍<code>cgroup</code>的实现原理</li><li>Android中的<code>cgroup</code>分组管理策略</li><li>如何利用<code>cgroup</code>优化Android系统性能</li></ul><span id="more"></span><h2 id="cgroup的实现原理"><a href="#cgroup的实现原理" class="headerlink" title="cgroup的实现原理"></a><strong>cgroup的实现原理</strong></h2><p><code>Linux</code>内核在初始化时，会初始化<code>cgroup</code>相关的配置，创建一个根<code>cgroup</code>分组，并注册一个虚拟的文件系统挂载到<code>/sys/fs/cgroup</code>目录下，这样用户空间执行<code>mount</code>之后就可以通过这些接口进行相关的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cgroup_init_early - cgroup initialization at system boot</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Initialize cgroups at system boot, and initialize any</span></span><br><span class="line"><span class="comment"> * subsystems that request early init.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __init <span class="title function_">cgroup_init_early</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_fs_context</span> __<span class="title">initdata</span> <span class="title">ctx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys</span> *<span class="title">ss</span>;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">ctx.root = &amp;cgrp_dfl_root;</span><br><span class="line">init_cgroup_root(&amp;ctx);</span><br><span class="line">cgrp_dfl_root.cgrp.self.flags |= CSS_NO_REF;</span><br><span class="line"></span><br><span class="line">RCU_INIT_POINTER(init_task.cgroups, &amp;init_css_set);</span><br><span class="line"></span><br><span class="line">for_each_subsys(ss, i) &#123;</span><br><span class="line">WARN(!ss-&gt;css_alloc || !ss-&gt;css_free || ss-&gt;name || ss-&gt;id,</span><br><span class="line">     <span class="string">&quot;invalid cgroup_subsys %d:%s css_alloc=%p css_free=%p id:name=%d:%s\n&quot;</span>,</span><br><span class="line">     i, cgroup_subsys_name[i], ss-&gt;css_alloc, ss-&gt;css_free,</span><br><span class="line">     ss-&gt;id, ss-&gt;name);</span><br><span class="line">WARN(<span class="built_in">strlen</span>(cgroup_subsys_name[i]) &gt; MAX_CGROUP_TYPE_NAMELEN,</span><br><span class="line">     <span class="string">&quot;cgroup_subsys_name %s too long\n&quot;</span>, cgroup_subsys_name[i]);</span><br><span class="line"></span><br><span class="line">ss-&gt;id = i;</span><br><span class="line">ss-&gt;name = cgroup_subsys_name[i];</span><br><span class="line"><span class="keyword">if</span> (!ss-&gt;legacy_name)</span><br><span class="line">ss-&gt;legacy_name = cgroup_subsys_name[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ss-&gt;early_init)</span><br><span class="line">cgroup_init_subsys(ss, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前<code>Linux</code>内核中常用的<code>cgroup</code>有如下几种：</p><ul><li><code>cpuset</code>: 控制<code>CPU</code>核的分组，可以将指定的<code>CPU</code>核心分配到某个<code>cgroup</code>中，从而控制系统中的<code>CPU</code>资源的使用；要使用<code>cpuset</code>需要开启内核配置<code>CONFIG_CPUSETS</code></li><li><code>cpu</code>: 控制<code>CPU</code>分组调度，用于控制不同分组的调度时间片分配，确保高优先级的任务可以得到更多的时间片，对应的内核配置为<code>CONFIG_CGROUP_SCHED</code></li><li><code>cpuacct</code>: 用于控制不同分组的<code>CPU</code>使用状态统计，可以看到各个分组的<code>CPU</code>调度与使用状态数据，要使用<code>cpuacct</code>需要开启内核配置<code>CONFIG_CGROUP_CPUACCT</code></li><li><code>blkio</code>: 用于控制不同分组的磁盘<code>IO</code>资源的使用，比如保证前台的应用<code>IO</code>优先级与带宽，减少后台应用对系统<code>IO</code>的抢占，要使用<code>blkio</code>需要开启内核配置<code>CONFIG_BLK_CGROUP</code></li><li><code>memcg</code>: 控制不同分组的内存分配与使用，比如限制某些进程的内存使用量；比如在虚拟机的场景，限制虚拟机总的内存使用量；<code>memcg</code>对应的内存配置<code>CONFIG_MEMCG</code></li><li><code>freezer</code>: 冻结分组子系统，通常用于进程的冻结控制，比如系统资源紧张时，主动冻结后台的某些任务，减少系统资源压力，要使用<code>freezer</code>需要开启内核配置<code>CONFIG_FREEZER</code></li></ul><p><code>Android</code>的<code>cgroup</code>配置都放在描述文件<code>cgroups.json</code>（<code>/system/core/libprocessgroup/profiles/</code>）中进行配置，<code>init</code>进程启动的时候会主动读取该配置文件，然后将各个分组控制器挂载到<code>/dev/xxx</code>对应的节点下，比如<code>cpu</code>分组控制器对应的目录为<code>/dev/cpuctl</code>; <code>cpuset</code>对应的目录为<code>/dev/cpuset</code>; <code>memory</code>对应的目录为<code>/dev/memcg</code>. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">SetupCgroup</span><span class="params">(<span class="type">const</span> CgroupDescriptor&amp; descriptor)</span> &#123;</span><br><span class="line">    <span class="type">const</span> format::CgroupController* controller = descriptor.controller();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (controller-&gt;version() == <span class="number">2</span>) &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(controller-&gt;name(), CGROUPV2_CONTROLLER_NAME)) &#123;</span><br><span class="line">            <span class="comment">// /sys/fs/cgroup is created by cgroup2 with specific selinux permissions,</span></span><br><span class="line">            <span class="comment">// try to create again in case the mount point is changed</span></span><br><span class="line">            <span class="keyword">if</span> (!Mkdir(controller-&gt;path(), <span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">&quot;Failed to create directory for &quot;</span> &lt;&lt; controller-&gt;name() &lt;&lt; <span class="string">&quot; cgroup&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = mount(<span class="string">&quot;none&quot;</span>, controller-&gt;path(), <span class="string">&quot;cgroup2&quot;</span>, MS_NODEV | MS_NOEXEC | MS_NOSUID,</span><br><span class="line">                           nullptr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// selinux permissions change after mounting, so it&#x27;s ok to change mode and owner now</span></span><br><span class="line">            <span class="keyword">if</span> (!ChangeDirModeAndOwner(controller-&gt;path(), descriptor.mode(), descriptor.uid(),</span><br><span class="line">                                       descriptor.gid())) &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">&quot;Failed to create directory for &quot;</span> &lt;&lt; controller-&gt;name() &lt;&lt; <span class="string">&quot; cgroup&quot;</span>;</span><br><span class="line">                result = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Mkdir(controller-&gt;path(), descriptor.mode(), descriptor.uid(), descriptor.gid())) &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">&quot;Failed to create directory for &quot;</span> &lt;&lt; controller-&gt;name() &lt;&lt; <span class="string">&quot; cgroup&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (controller-&gt;flags() &amp; CGROUPRC_CONTROLLER_FLAG_NEEDS_ACTIVATION) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;+&quot;</span>) + controller-&gt;name();</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> path = <span class="built_in">std</span>::<span class="built_in">string</span>(controller-&gt;path()) + <span class="string">&quot;/cgroup.subtree_control&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!base::WriteStringToFile(str, path)) &#123;</span><br><span class="line">                    LOG(ERROR) &lt;&lt; <span class="string">&quot;Failed to activate controller &quot;</span> &lt;&lt; controller-&gt;name();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// mkdir &lt;path&gt; [mode] [owner] [group]</span></span><br><span class="line">        <span class="keyword">if</span> (!Mkdir(controller-&gt;path(), descriptor.mode(), descriptor.uid(), descriptor.gid())) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">&quot;Failed to create directory for &quot;</span> &lt;&lt; controller-&gt;name() &lt;&lt; <span class="string">&quot; cgroup&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unfortunately historically cpuset controller was mounted using a mount command</span></span><br><span class="line">        <span class="comment">// different from all other controllers. This results in controller attributes not</span></span><br><span class="line">        <span class="comment">// to be prepended with controller name. For example this way instead of</span></span><br><span class="line">        <span class="comment">// /dev/cpuset/cpuset.cpus the attribute becomes /dev/cpuset/cpus which is what</span></span><br><span class="line">        <span class="comment">// the system currently expects.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(controller-&gt;name(), <span class="string">&quot;cpuset&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// mount cpuset none /dev/cpuset nodev noexec nosuid</span></span><br><span class="line">            result = mount(<span class="string">&quot;none&quot;</span>, controller-&gt;path(), controller-&gt;name(),</span><br><span class="line">                           MS_NODEV | MS_NOEXEC | MS_NOSUID, nullptr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// mount cgroup none &lt;path&gt; nodev noexec nosuid &lt;controller&gt;</span></span><br><span class="line">            result = mount(<span class="string">&quot;none&quot;</span>, controller-&gt;path(), <span class="string">&quot;cgroup&quot;</span>, MS_NODEV | MS_NOEXEC | MS_NOSUID,</span><br><span class="line">                           controller-&gt;name());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">bool</span> optional = controller-&gt;flags() &amp; CGROUPRC_CONTROLLER_FLAG_OPTIONAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (optional &amp;&amp; errno == EINVAL) &#123;</span><br><span class="line">            <span class="comment">// Optional controllers are allowed to fail to mount if kernel does not support them</span></span><br><span class="line">            LOG(INFO) &lt;&lt; <span class="string">&quot;Optional &quot;</span> &lt;&lt; controller-&gt;name() &lt;&lt; <span class="string">&quot; cgroup controller is not mounted&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">&quot;Failed to mount &quot;</span> &lt;&lt; controller-&gt;name() &lt;&lt; <span class="string">&quot; cgroup&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除此之外，<code>init</code>初始化时，<code>Android</code>会创建各种cgroup分组，然后通过<code>rc</code>配置或者<code>Framework</code>的接口设置各个进程所在的分组状态。接下来我们就来详细看看<code>Android</code>对应的cgroup分组管理策略。</p><h2 id="Android中的cgroup分组管理策略"><a href="#Android中的cgroup分组管理策略" class="headerlink" title="Android中的cgroup分组管理策略"></a><strong>Android中的cgroup分组管理策略</strong></h2><p><code>Android</code>为了确保前台应用的资源使用，减少后台应用对资源的抢占，保证关键任务的执行与调度，增加了好几个进程分组:</p><ul><li><code>foreground</code>: 前台进程分组，大部分的应用都属于这个分组，包括系统服务、应用、桌面、系统UI等。</li><li><code>background</code>: 后台进程分组，系统的一些常驻后台进程，如<code>logd</code>等可以放在这个分组中</li><li><code>system-background</code>： 系统服务进程分组，Android一些关键系统服务可以放入该分组，如<code>update_engine</code>, <code>traced_perf</code>, <code>system_server</code>等都放在该分组中</li><li><code>top-app</code>: 系统交互进程分组，正在执行的系统交互的可见应用都会放入该分组，确保前台交互应用的资源优先级</li><li><code>camera-daemon</code>: 摄像头进程分组，摄像头相关的核心服务放入该进程，确保使用摄像头的进程资源分配的优先级</li></ul><p><code>Android</code>系统提供了<code>task_profiles.json</code>（<code>/system/core/libprocessgroup/profiles/</code>）任务配置文件描述进程或者线程要执行的特定操作；每组操作都与一个配件名称相关联，并且可以通过函数<code>SetTaskProfiles</code>&#x2F;<code>SetProcessProfiles</code>进行设置：</p><p>例如，原生的<code>task_profiles.json</code>文件:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MaxCapacityCPUs&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpuset&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;File&quot;</span><span class="punctuation">:</span> <span class="string">&quot;top-app/cpus&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UClampLatencySensitive&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;File&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpu.uclamp.latency_sensitive&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FreezerState&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;freezer&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;File&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cgroup.freeze&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;Profiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Frozen&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Actions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SetAttribute&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Params&quot;</span><span class="punctuation">:</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FreezerState&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HighPerformance&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Actions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JoinCgroup&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Params&quot;</span><span class="punctuation">:</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;foreground&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MaxPerformance&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Actions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JoinCgroup&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Params&quot;</span><span class="punctuation">:</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;top-app&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CameraServicePerformance&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Actions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JoinCgroup&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Params&quot;</span><span class="punctuation">:</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpu&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;camera-daemon&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ProcessCapacityLow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Actions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JoinCgroup&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Params&quot;</span><span class="punctuation">:</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpuset&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;background&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ProcessCapacityHigh&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Actions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JoinCgroup&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Params&quot;</span><span class="punctuation">:</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpuset&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;foreground&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HighIoPriority&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Actions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JoinCgroup&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Params&quot;</span><span class="punctuation">:</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blkio&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SFMainPolicy&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Actions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JoinCgroup&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Params&quot;</span><span class="punctuation">:</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpuset&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system-background&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PerfBoost&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Actions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SetClamps&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Params&quot;</span><span class="punctuation">:</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Boost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;50%&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Clamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LowMemoryUsage&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Actions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SetAttribute&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Params&quot;</span><span class="punctuation">:</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MemSoftLimit&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;16MB&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SetAttribute&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Params&quot;</span><span class="punctuation">:</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MemSwappiness&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;Value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;150&quot;</span></span><br><span class="line"></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;AggregateProfiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SCHED_SP_BACKGROUND&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Profiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;HighEnergySaving&quot;</span><span class="punctuation">,</span> <span class="string">&quot;LowIoPriority&quot;</span><span class="punctuation">,</span> <span class="string">&quot;TimerSlackHigh&quot;</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SCHED_SP_FOREGROUND&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Profiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;HighPerformance&quot;</span><span class="punctuation">,</span> <span class="string">&quot;HighIoPriority&quot;</span><span class="punctuation">,</span> <span class="string">&quot;TimerSlackNormal&quot;</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SCHED_SP_TOP_APP&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Profiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;MaxPerformance&quot;</span><span class="punctuation">,</span> <span class="string">&quot;MaxIoPriority&quot;</span><span class="punctuation">,</span> <span class="string">&quot;TimerSlackNormal&quot;</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SCHED_SP_SYSTEM&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Profiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;ServicePerformance&quot;</span><span class="punctuation">,</span> <span class="string">&quot;LowIoPriority&quot;</span><span class="punctuation">,</span> <span class="string">&quot;TimerSlackNormal&quot;</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>任务配置文件主要包括两个部分：<code>Attributes</code>和<code>Profiles</code>。<code>Attributes</code>部分描述了如何配置控制组的属性，主要包含如下内容：</p><ul><li><code>name</code>字段： 制定<code>Attribute</code>的名称</li><li><code>Controller</code>字段： 按照名称引用<code>cgroups.json</code>文件的<code>cgroup</code>控制器</li><li><code>File</code>字段：相应控制器下的特定文件</li></ul><p><code>Attributes</code>是任务配置文件定义中的引用；在任务配置文件之外，仅当框架需要直接访问相应文件且无法使用任务配置文件抽象访问时，才应使用属性。在所有其他情况下，应该使用任务配置文件；它们可以更好地分离所需行为及其实现详情。<code>Profiles</code>部分使用以下字段来包含任务配置文件定义：</p><ul><li><code>Name</code>字段：定义配置文件的名称</li><li><code>Actions</code>部分： 列出配置文件对应执行的一组操作。每项操作包含如下几项：<ul><li><code>Name</code>字段： 指定操作</li><li><code>Params</code>字段： 指定操作的一组参数</li></ul></li></ul><p>下表是常用的受支持的操作：</p><table><thead><tr><th>操作</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>SetTimerSlack</td><td>Slack</td><td>定时器可宽延时间(ns)</td></tr><tr><td>SetAttribute</td><td>Name&#x2F;Value</td><td>引用Attributes部分中某一个属性的名称和值</td></tr><tr><td>WriteFile</td><td>FilePath&#x2F;Value</td><td>文件的路径和要写入的文件值</td></tr><tr><td>JoinCgroup</td><td>Controller&#x2F;Path</td><td>指定控制组的名称和对应的cgroup路径</td></tr></tbody></table><p>Android12及以上的版本有一个<code>AggregateProfiles</code>项，包含了聚合的配置文件，每个聚合配置文件对应了一个或者多个配置文件的别名。其包含了两个部分的内容：</p><ul><li><code>Name</code>字段：定义聚合配置文件的名称</li><li><code>Profiles</code>字段： 聚合配置文件中包含的配置文件名称</li></ul><h2 id="利用cgroup优化Android系统性能"><a href="#利用cgroup优化Android系统性能" class="headerlink" title="利用cgroup优化Android系统性能"></a><strong>利用cgroup优化Android系统性能</strong></h2><p>Android提供了两种方式来控制进程的<code>cgroup</code>分组以及对应的优先级状态，一种是通过<code>init</code>脚本语言命令来设置，一种是通过<code>libprocessgroup</code>的接口来设置：</p><ul><li><code>init</code>脚本语言提供了一个<code>task_profiles</code>命令来设置进程的<code>cgroup</code>分组状态。<code>task_profiles</code>命令的格式如下：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">task_profiles MaxPerformance</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Android 12以下的版本也可以通过<code>writepid</code>来写入到对应的<code>cgroup</code>目录:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">writepid /dev/cpuctl/top-app/tasks</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>API</code>接口设置进程的<code>cgroup</code>分组状态: 为了保持兼容，Android 10及更高版本保留了<code>cutils/sched_policy.h</code>的接口：<code>set_cpuset_policy</code>、<code>set_sched_policy</code> 和 <code>get_sched_policy</code> ，但Android 10以上的版本已经将对应的接口全部移到了<code>libprocessgroup</code>中，因此建议使用<code>processgroup/sched_policy.h</code>的接口。</li></ul><p>那么，利用Android提供的<code>cgroup</code>机制，我们可以做哪些方面的性能优化了？<code>cgroup</code>的核心是资源的分配与控制，确保系统优先级的任务得到更多资源，从这个角度出发，我们可以大致有如下几个优化的方向：</p><ul><li>通过<code>cpu</code>的<code>cgroup</code>分组管理，合理分配系统大小核心，这对于移动端大小核的异构架构来说，尤其重要。例如，将<code>top-app</code>, <code>camera-daemon</code>相关的分组绑定到大核，而<code>backgroud</code>&#x2F;<code>system-backgroud</code>等分组绑定到小核，可以确保系统关键的任务得到更多资源，确保系统响应延迟</li><li>为了减少渲染延迟，可以适当的将<code>SurfaceFlinger</code>相关的线程与服务都尽量绑定到大核上，从而提升系统渲染的帧率，减少卡顿、丢帧</li><li>通过<code>blkio</code>分组，可以用来控制前后台的<code>I/O</code>资源使用，在系统高负载时限制后台的<code>I/O</code>资源使用，从而提高前台应用的<code>I/O</code>响应延迟</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://source.android.com/docs/core/perf/cgroups?hl=zh-cn">https://source.android.com/docs/core/perf/cgroups?hl=zh-cn</a></li><li><a href="https://en.wikipedia.org/wiki/ARM_big.LITTLE">https://en.wikipedia.org/wiki/ARM_big.LITTLE</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;cgroups(Control Groups)&lt;/code&gt;即控制分组，是&lt;code&gt;Linux&lt;/code&gt;中的一种进程资源分组访问控制机制，用于将系统中的进程划分为不同的分组(形成一种树状层级的结构)，利用不同的分组可以实现对各个进程的资源使用，如CPU、IO、内存、网络等系统资源进行优先级管理，可以确保在系统资源紧张的情况下，高优先级的进程可以获得更多的系统资源。简单来说，通过&lt;code&gt;cgroups&lt;/code&gt;，我们可以实现对系统资源的分配、访问优先级、访问限制以及管理、监控等更精细的控制，从而提升系统的性能。本文主要介绍&lt;code&gt;Android&lt;/code&gt;系统如何利用&lt;code&gt;cgroups&lt;/code&gt;来改善系统性能，主要分为以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单介绍&lt;code&gt;cgroup&lt;/code&gt;的实现原理&lt;/li&gt;
&lt;li&gt;Android中的&lt;code&gt;cgroup&lt;/code&gt;分组管理策略&lt;/li&gt;
&lt;li&gt;如何利用&lt;code&gt;cgroup&lt;/code&gt;优化Android系统性能&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Android" scheme="https://sniffer.site/categories/Android/"/>
    
    
    <category term="性能优化" scheme="https://sniffer.site/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="cgroups" scheme="https://sniffer.site/tags/cgroups/"/>
    
  </entry>
  
  <entry>
    <title>如何移植fio到Android平台</title>
    <link href="https://sniffer.site/2024/03/28/%E5%A6%82%E4%BD%95%E7%A7%BB%E6%A4%8Dfio%E5%88%B0Android%E5%B9%B3%E5%8F%B0/"/>
    <id>https://sniffer.site/2024/03/28/%E5%A6%82%E4%BD%95%E7%A7%BB%E6%A4%8Dfio%E5%88%B0Android%E5%B9%B3%E5%8F%B0/</id>
    <published>2024-03-28T12:01:20.000Z</published>
    <updated>2024-03-31T10:06:11.900Z</updated>
    
    <content type="html"><![CDATA[<p>fio是一个广泛使用的磁盘性能测试工具，功能强大，可以用于测试磁盘性能，也可以通过<code>I/O</code>重放来模拟用户的实际请求，其主要有如下几个特点:</p><ul><li>支持多种文件系统，包括NTFS，ext4，btrfs，xfs等</li><li>支持多种IO模式，包括randwrite，read，write，dd，trim，flush，discard等<span id="more"></span></li><li>fio可以测试不同类型的IO，包括随机写，连续写，顺序写，随机读，连续读，顺序读等</li><li>另外<code>fio</code>还支持I&#x2F;O限制，可以限制IO带宽，IO延迟，IO吞吐量等</li></ul><p>这篇文章，我们将介绍如何移植<code>fio</code>到Android平台，以及常见的使用方法。首先来看看如何通过交叉编译移植<code>fio</code>。</p><h2 id="编译准备"><a href="#编译准备" class="headerlink" title="编译准备"></a><strong>编译准备</strong></h2><p>首先到<code>fio</code>的官方网站<code>https://github.com/axboe/fio</code>下载源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/axboe/fio</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果本地没有安装过NDK，需要下载NDK:<a href="https://developer.android.google.cn/ndk/downloads?hl=zh-cn%EF%BC%9B%E7%84%B6%E5%90%8E%E8%AE%BE%E5%AE%9ANDK%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%9A">https://developer.android.google.cn/ndk/downloads?hl=zh-cn；然后设定NDK的环境变量：</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">export</span> NDK_HOME=/path/to/ndk</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a><strong>编译代码</strong></h2><p>在编译之前，先通过<code>./configure --help</code>看看编译配置具体有哪些参数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">./configure --<span class="built_in">help</span></span><br><span class="line">--prefix=               Use this directory as installation prefix</span><br><span class="line">--cpu=                  Specify target CPU <span class="keyword">if</span> auto-detect fails</span><br><span class="line">--cc=                   Specify compiler to use</span><br><span class="line">--extra-cflags=         Specify extra CFLAGS to pass to compiler</span><br><span class="line">--build-32bit-win       Enable 32-bit build on Windows</span><br><span class="line">--target-win-ver=       Minimum version of Windows to target (only accepts 7)</span><br><span class="line">--enable-pdb            Enable Windows PDB symbols generation (needs clang/lld)</span><br><span class="line">--build-static          Build a static fio</span><br><span class="line">--esx                   Configure build options <span class="keyword">for</span> esx</span><br><span class="line">--enable-gfio           Enable building of gtk gfio</span><br><span class="line">--disable-numa          Disable libnuma even <span class="keyword">if</span> found</span><br><span class="line">--disable-rdma          Disable RDMA support even <span class="keyword">if</span> found</span><br><span class="line">--disable-rados         Disable Rados support even <span class="keyword">if</span> found</span><br><span class="line">--disable-rbd           Disable Rados Block Device even <span class="keyword">if</span> found</span><br><span class="line">--disable-http          Disable HTTP support even <span class="keyword">if</span> found</span><br><span class="line">--disable-gfapi         Disable gfapi</span><br><span class="line">--enable-libhdfs        Enable hdfs support</span><br><span class="line">--enable-libnfs         Enable nfs support</span><br><span class="line">--disable-libnfs        Disable nfs support</span><br><span class="line">--disable-lex           Disable use of lex/yacc <span class="keyword">for</span> math</span><br><span class="line">--disable-pmem          Disable pmem based engines even <span class="keyword">if</span> found</span><br><span class="line">--enable-lex            Enable use of lex/yacc <span class="keyword">for</span> math</span><br><span class="line">--disable-shm           Disable SHM support</span><br><span class="line">--disable-optimizations Don<span class="string">&#x27;t enable compiler optimizations</span></span><br><span class="line"><span class="string">--enable-cuda           Enable GPUDirect RDMA support</span></span><br><span class="line"><span class="string">--enable-libcufile      Enable GPUDirect Storage cuFile support</span></span><br><span class="line"><span class="string">--disable-native        Don&#x27;</span>t build <span class="keyword">for</span> native host</span><br><span class="line">--with-ime=             Install path <span class="keyword">for</span> DDN<span class="string">&#x27;s Infinite Memory Engine</span></span><br><span class="line"><span class="string">--enable-libiscsi       Enable iscsi support</span></span><br><span class="line"><span class="string">--enable-libnbd         Enable libnbd (NBD engine) support</span></span><br><span class="line"><span class="string">--disable-xnvme         Disable xnvme support even if found</span></span><br><span class="line"><span class="string">--disable-isal          Disable isal support even if found</span></span><br><span class="line"><span class="string">--disable-libblkio      Disable libblkio support even if found</span></span><br><span class="line"><span class="string">--disable-libzbc        Disable libzbc even if found</span></span><br><span class="line"><span class="string">--disable-tcmalloc      Disable tcmalloc support</span></span><br><span class="line"><span class="string">--dynamic-libengines    Lib-based ioengines as dynamic libraries</span></span><br><span class="line"><span class="string">--disable-dfs           Disable DAOS File System support even if found</span></span><br><span class="line"><span class="string">--enable-asan           Enable address sanitizer</span></span><br><span class="line"><span class="string">--seed-buckets=         Number of seed buckets for the refill-buffer</span></span><br><span class="line"><span class="string">--disable-tlsDisable __thread local storage</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>具体需要哪些选项，我们可以根据需要来进行选择与配置。为了便于编译，我们写一个简单的编译脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">UNAME=Android</span><br><span class="line">ARCH=arm64</span><br><span class="line">CPU=aarch64</span><br><span class="line">API=26</span><br><span class="line">PREFIX=$(<span class="built_in">pwd</span>)/Android/<span class="variable">$CPU</span></span><br><span class="line">CROSS_COMPILE=<span class="variable">$NDK_HOME</span>/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android<span class="variable">$API</span>-</span><br><span class="line">CC=<span class="variable">$NDK_HOME</span>/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android<span class="variable">$API</span>-clang</span><br><span class="line"><span class="comment">#CROSS_PREFIX=$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android$API-</span></span><br><span class="line"></span><br><span class="line">./configure --prefix=<span class="variable">$PREFIX</span> --cpu=<span class="variable">$CPU</span> --cc=<span class="variable">$CC</span> --build-static --disable-numa</span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">make V=1 UNAME=<span class="variable">$UNAME</span> CROSS_COMPILE=<span class="variable">$CROSS_COMPILE</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行上述脚本发现没在配置阶段会提示错误: 交叉编译工具使用的是 <code>gcc</code>, 而看NDK的工具都是 <code>clang</code> 的，需要修改下配置：</p><ul><li>由于当前NDK都采用 <code>clang</code>, 但 <code>fio</code>源码配置文件默认是 <code>gcc</code>的编译器，因此需要修改下 <code>configure</code>  文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/configure b/configure</span><br><span class="line">index 420d97db..c245bcd9 100755</span><br><span class="line">--- a/configure</span><br><span class="line">+++ b/configure</span><br><span class="line">@@ -350,7 +350,7 @@ <span class="keyword">if</span> <span class="built_in">test</span> -z <span class="string">&quot;<span class="variable">$&#123;CC&#125;</span><span class="variable">$&#123;cross_prefix&#125;</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">     cc=clang</span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">-  cc=<span class="string">&quot;<span class="variable">$&#123;CC-<span class="variable">$&#123;cross_prefix&#125;</span>gcc&#125;</span>&quot;</span></span><br><span class="line">+  cc=<span class="string">&quot;<span class="variable">$&#123;CC-<span class="variable">$&#123;cross_prefix&#125;</span>clang&#125;</span>&quot;</span></span><br><span class="line"> <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>修改完后，再次编译还是会提示错误:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In file included from engines/io_uring.c:29:</span><br><span class="line">engines/nvme.h:18:8: error: redefinition of <span class="string">&#x27;nvme_uring_cmd&#x27;</span></span><br><span class="line">struct nvme_uring_cmd &#123;</span><br><span class="line">       ^</span><br><span class="line">/home/jason/Android/Sdk/ndk/26.1.10909125/toolchains/llvm/prebuilt/linux-x86_64/bin/../sysroot/usr/include/linux/nvme_ioctl.h:80:8: note: previous definition is here</span><br><span class="line">struct nvme_uring_cmd &#123;</span><br><span class="line">       ^</span><br><span class="line">1 error generated.</span><br><span class="line">make: *** [Makefile:526: engines/io_uring.o] Error 1</span><br></pre></td></tr></table></figure><p>看代码是由于重复定义导致了， fio的源码里有一个地方重新定义了, 因此需要针对Android平台做判断, 照例修改下 <code>configure</code>的配置即可:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * If the uapi headers installed on the system lacks nvme uring <span class="built_in">command</span></span><br><span class="line"> * support, use the <span class="built_in">local</span> version to prevent compilation issues.</span><br><span class="line"> */</span><br><span class="line"><span class="comment">#ifndef CONFIG_NVME_URING_CMD</span></span><br><span class="line">struct nvme_uring_cmd &#123;</span><br><span class="line">__u8opcode;</span><br><span class="line">__u8flags;</span><br><span class="line">__u16rsvd1;</span><br><span class="line">__u32nsid;</span><br><span class="line">__u32cdw2;</span><br><span class="line">__u32cdw3;</span><br><span class="line">__u64metadata;</span><br><span class="line">__u64addr;</span><br><span class="line">__u32metadata_len;</span><br><span class="line">__u32data_len;</span><br><span class="line">__u32cdw10;</span><br><span class="line">__u32cdw11;</span><br><span class="line">__u32cdw12;</span><br><span class="line">__u32cdw13;</span><br><span class="line">__u32cdw14;</span><br><span class="line">__u32cdw15;</span><br><span class="line">__u32timeout_ms;</span><br><span class="line">__u32   rsvd2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>找到生成 <code>CONFIG_NVME_URING_CMD</code>的地方，增加对 <code>Android</code>的判断即可:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@@ -2656,7 +2656,7 @@ <span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$libzbc</span>&quot;</span> != <span class="string">&quot;no&quot;</span> ; <span class="keyword">then</span></span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"> print_config <span class="string">&quot;libzbc engine&quot;</span> <span class="string">&quot;<span class="variable">$libzbc</span>&quot;</span></span><br><span class="line"> </span><br><span class="line">-<span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$targetos</span>&quot;</span> = <span class="string">&quot;Linux&quot;</span> ; <span class="keyword">then</span></span><br><span class="line">+<span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$targetos</span>&quot;</span> = <span class="string">&quot;Linux&quot;</span> || <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$targetos</span>&quot;</span> = <span class="string">&quot;Android&quot;</span>; <span class="keyword">then</span></span><br><span class="line"> <span class="comment">##########################################</span></span><br><span class="line"> <span class="comment"># Check NVME_URING_CMD support</span></span><br><span class="line"> <span class="built_in">cat</span> &gt; <span class="variable">$TMPC</span> &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string"> </span></span><br></pre></td></tr></table></figure><p>这一次编译正常了，可以看到有生成可执行文件，将其push到Android设备，可以正常执行。</p><h2 id="如何使用fio"><a href="#如何使用fio" class="headerlink" title="如何使用fio"></a>如何使用<code>fio</code></h2><p><code>fio</code>的命令主要有两个部分，一部分是参数，一部分是测试的配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fio [options] [jobfile] ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数用于设置<code>fio</code>以及输出一些调试信息，而真正让<code>fio</code>运行的是<code>jobfile</code>，用于指定运行时的测试参数，包括如下几个部分:</p><ul><li>I&#x2F;O的类型： 指定读写模式，比如是顺序读还是随机读等，比如是否使用直接I&#x2F;O(<code>direct I/O</code>)</li><li>读写块大小： 指定读写块大小，比如是4k还是64k</li><li>读写的总文件大小： 指定文件大小，比如是1G还是10G</li><li>I&#x2F;O引擎: 使用共享内存的方式还是普通的读写操作</li><li>I&#x2F;O深度： 对于使用异步I&#x2F;O引擎的情况，指定I&#x2F;O队列的大小</li><li>目标文件与设备： 指定测试需要执行的文件或者设备</li><li>线程或进程： 指定测试需要执行的线程数量</li></ul><p>比如如果我们需要测试某个磁盘的性能可以使用直接模式，具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fio -direct=1 -iodepth=1 -thread -rw=randwrite -ioengine=psync -bs=16k -size=10G -numjobs=10 -runtime=1000 -group_reporting -name=fio-test</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试完成后，<code>fio</code>会生成报告, 包括<code>I/O</code>带宽，读写的速度以及<code>I/O</code>延迟等:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Jobs: 10 (f=10): [w(10)][85.7%][w=1829MiB/s][w=117k IOPS][eta 00m:01s]</span><br><span class="line">fio-test: (groupid=0, <span class="built_in">jobs</span>=10): err= 0: pid=16991: Sun Mar 31 18:03:08 2024</span><br><span class="line">  write: IOPS=95.3k, BW=1489MiB/s (1562MB/s)(10.0GiB/6875msec); 0 zone resets</span><br><span class="line">    clat (usec): min=14, max=545565, avg=101.30, stdev=3043.89</span><br><span class="line">     lat (usec): min=14, max=545569, avg=103.13, stdev=3043.92</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[   24],  5.00th=[   28], 10.00th=[   32], 20.00th=[   38],</span><br><span class="line">     | 30.00th=[   45], 40.00th=[   53], 50.00th=[   58], 60.00th=[   61],</span><br><span class="line">     | 70.00th=[   64], 80.00th=[   68], 90.00th=[   74], 95.00th=[   86],</span><br><span class="line">     | 99.00th=[  668], 99.50th=[ 2278], 99.90th=[ 4817], 99.95th=[ 5342],</span><br><span class="line">     | 99.99th=[ 6587]</span><br><span class="line">   bw (  MiB/s): min=    0, max= 1947, per=98.94%, avg=1473.64, stdev=65.83, samples=130</span><br><span class="line">   iops        : min=   20, max=124616, avg=94312.77, stdev=4213.24, samples=130</span><br><span class="line">  lat (usec)   : 20=0.12%, 50=35.96%, 100=60.59%, 250=2.20%, 500=0.09%</span><br><span class="line">  lat (usec)   : 750=0.06%, 1000=0.16%</span><br><span class="line">  lat (msec)   : 2=0.20%, 4=0.40%, 10=0.22%, 20=0.01%, 250=0.01%</span><br><span class="line">  lat (msec)   : 750=0.01%</span><br><span class="line">  cpu          : usr=4.98%, sys=37.83%, ctx=664271, majf=0, minf=0</span><br><span class="line">  IO depths    : 1=100.0%, 2=0.0%, 4=0.0%, 8=0.0%, 16=0.0%, 32=0.0%, &gt;=64=0.0%</span><br><span class="line">     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%</span><br><span class="line">     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%</span><br><span class="line">     issued rwts: total=0,655360,0,0 short=0,0,0,0 dropped=0,0,0,0</span><br><span class="line">     latency   : target=0, window=0, percentile=100.00%, depth=1</span><br><span class="line"></span><br><span class="line">Run status group 0 (all <span class="built_in">jobs</span>):</span><br><span class="line">  WRITE: bw=1489MiB/s (1562MB/s), 1489MiB/s-1489MiB/s (1562MB/s-1562MB/s), io=10.0GiB (10.7GB), run=6875-6875msec</span><br><span class="line"></span><br><span class="line">Disk stats (<span class="built_in">read</span>/write):</span><br><span class="line">  nvme0n1: ios=0/628636, sectors=0/20133840, merge=0/2245, ticks=0/40603, in_queue=41130, util=96.51%</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://fio.readthedocs.io/en/latest/fio_doc.html">https://fio.readthedocs.io/en/latest/fio_doc.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;fio是一个广泛使用的磁盘性能测试工具，功能强大，可以用于测试磁盘性能，也可以通过&lt;code&gt;I/O&lt;/code&gt;重放来模拟用户的实际请求，其主要有如下几个特点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持多种文件系统，包括NTFS，ext4，btrfs，xfs等&lt;/li&gt;
&lt;li&gt;支持多种IO模式，包括randwrite，read，write，dd，trim，flush，discard等</summary>
    
    
    
    <category term="Android" scheme="https://sniffer.site/categories/Android/"/>
    
    
    <category term="fio" scheme="https://sniffer.site/tags/fio/"/>
    
    <category term="文件系统" scheme="https://sniffer.site/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="性能工具" scheme="https://sniffer.site/tags/%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>你好,2024</title>
    <link href="https://sniffer.site/2024/01/30/%E4%BD%A0%E5%A5%BD,2024/"/>
    <id>https://sniffer.site/2024/01/30/%E4%BD%A0%E5%A5%BD,2024/</id>
    <published>2024-01-29T23:08:50.000Z</published>
    <updated>2024-02-26T10:10:42.901Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Nothing is easier than self-deceit. For what each man wishes, that he also believes to be true(人们善于自欺，人们想得到什么，就会相信什么)</p><p>  德摩斯梯尼（Demosthenes，古希腊）</p></blockquote><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/new-year-fireworks.jpg" alt="new year fireworks"></p><span id="more"></span><p>一晃眼，2024年已经过去一个月了，一直想写下2023年的总结，却因为各种事情迟迟没有动笔。2023发生了太多事情，想说点什么，却又无从说起。回想起来，各种事情却又历历在目:</p><ul><li>母亲今年开始一直开始头痛，国庆期间抽空回老家陪老妈去了一趟医院，所幸的是检查结果是良性的血管瘤，并没有大碍，修养调理下应该问题不大。这件事让我真正感到所谓上有老，下有小的压力与责任。</li><li>小宝贝开始进入幼儿园学习了，开始了全新的阶段，总体上说，她适应的不错，事实证明很多之前的担忧都是多余的；在陪伴小宝贝成长的过程中，我逐渐意识到，很多发生在儿女身上的问题，往往不是她自身有什么问题，问题的本质来源于家庭，来源于父母自己，来源于错误的观念。如果我多尝试站在女儿的角度思考某些问题，重新审视很多的事情，许多所谓的问题都会烟消云散。父母与儿女的冲突根源在于权力的不对等，为人父母总想用自己所谓的权威与身体上的强大来压制儿女的某些行为，结果只会让彼此更痛苦、难受。真正的爱首先是接纳，然后是理解与包容。我爱小宝贝，那么，我首先需要做的是接纳她的个性，接纳她身上所谓的<code>毛病</code>，然后理解她，用真情真心去陪伴她一起成长。我需要融入她的生活与思维，忘掉烙印在自己身上的各种身份，做一个引路人而不是主导者。</li><li>去年下旬，业内的一个技术大佬左耳朵耗子叔因为突发心肌梗塞去世了，真的非常难以置信；他去世前几天我还在看他的博文，字里行间可以感受到他对于技术的热爱，没料到翌日人就没了，真是伤心又难过。不得不感慨，人的生命其实非常脆弱，步入中年，身体在长年累月的工作与压力之下，是疾病的高发期。这也给我们做技术的人一个警醒，工作挣钱固然重要，更重要的是有一个健康的身体。</li><li>想了很久，还是离开了工作多年的公司，见证了公司曲折的创业历程，经历了从第一个产品推出到公司上市，非常难得的经历，有许多的不舍，但是考虑到自己职业生涯的发展，还是决定跳出当前的技术舒适圈，去寻求更大的突破。祝愿公司在未来的发展中百舸争流，再创辉煌。</li><li>阅读量较之前多了不少，可回想来看，阅读质量却没有太多的提升。印象比较深的是&lt;稻盛和夫的哲学&gt;、&lt;哲学之树-通往自我认知的哲学课&gt;、&lt;思考快与慢&gt;、&lt;史蒂夫-乔布斯传&gt;、&lt;认识大脑-关于大脑的7 1&#x2F;2课&gt;，其他的则只有一些很模糊的印象。阅读，在很大程度上是作者与读者之间的心灵交流，如果两方的思维方式差异较大，有时确实很难真正理解书中的思想与观点；总结下来，想要提升阅读的质量，一方面是要提升阅读技巧，要学会做阅读笔记，把阅读时的所思所想都记录下来；更多的还是要改善自己的思维方式，变换自己的观念，才能真正有所收获。</li></ul><p>生活曲曲折折，2023思考更多的是活着的意义与人生而为人的价值。前段时间看辽宁的一个名叫柏剑老师，十年如一日坚持不懈通过体育锻炼来培养一群问题少年的故事，十分感慨；与此同时，又看到某地的贪官私藏大量现金的新闻。联系起来看，不禁要问，人与人之间何以有如此大的差异了？从本质上来说，这些抉择的背后体现的就是一个人的价值观与世界观。这眼花缭乱的世界，一个人生命的意义与价值究竟在哪里？</p><p>如果从整个宇宙范围来说，人生其实是没有意义的，所有的意义都会指向一个空-即死亡；死亡之后，就是空，就是虚无。但人活着，有荷尔蒙，便会有欲望，有好奇心，有探索的渴求，正是身体里的这些化学的荷尔蒙驱动了我们的行为，塑造着我们独特的个性。回到生活本身，如果我们只是为身体的荷尔蒙驱使，被自己的意识与观念驱动，那本质上来说，我们只是自己的思维与欲望的囚徒，一个困在自然进化牢笼中的囚徒而已。欲望是一种枷锁，所有通过努力来获取到的财富、金钱、地位、名利以及身体的满足都是一种无形的枷锁，如果我们不去反思，不假思索的接受现实，无疑我们是在自我欺骗罢了。譬如，那些拼了命捞钱的贪官污吏，财迷心窍，最终也不过是让金钱、名利困住，成为一个监守自盗的人；那些努力通过流量与各种宣传话术来挣钱的主播，一旦丧失自己的内心的道德底线，最终不过是给自己戴上一个牢笼而已。</p><p>生命也好，生活也罢，真正难的是平衡，是平衡的智慧；是内心里对于现实的认知的平衡，不自欺，不自弃。做到不自欺，不自弃，我们才有可能真正迈向智慧的台阶，让自己生活快乐、轻松、淡定，平和。面向2024，也希望自己能做到不自欺，不自弃，踏踏实实过好每一天，成为一个更好的父亲，一个更好的老公，一个更好的人。以下几点自勉，与大家共勉。</p><ul><li>学会爱:不仅仅是要爱身边的人，也要学会爱自己；学会感受别人的爱，学会感受自然的一切馈赠。培养的爱的能力，保持自省与自律，做一个有智慧的人。</li><li>发现价值，创造价值: 工作不仅仅是赚取一份收入，也是体现自我价值的地方。做一件事，不能只关注短期的收益，也要努力思考背后的价值，看到背后更长远的收益；保持开放的视野，点滴积累，厚积薄发。</li><li>读书与思考：阅读让人平静，在如今被各种短视频充斥的媒体时代，时间被割裂成碎片，我们已很难专注的进行深度思考。多去阅读，保持思考，保持定力。</li><li>发现身体的价值: 在思维与认知上倾注了太多的精力、时间，身体太容易被忽略；只有当身体出现各种疾病症状时，我们才可能意识到身体的价值。人到中年，见多了生老病死，才慢慢发现，身体的价值可能远比想象的要大。我们要关注身体的信号，减少对身体的消耗-熬夜、通宵、不运动、饮食不规律。学着做身体的朋友，关心与呵护她。</li></ul><p>2023，再见；你好，2024！</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;Nothing is easier than self-deceit. For what each man wishes, that he also believes to be true(人们善于自欺，人们想得到什么，就会相信什么)&lt;/p&gt;
&lt;p&gt;  德摩斯梯尼（Demosthenes，古希腊）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://md-files.oss-cn-shenzhen.aliyuncs.com/new-year-fireworks.jpg&quot; alt=&quot;new year fireworks&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="https://sniffer.site/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="成长" scheme="https://sniffer.site/tags/%E6%88%90%E9%95%BF/"/>
    
    <category term="价值" scheme="https://sniffer.site/tags/%E4%BB%B7%E5%80%BC/"/>
    
    <category term="探索" scheme="https://sniffer.site/tags/%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>认识你的大脑</title>
    <link href="https://sniffer.site/2023/11/26/%E8%AE%A4%E8%AF%86%E4%BD%A0%E7%9A%84%E5%A4%A7%E8%84%91/"/>
    <id>https://sniffer.site/2023/11/26/%E8%AE%A4%E8%AF%86%E4%BD%A0%E7%9A%84%E5%A4%A7%E8%84%91/</id>
    <published>2023-11-26T04:37:04.000Z</published>
    <updated>2023-11-28T01:17:22.658Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>If we spoke a different language, we would perceive a somewhat differenet world.</p><pre><code>Ludwig Wittgenstein</code></pre></blockquote><p> <img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/high-tech-brain.jpg" alt="Your high tech brain"></p> <span id="more"></span><p> 一直对大脑的构造与运作机制比较感兴趣，想花点时间了解人类思维与意识的奥秘。前段时间，从图书馆借了<code>Eisa Feldman Barrett</code>写的一本比较薄的有关大脑的书<code>认识大脑-关于大脑的7 1/2堂课</code>，通俗易懂，也澄清了认知上的一些误解与疑惑。基于这本书的内容，结合自己这几年的思考与经历，有一些想法与心得，在这里一并写下来。有很多地方比较粗浅，有错误的地方，还请大家指正。</p><blockquote><p>我们的每一个想法，每一种快乐、愤怒或者敬畏的感觉，我们给予或者接受的每一个拥抱，释放的每一个善意，承受的每一次侮辱，都类似从身体预算中存款或者取款，我们往往意识不到，而实际一切都在发生。认清这一点，对理解大脑如何工作，以及如何保持健康，活的更长，更有意义至关重要。</p></blockquote><p>大脑的诞生并不是用于思考的，大脑是为生存而演化出来的复杂计算系统。在几亿年前，地球上并不存在有大脑的生物；当时的海洋中，有文昌鱼这种无脊椎动物，它们的神经系统非常单一，仅有一小团细胞（并不能称为大脑）；没有味觉与嗅觉器官，文昌鱼就是靠着简单的感知能力在海底生存了近5.5亿年。那么，地球上为什么会出现有大脑的生物了？进化论认为，这是源自生物的生存竞争与自然选择。在激烈的生存竞争中，那些拥有更快反应速度、更强大感知能力、更高的能效比的生物具备更好的生存能力，有更大的几率生存下来；而大脑正是用于调节生物内部能量效率的计算中心。对人类来说同样如此，大脑首先是一个为生存而演化出来的器官。人类的大脑会准确预算每个行为需要消耗的能量，为每个行为储备水、盐和葡萄糖等资源：你所采取的每一步行动都是一种带有经济考虑的选择-大脑会预测什么时候消耗资源，什么时候节省资源。所有动物，包括人类都学会了从过去的行为中学习如何预测下一次行动，如果过去的行为带来了好处，比如一次成功的逃脱或享受一顿美餐，那么它们就会重复过去的行为；大脑会通过某种方式唤起过去的经历，让身体为行动做好准备。</p><blockquote><p>柏拉图认为，人类的思维是一场三股不同力量之间持续不断地战争: 第一股力量是生存，代表饥饿与身体的欲望；第二股力量是情绪，如喜悦、愤怒和恐惧；第三种力量是理性思维。后来，有科学家根据这一类观点发展出三重脑理论，认为人的大脑有三层，一层负责生存（对应脑干），一层用来感受（对应边缘系统），一层用来思考（对应新皮质）。</p></blockquote><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/three-brain-theory.png" alt="三重大脑结构"></p><p>单纯就大脑的大小，人类的大脑确实比一般的动物，如老鼠，鱼类，蜥蜴，猕猴都要大得多，结构上也似乎不太相同。但最近的科学研究发现，所有哺乳动物的大脑发育都遵从同一个计划（爬行动物与其他脊椎动物的大脑也可能遵从类似的构造模式）：哺乳动物的大脑神经元的形成顺序是可预测的。区分在于，不同动物在构造的不同阶段所花费的时间不同而已，不同部分的大脑大小不一样罢了。因此，我们会看到人类有一个很大的新皮质，而老鼠的相对比较小。从这个角度来说，人类的大脑没有新增的部分-我们大脑中的神经元不仅可以在其他哺乳动物的大脑中发现，也可以在其他脊椎动物中被找到。人类的大脑并没有特别的地方；人类只是一种有趣的动物，具有特殊的适应性，帮助我们在特定的环境中生存与竞争。但自然界的其他动物表现的并不比人类差，如鸟可以飞，细菌则可以在恶劣的环境中存活。</p><p>那么，我们常说的理性又究竟是怎么回事？传统上，理性的行为是指不受情绪干扰-思维被认为是理性的，而情绪则被认为是非理性的。但事实并非如此。思维有时并非总是理性的。比如连续刷了几个小时抖音，你安慰自己发现了很多有趣的东西。因此，书中作者将理性定义为：身体预算-对我们每天所需的水、盐、葡萄糖和其他身体资源的管理；它意味着在特定情况下进行良好的身体预算投资。</p><blockquote><p>大脑是一个复杂的网络，由多达1280亿个神经元组成；神经元之间通过树突相互连接，通过突触来传递信号。这种复杂的神经元网络让大脑具备高度的复杂性，让大脑具备更高的容错能力与抗损伤能力，这也是人类创造性的源泉。与其他很多动物不同的是，人在刚出生时，虽然神经元的数量两倍于成年人的大脑，但神经元的连接只是完成了一部分，人类需要在后面长达25年的时间内不断完善、构造神经元的连接-新的连接被创建、不断调整，多余的连接则会被<code>修剪</code>掉。</p></blockquote><p>大脑神经元网络的复杂性所涌现出的能力，不禁让我联想起最近人工智能领域的<code>chatGPT</code>： 一个类神经元网络在数据与参数大到一定程度后所展现出的潜能让人惊讶不已。原本，人类可能需要通过正向分析大脑的整个构造过程才能解开智能的真正奥秘，如今通过<code>chatGPT</code>这种大模型技术，我们可能从另外一个角度破解智能的本质。但在此真正的通用人工智能出现之前，人还是要努力思考下，是什么让一个人具备了不一样的独特性？或者说，我们应该怎么做才能让一个婴儿能够变得更聪明，更有创造力，更有责任感与道德心？一个婴儿，刚出生时大脑连接尚未完成，理论上具备无限的可能。我们每一个人都应该重视对儿童的关心与爱护；整个社会要努力去营造一个让儿童健康成长的环境，这种付出成本较小，但是收益却是大的多：一个健康、智慧而有责任心的公民会为未来的社会带来可靠的价值，而一个在不幸与贫穷中长大的儿童则可能成长为一个愤世嫉俗、无所事事、毫无责任与道德感的人，这只会增加社会的成本。</p><blockquote><p>大脑是一个预测器官，它会根据过去的经验来对当前感知到的现实进行判断，从而做出预测；在我们做出某个行为之前，大脑实际上已经做了预测。什么在塑造我们的大脑神经元的构造？除了先天基因之外，家庭、教育、社会文化都在潜移默化中塑造一个人的大脑连接的回路。正是大脑神经元连接的多样性，塑造了丰富多彩的人类文明，让每个个体都具有独特的个性，使我们具备了与其他动物不一样的能力-创造社会现实。大脑通过创造力、沟通、模仿、合作以及压缩（总结信息，删除冗余）来构造人类独有的社会文化，让人类成为一个社会性的物种。</p></blockquote><p>是什么在塑造我们的大脑（心灵）？又是什么力量让人形成了对自我、他人以及社会的观念与看法？同样的一件事，每个人都会有自己的一套想法与思维方式；我们每一天的行为的驱动力又来自哪里？如果大脑的连接已经被过去的经验所塑造，我们改变不了过去，那么是否意味着我们也没法改变现状，没有拥有改变自我的意志与力量？但实际情况并非如此-我们可以改变自我。我们无法改变我们的家庭，无法改变身边的人，无法改变社会现实，但可以通过努力来改变大脑的连接方式，改变大脑对于外界的行为预测。比如，你可能在公众面前演讲比较紧张，通过足够的练习与反馈，你可以获得这一技能，从而让自己适应这种状态-在众人面前讲话做到放松自如。这就是大脑的潜能，作为大脑的主人，只要学会利用这种控制的权利，承担起改变的责任，那么，通过足够的努力与学习，我们就可以达成自己想要实现的目标。改变的前提是，我们要放下当前大脑固有连接所带来的认知与思维模式，换一种不一样的角度来看待当前的现实，从而调整大脑对于固有行为的预测，进而改变自我，完成新大脑神经元连接的塑造。</p><p>但在一个由各种类型连接的大脑塑造的社会现实中，我们不仅仅要面对自我，也要面对他人，以及形态各异的社会壁垒。我们渴望改变自我，但与此同时也受限于社会关系；我们要改变自我，那么不得不去与他人合作，与他人达成协作的关系。所谓<code>他人即天堂，他人即地狱</code>，与他人（家庭、同事、朋友）建立良好健康的关系，可以帮助我们重塑自我，让我们获得成长的动力，过得幸福、快乐与满足；反之，他人可能会成为吞噬自我的地狱，让我们陷入挣扎与纠缠的泥潭。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;If we spoke a different language, we would perceive a somewhat differenet world.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ludwig Wittgenstein
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt; &lt;img src=&quot;https://md-files.oss-cn-shenzhen.aliyuncs.com/high-tech-brain.jpg&quot; alt=&quot;Your high tech brain&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="社会万象" scheme="https://sniffer.site/categories/%E7%A4%BE%E4%BC%9A%E4%B8%87%E8%B1%A1/"/>
    
    
    <category term="哲学" scheme="https://sniffer.site/tags/%E5%93%B2%E5%AD%A6/"/>
    
    <category term="大脑" scheme="https://sniffer.site/tags/%E5%A4%A7%E8%84%91/"/>
    
    <category term="人生" scheme="https://sniffer.site/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Android常用的性能分析工具</title>
    <link href="https://sniffer.site/2023/10/20/Android%E5%B8%B8%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
    <id>https://sniffer.site/2023/10/20/Android%E5%B8%B8%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</id>
    <published>2023-10-20T03:45:04.000Z</published>
    <updated>2024-07-24T06:48:22.058Z</updated>
    
    <content type="html"><![CDATA[<p>在Android系统开发过程中，经常碰到CPU占用率高、内存泄露、内存占用高等性能相关的问题，这时通常需要抓取系统的<code>trace</code>日志，用以查看进程的CPU占用，内存分配等情况。怎么抓取系统trace， 这时一般需要用到系统性能相关的分析工具。这篇文章就以<code>Android S</code>为例，说明Android开发中常用的一些性能优化工具的使用方法，主要包括如下几个工具:</p><span id="more"></span><ul><li>atrace</li><li>systrace</li><li>dumpsys</li><li>simpleperf</li><li>perfetto</li><li>Android Profiler</li></ul><h2 id="atrace"><a href="#atrace" class="headerlink" title="atrace"></a><strong>atrace</strong></h2><p><code>atrace</code>是<code>Android</code>系统的自带的一个抓取<code>systrace</code>的工具，不仅可用于抓取系统服务的状态，如<code>input</code>、<code>SurfaceFlinger</code>、<code>Window Manager</code>等，也可以用于抓取内核的<code>trace</code>日志，如<code>CPU</code>调度、<code>irq</code>中断、内存等信息, 具体支持那些类型的<code>trace</code>日志，可以通过<code>adb shell atrace --list_categories</code>查看。</p><blockquote><p>对<code>atrace</code>实现感兴趣的同学，可以查看<code>frameworks/native/cmds/atrace</code>的代码</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">usage: atrace [options] [categories...]</span><br><span class="line">options include:</span><br><span class="line">-a appname      <span class="built_in">enable</span> app-level tracing <span class="keyword">for</span> a comma separated list of cmdlines; * is a wildcard matching any process</span><br><span class="line">-b N            use a trace buffer size of N KB</span><br><span class="line">-c              trace into a circular buffer</span><br><span class="line">-f filename     use the categories written <span class="keyword">in</span> a file as space-separated</span><br><span class="line">                    values <span class="keyword">in</span> a line</span><br><span class="line">-k fname,...    trace the listed kernel <span class="built_in">functions</span></span><br><span class="line">-n              ignore signals</span><br><span class="line">-s N            <span class="built_in">sleep</span> <span class="keyword">for</span> N seconds before tracing [default 0]</span><br><span class="line">-t N            trace <span class="keyword">for</span> N seconds [default 5]</span><br><span class="line">-z              compress the trace dump</span><br><span class="line">--async_start   start circular trace and <span class="built_in">return</span> immediately</span><br><span class="line">--async_dump    dump the current contents of circular trace buffer</span><br><span class="line">--async_stop    stop tracing and dump the current contents of circular</span><br><span class="line">                    trace buffer</span><br><span class="line">--stream        stream trace to stdout as it enters the trace buffer</span><br><span class="line">                    Note: this can take significant CPU time, and is best</span><br><span class="line">                    used <span class="keyword">for</span> measuring things that are not affected by</span><br><span class="line">                    CPU performance, like pagecache usage.</span><br><span class="line">--list_categories</span><br><span class="line">                list the available tracing categories</span><br><span class="line">-o filename      write the trace to the specified file instead</span><br><span class="line">                    of stdout.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如，如果我们想查看<code>SurfaceFlinger</code>（对应的类型未<code>gfx</code>）,可以再设备上执行如下命令抓取(默认只抓取5s的记录):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">atrace gfx irq <span class="built_in">sched</span> &gt; /data/gfx.trace</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把抓取到的<code>gfx.trace</code>文件拉到本地，然后使用<a href="https://ui.perfetto.dev/"><code>perfetto</code></a>工具打开即可查看。</p><h2 id="systrace"><a href="#systrace" class="headerlink" title="systrace"></a>systrace</h2><p>与<code>atrace</code>类似，<code>systrace</code>也是一个用于抓取系统<code>trace</code>日志的工具（适用于Android4.3以后的所有版本），不过<code>systrace</code>通过一个<code>python</code>脚本将抓取到的日志转换成<code>html</code>的可视化格式，这样就可以通过在<code>chrome</code>浏览器中输入<code>chrome://tracing/</code>，然后将对应的<code>html</code>加载即可浏览。</p><blockquote><p><code>systrace.py</code>工具可以通过<code>google</code>的网站下载或者再<code>SDK</code>中下载；如果是<code>SDK</code>，可以在<code>platform-tools/systrace</code>中找到对应的脚本</p></blockquote><p>通过<code>python2.7 systrace.py -h</code>查看具体的命令说明:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Usage: systrace.py [options] [category1 [category2 ...]]</span><br><span class="line"></span><br><span class="line">Example: systrace.py -b 32768 -t 15 gfx input view <span class="built_in">sched</span> freq</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -h, --<span class="built_in">help</span>            show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  -o FILE               write HTML to FILE</span><br><span class="line">  -t N, --time=N        trace <span class="keyword">for</span> N seconds</span><br><span class="line">  -b N, --buf-size=N    use a trace buffer size of N KB</span><br><span class="line">  -k KFUNCS, --ktrace=KFUNCS</span><br><span class="line">                        specify a comma-separated list of kernel <span class="built_in">functions</span> to</span><br><span class="line">                        trace</span><br><span class="line">  -l, --list-categories</span><br><span class="line">                        list the available categories and <span class="built_in">exit</span></span><br><span class="line">  -a APP_NAME, --app=APP_NAME</span><br><span class="line">                        <span class="built_in">enable</span> application-level tracing <span class="keyword">for</span> comma-separated</span><br><span class="line">                        list of app cmdlines</span><br><span class="line">  --link-assets         <span class="built_in">link</span> to original CSS or JS resources instead of</span><br><span class="line">                        embedding them</span><br><span class="line">  --from-file=FROM_FILE</span><br><span class="line">                        <span class="built_in">read</span> the trace from a file (compressed) rather than</span><br><span class="line">                        running a live trace</span><br><span class="line">  --asset-dir=ASSET_DIR</span><br><span class="line">  -e DEVICE_SERIAL, --serial=DEVICE_SERIAL</span><br><span class="line">                        adb device serial number</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如可以通过如下命令抓取图形、输入以及调度相关的<code>systrace</code>日志:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">python2<span class="number">.7</span> systrace.py -b <span class="number">32768</span> -t <span class="number">15</span> gfx input view sched freq</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认会抓取15s的日志，然后自动保存到一个<code>trace.html</code>的HTLM文件中；这个问题我们可以通过在<code>Chrome</code>浏览器中输入<code>chrome://tracing/</code>查看，也可以使用<a href="https://ui.perfetto.dev/"><code>perfetto</code></a>进行日志的浏览分析。</p><p>更多的使用规则可以参考<a href="https://stuff.mit.edu/afs/sipb/project/android/docs/tools/help/systrace.html">systrace usage</a></p><h2 id="dumpsys"><a href="#dumpsys" class="headerlink" title="dumpsys"></a><strong>dumpsys</strong></h2><p><code>dumpsys</code>是<code>Android</code>自带的一个工具，除了用于<code>dump</code>系统中注册的服务状态外，还可以用于各个进出的CPU占用、内存分配等情况，在分析一些系统的问题可能会有帮助:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">usage: dumpsys</span><br><span class="line">         To dump all services.</span><br><span class="line">or:</span><br><span class="line">       dumpsys [-t TIMEOUT] [--priority LEVEL] [--pid] [--thread] [--<span class="built_in">help</span> | -l | --skip SERVICES | SERVICE [ARGS]]</span><br><span class="line">         --<span class="built_in">help</span>: shows this <span class="built_in">help</span></span><br><span class="line">         -l: only list services, <span class="keyword">do</span> not dump them</span><br><span class="line">         -t TIMEOUT_SEC: TIMEOUT to use <span class="keyword">in</span> seconds instead of default 10 seconds</span><br><span class="line">         -T TIMEOUT_MS: TIMEOUT to use <span class="keyword">in</span> milliseconds instead of default 10 seconds</span><br><span class="line">         --pid: dump PID instead of usual dump</span><br><span class="line">         --thread: dump thread usage instead of usual dump</span><br><span class="line">         --proto: filter services that support dumping data <span class="keyword">in</span> proto format. Dumps</span><br><span class="line">               will be <span class="keyword">in</span> proto format.</span><br><span class="line">         --priority LEVEL: filter services based on specified priority</span><br><span class="line">               LEVEL must be one of CRITICAL | HIGH | NORMAL</span><br><span class="line">         --skip SERVICES: dumps all services but SERVICES (comma-separated list)</span><br><span class="line">         SERVICE [ARGS]: dumps only service SERVICE, optionally passing ARGS to it</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果我们只需要<code>dump</code>部分服务，可以先<code>dumpsys -l</code>获取到当前的服务列表, 然后保存对应的服务的<code>dump</code>日志:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dumpsys SurfaceFlinger</span><br><span class="line"></span><br><span class="line">dumpsys cpuinfo</span><br><span class="line"></span><br><span class="line">dumpsys meminfo</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="simpleperf"><a href="#simpleperf" class="headerlink" title="simpleperf"></a><strong>simpleperf</strong></h2><p><code>simpleperf</code>是Android原生自带的一个用于采集APP或者系统日志的分析工具，其实际上包含了一系列工具库，包括可以在Android Native的直接运行的工具<code>simpleperf</code>；可以在PC上执行的脚本集合，包括生成火焰图的<code>inferno.py</code>, 用于分析APP（包括Native进程）的<code>app_profile.py</code>，所有的这些包括源代码都可以在AOSP的源代码仓库路径<code>system/extras/simpleperf</code>中找到。</p><p>先来看下如何使用<code>simpleperf</code>在Android本地上抓取分析的日志(如果没有<code>simpleperf</code>，可以到<code>simpleperf</code>目录下载或者自行编译一个push到系统中)；输入<code>simpleperf -h</code>查看使用说明:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Usage: simpleperf [common options] subcommand [args_for_subcommand]</span><br><span class="line">common options:</span><br><span class="line">    -h/--help     Print this <span class="built_in">help</span> information.</span><br><span class="line">    --<span class="built_in">log</span> &lt;severity&gt; Set the minimum severity of logging. Possible severities</span><br><span class="line">                     include verbose, debug, warning, info, error, fatal.</span><br><span class="line">                     Default is info.</span><br><span class="line">    --log-to-android-buffer  Write <span class="built_in">log</span> to android <span class="built_in">log</span> buffer instead of stderr.</span><br><span class="line">    --version     Print version of simpleperf.</span><br><span class="line">subcommands:</span><br><span class="line">    api-collect         Collect recording data generated by app api</span><br><span class="line">    api-prepare         Prepare recording via app api</span><br><span class="line">    debug-unwind        Debug/test offline unwinding.</span><br><span class="line">    dump                dump perf record file</span><br><span class="line">    <span class="built_in">help</span>                <span class="built_in">print</span> <span class="built_in">help</span> information <span class="keyword">for</span> simpleperf</span><br><span class="line">    inject              parse etm instruction tracing data</span><br><span class="line">    kmem                collect kernel memory allocation information</span><br><span class="line">    list                list available event types</span><br><span class="line">    merge               merge multiple perf.data into one</span><br><span class="line">    monitor             monitor events and <span class="built_in">print</span> their textual representations to stdout</span><br><span class="line">    record              record sampling info <span class="keyword">in</span> perf.data</span><br><span class="line">    report              report sampling information <span class="keyword">in</span> perf.data</span><br><span class="line">    report-sample       report raw sample information <span class="keyword">in</span> perf.data</span><br><span class="line">    <span class="built_in">stat</span>                gather performance counter information</span><br><span class="line">    trace-sched         Trace system-wide process runtime events.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里比较关键的两个命令是<code>simpleperf record/report</code>, <code>record</code>命令用于抓取进程的<code>perf</code>数据，而<code>report</code>指令则用于展示抓取到的<code>perf.data</code>，比如我们用如下命令抓取某个进程的分析日志:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># perf.data会保存在该目录</span></span><br><span class="line"><span class="built_in">cd</span> /data</span><br><span class="line"></span><br><span class="line">simpleperf record -p 1047 --duration 10</span><br><span class="line"></span><br><span class="line">simpleperf report</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了在Android查看<code>perf.data</code>之外，也可以将<code>perf.data</code>的数据保存到PC上，用<code>scripts</code>下面的<code>report_html.py</code>脚本以网页的形式查看结果, 只需要执行<code>./report_html.py -i perf.data</code>，脚本就会自动解析日志并在浏览器中展示一个HTML形式的报告。</p><p><code>simpleperf</code>里边还有一个很有趣的工具<code>inferno.sh</code>，可以一个指令快速生成火焰图：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">./inferno.sh --pid 2481 --title system</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行后会自动生成一个对应进程调用链的<a href="https://www.brendangregg.com/flamegraphs.html">火焰图</a>，然后在浏览器中查看各个线程执行的调用堆栈。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/simpleperf-flamegraph.png" alt="flamegraph"></p><p>另外我们还可以通过<code>simpleperf</code>来获取某个进程内核的<code>CPU</code>占用以及指令执行的统计信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Stat using default events (cpu-cycles,instructions,...), and monitor process 7394 for 10 seconds.</span></span><br><span class="line">$ simpleperf <span class="built_in">stat</span> -p 7394 --duration 10</span><br><span class="line">Performance counter statistics:</span><br><span class="line"></span><br><span class="line"><span class="comment">#         count  event_name                # count / runtime</span></span><br><span class="line">     16,513,564  cpu-cycles                <span class="comment"># 1.612904 GHz</span></span><br><span class="line">      4,564,133  stalled-cycles-frontend   <span class="comment"># 341.490 M/sec</span></span><br><span class="line">      6,520,383  stalled-cycles-backend    <span class="comment"># 591.666 M/sec</span></span><br><span class="line">      4,900,403  instructions              <span class="comment"># 612.859 M/sec</span></span><br><span class="line">         47,821  branch-misses             <span class="comment"># 6.085 M/sec</span></span><br><span class="line">  25.274251(ms)  task-clock                <span class="comment"># 0.002520 cpus used</span></span><br><span class="line">              4  context-switches          <span class="comment"># 158.264 /sec</span></span><br><span class="line">            466  page-faults               <span class="comment"># 18.438 K/sec</span></span><br><span class="line"></span><br><span class="line">Total <span class="built_in">test</span> time: 10.027923 seconds.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多详情可以参考<a href="https://android.googlesource.com/platform/system/extras/+/master/simpleperf/doc/executable_commands_reference.md">simpleperf usage</a>或者AOSP中的代码目录<code>system/extras/simpleperf</code>。</p><h2 id="perfetto"><a href="#perfetto" class="headerlink" title="perfetto"></a><strong>perfetto</strong></h2><p><a href="https://perfetto.dev/"><code>perfetto</code></a>是Google开源的用于系统性能分析、Trace日志抓取的工具，是一个综合了Trace日志抓取、分析以及UI展示的工具链。<code>perfetto</code>采集的数据主要来自<code>ftrace</code>(收集内核信息)，<code>atrace</code>(收集服务与应用的Trace日志)以及<code>heapprofd</code>(用于收集APP的内存使用情况)；Android 10以后的版本都默认集成了一个<code>perfetto</code>的可执行程序用于Trace的抓取:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Usage: perfetto</span><br><span class="line">  --background     -d      : Exits immediately and continues tracing <span class="keyword">in</span></span><br><span class="line">                            background</span><br><span class="line">  --config         -c      : /path/to/trace/config/file or - <span class="keyword">for</span> stdin</span><br><span class="line">  --out            -o      : /path/to/out/trace/file or - <span class="keyword">for</span> stdout</span><br><span class="line">  --upload                 : Upload field trace (Android only)</span><br><span class="line">  --dropbox        TAG     : DEPRECATED: Use --upload instead</span><br><span class="line">                            TAG should always be <span class="built_in">set</span> to <span class="string">&#x27;perfetto&#x27;</span></span><br><span class="line">  --no-guardrails          : Ignore guardrails triggered when using --upload</span><br><span class="line">                            (<span class="keyword">for</span> testing).</span><br><span class="line">  --txt                    : Parse config as pbtxt. Not <span class="keyword">for</span> production use.</span><br><span class="line">                            Not a stable API.</span><br><span class="line">  --reset-guardrails       : Resets the state of the guardails and exits</span><br><span class="line">                            (<span class="keyword">for</span> testing).</span><br><span class="line">  --query                  : Queries the service state and prints it as</span><br><span class="line">                            human-readable text.</span><br><span class="line">  --query-raw              : Like --query, but prints raw proto-encoded bytes</span><br><span class="line">                            of tracing_service_state.proto.</span><br><span class="line">  --save-for-bugreport     : If a trace with bugreport_score &gt; 0 is running, it</span><br><span class="line">                            saves it into a file. Outputs the path when <span class="keyword">done</span>.</span><br><span class="line">  --<span class="built_in">help</span>           -h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">light configuration flags: (only when NOT using -c/--config)</span><br><span class="line">  --time           -t      : Trace duration N[s,m,h] (default: 10s)</span><br><span class="line">  --buffer         -b      : Ring buffer size N[mb,gb] (default: 32mb)</span><br><span class="line">  --size           -s      : Max file size N[mb,gb] (default: in-memory ring-buffer only)</span><br><span class="line">  --app            -a      : Android (atrace) app name</span><br><span class="line">  ATRACE_CAT               : Record ATRACE_CAT (e.g. wm)</span><br><span class="line">  FTRACE_GROUP/FTRACE_NAME : Record ftrace event (e.g. <span class="built_in">sched</span>/sched_switch)</span><br><span class="line"></span><br><span class="line">statsd-specific flags:</span><br><span class="line">  --alert-id           : ID of the alert that triggered this trace.</span><br><span class="line">  --config-id          : ID of the triggering config.</span><br><span class="line">  --config-uid         : UID of app <span class="built_in">which</span> registered the config.</span><br><span class="line">  --subscription-id    : ID of the subscription that triggered this trace.</span><br><span class="line"></span><br><span class="line">Detach mode. DISCOURAGED, <span class="built_in">read</span> https://perfetto.dev/docs/concepts/detached-mode :</span><br><span class="line">  --detach=key          : Detach from the tracing session with the given key.</span><br><span class="line">  --attach=key [--stop] : Re-attach to the session (optionally stop tracing once reattached).</span><br><span class="line">  --is_detached=key     : Check <span class="keyword">if</span> the session can be re-attached (0:Yes, 2:No, 1:Error).</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>perfetto</code>包含以下两种模式，可确定用于记录跟踪数据的数据源：</p><ul><li>轻量模式：只能选择一部分数据源，具体来说就是<code>atrace</code>和<code>ftrace</code>。但此模式可提供类似于<code>systrace</code>的接口。</li><li>普通模式：从协议缓冲区获取其配置，并允许您更充分地利用<code>perfetto</code>功能，方法是使用<code>atrace</code>和<code>ftrace</code>之外的数据源。</li></ul><p>使用轻量模式来抓取<code>Trace</code>日志，这个跟<code>systrace</code>的用法类似，只需要制定<code>APP</code>的名字即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">perfetto --app &lt;app_name&gt; --time 15s -o /data/ss.trace</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果使用普通模式，首先需要参考标准的<a href="https://perfetto.dev/docs/reference/trace-config-proto"><code>TraceConfig</code></a>写一个配置文件；生成配置文件后，可以选择以<code>PBTX(ProtoBuf TeXtual representation)</code>的传递（生产环境不推荐）或者通过<a href="https://github.com/protocolbuffers/protobuf/releases"><code>protoc</code></a>工具转换成<code>Binary</code>形式的<code>protobuf</code>文件传给给<code>perfetto</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#把本地的sys_stats.cfg推到/data/misc/perfetto-configs</span></span><br><span class="line">perfetto -c /data/misc/perfetto-configs/sys_stats.cfg --txt -o /data/sys-stats.trace</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在AOSP源码目录<code>external/perfetto/test/configs</code>下面提供了很多<code>perfetto</code>的配置文件可以参考。除了使用<code>Android</code>系统自带的<code>perfetto</code>工具抓取Trace之外，还可以用<a href="https://ui.perfetto.dev/">网页版的<code>perfetto</code>工具抓取</a>: 点击<code>Record new trace</code>，会弹出一个页面，可以选择抓取<code>CPU</code>、<code>GPU</code>、<code>Memory</code>以及APP与服务的Trace日志:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/perfetto-ui-record-new-traces.png" alt="perfetto-ui usage"></p><h2 id="Android-Profiler"><a href="#Android-Profiler" class="headerlink" title="Android Profiler"></a>Android Profiler</h2><p>除了使用上述几个工具之外，<code>Android Studio(AS)</code>中也提供了一个可视化的<a href="https://developer.android.com/studio/profile?hl=zh-cn">图形界面工具<code>Profiler</code></a>来分析APP或者设备中进程的性能，包括CPU占用、内存分配以及网络使用等常见的性能指标。</p><p>打开<code>AS</code>后，点击界面的下方中的仪表指针的图标<code>Profiler</code>，然后点击弹出的界面左侧<code>SESSIONS</code>一栏中点击<code>+</code>按钮，选择需要分析跟踪的进程后，会弹出一个显示进程CPU、内存以及网络占用情况的界面:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/android-profiler-ui.png" alt="android profiler ui"></p><p>点击图中的<code>CPU</code>可以看到进程中各个线程的CPU占用情况，如果想要查看某个线程的调用堆栈，可以通过界面上的<code>Record</code>的功能来抓取<code>Java</code>或者<code>C/C++</code>代码<code>Trace</code>日志，抓取完成后会生产对应<code>Trace</code>的火焰图，可以用来进一步分析各个线程执行耗时; 类似的，<code>MEMORY</code>工具可以用来分析热点代码的内存分配情况，用来分析内存泄露、内存占用不合理的情况。</p><p>有关更多Profiler工具的使用说明，可以参考<a href="https://developer.android.com/studio/profile?hl=zh-cn">Android Profiler官网链接</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.android.com/topic/performance/tracing?hl=zh-cn">https://developer.android.com/topic/performance/tracing?hl=zh-cn</a></li><li><a href="https://developer.android.com/studio/profile?hl=zh-cn">https://developer.android.com/studio/profile?hl=zh-cn</a></li><li><a href="https://cs.android.com/">https://cs.android.com/</a></li><li><a href="https://facebookmicrosites.github.io/psi/docs/overview">https://facebookmicrosites.github.io/psi/docs/overview</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Android系统开发过程中，经常碰到CPU占用率高、内存泄露、内存占用高等性能相关的问题，这时通常需要抓取系统的&lt;code&gt;trace&lt;/code&gt;日志，用以查看进程的CPU占用，内存分配等情况。怎么抓取系统trace， 这时一般需要用到系统性能相关的分析工具。这篇文章就以&lt;code&gt;Android S&lt;/code&gt;为例，说明Android开发中常用的一些性能优化工具的使用方法，主要包括如下几个工具:&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://sniffer.site/categories/Android/"/>
    
    
    <category term="Android" scheme="https://sniffer.site/tags/Android/"/>
    
    <category term="性能分析" scheme="https://sniffer.site/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
    <category term="systrace" scheme="https://sniffer.site/tags/systrace/"/>
    
    <category term="perfetto" scheme="https://sniffer.site/tags/perfetto/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化之三virtio的实现原理</title>
    <link href="https://sniffer.site/2023/09/15/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E4%B8%89virtio%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sniffer.site/2023/09/15/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E4%B8%89virtio%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2023-09-15T10:42:33.000Z</published>
    <updated>2023-09-18T05:30:36.792Z</updated>
    
    <content type="html"><![CDATA[<p>在讲<a href="https://sniffer.site/2023/08/09/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E4%BA%8Cqnx%E8%99%9A%E6%8B%9F%E5%8C%96%E5%B9%B3%E5%8F%B0%E7%AE%80%E4%BB%8B/">虚拟化的第二篇QNX系统</a>时，提到在<code>QNX</code>中设备的虚拟化有直通(<code>pass-through</code>)、半虚拟化(<code>para-virtulization</code>)、全虚拟化(<code>full-virtualization</code>)等几种形式，而像串口、网络设备、块设备等通常都是基于半虚拟化的形式实现的。在半虚拟化的实现方案中，<code>virtio</code>是最常见的一种。简单来说，<code>virtio</code>是虚拟化设备的中间抽象层，为设备的虚拟化提供了一个统一的框架与接口，增加了跨平台时代码的复用性。<span id="more"></span></p><p>下图是两种虚拟化方案:全虚拟化与半虚拟化的框架简图。对全虚拟化方案而已，虚拟机完全不知道自己运行在一个虚拟化平台之上，<code>hypervisor</code>为虚拟机提供了一个完全模拟的环境，虚拟机对资源与设备的访问都需要通过异常的陷入(<code>trap</code>)指令来完成,这在一定程度上降低了资源访问的效率；而对半虚拟化方案而言，虚拟机与宿主机共同来完成虚拟化，虚拟机是完全知道自己运行在一个虚拟化的环境中，相对而言，半虚拟化的效率更高。</p><p><img src="https://developer.ibm.com/developer/default/articles/l-virtio/images/figure1.gif" alt="full-para virtualization"></p><p>而<code>virtio</code>正是半虚拟化技术中实现设备虚拟化的一种被广泛使用的方案，并被非营利性标准化组织<a href="https://www.oasis-open.org/org/"><code>OASIS</code></a>进行了标准化，详细的标准文档可以参考<a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html">Virtio V1.2</a>；<code>virtio</code>将设备驱动的实现分离为前端(<code>front-end</code>)与后端(<code>back-end</code>)两个部分:</p><ul><li>前端驱动(<code>front-end driver</code>): 虚拟机系统中的一个设备驱动模块，负责接收来自虚拟机用户的请求，将其发送给宿主机上的后端驱动</li><li>后端驱动(<code>back-end driver</code>): 运行在宿主机上的驱动模块，接收到来自虚拟机上的请求后，将其转换成物理设备上的操作</li></ul><p><img src="https://developer.ibm.com/developer/default/articles/l-virtio/images/figure2.gif" alt="driver abstractions with virtio"></p><p>对<code>QNX</code>系统，提供了常见的如网络设备、串口设备以及块设备等多种后端虚拟化实现, 可以很好的与<code>Linux</code>下的<code>virtio</code>框架进行衔接，例如要在<code>QNX</code>上给<code>Linux</code>的虚拟机提供一张虚拟网卡，只需要在<code>linux-lv.config</code>中如下配置即可:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vdev vdev-virtio-net.so loc <span class="number">0x1b018000</span> intr gic:<span class="number">45</span> peer /dev/vdevpeer/vp_lv mac aa:aa:aa:aa:aa:b1 bind-mode <span class="number">0660</span> name agl_to_host</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>Linux</code>虚拟机上打开内核配置<code>CONFIG_VIRTIO_NET</code>就可以枚举到对应的虚拟网卡， 其<code>mac</code>地址为<code>aa:aa:aa:aa:aa:b1</code>，中断号为<code>45</code>。接下来我们就以虚拟网卡<code>virtio-net</code>为例说明<code>virtio</code>具体的实现原理。</p><h2 id="virtio的原理"><a href="#virtio的原理" class="headerlink" title="virtio的原理"></a>virtio的原理</h2><p><code>QNX</code>中的<code>virtio</code>驱动分为两个部分: 前端设备驱动(<code>front-end driver</code>)与后端驱动(<code>back-end driver</code>)，前端驱动负责将虚拟机中的请求发送给后端驱动，后端驱动负责与前端驱动交互并将其请求发送给物理设备，像磁盘、网络、I2C、串口、fastRPC(用于与DSP交互)等设备都是通过<code>virtio</code>的方式来实现的，而其他的如音视频、显示、图形(Graphics)、Camera等传输数据比较大的模块也是采用了类似的前端与后端框架(高通称之为<code>HAB(Hypervisor ABstraction)</code>)。<code>virtio</code>为虚拟化驱动的实现提供了一个标准接口，从而解耦了宿主机与虚拟机之间的驱动开发, 提高了系统的开发效率。以<code>QNX</code>中的网络驱动为例:</p><ul><li>虚拟机有虚拟网卡驱动，与后端驱动通过一个内存映射的区域进行数据交互</li><li>后端驱动接收到虚拟机的数据后通过一个桥接口与<code>QNX</code>宿主机上的物理网卡驱动进行交互</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/virtio-net-qnx.png" alt="QNX虚拟网卡驱动框架"></p><p>接下来，我们从设备的识别与发现的过程来看下虚拟网卡中的具体实现。</p><h2 id="设备的识别与初始化"><a href="#设备的识别与初始化" class="headerlink" title="设备的识别与初始化"></a>设备的识别与初始化</h2><p><code>virtio</code>设备的发现一般有两种方式，一种是基于<code>PCI</code>虚拟总线进行设备枚举，一种是基于内存映射的方式。在QNX上，很多设备如虚拟网卡，虚拟磁盘设备等都是基于内存映射(<code>MMIO</code>)的方式来实现的。具体可以参考: </p><ul><li><a href="https://www.qnx.com/developers/docs/7.0.0/#com.qnx.doc.hypervisor.user/topic/use/virtio_guest.html">虚拟机上的设备发现</a></li><li><a href="https://docs.kernel.org/next/driver-api/virtio/virtio.html">Virtio on Linux</a></li><li><a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.pdf">virtio标准中设备发现部分</a></li><li><a href="https://www.qnx.com/developers/docs/7.0.0/index.html#com.qnx.doc.hypervisor.vdev/topic/intro/intro.html">如何在QNX中实现一个vdev</a></li></ul><blockquote><p>QNX上的虚拟设备<code>vdev</code>采用的是内存映射的方式，就是说虚拟设备实际是一个虚拟机的物理地址。<code>QNX</code>在启动<code>vdev</code>后端驱动进程时，会通过<code>gfdt_add_vdev</code>&#x2F;<code>gfdt_update_node</code>添加设备树到虚拟机上，这样虚拟机会在启动的时候枚举到对应的虚拟设备<br>可以在<code>/sys/firmware/devicetree/base/vdevs</code>目录中查找虚拟机上对应的设备树节点</p></blockquote><p><code>virtio</code>采用标准的<a href="https://linux-kernel-labs.github.io/refs/heads/master/labs/device_model.html">Linux设备模型</a>，设备与设备驱动之间通过一个名为<code>virtio</code>的虚拟总线进行连接。在虚拟机启动时，会枚举到<code>QNX</code>配置的虚拟设备，并调用<code>virtio_mmio_probe</code>:</p><ul><li>首先会通过<code>devm_request_mem_region</code>请求虚拟设备对应的内存区域，用于设备的控制与事件传递</li><li>接着会读取设备<code>I/O</code>地址来确认设备的类型(魔数)、<code>virtio</code>的版本号以及设备ID</li><li>最后<code>register_virtio_device</code>将该虚拟设cat备添加到系统中，这样设备驱动加载时可以匹配到对应的设备</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">virtio_mmio_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">virtio_mmio_device</span> *vm_dev;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">resource</span> *mem;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> magic;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">    mem = <span class="built_in">platform_get_resource</span>(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mem)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">devm_request_mem_region</span>(&amp;pdev-&gt;dev, mem-&gt;start,</span><br><span class="line">            <span class="built_in">resource_size</span>(mem), pdev-&gt;name))</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">    vm_dev = <span class="built_in">devm_kzalloc</span>(&amp;pdev-&gt;dev, <span class="built_in">sizeof</span>(*vm_dev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!vm_dev)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    vm_dev-&gt;vdev.dev.parent = &amp;pdev-&gt;dev;</span><br><span class="line">    vm_dev-&gt;vdev.dev.release = virtio_mmio_release_dev;</span><br><span class="line">    vm_dev-&gt;vdev.config = &amp;virtio_mmio_config_ops;</span><br><span class="line">    vm_dev-&gt;pdev = pdev;</span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;vm_dev-&gt;virtqueues);</span><br><span class="line">    <span class="built_in">spin_lock_init</span>(&amp;vm_dev-&gt;lock);</span><br><span class="line"></span><br><span class="line">    vm_dev-&gt;base = <span class="built_in">devm_ioremap</span>(&amp;pdev-&gt;dev, mem-&gt;start, <span class="built_in">resource_size</span>(mem));</span><br><span class="line">    <span class="keyword">if</span> (vm_dev-&gt;base == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check magic value */</span></span><br><span class="line">    magic = <span class="built_in">readl</span>(vm_dev-&gt;base + VIRTIO_MMIO_MAGIC_VALUE);</span><br><span class="line">    <span class="keyword">if</span> (magic != (<span class="string">&#x27;v&#x27;</span> | <span class="string">&#x27;i&#x27;</span> &lt;&lt; <span class="number">8</span> | <span class="string">&#x27;r&#x27;</span> &lt;&lt; <span class="number">16</span> | <span class="string">&#x27;t&#x27;</span> &lt;&lt; <span class="number">24</span>)) &#123;</span><br><span class="line">        <span class="built_in">dev_warn</span>(&amp;pdev-&gt;dev, <span class="string">&quot;Wrong magic value 0x%08lx!\n&quot;</span>, magic);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check device version */</span></span><br><span class="line">    vm_dev-&gt;version = <span class="built_in">readl</span>(vm_dev-&gt;base + VIRTIO_MMIO_VERSION);</span><br><span class="line">    <span class="keyword">if</span> (vm_dev-&gt;version &lt; <span class="number">1</span> || vm_dev-&gt;version &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;Version %ld not supported!\n&quot;</span>,</span><br><span class="line">                vm_dev-&gt;version);</span><br><span class="line">        <span class="keyword">return</span> -ENXIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vm_dev-&gt;vdev.id.device = <span class="built_in">readl</span>(vm_dev-&gt;base + VIRTIO_MMIO_DEVICE_ID);</span><br><span class="line">    ...</span><br><span class="line">    vm_dev-&gt;vdev.id.vendor = <span class="built_in">readl</span>(vm_dev-&gt;base + VIRTIO_MMIO_VENDOR_ID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm_dev-&gt;version == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">writel</span>(PAGE_SIZE, vm_dev-&gt;base + VIRTIO_MMIO_GUEST_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        rc = <span class="built_in">dma_set_mask</span>(&amp;pdev-&gt;dev, <span class="built_in">DMA_BIT_MASK</span>(<span class="number">64</span>));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * In the legacy case, ensure our coherently-allocated virtio</span></span><br><span class="line"><span class="comment">        * ring will be at an address expressable as a 32-bit PFN.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (!rc)</span><br><span class="line">            <span class="built_in">dma_set_coherent_mask</span>(&amp;pdev-&gt;dev,</span><br><span class="line">                        <span class="built_in">DMA_BIT_MASK</span>(<span class="number">32</span> + PAGE_SHIFT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rc = <span class="built_in">dma_set_mask_and_coherent</span>(&amp;pdev-&gt;dev, <span class="built_in">DMA_BIT_MASK</span>(<span class="number">64</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rc)</span><br><span class="line">        rc = <span class="built_in">dma_set_mask_and_coherent</span>(&amp;pdev-&gt;dev, <span class="built_in">DMA_BIT_MASK</span>(<span class="number">32</span>));</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">platform_set_drvdata</span>(pdev, vm_dev);</span><br><span class="line"></span><br><span class="line">    rc = <span class="built_in">register_virtio_device</span>(&amp;vm_dev-&gt;vdev);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>register_virtio_device</code>将虚拟设备注册到系统中，对应的总线类型为<code>virtio_bus</code>, 用于设备驱动的匹配与查找；对应的设备名称格式为<code>virtio%u</code>, 比如<code>virtio33</code>&#x2F;<code>virtio21</code>; 在Linux系统中，我们可以到路径<code>/sys/devices/platform/vdevs</code>中查看当前系统有哪些<code>virtio</code>设备:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">register_virtio_device</span><span class="params">(<span class="keyword">struct</span> virtio_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    dev-&gt;dev.bus = &amp;virtio_bus;</span><br><span class="line">    <span class="built_in">device_initialize</span>(&amp;dev-&gt;dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assign a unique device index and hence name. */</span></span><br><span class="line">    err = <span class="built_in">ida_simple_get</span>(&amp;virtio_index_ida, <span class="number">0</span>, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    dev-&gt;index = err;</span><br><span class="line">    <span class="built_in">dev_set_name</span>(&amp;dev-&gt;dev, <span class="string">&quot;virtio%u&quot;</span>, dev-&gt;index);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spin_lock_init</span>(&amp;dev-&gt;config_lock);</span><br><span class="line">    dev-&gt;config_enabled = <span class="literal">false</span>;</span><br><span class="line">    dev-&gt;config_change_pending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We always start by resetting the device, in case a previous</span></span><br><span class="line"><span class="comment">    * driver messed it up.  This also tests that code path a little. */</span></span><br><span class="line">    dev-&gt;config-&gt;<span class="built_in">reset</span>(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Acknowledge that we&#x27;ve seen the device. */</span></span><br><span class="line">    <span class="built_in">virtio_add_status</span>(dev, VIRTIO_CONFIG_S_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;dev-&gt;vqs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * device_add() causes the bus infrastructure to look for a matching</span></span><br><span class="line"><span class="comment">    * driver.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    err = <span class="built_in">device_add</span>(&amp;dev-&gt;dev);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设备注册完后，虚拟网卡设备驱动程序<code>virtio-net</code>在注册时，会主动匹配与之对应的设备, 如果匹配到则会调用对应驱动的<code>probe</code>函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">virtio_driver</span> virtio_net_driver = &#123;</span><br><span class="line">    .feature_table = features,</span><br><span class="line">    .feature_table_size = <span class="built_in">ARRAY_SIZE</span>(features),</span><br><span class="line">    .feature_table_legacy = features_legacy,</span><br><span class="line">    .feature_table_size_legacy = <span class="built_in">ARRAY_SIZE</span>(features_legacy),</span><br><span class="line">    .driver.name =KBUILD_MODNAME,</span><br><span class="line">    .driver.owner =THIS_MODULE,</span><br><span class="line">    .id_table =id_table,</span><br><span class="line">    .validate =virtnet_validate,</span><br><span class="line">    .probe =virtnet_probe,</span><br><span class="line">    .remove =virtnet_remove,</span><br><span class="line">    .config_changed = virtnet_config_changed,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">    .freeze =virtnet_freeze,</span><br><span class="line">    .restore =virtnet_restore,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> __init <span class="type">int</span> <span class="title">virtio_net_driver_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">cpuhp_setup_state_multi</span>(CPUHP_AP_ONLINE_DYN, <span class="string">&quot;virtio/net:online&quot;</span>,</span><br><span class="line">                    virtnet_cpu_online,</span><br><span class="line">                    virtnet_cpu_down_prep);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    virtionet_online = ret;</span><br><span class="line">    ret = <span class="built_in">cpuhp_setup_state_multi</span>(CPUHP_VIRT_NET_DEAD, <span class="string">&quot;virtio/net:dead&quot;</span>,</span><br><span class="line">                    <span class="literal">NULL</span>, virtnet_cpu_dead);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> err_dead;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">register_virtio_driver</span>(&amp;virtio_net_driver);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module_init</span>(virtio_net_driver_init);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虚拟网卡的驱动加载函数<code>virtnet_probe</code>主要做几个事情:</p><ul><li>根据宿主机的驱动配置，设置对应的网卡特性，比如是否支持硬件校验计算、TSO、GSO等</li><li><code>alloc_etherdev_mq</code>分配协议栈的网络设备对象<code>net_device</code>, 将其注册到内核中<code>register_netdev</code></li><li>通过检查虚拟设备的特性(feature)确认是否打开网络设备某些配置，比如是否支持<code>GSO/TSO</code>等</li><li><code>init_vqs</code>初始化虚拟网卡的接收与发送队列， 创建对应的<code>virtqueue</code>循环队列</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">virtnet_probe</span><span class="params">(<span class="keyword">struct</span> virtio_device *vdev)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, err = -ENOMEM;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">net_device</span> *dev;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">virtnet_info</span> *vi;</span><br><span class="line">        u16 max_queue_pairs;</span><br><span class="line">        <span class="type">int</span> mtu;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Find if host supports multiqueue virtio_net device */</span></span><br><span class="line">        err = <span class="built_in">virtio_cread_feature</span>(vdev, VIRTIO_NET_F_MQ,</span><br><span class="line">                    <span class="keyword">struct</span> virtio_net_config,</span><br><span class="line">                    max_virtqueue_pairs, &amp;max_queue_pairs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We need at least 2 queue&#x27;s */</span></span><br><span class="line">        <span class="keyword">if</span> (err || max_queue_pairs &lt; VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN ||</span><br><span class="line">            max_queue_pairs &gt; VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX ||</span><br><span class="line">            !<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_CTRL_VQ))</span><br><span class="line">            max_queue_pairs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Allocate ourselves a network device with room for our info */</span></span><br><span class="line">        dev = <span class="built_in">alloc_etherdev_mq</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> virtnet_info), max_queue_pairs);</span><br><span class="line">        <span class="keyword">if</span> (!dev)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set up network device as normal. */</span></span><br><span class="line">        dev-&gt;priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE;</span><br><span class="line">        dev-&gt;netdev_ops = &amp;virtnet_netdev;</span><br><span class="line">        dev-&gt;features = NETIF_F_HIGHDMA;</span><br><span class="line"></span><br><span class="line">        dev-&gt;ethtool_ops = &amp;virtnet_ethtool_ops;</span><br><span class="line">        <span class="built_in">SET_NETDEV_DEV</span>(dev, &amp;vdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Do we support &quot;hardware&quot; checksums? */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_CSUM)) &#123;</span><br><span class="line">            <span class="comment">/* This opens up the world of extra features. */</span></span><br><span class="line">            dev-&gt;hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;</span><br><span class="line">            <span class="keyword">if</span> (csum)</span><br><span class="line">                dev-&gt;features |= NETIF_F_HW_CSUM | NETIF_F_SG;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_GSO)) &#123;</span><br><span class="line">                dev-&gt;hw_features |= NETIF_F_TSO</span><br><span class="line">                    | NETIF_F_TSO_ECN | NETIF_F_TSO6;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Individual feature bits: what can host handle? */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_HOST_TSO4))</span><br><span class="line">                dev-&gt;hw_features |= NETIF_F_TSO;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_HOST_TSO6))</span><br><span class="line">                dev-&gt;hw_features |= NETIF_F_TSO6;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_HOST_ECN))</span><br><span class="line">                dev-&gt;hw_features |= NETIF_F_TSO_ECN;</span><br><span class="line"></span><br><span class="line">            dev-&gt;features |= NETIF_F_GSO_ROBUST;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (gso)</span><br><span class="line">                dev-&gt;features |= dev-&gt;hw_features &amp; NETIF_F_ALL_TSO;</span><br><span class="line">            <span class="comment">/* (!csum &amp;&amp; gso) case will be fixed by register_netdev() */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_GUEST_CSUM))</span><br><span class="line">            dev-&gt;features |= NETIF_F_RXCSUM;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_GUEST_TSO4) ||</span><br><span class="line">            <span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_GUEST_TSO6))</span><br><span class="line">            dev-&gt;features |= NETIF_F_GRO_HW;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_CTRL_GUEST_OFFLOADS))</span><br><span class="line">            dev-&gt;hw_features |= NETIF_F_GRO_HW;</span><br><span class="line"></span><br><span class="line">        dev-&gt;vlan_features = dev-&gt;features;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* MTU range: 68 - 65535 */</span></span><br><span class="line">        dev-&gt;min_mtu = MIN_MTU;</span><br><span class="line">        dev-&gt;max_mtu = MAX_MTU;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Configuration may specify what MAC to use.  Otherwise random. */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_MAC))</span><br><span class="line">            <span class="built_in">virtio_cread_bytes</span>(vdev,</span><br><span class="line">                    <span class="built_in">offsetof</span>(<span class="keyword">struct</span> virtio_net_config, mac),</span><br><span class="line">                    dev-&gt;dev_addr, dev-&gt;addr_len);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">eth_hw_addr_random</span>(dev);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set up our device-specific information */</span></span><br><span class="line">        vi = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line">        vi-&gt;dev = dev;</span><br><span class="line">        vi-&gt;vdev = vdev;</span><br><span class="line">        vdev-&gt;priv = vi;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">INIT_WORK</span>(&amp;vi-&gt;config_work, virtnet_config_changed_work);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we can receive ANY GSO packets, we must allocate large ones. */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_GUEST_TSO4) ||</span><br><span class="line">            <span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_GUEST_TSO6) ||</span><br><span class="line">            <span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_GUEST_ECN) ||</span><br><span class="line">            <span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_GUEST_UFO))</span><br><span class="line">            vi-&gt;big_packets = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_MRG_RXBUF))</span><br><span class="line">            vi-&gt;mergeable_rx_bufs = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_MRG_RXBUF) ||</span><br><span class="line">            <span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_F_VERSION_1))</span><br><span class="line">            vi-&gt;hdr_len = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> virtio_net_hdr_mrg_rxbuf);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            vi-&gt;hdr_len = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> virtio_net_hdr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_F_ANY_LAYOUT) ||</span><br><span class="line">            <span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_F_VERSION_1))</span><br><span class="line">            vi-&gt;any_header_sg = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_CTRL_VQ))</span><br><span class="line">            vi-&gt;has_cvq = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_MTU)) &#123;</span><br><span class="line">            mtu = <span class="built_in">virtio_cread16</span>(vdev,</span><br><span class="line">                        <span class="built_in">offsetof</span>(<span class="keyword">struct</span> virtio_net_config,</span><br><span class="line">                            mtu));</span><br><span class="line">            <span class="keyword">if</span> (mtu &lt; dev-&gt;min_mtu) &#123;</span><br><span class="line">                <span class="comment">/* Should never trigger: MTU was previously validated</span></span><br><span class="line"><span class="comment">                * in virtnet_validate.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="built_in">dev_err</span>(&amp;vdev-&gt;dev,</span><br><span class="line">                    <span class="string">&quot;device MTU appears to have changed it is now %d &lt; %d&quot;</span>,</span><br><span class="line">                    mtu, dev-&gt;min_mtu);</span><br><span class="line">                err = -EINVAL;</span><br><span class="line">                <span class="keyword">goto</span> free;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dev-&gt;mtu = mtu;</span><br><span class="line">            dev-&gt;max_mtu = mtu;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* <span class="doctag">TODO:</span> size buffers correctly in this case. */</span></span><br><span class="line">            <span class="keyword">if</span> (dev-&gt;mtu &gt; ETH_DATA_LEN)</span><br><span class="line">                vi-&gt;big_packets = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vi-&gt;any_header_sg)</span><br><span class="line">            dev-&gt;needed_headroom = vi-&gt;hdr_len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Enable multiqueue by default */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">num_online_cpus</span>() &gt;= max_queue_pairs)</span><br><span class="line">            vi-&gt;curr_queue_pairs = max_queue_pairs;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            vi-&gt;curr_queue_pairs = <span class="built_in">num_online_cpus</span>();</span><br><span class="line">        vi-&gt;max_queue_pairs = max_queue_pairs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Allocate/initialize the rx/tx queues, and invoke find_vqs */</span></span><br><span class="line">        err = <span class="built_in">init_vqs</span>(vi);</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">netif_set_real_num_tx_queues</span>(dev, vi-&gt;curr_queue_pairs);</span><br><span class="line">        <span class="built_in">netif_set_real_num_rx_queues</span>(dev, vi-&gt;curr_queue_pairs);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">virtnet_init_settings</span>(dev);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_STANDBY)) &#123;</span><br><span class="line">            vi-&gt;failover = <span class="built_in">net_failover_create</span>(vi-&gt;dev);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(vi-&gt;failover)) &#123;</span><br><span class="line">                err = <span class="built_in">PTR_ERR</span>(vi-&gt;failover);</span><br><span class="line">                <span class="keyword">goto</span> free_vqs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">register_netdev</span>(dev);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="built_in">virtio_device_ready</span>(vdev);</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">virtnet_cpu_notif_add</span>(vi);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="built_in">virtnet_set_queues</span>(vi, vi-&gt;curr_queue_pairs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Assume link up if device can&#x27;t report link status,</span></span><br><span class="line"><span class="comment">        otherwise get link status from config. */</span></span><br><span class="line">        <span class="built_in">netif_carrier_off</span>(dev);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vi-&gt;vdev, VIRTIO_NET_F_STATUS)) &#123;</span><br><span class="line">            <span class="built_in">schedule_work</span>(&amp;vi-&gt;config_work);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vi-&gt;status = VIRTIO_NET_S_LINK_UP;</span><br><span class="line">            <span class="built_in">virtnet_update_settings</span>(vi);</span><br><span class="line">            <span class="built_in">netif_carrier_on</span>(dev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">ARRAY_SIZE</span>(guest_offloads); i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vi-&gt;vdev, guest_offloads[i]))</span><br><span class="line">                <span class="built_in">set_bit</span>(guest_offloads[i], &amp;vi-&gt;guest_offloads);</span><br><span class="line">        vi-&gt;guest_offloads_capable = vi-&gt;guest_offloads;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pr_debug</span>(<span class="string">&quot;virtnet: registered device %s with %d RX and TX vq&#x27;s\n&quot;</span>,</span><br><span class="line">            dev-&gt;name, max_queue_pairs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重点来看看<code>init_vqs</code>，这个函数首先分配用于接发数据的队列，然后调用<code>virtnet_find_vqs</code>来设置每个接发队列的回调，以及通过<code>virtio_mmio</code>的接口配置中断、配置接发缓冲区的内存等:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">init_vqs</span><span class="params">(<span class="keyword">struct</span> virtnet_info *vi)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate send &amp; receive queues */</span></span><br><span class="line">    ret = virtnet_alloc_queues(vi);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    ret = virtnet_find_vqs(vi);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> err_free;</span><br><span class="line"></span><br><span class="line">    get_online_cpus();</span><br><span class="line">    virtnet_set_affinity(vi);</span><br><span class="line">    put_online_cpus();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>virtnet_find_vqs</code>最终会通过<code>vdev-&gt;config-&gt;find_vqs</code>调用<code>virtio_mmio.c</code>设备的配置操作函数列表<code>virtio_mmio_config_ops-&gt;find_vqs</code>, 即<code>vm_find_vqs</code>, 这个函数主要做了如下几个事情:</p><ul><li>配置中断<code>request_irq</code>, 这个中断号就是从宿主机QNX端配置的，比如数据发送，数据接收等信号都是通过这个中断发送过来的</li><li>为每个接发队列分配足够的环形缓冲区，这个缓冲区的内存位于虚拟机上，分配成功后会通过通过<code>virtio</code>的协议，将对应的缓冲区队列的虚拟地址传递给宿主机QNX端，这样前端驱动就可以与后端进行数据的交互</li></ul><p>有关具体的配置细节可以参考<code>vring_create_virtqueue</code>&#x2F;<code>vring_create_virtqueue</code>这两个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vm_find_vqs</span><span class="params">(<span class="keyword">struct</span> virtio_device *vdev, <span class="type">unsigned</span> nvqs,</span></span><br><span class="line"><span class="params">          <span class="keyword">struct</span> virtqueue *vqs[],</span></span><br><span class="line"><span class="params">          <span class="type">vq_callback_t</span> *callbacks[],</span></span><br><span class="line"><span class="params">          <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> names[],</span></span><br><span class="line"><span class="params">          <span class="type">const</span> <span class="type">bool</span> *ctx,</span></span><br><span class="line"><span class="params">          <span class="keyword">struct</span> irq_affinity *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">virtio_mmio_device</span> *<span class="title">vm_dev</span> =</span> to_virtio_mmio_device(vdev);</span><br><span class="line">  <span class="type">int</span> irq = platform_get_irq(vm_dev-&gt;pdev, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> i, err, queue_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (irq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    dev_err(&amp;vdev-&gt;dev, <span class="string">&quot;Cannot get IRQ resource\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> irq;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err = request_irq(irq, vm_interrupt, IRQF_SHARED,</span><br><span class="line">      dev_name(&amp;vdev-&gt;dev), vm_dev);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (of_property_read_bool(vm_dev-&gt;pdev-&gt;dev.of_node, <span class="string">&quot;virtio,wakeup&quot;</span>))</span><br><span class="line">    enable_irq_wake(irq);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nvqs; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!names[i]) &#123;</span><br><span class="line">      vqs[i] = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vqs[i] = vm_setup_vq(vdev, queue_idx++, callbacks[i], names[i],</span><br><span class="line">            ctx ? ctx[i] : <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(vqs[i])) &#123;</span><br><span class="line">      vm_del_vqs(vdev);</span><br><span class="line">      <span class="keyword">return</span> PTR_ERR(vqs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p><code>virtio</code>是虚拟化技术中很常见的一种设备虚拟化方案，相比全模拟的设备虚拟化，<code>virtio</code>效率更高，性能更优；正是因为其在性能上的优势，<code>virtio</code>在QNX, KVM， QEMU等虚拟化方案中都得到了广泛的应用，QNX中的网络, 磁盘等虚拟化设备都是基于该技术方案实现的。目前，<code>virtio</code>的接口已经被<code>OASIS</code>标准化，这样前端的设备驱动开发与后端宿主机的驱动实现了完全的解耦，彼此只需要遵循标准的接口与协议即可相互匹配工作。</p><p>这篇文章我们主要以<code>virtio-net</code>虚拟网卡为例来说明<code>virtio</code>的大致原理，感兴趣的同学也可以下载<code>Linux</code>内核代码学习下其他如输入设备、块设备等虚拟设备驱动是如何实现的, 主要代码路径如下:</p><ul><li><code>drivers/virtio</code>: <code>virtio</code>的数据传输层代码，包括<code>PCI/MMIO</code>两种设备枚举方式以及<code>vring</code>的实现</li><li><code>drivers/net/virtio_net.c</code>: 虚拟网卡设备驱动</li><li><code>drivers/block/virtio_blk.c</code>: 块设备驱动</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blogs.oracle.com/linux/post/introduction-to-virtio">https://blogs.oracle.com/linux/post/introduction-to-virtio</a></li><li><a href="https://developer.ibm.com/articles/l-virtio/">https://developer.ibm.com/articles/l-virtio/</a></li><li><a href="https://www.cs.cmu.edu/~412/lectures/Virtio_2015-10-14.pdf">https://www.cs.cmu.edu/~412/lectures/Virtio_2015-10-14.pdf</a></li><li><a href="https://en.wikipedia.org/wiki/Kernel-based_Virtual_Machine">https://en.wikipedia.org/wiki/Kernel-based_Virtual_Machine</a></li><li><a href="https://lwn.net/Articles/239238/">An API for virtual I&#x2F;O: virtio</a></li><li><a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html">Virtual I&#x2F;O Device (VIRTIO) Version 1.2</a></li><li><a href="https://genode.org/documentation/articles/arm_virtualization">ARM virtualization</a></li><li><a href="https://developer.arm.com/documentation/100942/0100/Hypervisor-software">AArch64 virtualization</a></li><li><a href="https://tinylab.org/virtio-intro/#virtio-net">https://tinylab.org/virtio-intro/#virtio-net</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在讲&lt;a href=&quot;https://sniffer.site/2023/08/09/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E4%BA%8Cqnx%E8%99%9A%E6%8B%9F%E5%8C%96%E5%B9%B3%E5%8F%B0%E7%AE%80%E4%BB%8B/&quot;&gt;虚拟化的第二篇QNX系统&lt;/a&gt;时，提到在&lt;code&gt;QNX&lt;/code&gt;中设备的虚拟化有直通(&lt;code&gt;pass-through&lt;/code&gt;)、半虚拟化(&lt;code&gt;para-virtulization&lt;/code&gt;)、全虚拟化(&lt;code&gt;full-virtualization&lt;/code&gt;)等几种形式，而像串口、网络设备、块设备等通常都是基于半虚拟化的形式实现的。在半虚拟化的实现方案中，&lt;code&gt;virtio&lt;/code&gt;是最常见的一种。简单来说，&lt;code&gt;virtio&lt;/code&gt;是虚拟化设备的中间抽象层，为设备的虚拟化提供了一个统一的框架与接口，增加了跨平台时代码的复用性。</summary>
    
    
    
    <category term="虚拟化" scheme="https://sniffer.site/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="https://sniffer.site/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="QNX" scheme="https://sniffer.site/tags/QNX/"/>
    
    <category term="virtio" scheme="https://sniffer.site/tags/virtio/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化之二QNX虚拟化平台简介</title>
    <link href="https://sniffer.site/2023/08/09/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E4%BA%8CQNX%E8%99%9A%E6%8B%9F%E5%8C%96%E5%B9%B3%E5%8F%B0%E7%AE%80%E4%BB%8B/"/>
    <id>https://sniffer.site/2023/08/09/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E4%BA%8CQNX%E8%99%9A%E6%8B%9F%E5%8C%96%E5%B9%B3%E5%8F%B0%E7%AE%80%E4%BB%8B/</id>
    <published>2023-08-09T07:33:40.000Z</published>
    <updated>2023-08-10T04:34:45.997Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/QNX"><code>QNX</code></a>最初是<code>Gordon Bell</code>与<code>Dan Dodge</code>两人在1980年代初期创建的一个实时微内核操作系统(<code>RTOS(Real-Time Operating System</code>), 后来被黑莓(<code>BlackBerry</code>)公司收购，因此也叫做<code>Blackberry QNX</code>系统。<code>QNX</code>被世人熟知还是因为其高安全性、<code>QNX hypervisor</code>等特性在汽车领域的广泛应用。</p><span id="more"></span><p>这篇文章，我们就来看看<code>QNX</code>虚拟化平台的基本架构与实现原理，着重会介绍虚拟化方案:</p><ul><li>介绍<code>QNX</code>以及虚拟化平台的基本概念与架构</li><li>介绍QNX虚拟化的实现方法，包括<code>CPU</code>虚拟化，内存虚拟化，设备虚拟化等</li></ul><h2 id="QNX虚拟化平台的架构组成"><a href="#QNX虚拟化平台的架构组成" class="headerlink" title="QNX虚拟化平台的架构组成"></a><strong>QNX虚拟化平台的架构组成</strong></h2><p><code>QNX</code>系统是一个微内核(<code>microkernel</code>)的类<code>UNIX</code>的实时操作系统，支持<code>x86/ARM/PowerPC/MIPS</code>等多个芯片架构，可以应用到从小型的嵌入式硬件到大型的分布式系统中。总结来说，主要有如下几个特点:</p><ul><li>微内核的实时操作系统: 与Linux这样的宏内核(<code>Monolithic</code>)操作系统不同的是，QNX采用的微内核的实现。内核只实现了很少一部分功能，比如进程管理与进程通讯，进程同步与调度等，其他的如文件系统，设备驱动以及网络协议栈都在用户空间中实现。这么做一个明显的好处是，内核不会设备驱动或者网络协议栈等异常崩溃而卡死，从而提升了系统的稳定性与可用性；进程的上下文切换效率更高，因而实时性更好。</li><li>支持<code>POSIX</code>接口: 与大部分<code>UNIX</code>的操作系统类似，<code>QNX</code>支持<code>POSIX</code>标准接口，这样其他很多比如在<code>Linux</code>上写的程序就可以直接移植到<code>QNX</code>上，减少了开发成本。</li><li>系统级别的HA(<code>High Availability</code>)框架： <code>QNX</code>专门提供了一套高可用的开发框架，可以用于进程的快速恢复，确保系统业务功能的高可用性。</li><li>多个行业安全认证: <code>QNX</code>代码经过多个行业安全标准，如通信行业的<code>FIPS 140-2</code>, 工控行业的<code>IEC 61508</code>, 汽车电子领域的<code>ISO 26262</code>等等，从代码级别上提升了系统的安全性。</li><li>支持多个硬件平台：支持市面上大部分<code>SoC</code>供应商如<code>AMD</code>、<code>Intel</code>、<code>Nvidia</code>、<code>NXP</code>、<code>Qualcomm</code>的芯片</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qnx-sys-architecture.jpg" alt="QNX RTOS"></p><p>如上图所示，是<code>QNX</code>系统的一个架构简图，可以看到，内核为所有进程通讯提供了一个软总线(<code>software bus</code>),进程之间的通讯都是通过这条软总线传递消息。内核只是实现了诸如线程管理、消息传递、发送信号、中断处理、并发同步等功能，其他的如显示驱动，文件系统，网络协议栈、字符设备等统一在用户空间实现。</p><p><code>QNX</code>在原有系统上进行了虚拟化扩展，支持了<code>hypervisor</code>功能；在<code>hypervisor</code>的基础上，<code>QVM</code>(<code>QNX Virtual Machine</code>)支持运行如<code>Linux</code>、<code>Android</code>、<code>QNX</code>等<code>Guest</code>操作系统。目前常见的汽车座舱芯片如<code>Renesas R-Car H3</code>, 高通<code>820A</code>、<code>8155</code>以及<code>NXP i.MX 8</code>等都支持<code>QNX</code>虚拟化方案。</p><p>下图是<code>QNX</code>虚拟化平台的一个框架简图，每个运行的客户操作系统(<code>Guest OS</code>)都对应个<code>QVM</code>进程；客户操作系统可以通过虚拟设备或者<code>pass-through</code>的方式访问控制硬件。实际上，对<code>QNX</code>来说，客户操作系统并不一定运行在虚拟的环境，而是大部分时候都直接在物理<code>CPU</code>上执行指令，只有当需要访问一些特权指令或者无法访问的内存时，<code>hypervisor</code>才会介入，执行虚拟化相关的指令，让虚拟机退出。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qnx_qvm_arch.png" alt="QNX hypervisor architecture"></p><p>以单个<code>CPU</code>的执行流程为例，当<code>hypervisor</code>陷入到虚拟化相关的指令后，首先会尝试保存当前虚拟机的上下文信息，此时虚拟机退出，由<code>hypervisor</code>完成必要的工作后再恢复虚拟机的上下文，重新执行虚拟机被打断的流程(具体路程参考下图):</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qvm_lahavline.png" alt="The lahav line"></p><p>接下来我们就具体来看看<code>QNX</code>是如何实现<code>CPU</code>、内存、<code>I/O</code>设备以及中断是如何处理的。</p><h2 id="QNX虚拟化实现"><a href="#QNX虚拟化实现" class="headerlink" title="QNX虚拟化实现"></a><strong>QNX虚拟化实现</strong></h2><h3 id="CPU的虚拟化"><a href="#CPU的虚拟化" class="headerlink" title="CPU的虚拟化"></a><strong>CPU的虚拟化</strong></h3><p>虚拟机上的进程的调度实际是以虚拟<code>CPU</code>(vCPU)为基础进行的，每个虚拟机在启动时，可以配置<code>vCPU</code>的数量;<code>vCPU</code>的调度是由在<code>hypervisor</code>中的调度线程负责执行的。一个物理<code>CPU</code>可能对应着多个<code>vCPU</code>；类似的，一个<code>vCPU</code>也可以选择在多个物理<code>CPU</code>上电调度执行。需要注意的是，虚拟机中的线程优先级与宿主机中<code>QNX</code>的线程优先级没有关系，具体何时执行哪个<code>vCPU</code>完全是由<code>hypervisor</code>中的调度线程的优先级决定的: 两个<code>vCPU</code>竞争物理<code>CPU</code>时，对应的<code>hypervisor</code>调度线程的优先级更高的任务获得对应的物理<code>CPU</code>执行权。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qnx-process-schedule.png" alt="QNX虚拟化中进程的调度"></p><p>虚拟机的线程调度到物理<code>CPU</code>的过程类似与普通操作系统中进程上下文切换的过程: 在虚拟机上需要保存当前线程的上下文信息，接着通过一个虚拟指令陷入(<code>trap</code>, 这个跟<code>Linux</code>下的系统调用从用户空间切换到内核空间的过程很类似)到<code>hypervisor</code>中，然后由<code>hypervisor</code>最终完成整个调度上下文的状态保存与切换。当一个客户虚拟机中发生如<code>QNX</code>的中断，虚拟设备访问(不一定放弃<code>CPU</code>的控制权)，虚拟时钟到期等事件时，虚拟机就会让出当前<code>CPU</code>的控制权。</p><h3 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a><strong>内存虚拟化</strong></h3><p><code>QNX</code>中使用<a href="https://developer.arm.com/documentation/102142/0100/Stage-2-translation"><code>stage 2 translation</code>(二阶转换)</a>来完成内存的虚拟化，虚拟机看到的<code>物理内存</code>实际上是<code>QNX</code>宿主系统管理的非连续虚拟内存而已：二阶内存转换就是在正常的<code>VA-&gt;PA</code>之间增加一个地址转换过程<code>IPA(Intermediate Physical Address)</code>，于是虚拟机的内存访问就变成了<code>VA-&gt;IPA-&gt;PA</code>这样一个二阶段的过程。</p><ul><li>阶段1的内存地址转换<code>VA-&gt;IPA</code>由虚拟机来控制完成</li><li>阶段2的内存地址转换<code>IPA-&gt;PA</code>由<code>QNX</code>宿主机系统来完成</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qnx-hyp-ipa-pa.png" alt="QNX内存虚拟化"></p><p>由于增加了中间地址的转换层<code>IPA</code>，这样虚拟机与<code>QNX</code>宿主机之间的内存空间就完全隔离了，虚拟机只能看到<code>QNX</code>宿主机分配好的内存，无法访问其他虚拟机或者宿主机的内存空间。除此之外，<code>QNX</code>还提供了额外的内存访问方式:</p><ul><li><code>Pass-through memory</code>:直通内存允许虚拟机将某些设备直接映射到某个内存区域，然后直接访问这个物理设备；直通模式下的设备只有该虚拟机才能访问，在性能上比虚拟的设备会更高。有关直通设备的详细信息可以参考<a href="https://www.qnx.com/developers/docs/7.0.0/index.html#com.qnx.doc.hypervisor.user/topic/virt/pdevs.html">直通设备</a></li><li><code>Shared Memory</code>: 共享内存允许不同虚拟机共享同一块物理内存，通过该内存区域进行数据交互</li></ul><h3 id="I-x2F-O设备虚拟化"><a href="#I-x2F-O设备虚拟化" class="headerlink" title="I&#x2F;O设备虚拟化"></a><strong>I&#x2F;O设备虚拟化</strong></h3><p>在<code>QNX</code>中，物理设备可以由宿主机或者虚拟机独占，也可以由虚拟机与宿主机之间共享。虚拟机要访问物理设备，可以通过直通或者虚拟化的方式实现:</p><ul><li><code>Pass-through device</code>: 直通设备的访问完全由虚拟机控制，驱动也在虚拟机中实现， 而<code>hypervisor</code>只是负责识别、传递来自设备的中断，传递来自虚拟机发送过来的信号。</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qvm_pdev_passthru.png" alt="pass-through device"></p><ul><li><code>Virtual Devices</code>: 虚拟设备<code>vdev</code>可以是一个物理设备的模拟，也可以只是提供了一个类似物理设备功能的模拟设备。与直通设备类似，虚拟机要使用虚拟设备也需要提供驱动。目前<code>QNX hypervisor</code>提供了两种形式的虚拟设备-一个是模拟(<code>Emulation</code>)设备，一个是半虚拟化设备(<code>para-virtualized</code>， 见下图)。<code>QNX</code>中很多设备都是通过半虚拟化提供给虚拟机的，如输入设备、虚拟网卡都是通过半虚拟化方式<code>virtio</code>实现的，后面我们会专门用一篇文章来分析下<code>virtio</code>的虚拟化设备怎样的工作原理。</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qvm_vdev_paravirt.png" alt="Para-virtualized devices"></p><p>更多有关<code>QNX</code>支持的虚拟设备的可以参考<a href="https://www.qnx.com/developers/docs/7.0.0/index.html#com.qnx.doc.hypervisor.user/topic/vdev_ref/vdev_ref.html">vdev references</a>。</p><h3 id="虚拟机的中断处理流程"><a href="#虚拟机的中断处理流程" class="headerlink" title="虚拟机的中断处理流程"></a><strong>虚拟机的中断处理流程</strong></h3><p>每个中断都有一个中断号，如果设备需要处理中断，需要通过<code>vdev</code>或者<code>pass</code>直通的方式传递给虚拟机:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//vdev </span></span><br><span class="line">vdev vdev-virtio-i2c.so loc <span class="number">0x1cd00000</span> intr gic:<span class="number">104</span> verbose <span class="number">3</span> device i2c5</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass through</span></span><br><span class="line">pass intr gic:<span class="number">183</span>=<span class="number">183</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当一个中断发生时，如下图所示一般分为两种情况:</p><ul><li>如果当前中断发生的<code>CPU</code>执行是虚拟机线程，则首先虚拟机的线程退出，将中断丢给<code>hypervisor</code>处理，并切换到宿主机，由<code>QNX</code>判断该中断属于虚拟机还是宿主机:如果中断属于宿主机<code>QNX</code>，则由其处理中断即可；如果是属于虚拟机的中断，则需要通过<code>hypervisor</code>发送一个中断信号给虚拟机，然后交由虚拟机处理</li><li>如果当前中断发生的<code>CPU</code>执行的是宿主机<code>QNX</code>线程，<code>QNX</code>判断是虚拟机的线程则按照前述的步骤交由虚拟机处理。</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/gic_handling_process.png" alt="GIC handling process"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="http://www.qnx.com/developers/docs/">QNX 系统资料</a></li><li><a href="https://www.qnx.com/developers/docs/7.0.0/index.html#com.qnx.doc.hypervisor.nav/topic/bookset.html">QNX hypervisor</a></li><li><a href="https://developer.arm.com/documentation/102142/0100/Overview">ARM virtualization文档</a></li><li>hardware and software support for virtualization(Edouard Bugnion, Jason Nieh, and Dan Tsafrir)</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/QNX&quot;&gt;&lt;code&gt;QNX&lt;/code&gt;&lt;/a&gt;最初是&lt;code&gt;Gordon Bell&lt;/code&gt;与&lt;code&gt;Dan Dodge&lt;/code&gt;两人在1980年代初期创建的一个实时微内核操作系统(&lt;code&gt;RTOS(Real-Time Operating System&lt;/code&gt;), 后来被黑莓(&lt;code&gt;BlackBerry&lt;/code&gt;)公司收购，因此也叫做&lt;code&gt;Blackberry QNX&lt;/code&gt;系统。&lt;code&gt;QNX&lt;/code&gt;被世人熟知还是因为其高安全性、&lt;code&gt;QNX hypervisor&lt;/code&gt;等特性在汽车领域的广泛应用。&lt;/p&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://sniffer.site/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="virtualization" scheme="https://sniffer.site/tags/virtualization/"/>
    
    <category term="虚拟化" scheme="https://sniffer.site/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="QNX" scheme="https://sniffer.site/tags/QNX/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化之一虚拟机的基本概念</title>
    <link href="https://sniffer.site/2023/06/30/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E4%B8%80%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://sniffer.site/2023/06/30/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E4%B8%80%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2023-06-30T05:58:13.000Z</published>
    <updated>2023-06-30T06:06:42.944Z</updated>
    
    <content type="html"><![CDATA[<p>这两年汽车领域在智能与域融合的推动下，开始兴起了各种虚拟化(<code>Virtualization</code>)的座舱解决方案，尤其以<a href="https://blackberry.qnx.com/en">黑莓公司的<code>QNX</code>虚拟化</a>方案应用最为广泛。说起来，虚拟化并不是什么新的概念，操作系统诞生之初就有了类似的原型: 对于一个分时的操作系统，通过在不同进程之间切换状态，给每个用户都制造一种完全使用整个机器的感觉，实则是操作系统通过进程之间的资源分时复用实现的结果。简单来说，虚拟化就是一种资源隔离与抽象的方案，通过对<code>CPU</code>、<code>Memory</code>、<code>I/O</code>设备增加中间层的访问控制，以达到与访问物理资源同等的效果。</p><span id="more"></span><p>在接下来的三篇文章里，我们就来一起来梳理虚拟化方案的整体脉络，先从大的基本概念入手，再将具体的实现细节，力求能够理解虚拟化的基本概念与实现原理:</p><ul><li>虚拟机的基本概念，主要讲虚拟化方案的优势，类型以及常见的虚拟化方案</li><li>汽车软件中常用的<code>QNX</code>虚拟化平台介绍，以及<code>CPU</code>、<code>I/O</code>、<code>Memory</code>以及中断虚拟化的具体原理</li><li><code>Linux</code>下的<code>I/O</code>设备虚拟化方案<code>virtio</code>的原理介绍</li></ul><p>这篇文章，我们就来看看虚拟化的一些基本概念，以及实现的类型与方式。</p><h2 id="虚拟化的基本概念"><a href="#虚拟化的基本概念" class="headerlink" title="虚拟化的基本概念"></a><strong>虚拟化的基本概念</strong></h2><p>从本质来说，虚拟化是一种资源隔离与权限访问控制的方法，比如常见的操作系统中的虚拟内存(<code>Virtual Memory</code>)以及<code>Java</code>中的<code>JVM(Java Virtual Machine</code>)都是基于类似的思路实现的。<code>JVM</code>是一种语言级别的虚拟化解决方案，其更多的是为了提供一个跨平台的执行环境，以解决编程语言的移植性;对于系统级别的虚拟化方案，如<code>VMWare/Xen/QNX</code>等，则是为了虚拟化整个操作系统所需要的环境，从而实现不同操作系统在同一个平台运行的目的。</p><p>常见的虚拟化方案有两种，分别称为<code>type-1</code>和<code>type-2</code>:</p><ul><li><code>type-1</code>的虚拟化方案的<code>hypervisor</code>直接运行在硬件上，此类虚拟机常见的有<code>VMWare ESX server</code>、<code>Xen</code>以及<code>QNX</code>等</li><li><code>type-2</code>的虚拟化方案的<code>hypervisor</code>则跑在一个宿主操作系统上,常见的虚拟机有<code>QEMU</code>、<code>VMWare Workstations</code>、<code>KVM</code>、<code>Oracle VirtualBox</code>等</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/vm-type.png" alt="虚拟化平台类型"></p><blockquote><p><code>hypervisor</code>是为虚拟机提供运行环境的系统软件，其目的是为了尽可能减少虚拟化带来的性能损失，也被称为<code>Virtual Machine Monitor(VMM)</code></p></blockquote><p>1974年， <code>Popek</code>与<code>Goldberg</code>提出了一个虚拟化管理程序<code>hypervisor</code>所需要遵循的三个基本的原则:</p><ul><li><code>Equivalence</code>(等价性): 虚拟机所执行的环境跟实际的物理硬件是等价的，一个<code>Guest</code>操作系统并不需要知道其本身是运行在虚拟机上还是实际的物理机上。这个规定相对而言比较严格，有时为了实现某些功能或者性能需要，<code>Guest</code>操作系统可能需要知道自己当前执行的是虚拟环境。</li><li><code>Safty</code>(安全): 虚拟化的隔离要求不同的虚拟机之间以及与<code>hypervisor</code>是完全隔离的，确保每个系统都是模块化的，互不影响。</li><li><code>Performance</code>(性能)： 虚拟化<code>hypervisor</code>需要尽可能的减少因为隔离与控制切换带来的性能损失，以接近于真实的物理执行环境的速度。</li></ul><h2 id="虚拟化的方法"><a href="#虚拟化的方法" class="headerlink" title="虚拟化的方法"></a><strong>虚拟化的方法</strong></h2><p>早期的很多虚拟化方案，由于没有芯片指令级的支持，通常都需要通过<a href="https://www.vmware.com/pdf/asplos235_adams.pdf">二进制翻译(<code>binary translation</code>)的方式</a>来达到<code>trap-and-emulate</code>(陷入与模拟)的虚拟化隔离，但这种方式效率较低，因此随着后续<code>x86</code>、<code>ARM</code>等平台增加了专门用于虚拟化的指令集，从而提升了虚拟机程序执行的效率。</p><p>实现虚拟化的方法一般有如下三种(下图中包含了软虚拟化与半虚拟化方案的示意图):</p><ul><li>软件虚拟化(<code>Full(software) Virtualization</code>): 虚拟机完全运行在<code>hypervisor</code>之上，并不知道当前运行在虚拟的环境中。常见的虚拟化提供商<code>VirtualBox/VMWare</code>都有类似的解决方案</li><li>硬件辅助虚拟化(<code>Hardware Virtualization, HVM</code>): 通过在芯片指令集中增加特殊的指令来辅助进行虚拟化，以提升虚拟化的性能</li><li>半虚拟化(<code>Paravirtualization</code>): 半虚拟化方案则通过虚拟机与<code>hypervisor</code>相互协作以完成虚拟化操作，此时虚拟机需要做额外的配置以实现虚拟化</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/virtualization-methods.gif" alt="虚拟化的实现方法"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>虚拟化的概念伴随着计算机操作系统的概念一起诞生的，至今已有几十年历史。不管是在个人消费领域，还是分布式系统上，都可以看到虚拟化的身影。而在汽车领域，由于软件定义汽车(<code>SDV(Software Define Vehicle</code>)&#x2F;<code>SOA(Service Oriented Achitecture)</code>等概念与方案的逐步落地，用户对车辆不再满足于单一行车的功能，而是会有更多如个性化、智能化以及网联的需求。这些功能要求汽车厂商以及供应商具备更快速开发迭代的能力。目前虚拟化方案已经开始成为主机厂与方案供应商T1的首选方案了。未来，相信随着智能座舱域与自动驾驶域逐步走向融合，虚拟化方案由于其安全、高可用性、资源隔离等优点会得到更多的应用。</p><p>在下一篇文章，我们就一起来看看汽车领域的虚拟化方案领先者-<code>QNX</code>系统的架构与虚拟化实现原理。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.ibm.com/articles/l-virtio/">Virtio: An I&#x2F;O virtualization framework for Linux</a></li><li><a href="https://www.vmware.com/pdf/asplos235_adams.pdf">A Comparison of Software and Hardware Techniques for x86 Virtualization</a></li><li><a href="https://blackberry.qnx.com/en">Blackberry QNX</a></li><li>hardware and software support for virtualization(Edouard Bugnion, Jason Nieh, and Dan Tsafrir)</li><li><a href="https://github.com/Wenzel/awesome-virtualization">awesome-virtualization</a></li><li><a href="https://developer.ibm.com/tutorials/l-hypervisor/">Anatomy of a Linux hypervisor</a></li><li><a href="https://genode.org/documentation/articles/arm_virtualization">An in-depth look into the ARM virtualization extensions</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两年汽车领域在智能与域融合的推动下，开始兴起了各种虚拟化(&lt;code&gt;Virtualization&lt;/code&gt;)的座舱解决方案，尤其以&lt;a href=&quot;https://blackberry.qnx.com/en&quot;&gt;黑莓公司的&lt;code&gt;QNX&lt;/code&gt;虚拟化&lt;/a&gt;方案应用最为广泛。说起来，虚拟化并不是什么新的概念，操作系统诞生之初就有了类似的原型: 对于一个分时的操作系统，通过在不同进程之间切换状态，给每个用户都制造一种完全使用整个机器的感觉，实则是操作系统通过进程之间的资源分时复用实现的结果。简单来说，虚拟化就是一种资源隔离与抽象的方案，通过对&lt;code&gt;CPU&lt;/code&gt;、&lt;code&gt;Memory&lt;/code&gt;、&lt;code&gt;I/O&lt;/code&gt;设备增加中间层的访问控制，以达到与访问物理资源同等的效果。&lt;/p&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://sniffer.site/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="virtualization" scheme="https://sniffer.site/tags/virtualization/"/>
    
    <category term="虚拟化" scheme="https://sniffer.site/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="QNX" scheme="https://sniffer.site/tags/QNX/"/>
    
  </entry>
  
  <entry>
    <title>投屏中的服务发现协议</title>
    <link href="https://sniffer.site/2023/05/27/%E6%8A%95%E5%B1%8F%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8D%8F%E8%AE%AE/"/>
    <id>https://sniffer.site/2023/05/27/%E6%8A%95%E5%B1%8F%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8D%8F%E8%AE%AE/</id>
    <published>2023-05-27T06:29:32.000Z</published>
    <updated>2023-07-07T01:40:37.150Z</updated>
    
    <content type="html"><![CDATA[<p>投屏是指将某个终端的音视频或者其他内容通过有线或者无线的形式投射到其他终端上的一种协议。目前常见的投屏协议有<code>DLNA</code>&#x2F;<code>Airplay</code>&#x2F;<code>Mirracast</code>&#x2F;<code>Chromecast</code>:</p><ul><li><code>DLNA</code>(<code>Digital Living Network Alliance</code>): <a href="https://en.wikipedia.org/wiki/Digital_Living_Network_Alliance">DNLA</a>是由英特尔、索尼、微软等消费电子巨头在2003年建立的一个文件共享协议，目前很多的电视都会支持<code>DLNA</code>协议，用于手机与电视之间共享视频与图片等资源。</li><li><code>Airplay</code>: <a href="https://en.wikipedia.org/wiki/AirPlay">Airplay</a>是苹果公司开发的一个私有的投屏协议，实际包含了视频投屏与屏幕镜像等几个功能(音视频数据流包括交互控制协议都有是加密的)，可以用于播放音频、视频，也可以把本地的图片投屏到电视上进行浏览。目前国内很多支持<code>Airplay</code>的投屏协议都是基于秘钥破解进行开发的。<span id="more"></span></li><li><code>Mirracast</code>: <a href="https://www.wi-fi.org/discover-wi-fi/miracast">Mirracast</a>是<code>WIFI</code>联盟在2012年推出的一种基于<code>WIFI</code>将某个终端设备的音视频投屏到其他终端(比如电视、平板)上的协议，通常也被称为<code>HDMI over WIFI</code>。<code>Android</code>最开始在<code>AOSP 4.1</code>上实现了一个类似的<code>Mirracast</code>协议，后来的版本则全部删除了，后来<code>Google</code>就推出了闭源的一个投屏协议<code>Chromecast</code>。</li><li><code>Chromecast</code>: <code>Google</code>在2013年基于<code>Google Cast</code>协议开发的一个闭源的投屏协议，可以用于播放在线的音视频内容,用户可以通过支持<code>Google Cast</code>协议的手机或PC上的浏览器来控制音视频内容的播放。同时，<code>Google</code>提供了一个SDK给第三方应用开发投屏功能。</li></ul><p>对一个投屏协议来说，要在两个终端之间建立一个投屏的连接，通常需要经历如下几个步骤:</p><ul><li>被投屏的设备端以广播的形式向局域网的设备发布服务(该服务的信息通常会包含设备的名车，IP地址，以及通讯所用的端口地址等)</li><li>需要投屏的终端发现该服务后，会基于广播中的端口地址与另一端建立网络链接(控制与数据传输可能需要分开两个连接)</li><li>网络连接建立完成后，服务端需要告知对端设备的一些配置信息(比如设备的显示器的大小以及刷新率等)</li><li>投屏完成初始化配置后，最后一步就是投屏的终端向服务端发送需要投屏的内容(内容可能是音视频数据流，也可能是一个在线播放的<code>URL</code>)</li></ul><p>从上面的流程，我们可以看到，不同的投屏协议在其他方面可能有很大差别，但都离不开服务发现协议(<code>Service Discovery</code>)。在这篇文章，我们就来看看<code>DLNA</code>&#x2F;<code>Airplay</code>&#x2F;<code>Mirracast</code>三种投屏协议中所使用到的服务发现协议具体是怎么个原理。</p><h2 id="DLNA的服务发现"><a href="#DLNA的服务发现" class="headerlink" title="DLNA的服务发现"></a><strong>DLNA的服务发现</strong></h2><p>在<code>DLNA</code>中，播放音视频的一方通常被称为<code>Digital Media Renderer(DMR)</code>，而发送音视频数据的一方则称为<code>Digital Media Server(DMS)</code>, 负责中转数据的设备节点则称为<code>Control Point</code>(一般情况下，我们通常只有<code>DMS/DMR</code>两个设备，因此下文都是基于这种两个设备通讯的情况下进行讨论的)。<code>DLNA</code>使用<code>UPnP(Universal Plug and Play)</code>协议来进行服务发现以及数据的传输；<code>UPnP</code>可以在网络连接后通过<code>UDP</code>端口<code>1900</code>自动发布服务，<code>DMS</code>在收到该服务的广播消息后，会发送一个消息确认<code>DMR</code>的存在，这样整个服务发现过程就完成了。<code>UPnP</code>使用的服务发现协议叫做<code>SSDP(Simple Service Discovery Protocol)</code>。</p><p><code>DMR</code>服务启动后，会不断的通过组播地址<code>239.255.255.250:1900</code>发送<code>Advertisement</code>消息，广播系统当前的设备与服务状态(如果<code>DMR</code>中有多个设备或者服务，则会同时发送多个组播消息)，告知<code>DMS</code>有相应的设备与服务可用; 需要投屏的设备(<code>DMS</code>)收到该广播消息后，主动发送一个<code>M-SEARCH(ssdp:discover)</code>的消息, <code>DMR</code>收到该消息后需要发送一个<code>UDP</code>消息给<code>DMS</code>设备，该消息需要包含一个与广播<code>Advertisement</code>中一样的<code>UUID</code>。<code>Advertisement</code>消息一般有三种类型:</p><ul><li><code>NOTIFY ssdp:alive</code>: 当一个设备加入到网络中时需要发送<code>alive</code>消息广播根设备(<code>root device</code>)以及其他设备与服务的为可用状态，这样其他设备收到该消息后就可以发起连接</li><li><code>NOTIFY ssdp:byebye</code>: 设备从网络中移除时需要发送一个<code>byebyte</code>的消息告知其他节点设备即将变为不可用状态</li><li><code>NOTIFY ssdp:update</code>: 这个消息主要用于多IP设备广播设备与服务状态</li></ul><p>以<code>alive</code>组播消息为例，可以看到对于<code>SSDP</code>报文来说，最主要的字段主要有如下几个:</p><ul><li><code>CACHE-CONTROL:max-age=1800</code>: <code>Advertisement</code>消息最长生命周期</li><li><code>LOCATION</code>: 根设备的<code>URL</code>地址，一般是由IP地址与连接协议的监听端口号组成</li><li><code>NT</code>: 通知类型，如果是根设备通常是<code>upnp:rootdevice</code>, 其他设备对应的类型值是<code>NT:uuid:&lt;uuid&gt;</code>；如果是服务，则一般以<code>urn</code>开头,如:<ul><li><code>NT: urn:schemas-upnp-org:device:MediaRenderer</code></li><li><code>NT: urn:schemas-upnp-org:service:ConnectionManager</code></li></ul></li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ssdp-advertisement.png" alt="SSDP服务广播报文结构"></p><p>一旦完成服务发现，<code>DMR</code>通过<code>SOAP/XML</code>以及<code>HTTP</code>协议发布服务能力以及支持的协议，比如是否可以播放视频，是否能浏览图片等，最后通过连接服务来发送控制指令，可以完成诸如播放、暂停、跳转等功能。更多有关<code>UPnP/SSDP</code>协议相关的可以参考如下两个链接:</p><ul><li><a href="https://openconnectivity.org/upnp-specs/UPnP-arch-DeviceArchitecture-v2.0-20200417.pdf">UPnP Device Architecture 2.0</a></li><li><a href="https://github.com/4thline/cling">开源的协议实现:UPnP for Java&#x2F;Android</a></li></ul><h2 id="Airplay中的服务发现"><a href="#Airplay中的服务发现" class="headerlink" title="Airplay中的服务发现"></a><strong>Airplay中的服务发现</strong></h2><p>苹果的<code>Airplay</code>协议算是投屏协议里比较完全全面的，可以支持在线的音视频投屏、屏幕镜像以及图片浏览等功能，而且投屏过程中加入了私有秘钥验证机制，可以说是这几个投屏协议里安全性最好的。另外，<code>Airplay</code>可以支持有线与无线两种投屏方式。</p><p>实际上<code>Airplay</code>包含了两个服务，一个用于传输音频数据流的<a href="https://en.wikipedia.org/wiki/Remote_Audio_Output_Protocol"><code>RAOP(Remote Audio Output Protocol)</code></a>; 一个是用于传输视频与图片数据流的<code>Airplay</code>服务。<code>Airplay</code>中的服务发现是基于<code>DNS</code>的多播协议<code>muticast DNS(mDNS)</code>(最开始由<code>Apple</code>开源出来，也叫做<code>Bonjour</code>)来实现的，服务的发布与发现类似与域名的<code>DNS</code>解析过程:</p><ul><li>服务端通过<code>mDNS</code>服务进程发布<code>RAOP/Airplay</code>服务, 并监听<code>UDP</code>端口<code>5353</code></li><li>客户端连接上同一网络后，会发送<code>QUERY</code>到多播地址<code>224.0.0.251</code>对应的<code>5353</code>端口</li><li>服务端的<code>mDNS</code>收到请求后，把登记好的服务发送给对应的客户端</li></ul><blockquote><p>通过单播(<code>Unicast</code>)方式发送的<code>QUERY</code>响应(<code>RESPONSE</code>)的消息，称为<code>QU</code>消息; 通过多播方式发送<code>RESPONSE</code>的消息，称为<code>QM</code>消息。这个标志位会在<code>mDNS</code>消息中设置</p></blockquote><p>下面两个图分别是<code>mDNS</code>的<code>QUERY/RESPONSE</code>的消息，可以看到<code>mDNS</code>的消息结构与<code>DNS</code>的完全一致: <code>QUERY</code>中包含了需要查询的服务以及权威名称服务(<code>Authoritative nameservers</code>， 实际是客户端网口的<code>MAC</code>组成的一个名字而已); <code>RESPONSE</code>消息(根据记录类型不同，一般有<code>PTR</code>&#x2F;<code>TXT</code>两种)包含了服务的名称、协议类型，端口号以及协议所需要的其他字段(如设备的属性，设备的能力以及<code>MAC</code>地址等)。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/mdns-query.png" alt="mDNS query message"></p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/mdns-query-response.png" alt="mDNS query response"></p><p>完成服务发现后，客户端就会根据查询到的服务的端口与服务端建立连接，一般数据传输都使用<code>TCP</code>传输，其他的如时间同步协议则使用<code>UDP</code>。</p><p><code>Android</code>中已经集成了<code>mDNS</code>协议，代码可以参考<a href="https://cs.android.com/android/platform/superproject/+/master:external/mdnsresponder/">mdnsresponder</a>, 有关<code>mDNS</code>的详细细节可以参考<a href="https://www.rfc-editor.org/rfc/rfc6762.html">RFC6762</a>。</p><p><code>Airplay</code>是苹果公司的私有投屏协议，网上有一些相关的协议逆向分析的文档，但是都不算很全面，这里是之前搜索到的资料可以参考:</p><ul><li><a href="https://openairplay.github.io/airplay-spec/">Airplay非官方协议-总结的比较详细</a></li><li><a href="https://nto.github.io/AirPlay.html">Airplay协议分析</a></li><li><a href="https://emanuelecozzi.net/docs/airplay2">Airplay2协议细节</a></li></ul><p>已有实现的参考代码<a href="https://github.com/FD-/RPiPlay">Github RPiPlay</a>。</p><h2 id="Mirrorcast中的服务发现"><a href="#Mirrorcast中的服务发现" class="headerlink" title="Mirrorcast中的服务发现"></a><strong>Mirrorcast中的服务发现</strong></h2><p><code>Mirrorcast</code>在Android也被称作<code>Wifi Display(WFD)</code>，简单来说是一个通过<code>WIFI</code>来传输音视频数据的协议， 可以用于设备的屏幕镜像，这个跟<code>Airplay</code>的屏幕镜像功能是类似的。早在<code>Android 4.1</code>的时候<code>Google</code>开源过<a href="https://github.com/ivygroup/miracast-sink">相关代码</a>; 从实现来看， <code>Mirrorcast</code>并不算复杂，其主要分为两个大的步骤:</p><ul><li>通过<code>P2P</code>协议(也叫做<code>WIFI</code>直连(<code>Wifi Direct</code>))发现可用的<code>WFD</code>设备</li><li>与对应的<code>P2P</code>设备建立<code>RTP</code>连接，镜像的数据会通过<code>RTP</code>发送到接收端</li></ul><p><code>P2P</code>协议的发现分为两个流程，首先是设备的发现(<code>Device Disconvery</code>): 设备发现大致需要经过扫描与发现两个阶段。一个<code>P2P</code>设备要被发现需要处于<code>LISTEN</code>状态，并在2.4GHZ中的几个固定的<code>Socical</code>频段(1&#x2F;6&#x2F;11三个频段)选择一个频段进行监听，<code>P2P</code>设备在监听状态时只会对<code>Prope Request Frames</code>做出响应；设备在监听状态会等待固定的时间长度(0~100TU的随机时间)后，进入设备扫描阶段，扫描阶段，<code>P2P</code>会扫描周围设备与网络的所支持的所有频段。发现阶段的作用是确保两个设备处于同一个通讯频段。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/wifi-p2p-device-discovery-process.png" alt="P2P device discovery process"></p><p>设备发现完成后，就会进行服务发现。<code>P2P</code>的服务协议可以基于<code>Airplay/DLNA</code>中的协议如<code>mDNS/UPnP</code>进行扩展。搜索的一端主动发送<code>Service Discovery</code>数据帧，服务端收到搜索请求后发送<code>Response</code>给对端。<code>Android S</code>中可以看到两种服务发现协议的封装<a href="https://cs.android.com/android/platform/superproject/+/master:packages/modules/Wifi/framework/java/android/net/wifi/p2p/">WIFI P2P NSD</a>。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/p2p-service-discovery-process.png" alt="P2P service discovery process"></p><p>有关<code>WIFI P2P</code>的更多细节可以参考标准文档<a href="https://cse.iitkgp.ac.in/~bivasm/sp_notes/wifi_direct_2.pdf">WIFI Direct Spec</a>; 相关的代码实现可以参考<code>AOSP</code>的源码:</p><ul><li><a href="https://cs.android.com/android/platform/superproject/+/master:packages/modules/Wifi/">WIFI框架层代码</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://openconnectivity.org/upnp-specs/UPnP-arch-DeviceArchitecture-v2.0-20200417.pdf">UPnP协议文档</a></li><li><a href="https://openairplay.github.io/airplay-spec">Airplay非官方协议文档</a></li><li><a href="https://cse.iitkgp.ac.in/~bivasm/sp_notes/wifi_direct_2.pdf">P2P协议标准文档</a></li><li><a href="https://datatracker.ietf.org/doc/html/rfc3550">RTP协议标准文档</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;投屏是指将某个终端的音视频或者其他内容通过有线或者无线的形式投射到其他终端上的一种协议。目前常见的投屏协议有&lt;code&gt;DLNA&lt;/code&gt;&amp;#x2F;&lt;code&gt;Airplay&lt;/code&gt;&amp;#x2F;&lt;code&gt;Mirracast&lt;/code&gt;&amp;#x2F;&lt;code&gt;Chromecast&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DLNA&lt;/code&gt;(&lt;code&gt;Digital Living Network Alliance&lt;/code&gt;): &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_Living_Network_Alliance&quot;&gt;DNLA&lt;/a&gt;是由英特尔、索尼、微软等消费电子巨头在2003年建立的一个文件共享协议，目前很多的电视都会支持&lt;code&gt;DLNA&lt;/code&gt;协议，用于手机与电视之间共享视频与图片等资源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Airplay&lt;/code&gt;: &lt;a href=&quot;https://en.wikipedia.org/wiki/AirPlay&quot;&gt;Airplay&lt;/a&gt;是苹果公司开发的一个私有的投屏协议，实际包含了视频投屏与屏幕镜像等几个功能(音视频数据流包括交互控制协议都有是加密的)，可以用于播放音频、视频，也可以把本地的图片投屏到电视上进行浏览。目前国内很多支持&lt;code&gt;Airplay&lt;/code&gt;的投屏协议都是基于秘钥破解进行开发的。</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="投屏" scheme="https://sniffer.site/tags/%E6%8A%95%E5%B1%8F/"/>
    
    <category term="DLNA" scheme="https://sniffer.site/tags/DLNA/"/>
    
    <category term="Airplay" scheme="https://sniffer.site/tags/Airplay/"/>
    
  </entry>
  
  <entry>
    <title>Android如何进行DNS解析</title>
    <link href="https://sniffer.site/2023/04/17/Android%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8CDNS%E8%A7%A3%E6%9E%90/"/>
    <id>https://sniffer.site/2023/04/17/Android%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8CDNS%E8%A7%A3%E6%9E%90/</id>
    <published>2023-04-17T08:54:27.000Z</published>
    <updated>2023-04-18T06:07:52.377Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Domain_Name_System"><code>DNS(Domain Name System)</code></a>即域名解析系统，是网络访问时用于将域名解析成对应IP地址的一种分布式网络服务。比如，要访问<code>www.google.com</code>这个域名，<code>Android</code>系统会首先发送一个<code>UDP</code>请求到标准的<code>53</code>端口系统的域名解析服务器，拿到对应的IP地址后才会与服务端建立连接。除了标准的<code>DNS</code>服务外，目前还有<code>HttpDNS</code>(<a href="https://en.wikipedia.org/wiki/DNS_over_HTTPS"><code>DNS over Https, DoH</code></a>)以及基于<code>TSL</code>的<code>DNS</code>服务(<a href="https://datatracker.ietf.org/doc/html/rfc7858"><code>DNS over TLS， DoT</code></a>)。</p><p>那么，<code>Android</code>中<code>DNS</code>解析的大致框架是怎么的？整个<code>DNS</code>解析的流程又是怎么样的？ 在看具体实现细节之前，我们不妨思考一下几个问题，想一想，如果我们自己从零开始为<code>Android</code>设计一个<code>DNS</code>系统，应该怎么做？</p><span id="more"></span><ul><li><code>DNS</code>服务应该何时启动初始化，以何种形式为应用提供服务？</li><li><code>Android</code>中每个应用访问网络都会进行域名解析，如何对解析结果进行缓存，确保同样的域名不会被重复解析？</li><li>不同网络切换时，比如从<code>WIFI</code>切换到<code>4G</code>网络时，<code>DNS</code>解析的缓存应该如何清除？</li></ul><p>带着这几个问题，本文将从三个方面详细阐述下<code>Android</code>中<code>DNS</code>解析的具体原理与实现细节:</p><ul><li><code>DNS</code>服务的初始化</li><li>应用是如何执行域名解析的</li><li>网络变化时，<code>DNS</code>域名解析缓存是如何变化的</li></ul><blockquote><p>本文参考的源码是<code>Android S(12)</code></p></blockquote><h2 id="DNS系统服务的初始化"><a href="#DNS系统服务的初始化" class="headerlink" title="DNS系统服务的初始化"></a><strong>DNS系统服务的初始化</strong></h2><p><code>Android</code>中网络管理的核心服务都是在<a href="https://sniffer.site/2018/12/18/android-netd%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"><code>NETD</code></a>进程中实现的，<code>DNS</code>也不例外。在<code>netd</code>进程初始化时，系统会对<code>DNS</code>服务进行初始化<code>initDnsResolver</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stopwatch s;</span><br><span class="line">    gLog.<span class="built_in">info</span>(<span class="string">&quot;netd 1.0 starting&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Make sure BPF programs are loaded before doing anything</span></span><br><span class="line">    android::bpf::<span class="built_in">waitForProgsLoaded</span>();</span><br><span class="line">    gLog.<span class="built_in">info</span>(<span class="string">&quot;BPF programs are loaded&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Set local DNS mode, to prevent bionic from proxying</span></span><br><span class="line">    <span class="comment">// back to this service, recursively.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Check if we could remove it since resolver cache no loger</span></span><br><span class="line">    <span class="comment">// checks this environment variable after aosp/838050.</span></span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;ANDROID_DNS_MODE&quot;</span>, <span class="string">&quot;local&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Note that only call initDnsResolver after gCtls initializing.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">initDnsResolver</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to init resolver&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MDnsSdListener mdnsl;</span><br><span class="line">    <span class="keyword">if</span> (mdnsl.<span class="built_in">startListener</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to start MDnsSdListener (%s)&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">FwmarkServer <span class="title">fwmarkServer</span><span class="params">(&amp;gCtls-&gt;netCtrl, &amp;gCtls-&gt;eventReporter, &amp;gCtls-&gt;trafficCtrl)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (fwmarkServer.<span class="built_in">startListener</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to start FwmarkServer (%s)&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stopwatch subTime;</span><br><span class="line">    <span class="type">status_t</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = NetdNativeService::<span class="built_in">start</span>()) != android::OK) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to start NetdNativeService: %d&quot;</span>, ret);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    gLog.<span class="built_in">info</span>(<span class="string">&quot;Registering NetdNativeService: %&quot;</span> PRId64 <span class="string">&quot;us&quot;</span>, subTime.<span class="built_in">getTimeAndResetUs</span>());</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    gLog.<span class="built_in">info</span>(<span class="string">&quot;netd exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>initDnsResolver</code>调用<code>resolv_init</code>执行<code>DNS</code>服务的初始化，并注册一个回调函数，用于<code>DNS</code>服务调用时权限检查、获取当前网络ID以及打印日志等:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">initDnsResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResolverNetdCallbacks callbacks = &#123;</span><br><span class="line">            .check_calling_permission = &amp;checkCallingPermissionCallback,</span><br><span class="line">            .get_network_context = &amp;getNetworkContextCallback,</span><br><span class="line">            .log = &amp;logCallback,</span><br><span class="line">            .tagSocket = &amp;tagSocketCallback,</span><br><span class="line">            .evaluate_domain_name = &amp;evaluateDomainNameCallback,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">resolv_init</span>(&amp;callbacks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Android S</code>中<code>DNS</code>服务的代码放在了一个单独的模块<code>packages/modules/DnsResolver</code>中，函数<code>resolv_init</code>就是在模块的<code>DnsResolver.cpp</code>中实现的, 主要是设置日志标记以及打印等级，核心逻辑是创建一个<code>DnsResolver</code>对象，并启动<code>DNS</code>服务:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">resolv_init</span><span class="params">(<span class="type">const</span> ResolverNetdCallbacks* callbacks)</span> </span>&#123;</span><br><span class="line">    android::base::<span class="built_in">InitLogging</span>(<span class="comment">/*argv=*/</span><span class="literal">nullptr</span>);</span><br><span class="line">    android::base::<span class="built_in">SetDefaultTag</span>(<span class="string">&quot;libnetd_resolv&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: Initializing resolver&quot;</span>;</span><br><span class="line">    <span class="comment">// TODO(b/170539625): restore log level to WARNING after clarifying flaky tests.</span></span><br><span class="line">    <span class="built_in">resolv_set_log_severity</span>(<span class="built_in">isUserDebugBuild</span>() ? android::base::DEBUG : android::base::WARNING);</span><br><span class="line">    <span class="keyword">using</span> android::net::gApiLevel;</span><br><span class="line">    gApiLevel = <span class="built_in">getApiLevel</span>();</span><br><span class="line">    <span class="keyword">using</span> android::net::gResNetdCallbacks;</span><br><span class="line">    gResNetdCallbacks.check_calling_permission = callbacks-&gt;check_calling_permission;</span><br><span class="line">    gResNetdCallbacks.get_network_context = callbacks-&gt;get_network_context;</span><br><span class="line">    gResNetdCallbacks.log = callbacks-&gt;log;</span><br><span class="line">    <span class="keyword">if</span> (gApiLevel &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">        gResNetdCallbacks.tagSocket = callbacks-&gt;tagSocket;</span><br><span class="line">        gResNetdCallbacks.evaluate_domain_name = callbacks-&gt;evaluate_domain_name;</span><br><span class="line">    &#125;</span><br><span class="line">    android::net::gDnsResolv = android::net::DnsResolver::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">return</span> android::net::gDnsResolv-&gt;<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>DNS</code>服务的启动主要完成了三件事情: </p><ul><li>初始化私有DNS功能<code>DnsTlsDispatcher::getInstance()</code></li><li>启动<code>DNS</code>代理服务，启动一个名为<code>dnsproxyd</code>的<code>Unix Socket</code>服务，用于监听应用的域名解析请求</li><li>启动<code>IDnsResolver.aidl</code>的<code>HAL binder</code>服务，主要提供网络切换时设置<code>DNS</code>，创建缓存、清理缓存等接口</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DnsResolver::<span class="built_in">DnsResolver</span>() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> make them member variables after fixing the circular dependency:</span></span><br><span class="line">    <span class="comment">//   DnsTlsDispatcher.h -&gt; resolv_private.h -&gt; DnsResolver.h -&gt; DnsTlsDispatcher.h</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; dnsTlsDispatcher = DnsTlsDispatcher::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">auto</span>&amp; privateDnsConfiguration = PrivateDnsConfiguration::<span class="built_in">getInstance</span>();</span><br><span class="line">    privateDnsConfiguration.<span class="built_in">setObserver</span>(&amp;dnsTlsDispatcher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DnsResolver::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">verifyCallbacks</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: Callback verification failed&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDnsProxyListener.<span class="built_in">startListener</span>()) &#123;</span><br><span class="line">        <span class="built_in">PLOG</span>(ERROR) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: Unable to start DnsProxyListener&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">binder_status_t</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = DnsResolverService::<span class="built_in">start</span>()) != STATUS_OK) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: Unable to start DnsResolverService: &quot;</span> &lt;&lt; ret;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，<code>DNS</code>相关的功能完成了初始化。接下来，我们继续看第二部分: 应用是如何获取到域名的IP地址的。</p><h2 id="应用是如何解析域名的"><a href="#应用是如何解析域名的" class="headerlink" title="应用是如何解析域名的"></a><strong>应用是如何解析域名的</strong></h2><p>在深入细节之前，不妨看下<code>Android</code>中的<code>DNS</code>服务的大致框架。应用通过标准的JAVA接口<code>getAllByName</code>尝试解析域名，然后通过JNI调用<code>libc</code>中的接口，<code>libc</code>负责将域名解析请求通过名为<code>dnsproxyd</code>的<code>Unix Socket</code>发送给<code>DNS</code>代理服务，<code>DNS</code>服务查询到对应域名的IP地址列表再通过<code>socket</code>接口返回给应用。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/how_android_dns_works.png" alt="Android DNS服务框架"></p><ul><li>应用调用<code>InetAddress.getAllByName</code>获取域名对应的IP列表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* The implementation is always dual stack IPv6/IPv4 on android */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">InetAddressImpl</span> <span class="variable">impl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inet6AddressImpl</span>();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress[] getAllByName(String host)</span><br><span class="line">    <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">    <span class="comment">// Android-changed: Resolves a hostname using Libcore.os.</span></span><br><span class="line">    <span class="comment">// Also, returns both the Inet4 and Inet6 loopback for null/empty host</span></span><br><span class="line">    <span class="keyword">return</span> impl.lookupAllHostAddr(host, NETID_UNSET).clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>尝试从JAVA中的缓存中获取IP地址，如果没有缓存，则尝试解析域名, 并将结果保存到缓存中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resolves a hostname to its IP addresses using a cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InetAddress[] lookupHostByName(String host, <span class="type">int</span> netId)</span><br><span class="line">        <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">    BlockGuard.getThreadPolicy().onNetwork();</span><br><span class="line">    <span class="comment">// Do we have a result cached?</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cachedResult</span> <span class="operator">=</span> addressCache.get(host, netId);</span><br><span class="line">    <span class="keyword">if</span> (cachedResult != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedResult <span class="keyword">instanceof</span> InetAddress[]) &#123;</span><br><span class="line">            <span class="comment">// A cached positive result.</span></span><br><span class="line">            <span class="keyword">return</span> (InetAddress[]) cachedResult;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// A cached negative result.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnknownHostException</span>((String) cachedResult);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">StructAddrinfo</span> <span class="variable">hints</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StructAddrinfo</span>();</span><br><span class="line">        hints.ai_flags = AI_ADDRCONFIG;</span><br><span class="line">        hints.ai_family = AF_UNSPEC;</span><br><span class="line">        <span class="comment">// If we don&#x27;t specify a socket type, every address will appear twice, once</span></span><br><span class="line">        <span class="comment">// for SOCK_STREAM and one for SOCK_DGRAM. Since we do not return the family</span></span><br><span class="line">        <span class="comment">// anyway, just pick one.</span></span><br><span class="line">        hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">        InetAddress[] addresses = Libcore.os.android_getaddrinfo(host, hints, netId);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> should getaddrinfo set the hostname of the InetAddresses it returns?</span></span><br><span class="line">        <span class="keyword">for</span> (InetAddress address : addresses) &#123;</span><br><span class="line">            address.holder().hostName = host;</span><br><span class="line">            address.holder().originalHostName = host;</span><br><span class="line">        &#125;</span><br><span class="line">        addressCache.put(host, netId, addresses);</span><br><span class="line">        <span class="keyword">return</span> addresses;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (GaiException gaiException) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>Libcore.os.android_getaddrinfo</code>调用<code>libc</code>中的<code>DNS</code>接口<code>android_getaddrinfofornet</code>尝试解析域名:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> jobjectArray <span class="title">Linux_android_getaddrinfo</span><span class="params">(JNIEnv* env, jobject, jstring javaNode,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject javaHints, jint netId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    addrinfo hints;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="built_in">sizeof</span>(hints));</span><br><span class="line">    hints.ai_flags = env-&gt;<span class="built_in">GetIntField</span>(javaHints, flagsFid);</span><br><span class="line">    hints.ai_family = env-&gt;<span class="built_in">GetIntField</span>(javaHints, familyFid);</span><br><span class="line">    hints.ai_socktype = env-&gt;<span class="built_in">GetIntField</span>(javaHints, socktypeFid);</span><br><span class="line">    hints.ai_protocol = env-&gt;<span class="built_in">GetIntField</span>(javaHints, protocolFid);</span><br><span class="line"></span><br><span class="line">    addrinfo* addressList = <span class="literal">NULL</span>;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rc = <span class="built_in">android_getaddrinfofornet</span>(node.<span class="built_in">c_str</span>(), <span class="literal">NULL</span>, &amp;hints, netId, <span class="number">0</span>, &amp;addressList);</span><br><span class="line">    <span class="function">std::unique_ptr&lt;addrinfo, addrinfo_deleter&gt; <span class="title">addressListDeleter</span><span class="params">(addressList)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">throwGaiException</span>(env, <span class="string">&quot;android_getaddrinfo&quot;</span>, rc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count results so we know how to size the output array.</span></span><br><span class="line">    <span class="type">int</span> addressCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (addrinfo* ai = addressList; ai != <span class="literal">NULL</span>; ai = ai-&gt;ai_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ai-&gt;ai_family == AF_INET || ai-&gt;ai_family == AF_INET6) &#123;</span><br><span class="line">            ++addressCount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;android_getaddrinfo unexpected ai_family %i&quot;</span>, ai-&gt;ai_family);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Prepare output array.</span></span><br><span class="line">    jobjectArray result = env-&gt;<span class="built_in">NewObjectArray</span>(addressCount, JniConstants::<span class="built_in">GetInetAddressClass</span>(env), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Examine returned addresses one by one, save them in the output array.</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (addrinfo* ai = addressList; ai != <span class="literal">NULL</span>; ai = ai-&gt;ai_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ai-&gt;ai_family != AF_INET &amp;&amp; ai-&gt;ai_family != AF_INET6) &#123;</span><br><span class="line">            <span class="comment">// Unknown address family. Skip this address.</span></span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;android_getaddrinfo unexpected ai_family %i&quot;</span>, ai-&gt;ai_family);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert each IP address into a Java byte array.</span></span><br><span class="line">        sockaddr_storage&amp; address = *<span class="built_in">reinterpret_cast</span>&lt;sockaddr_storage*&gt;(ai-&gt;ai_addr);</span><br><span class="line">        <span class="function">ScopedLocalRef&lt;jobject&gt; <span class="title">inetAddress</span><span class="params">(env, sockaddrToInetAddress(env, address, <span class="literal">NULL</span>))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (inetAddress.<span class="built_in">get</span>() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        env-&gt;<span class="built_in">SetObjectArrayElement</span>(result, index, inetAddress.<span class="built_in">get</span>());</span><br><span class="line">        ++index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>继续调用<code>android_getaddrinfofornetcontext</code>:该函数实际通过<code>android_getaddrinfo_proxy</code>将域名解析请求通过<code>dnsproxyd</code>的<code>Unix Socket</code>发送给<code>netd</code>的<code>DNS</code>解析服务:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">__BIONIC_WEAK_FOR_NATIVE_BRIDGE</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">android_getaddrinfofornetcontext</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hostname, <span class="type">const</span> <span class="type">char</span> *servname,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="type">const</span> <span class="keyword">struct</span> android_net_context *netcontext,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> addrinfo **res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">addrinfo</span> *pai;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">explore</span> *ex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* hostname is allowed to be NULL */</span></span><br><span class="line">  <span class="comment">/* servname is allowed to be NULL */</span></span><br><span class="line">  <span class="comment">/* hints is allowed to be NULL */</span></span><br><span class="line">  <span class="built_in">assert</span>(res != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">assert</span>(netcontext != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;sentinel, <span class="number">0</span>, <span class="built_in">sizeof</span>(sentinel));</span><br><span class="line">  cur = &amp;sentinel;</span><br><span class="line">  pai = &amp;ai;</span><br><span class="line">  pai-&gt;ai_flags = <span class="number">0</span>;</span><br><span class="line">  pai-&gt;ai_family = PF_UNSPEC;</span><br><span class="line">  pai-&gt;ai_socktype = ANY;</span><br><span class="line">  pai-&gt;ai_protocol = ANY;</span><br><span class="line">  pai-&gt;ai_addrlen = <span class="number">0</span>;</span><br><span class="line">  pai-&gt;ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">  pai-&gt;ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">  pai-&gt;ai_next = <span class="literal">NULL</span>;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏变量`__ANDROID__`是在`libc`库编译的时候设置的</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">  <span class="type">int</span> gai_error = <span class="built_in">android_getaddrinfo_proxy</span>(</span><br><span class="line">    hostname, servname, hints, res, netcontext-&gt;app_netid);</span><br><span class="line">  <span class="keyword">if</span> (gai_error != EAI_SYSTEM) &#123;</span><br><span class="line">    <span class="keyword">return</span> gai_error;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>函数<code>android_getaddrinfo_proxy</code>首先通过<code>NetdClient</code>中的函数<code>dns_open_proxy</code>创建与<code>DNS</code>服务的<code>socket</code>接口，然后向服务端发送一个<code>getaddrinfo www.google.com x x x x x</code>的指令, 然后尝试读取服务端返回的结果:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// Returns 0 on success, else returns on error.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">android_getaddrinfo_proxy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="type">char</span> *hostname, <span class="type">const</span> <span class="type">char</span> *servname,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **res, <span class="type">unsigned</span> netid)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear this at start, as we use its non-NULLness later (in the</span></span><br><span class="line">    <span class="comment">// error path) to decide if we have to free up any memory we</span></span><br><span class="line">    <span class="comment">// allocated in the process (before failing).</span></span><br><span class="line">    *res = <span class="literal">NULL</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    FILE* proxy = <span class="built_in">fdopen</span>(__netdClientDispatch.<span class="built_in">dnsOpenProxy</span>(), <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (proxy == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> EAI_SYSTEM;</span><br><span class="line">    &#125;</span><br><span class="line">    netid = __netdClientDispatch.<span class="built_in">netIdForResolv</span>(netid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send the request.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fprintf</span>(proxy, <span class="string">&quot;getaddrinfo %s %s %d %d %d %d %u&quot;</span>,</span><br><span class="line">          hostname == <span class="literal">NULL</span> ? <span class="string">&quot;^&quot;</span> : hostname,</span><br><span class="line">          servname == <span class="literal">NULL</span> ? <span class="string">&quot;^&quot;</span> : servname,</span><br><span class="line">          hints == <span class="literal">NULL</span> ? <span class="number">-1</span> : hints-&gt;ai_flags,</span><br><span class="line">          hints == <span class="literal">NULL</span> ? <span class="number">-1</span> : hints-&gt;ai_family,</span><br><span class="line">          hints == <span class="literal">NULL</span> ? <span class="number">-1</span> : hints-&gt;ai_socktype,</span><br><span class="line">          hints == <span class="literal">NULL</span> ? <span class="number">-1</span> : hints-&gt;ai_protocol,</span><br><span class="line">          netid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">// read result code for gethostbyaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="built_in">sizeof</span>(buf), proxy) != <span class="built_in">sizeof</span>(buf)) &#123;</span><br><span class="line">      <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result_code = (<span class="type">int</span>)<span class="built_in">strtol</span>(buf, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// verify the code itself</span></span><br><span class="line">    <span class="keyword">if</span> (result_code != DnsProxyQueryResult) &#123;</span><br><span class="line">      <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="built_in">sizeof</span>(buf), proxy);</span><br><span class="line">      <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span>* ai = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span>** nextres = res;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">int32_t</span> have_more;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">readBE32</span>(proxy, &amp;have_more)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (have_more == <span class="number">0</span>) &#123;</span><br><span class="line">        success = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ai = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> addrinfo) + <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage));</span><br><span class="line">      <span class="keyword">if</span> (ai == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ai-&gt;ai_addr = (<span class="keyword">struct</span> sockaddr*)(ai + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// struct addrinfo &#123;</span></span><br><span class="line">      <span class="comment">//intai_flags;/* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */</span></span><br><span class="line">      <span class="comment">//intai_family;/* PF_xxx */</span></span><br><span class="line">      <span class="comment">//intai_socktype;/* SOCK_xxx */</span></span><br><span class="line">      <span class="comment">//intai_protocol;/* 0 or IPPROTO_xxx for IPv4 and IPv6 */</span></span><br><span class="line">      <span class="comment">//socklen_t ai_addrlen;/* length of ai_addr */</span></span><br><span class="line">      <span class="comment">//char*ai_canonname;/* canonical name for hostname */</span></span><br><span class="line">      <span class="comment">//structsockaddr *ai_addr;/* binary address */</span></span><br><span class="line">      <span class="comment">//structaddrinfo *ai_next;/* next structure in linked list */</span></span><br><span class="line">      <span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Read the struct piece by piece because we might be a 32-bit process</span></span><br><span class="line">      <span class="comment">// talking to a 64-bit netd.</span></span><br><span class="line">      <span class="type">int32_t</span> addr_len;</span><br><span class="line">      <span class="type">bool</span> success =</span><br><span class="line">          <span class="built_in">readBE32</span>(proxy, &amp;ai-&gt;ai_flags) &amp;&amp;</span><br><span class="line">          <span class="built_in">readBE32</span>(proxy, &amp;ai-&gt;ai_family) &amp;&amp;</span><br><span class="line">          <span class="built_in">readBE32</span>(proxy, &amp;ai-&gt;ai_socktype) &amp;&amp;</span><br><span class="line">          <span class="built_in">readBE32</span>(proxy, &amp;ai-&gt;ai_protocol) &amp;&amp;</span><br><span class="line">          <span class="built_in">readBE32</span>(proxy, &amp;addr_len);</span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set ai_addrlen and read the ai_addr data.</span></span><br><span class="line">      ai-&gt;ai_addrlen = addr_len;</span><br><span class="line">      <span class="keyword">if</span> (addr_len != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">size_t</span>) addr_len &gt; <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage)) &#123;</span><br><span class="line">          <span class="comment">// Bogus; too big.</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fread</span>(ai-&gt;ai_addr, addr_len, <span class="number">1</span>, proxy) != <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ai != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">// Clean up partially-built addrinfo that we never ended up</span></span><br><span class="line">      <span class="comment">// attaching to the response.</span></span><br><span class="line">      <span class="built_in">freeaddrinfo</span>(ai);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>服务端的代理<code>DnsProxyListener</code>收到域名解析指令<code>getaddrinfo</code>后，启动一个新的线程处理该请求:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DnsProxyListener::GetAddrInfoCmd::<span class="built_in">GetAddrInfoCmd</span>() : <span class="built_in">FrameworkCommand</span>(<span class="string">&quot;getaddrinfo&quot;</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> DnsProxyListener::GetAddrInfoCmd::<span class="built_in">runCommand</span>(SocketClient* cli, <span class="type">int</span> argc, <span class="type">char</span>** argv) &#123;</span><br><span class="line">    <span class="built_in">logArguments</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* msg = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">asprintf</span>(&amp;msg, <span class="string">&quot;Invalid number of arguments to getaddrinfo: %i&quot;</span>, argc);</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;GetAddrInfoCmd::runCommand: &quot;</span> &lt;&lt; (msg ? msg : <span class="string">&quot;null&quot;</span>);</span><br><span class="line">        cli-&gt;<span class="built_in">sendMsg</span>(ResponseCode::CommandParameterError, msg, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">free</span>(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string name = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">const</span> std::string service = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ai_flags = <span class="built_in">strtol</span>(argv[<span class="number">3</span>], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> ai_family = <span class="built_in">strtol</span>(argv[<span class="number">4</span>], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> ai_socktype = <span class="built_in">strtol</span>(argv[<span class="number">5</span>], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> ai_protocol = <span class="built_in">strtol</span>(argv[<span class="number">6</span>], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">unsigned</span> netId = <span class="built_in">strtoul</span>(argv[<span class="number">7</span>], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> useLocalNameservers = <span class="built_in">checkAndClearUseLocalNameserversFlag</span>(&amp;netId);</span><br><span class="line">    <span class="type">const</span> <span class="type">uid_t</span> uid = cli-&gt;<span class="built_in">getUid</span>();</span><br><span class="line"></span><br><span class="line">    android_net_context netcontext;</span><br><span class="line">    gResNetdCallbacks.<span class="built_in">get_network_context</span>(netId, uid, &amp;netcontext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useLocalNameservers) &#123;</span><br><span class="line">        netcontext.flags |= NET_CONTEXT_FLAG_USE_LOCAL_NAMESERVERS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;addrinfo&gt; hints;</span><br><span class="line">    <span class="keyword">if</span> (ai_flags != <span class="number">-1</span> || ai_family != <span class="number">-1</span> || ai_socktype != <span class="number">-1</span> || ai_protocol != <span class="number">-1</span>) &#123;</span><br><span class="line">        hints.<span class="built_in">reset</span>((addrinfo*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(addrinfo)));</span><br><span class="line">        hints-&gt;ai_flags = ai_flags;</span><br><span class="line">        hints-&gt;ai_family = ai_family;</span><br><span class="line">        hints-&gt;ai_socktype = ai_socktype;</span><br><span class="line">        hints-&gt;ai_protocol = ai_protocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">new</span> <span class="built_in">GetAddrInfoHandler</span>(cli, name, service, <span class="built_in">move</span>(hints), netcontext))-&gt;<span class="built_in">spawn</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>处理域名解析请求的线程执行，首先会通过<code>resolv_getaddrinfo</code>尝试域名解析(如果没有cache，则会向域名解析服务器发送解析请求，这里默认是<code>53</code>的UDP端口)，拿到解析后的IP地址后，通过<code>socket</code>发送地址列表给客户端。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> DnsProxyListener::GetAddrInfoHandler::<span class="built_in">run</span>() &#123;</span><br><span class="line">    addrinfo* result = <span class="literal">nullptr</span>;</span><br><span class="line">    Stopwatch s;</span><br><span class="line">    <span class="built_in">maybeFixupNetContext</span>(&amp;mNetContext, mClient-&gt;<span class="built_in">getPid</span>());</span><br><span class="line">    <span class="type">const</span> <span class="type">uid_t</span> uid = mClient-&gt;<span class="built_in">getUid</span>();</span><br><span class="line">    <span class="type">int32_t</span> rv = <span class="number">0</span>;</span><br><span class="line">    NetworkDnsEventReported event;</span><br><span class="line">    <span class="built_in">initDnsEvent</span>(&amp;event, mNetContext);</span><br><span class="line">    <span class="keyword">if</span> (queryLimiter.<span class="built_in">start</span>(uid)) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* host = mHost.<span class="built_in">starts_with</span>(<span class="string">&#x27;^&#x27;</span>) ? <span class="literal">nullptr</span> : mHost.<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* service = mService.<span class="built_in">starts_with</span>(<span class="string">&#x27;^&#x27;</span>) ? <span class="literal">nullptr</span> : mService.<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">evaluate_domain_name</span>(mNetContext, host)) &#123;</span><br><span class="line">            rv = <span class="built_in">resolv_getaddrinfo</span>(host, service, mHints.<span class="built_in">get</span>(), &amp;mNetContext, &amp;result, &amp;event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rv = EAI_SYSTEM;</span><br><span class="line">        &#125;</span><br><span class="line">        queryLimiter.<span class="built_in">finish</span>(uid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Note that this error code is currently not passed down to the client.</span></span><br><span class="line">        <span class="comment">// android_getaddrinfo_proxy() returns EAI_NODATA on any error.</span></span><br><span class="line">        rv = EAI_MEMORY;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;GetAddrInfoHandler::run: from UID &quot;</span> &lt;&lt; uid</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, max concurrent queries reached&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">doDns64Synthesis</span>(&amp;rv, &amp;result, &amp;event);</span><br><span class="line">    <span class="type">const</span> <span class="type">int32_t</span> latencyUs = <span class="built_in">saturate_cast</span>&lt;<span class="type">int32_t</span>&gt;(s.<span class="built_in">timeTakenUs</span>());</span><br><span class="line">    event.<span class="built_in">set_latency_micros</span>(latencyUs);</span><br><span class="line">    event.<span class="built_in">set_event_type</span>(EVENT_GETADDRINFO);</span><br><span class="line">    event.<span class="built_in">set_hints_ai_flags</span>((mHints ? mHints-&gt;ai_flags : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">        <span class="comment">// getaddrinfo failed</span></span><br><span class="line">        success = !mClient-&gt;<span class="built_in">sendBinaryMsg</span>(ResponseCode::DnsProxyOperationFailed, &amp;rv, <span class="built_in">sizeof</span>(rv));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        success = !mClient-&gt;<span class="built_in">sendCode</span>(ResponseCode::DnsProxyQueryResult);</span><br><span class="line">        addrinfo* ai = result;</span><br><span class="line">        <span class="keyword">while</span> (ai &amp;&amp; success) &#123;</span><br><span class="line">            success = <span class="built_in">sendBE32</span>(mClient, <span class="number">1</span>) &amp;&amp; <span class="built_in">sendaddrinfo</span>(mClient, ai);</span><br><span class="line">            ai = ai-&gt;ai_next;</span><br><span class="line">        &#125;</span><br><span class="line">        success = success &amp;&amp; <span class="built_in">sendBE32</span>(mClient, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">freeaddrinfo</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有关域名解析的具体实现<code>resolv_getaddrinfo</code>可以参考<code>packages/modules/DnsResolver</code>中的代码，这里就不具体展开分析了。</p><h2 id="网络切换时DNS缓存时如何清除的"><a href="#网络切换时DNS缓存时如何清除的" class="headerlink" title="网络切换时DNS缓存时如何清除的"></a><strong>网络切换时DNS缓存时如何清除的</strong></h2><p>发生网络切换时，<code>Android</code>需要确保<code>DNS</code>服务使用了正确的服务器进行域名解析，另外要清除掉之前网络域名解析的缓存，确保两个网络的解析结果是独立的。<code>Android</code>的网络管理都是由<code>ConnectivityService</code>系统服务来完成的，当两个网络发生切换时，<code>ConnectivityService</code>会更新网络的<code>DNS</code>配置, 并清除<code>DNS</code>服务中对应的缓存:</p><ul><li><code>updateLinkProperties</code>时网络状态切换: 设置<code>DNS</code>解析服务器，清除应用自身的缓存</li><li><code>destroyNetwork</code>: 断开网络时，会完全清除系统对应的<code>DNS</code>缓存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateLinkProperties</span><span class="params">(NetworkAgentInfo networkAgent, <span class="meta">@NonNull</span> LinkProperties newLp,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> LinkProperties oldLp)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">netId</span> <span class="operator">=</span> networkAgent.network.getNetId();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (isDefaultNetwork(networkAgent)) &#123;</span><br><span class="line">        updateTcpBufferSizes(newLp.getTcpBufferSizes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateRoutes(newLp, oldLp, netId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新DNS配置</span></span><br><span class="line">    updateDnses(newLp, oldLp, netId);</span><br><span class="line">    <span class="comment">// Make sure LinkProperties represents the latest private DNS status.</span></span><br><span class="line">    <span class="comment">// This does not need to be done before updateDnses because the</span></span><br><span class="line">    <span class="comment">// LinkProperties are not the source of the private DNS configuration.</span></span><br><span class="line">    <span class="comment">// updateDnses will fetch the private DNS configuration from DnsManager.</span></span><br><span class="line">    mDnsManager.updatePrivateDnsStatus(netId, newLp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDefaultNetwork(networkAgent)) &#123;</span><br><span class="line">        handleApplyDefaultProxy(newLp.getHttpProxy());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        updateProxy(newLp, oldLp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateWakeOnLan(newLp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Captive portal data is obtained from NetworkMonitor and stored in NetworkAgentInfo.</span></span><br><span class="line">    <span class="comment">// It is not always contained in the LinkProperties sent from NetworkAgents, and if it</span></span><br><span class="line">    <span class="comment">// does, it needs to be merged here.</span></span><br><span class="line">    newLp.setCaptivePortalData(mergeCaptivePortalData(networkAgent.networkAgentPortalData,</span><br><span class="line">            networkAgent.capportApiData));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法<code>updateDnses</code>主要做两件事情:</p><ul><li>设置当前网络的<code>DNS</code>服务器, 调用<code>IDnsResolver</code>的接口<code>setResolverConfiguration</code>设置当前系统的DNS服务的配置</li><li>清除当前系统的<code>DNS</code>解析缓存, 发送<code>ACTION_CLEAR_DNS_CACHE</code>来清除缓存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateDnses</span><span class="params">(LinkProperties newLp, LinkProperties oldLp, <span class="type">int</span> netId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldLp != <span class="literal">null</span> &amp;&amp; newLp.isIdenticalDnses(oldLp)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// no updating necessary</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mDnsManager.noteDnsServersForNetwork(netId, newLp);</span><br><span class="line">        mDnsManager.flushVmDnsCache();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        loge(<span class="string">&quot;Exception in setDnsConfigurationForNetwork: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于如何设置<code>DNS</code>配置，大家可以查看<code>DnsResolverService.cpp</code>的代码；这里，我们重点看下缓存清理的大致流程。清理系统<code>DNS</code>缓存时，向<code>ActivityManager</code>发送一个<code>ACTION_CLEAR_DNS_CACHE</code>广播：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flush DNS caches and events work before boot has completed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flushVmDnsCache</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Tell the VMs to toss their DNS caches</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(ConnectivityManager.ACTION_CLEAR_DNS_CACHE);</span><br><span class="line">    intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Connectivity events can happen before boot has completed ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(ident);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ActivityManager</code>收到清除的广播后，调用<code>IApplicationThread.clearDnsCache</code>清理所有进程的<code>DNS</code>缓存:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (mProcLock) &#123;</span><br><span class="line">    mProcessList.clearAllDnsCacheLOSP();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy(anyOf = &#123;&quot;mService&quot;, &quot;mProcLock&quot;&#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clearAllDnsCacheLOSP</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mLruProcesses.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">ProcessRecord</span> <span class="variable">r</span> <span class="operator">=</span> mLruProcesses.get(i);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">IApplicationThread</span> <span class="variable">thread</span> <span class="operator">=</span> r.getThread();</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.clearDnsCache();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Failed to clear dns cache for: &quot;</span> + r.info.processName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>IApplicationThread</code>的实现在<code>ActivityThread</code>中， 接口<code>clearDnsCache</code>清除的是应用自身的解析缓存:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearDnsCache</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// a non-standard API to get this to libcore</span></span><br><span class="line">    InetAddress.clearDnsCache();</span><br><span class="line">    <span class="comment">// Allow libcore to perform the necessary actions as it sees fit upon a network</span></span><br><span class="line">    <span class="comment">// configuration change.</span></span><br><span class="line">    NetworkEventDispatcher.getInstance().dispatchNetworkConfigurationChange();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>网络切换完成后，会断开之前的网络，清除系统中对应的解析缓存:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">destroyNetwork</span><span class="params">(NetworkAgentInfo nai)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nai.created) &#123;</span><br><span class="line">        <span class="comment">// Tell netd to clean up the configuration for this network</span></span><br><span class="line">        <span class="comment">// (routing rules, DNS, etc).</span></span><br><span class="line">        <span class="comment">// This may be slow as it requires a lot of netd shelling out to ip and</span></span><br><span class="line">        <span class="comment">// ip[6]tables to flush routes and remove the incoming packet mark rule, so do it</span></span><br><span class="line">        <span class="comment">// after we&#x27;ve rematched networks with requests (which might change the default</span></span><br><span class="line">        <span class="comment">// network or service a new request from an app), so network traffic isn&#x27;t interrupted</span></span><br><span class="line">        <span class="comment">// for an unnecessarily long time.</span></span><br><span class="line">        destroyNativeNetwork(nai);</span><br><span class="line">        mDnsManager.removeNetwork(nai.network);</span><br><span class="line">    &#125;</span><br><span class="line">    mNetIdManager.releaseNetId(nai.network.getNetId());</span><br><span class="line">    nai.onNetworkDestroyed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理系统缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">destroyNativeNetwork</span><span class="params">(<span class="meta">@NonNull</span> NetworkAgentInfo nai)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mNetd.networkDestroy(nai.network.getNetId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException | ServiceSpecificException e) &#123;</span><br><span class="line">        loge(<span class="string">&quot;Exception destroying network(networkDestroy): &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mDnsResolver.destroyNetworkCache(nai.network.getNetId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException | ServiceSpecificException e) &#123;</span><br><span class="line">        loge(<span class="string">&quot;Exception destroying network: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>本文阐述了Android中DNS解析的原理和实现细节，重点关注了三个方面：</p><ul><li>DNS服务的初始化</li><li>应用程序如何执行域名解析</li><li>网络变化时DNS域名解析缓存的变化</li></ul><p>在Android中，DNS服务是在NETD进程中实现的，系统在进程初始化时对DNS服务进行初始化。文章还讨论了应用程序如何执行域名解析以及网络从Wi-Fi切换到4G时DNS域名解析缓存是如何清除的。理清这些流程，一方面是为了更好的定位遇到的网络问题，也可以更深入的理解Android中系统架构设计的思路以及代码的整体框架。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://datatracker.ietf.org/doc/html/rfc7858">DNS over TLS</a></li><li><a href="https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/">什么是DNS</a></li><li><a href="https://en.wikipedia.org/wiki/Domain_Name_System">Wikipedia DNS</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_Name_System&quot;&gt;&lt;code&gt;DNS(Domain Name System)&lt;/code&gt;&lt;/a&gt;即域名解析系统，是网络访问时用于将域名解析成对应IP地址的一种分布式网络服务。比如，要访问&lt;code&gt;www.google.com&lt;/code&gt;这个域名，&lt;code&gt;Android&lt;/code&gt;系统会首先发送一个&lt;code&gt;UDP&lt;/code&gt;请求到标准的&lt;code&gt;53&lt;/code&gt;端口系统的域名解析服务器，拿到对应的IP地址后才会与服务端建立连接。除了标准的&lt;code&gt;DNS&lt;/code&gt;服务外，目前还有&lt;code&gt;HttpDNS&lt;/code&gt;(&lt;a href=&quot;https://en.wikipedia.org/wiki/DNS_over_HTTPS&quot;&gt;&lt;code&gt;DNS over Https, DoH&lt;/code&gt;&lt;/a&gt;)以及基于&lt;code&gt;TSL&lt;/code&gt;的&lt;code&gt;DNS&lt;/code&gt;服务(&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7858&quot;&gt;&lt;code&gt;DNS over TLS， DoT&lt;/code&gt;&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;那么，&lt;code&gt;Android&lt;/code&gt;中&lt;code&gt;DNS&lt;/code&gt;解析的大致框架是怎么的？整个&lt;code&gt;DNS&lt;/code&gt;解析的流程又是怎么样的？ 在看具体实现细节之前，我们不妨思考一下几个问题，想一想，如果我们自己从零开始为&lt;code&gt;Android&lt;/code&gt;设计一个&lt;code&gt;DNS&lt;/code&gt;系统，应该怎么做？&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://sniffer.site/categories/Android/"/>
    
    
    <category term="DNS" scheme="https://sniffer.site/tags/DNS/"/>
    
    <category term="TCP/IP" scheme="https://sniffer.site/tags/TCP-IP/"/>
    
    <category term="域名解析" scheme="https://sniffer.site/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    
    <category term="Private DNS" scheme="https://sniffer.site/tags/Private-DNS/"/>
    
  </entry>
  
  <entry>
    <title>chatGPT之后，我们还能做什么?</title>
    <link href="https://sniffer.site/2023/03/23/chatGPT%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88/"/>
    <id>https://sniffer.site/2023/03/23/chatGPT%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88/</id>
    <published>2023-03-23T01:37:05.000Z</published>
    <updated>2023-04-18T12:17:43.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Those who cannot remember the past are condemned to repeat it</p><p><strong>George Santayana</strong></p></blockquote><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/JasonW_a_young_chinese_girl_ride_on_a_chinese_dragon.png" alt="龙女儿"></p><span id="more"></span><p>最近铺天盖地都是<code>chatGpt</code>的新闻，各种基于<code>GPT</code>的工具与应用不断涌现，十分热闹。这种狂热的情绪不禁让人浮想联翩。前几年热火朝天的比特币以及区块链技术，当时的人们也一度兴奋异常，说一场颠覆金融与银行的技术变革已然到来，结果在资本逐利与人性的贪婪之下，比特币与区块链在无数的涨涨跌跌中归于平淡。如今，人们谈及比特币没有了最初的热情，也没多少人聊区块链金融了。</p><p>可是，体验过<code>chatGPT</code>以及<code>AIGC(AI Gernerated Content)</code>相关的工具以后(开头的图片就是使用<a href="https://discord.com/"><code>midjourney</code></a>自动生成的,几分钟时间生成的图片效果不错)，还是觉得这次应该不一样了，这是人工智能历史上一次具有革命意义的变化，是人类自有了计算机以来，生产力工具的一次重大转折与突破。就好比从前我们使用的是镰刀与斧头，如今直接用上推土机与坦克了；<code>chatGPT</code>完成了从<code>深度学习</code>到<code>通用智能</code>的转变，可以把信息与知识的呈现完全以新的形式展现给用户,把人从简单繁琐的任务中解脱出来，让人可以有更多精力与时间做更多有价值的事情。比如，用开源的<a href="https://www.cursor.so/"><code>cursor编辑器</code></a>，可以查找函数的使用示例；写代码的单元测试；查看语言的特性等等，这能提升开发的效率。<code>chatGPT</code>让人跟机器的界限慢慢被打破，机器为人类的决策提供了更多的帮助，让生产效率成倍的增长。就像人类从石器时代一下到了铁器时代，新的生产力工具让人类社会有了更多的想象空间。</p><p>或许，<code>chatGPT</code>这种大语言模型(LLM)展现出来对自然语言上下文惊人的理解能力才是真正让人惊讶与恐怖的事情。<code>GPT-4</code>模型俨然是一个百科全书的知识库，具备了很好的推理能力，能把各种知识与信息组织的条理井然。这是通用智能的前奏，几十年前阿兰图灵设想的图灵测试恐怕就要被超越了，而一旦模型或算法本身进化成了具备自我意识的一个实体，人与机器的关系到底该如何界定？我们如何看到一个具备智能的机器？这个机器又如何看待人类？这不仅是技术的变革，而是人类社会伦理与存在的一次挑战。我们是否做好了充分准备来迎接这样的变革？</p><p>从技术角度来看，不论是<code>chatGPT</code>大语言模型还是如<code>midjourney</code>这样的<code>AIGC</code>工具，无非都是一个个简单的人工神经元组成的巨大网络，里面有上千亿的模型参数，通过复杂的网络布局以及适当的反馈回路，这种深度神经网络竟然会拥有如此强大的推理与泛化能力，不得不让人赞叹，就像一个个大脑细胞通过突触相互链接让人拥有了智能，拥有了自我意识一样，或许在某一天， 大规模的机器模型也会来到这个智慧的临界点-产生自我意识。人创造了一个智慧体，上帝是喜还是忧？</p><p>从人类现有历史来看，技术的发展与进化对社会的影响是深刻而不可逆的(这种不可逆可能也让人类常常想回到最初的那种原始自然的状态，就好像我们从乡村来到城市，却会时常想回到乡村去一样):</p><ul><li>人有了数字的概念，并发明了数字0，然后人类在数学方面完成了革新，重塑人类对自然的理解，奠定了科学进步的基础</li><li>人类学会利用火，不用再像其他动物一样生吃肉或者蔬菜了，饮食成了一种美味的享受，让人在数千年的进化中逐步蜕变，并利用各种能源如煤炭、石油、自然能源等让社会生产力得以提升</li><li>牛顿发现了万有引力，完成了认识宇宙的第一步，把人类文明提升到新的高度；爱因斯坦的相对论再一次扩展了人类对于宇宙与自身存在的认识，让我们对宇宙的历史不再望而却步</li></ul><p>今天，以<a href="https://openai.com/"><code>OpenAI</code></a>公司的<code>chatGPT</code>在通用智能上完成突破，其意义非凡，但也让人在深思熟虑之后产生些许忧虑与不安。对于一名软件开发人员，能使用这种生产力倍增的工具自然感到兴奋，但在整个人类社会，还有很多的人没有能力去获取或者接触到任何智能相关的技术与工具，这是一个鸿沟，短期内无法填平的数字鸿沟。这也就势必会给有技术领先优势的公司或者组织更多的掌控力与控制权，渐渐的形成<code>AI霸权</code>，带来更多的数字鸿沟:那些掌控了<code>AI</code>能力的群体自然而然有更多的话语权与影响力，从而得以维护自己的利益。这很难说不是现状，但恐怕未来随着<code>AI</code>技术的发展只会愈加明显。</p><p>随着<code>chatGPT</code>这种具备通用智能模型的不断进步与发展，很多没有太多原创性的工作可能被替代，比如秘书，文案写作者，但是不是就像许多耸人听闻的标题说的那样，人快成了完美的废物:35岁卷不动，只好吃喝等死了。从历史上来看，任何技术的进步都是一把双刃剑，让某些行业受益的同时，也会给其他行业造成冲击，但对社会总体而言是利大于弊，是有价值的。与其回避技术可能带来的变化，不如主动拥抱这种变化。作为一名技术人员，在这种快速变化的智能时代，我们应该怎么做？</p><ul><li>保持开放的心态，努力学习。如果不能成为这股技术变革中的一员，那么努力想想自己所在行业可以如何跟AI进行结合，是否可以在AI的帮助下做的更好</li><li>提升创新与创造的能力，主动寻求变化，跳出舒适区，让自己更具韧性与适应能力</li><li>做更多有价值的事情。为用户创造价值，为组织创造价值，为社会创造价值，让自己活的更有价值</li><li>学会从更大的视角看待事物，更高的维度思考问题。不满足于已有的答案，要有系统性的思维能力</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>二百多年前，英国数学家<code>Charles Babbage</code>便有了利用机器来计算的想法，并尝试制造了第一台差分机。而人工智能概念的出现到如今的<code>chatGPT</code>多模态的通用智能模型，也不过八十来年的历史。技术进步正在加速，我们该如何应对这种技术的变革，如何面对通用智能带来的挑战？需要改变的不仅仅是个人，而是教育体系。我们的下一代将生活在智能主导的世界，他们需要有新的思维与认知方式，需要创造与创新的能力去解决面临的问题。未来的教育不能再想如今一样只是教授知识，更多的应该要培养人的原创力。</p><p>而如今，在新的时代起点上，如何去选择？我们需要重新思考自身的价值，思考存在的意义，思考如何利用智能的工具创造更多的价值。人类在地球上生存了千百年，很多东西变了，很多仍然没有变化。那些让人类不断进化，不断创造的源动力并没有变。我们可以欣赏自然的美，可以感受爱与温情，可以体验快乐与幸福，可以创造与构建，可以思考这个世界一切的奥秘。而这正是每一个人存在的价值。</p><p>有关更多<code>GPT</code>哲学上的探讨，可以看下<a href="https://mp.weixin.qq.com/s/AnlhmRHoSJM-O9bLBlxOVw">赵汀阳：GPT在哪些问题上逼得思想无路可走？</a>这篇文章。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;Those who cannot remember the past are condemned to repeat it&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;George Santayana&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/JasonW_a_young_chinese_girl_ride_on_a_chinese_dragon.png&quot; alt=&quot;龙女儿&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="人工智能" scheme="https://sniffer.site/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="人工智能" scheme="https://sniffer.site/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="AI" scheme="https://sniffer.site/tags/AI/"/>
    
    <category term="chatGPT" scheme="https://sniffer.site/tags/chatGPT/"/>
    
    <category term="LLM" scheme="https://sniffer.site/tags/LLM/"/>
    
    <category term="AIGC" scheme="https://sniffer.site/tags/AIGC/"/>
    
  </entry>
  
  <entry>
    <title>Android中HAL服务无法使用网络的问题</title>
    <link href="https://sniffer.site/2023/03/09/Android%E4%B8%ADHAL%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://sniffer.site/2023/03/09/Android%E4%B8%ADHAL%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-09T06:19:09.000Z</published>
    <updated>2023-03-13T12:03:38.848Z</updated>
    
    <content type="html"><![CDATA[<p>最近有同学在<code>Android S(12)</code>上遇到了一个奇怪的网络问题，说自己的<code>audio HAL</code>服务尝试通过以太网创建<code>socket</code>与其他局域网的节点通讯时，总是提示<code>Operation Not Permitted</code>。原先怀疑是<code>Selinux</code>的问题，但是目前在开发版本中<code>selinux</code>是完全关闭的；从问题发生的现象看，只有属于<code>audioserver</code>这个<code>UID</code>的进程才有问题，其他的如<code>system/root</code>的进程则没有问题。</p><p>据此，我们可以推断，<code>audioserver</code>这个<code>UID</code>的进程没有相关权限，所以导致无法使用局域网的网络。记得在早前的<code>Android</code>版本中，很多网络系统调用会通过<code>netd</code>代理进行权限检查，比如<code>socket/connect/bind</code>等系统调用都会先通过<code>netdClient</code>这个库的接口进行权限检查，而后才真正进行系统调用。<span id="more"></span>查看了<code>Android S</code>中<code>netd/client</code>中的代码，果真有一个<code>socket</code>的代理接口会检查权限:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">netdClientSocket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Block creating AF_INET/AF_INET6 socket if networking is not allowed.</span></span><br><span class="line">    <span class="keyword">if</span> (FwmarkCommand::<span class="built_in">isSupportedFamily</span>(domain) &amp;&amp; !allowNetworkingForProcess.<span class="built_in">load</span>()) &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> socketFd = <span class="built_in">libcSocket</span>(domain, type, protocol);</span><br><span class="line">    <span class="keyword">if</span> (socketFd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> netId = netIdForProcess &amp; ~NETID_USE_LOCAL_NAMESERVERS;</span><br><span class="line">    <span class="keyword">if</span> (netId != NETID_UNSET &amp;&amp; FwmarkClient::<span class="built_in">shouldSetFwmark</span>(domain)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">int</span> error = <span class="built_in">setNetworkForSocket</span>(netId, socketFd)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">closeFdAndSetErrno</span>(socketFd, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> socketFd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>有关<code>netd</code>的详细介绍可以参考<a href="https://sniffer.site/2018/12/18/android-netd%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">Android Netd工作原理详解</a></p></blockquote><p>继续跟踪这个代码路径，发现<code>Android</code>的<code>Zygote</code>进程创建应用进程的时候会调用<code>setAllowNetworkingForProcess</code>接口，根据进程是否在一个<code>INET_GID</code>用户组来设置该进程是否有权限访问网络:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 进程是否包含了在INET对应的用户组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">containsInetGid</span><span class="params">(<span class="type">int</span>[] gids)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gids.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gids[i] == android.os.Process.INET_GID) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">forkAndSpecialize</span><span class="params">(<span class="type">int</span> uid, <span class="type">int</span> gid, <span class="type">int</span>[] gids, <span class="type">int</span> runtimeFlags,</span></span><br><span class="line"><span class="params">        <span class="type">int</span>[][] rlimits, <span class="type">int</span> mountExternal, String seInfo, String niceName, <span class="type">int</span>[] fdsToClose,</span></span><br><span class="line"><span class="params">        <span class="type">int</span>[] fdsToIgnore, <span class="type">boolean</span> startChildZygote, String instructionSet, String appDataDir,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> isTopApp, String[] pkgDataInfoList, String[] allowlistedDataInfoList,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> bindMountAppDataDirs, <span class="type">boolean</span> bindMountAppStorageDirs)</span> &#123;</span><br><span class="line">    ZygoteHooks.preFork();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> nativeForkAndSpecialize(</span><br><span class="line">            uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">            fdsToIgnore, startChildZygote, instructionSet, appDataDir, isTopApp,</span><br><span class="line">            pkgDataInfoList, allowlistedDataInfoList, bindMountAppDataDirs,</span><br><span class="line">            bindMountAppStorageDirs);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Note that this event ends at the end of handleChildProc,</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;PostFork&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If no GIDs were specified, don&#x27;t make any permissions changes based on groups.</span></span><br><span class="line">        <span class="keyword">if</span> (gids != <span class="literal">null</span> &amp;&amp; gids.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            NetworkUtilsInternal.setAllowNetworkingForProcess(containsInetGid(gids));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the Java Language thread priority to the default value for new apps.</span></span><br><span class="line">    Thread.currentThread().setPriority(Thread.NORM_PRIORITY);</span><br><span class="line"></span><br><span class="line">    ZygoteHooks.postForkCommon();</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次检查<code>HAL</code>服务的<code>rc</code>配置，发现<code>group</code>用户组中已经包含了<code>inet</code>了。而且，从问题的现象来看，是跟进程的<code>UID</code>有关，与<code>GID</code>的关系不大。那么，到底是哪里设置了<code>UID</code>相关的权限了？ 跟同事一起确认发现，只要在<code>/system/etc/permission/platform.xml</code>中为<code>audioserver</code>添加一个<code>INTERNET</code>权限网络就可以正常访问了:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;assign-permission name=<span class="string">&quot;android.permission.INTERNET&quot;</span> uid=<span class="string">&quot;audioserver&quot;</span> /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>问题好像比较清晰了，应该是系统启动时，对于那些无法通过<code>AndroidManifest.xml</code>声明权限的服务，比如<code>native</code>的服务，包管理服务<code>PMS</code>会去解析对应<code>UID</code>的权限，然后再通过某种方式设置到系统，确保其在创建<code>socket</code>时相关的权限会被检查。查看<code>frameworks/base/services/../pm/permission</code>代码可以大概知道，<code>Android</code>中的所有权限都统一由系统服务<code>PermissionManagerService</code>来管理，系统启动时，就会通过这个服务解析<code>platform.xml</code>文件中各个<code>UID</code>的权限声明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">SystemConfig</span> <span class="variable">systemConfig</span> <span class="operator">=</span> SystemConfig.getInstance();</span><br><span class="line">mSystemPermissions = systemConfig.getSystemPermissions();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但继续跟踪代码，却没有看到是这个权限配置是如何与<code>socket</code>的创建控制关联在一起的。这个想来十分奇怪，按照实现逻辑来说，这种权限控制不会放在内核实现，而是应该在用户空间的某个地方设置。过了两天再来看这个问题，突然想起之前做流量统计功能时，<code>Android</code>中使用了<code>BPF</code>，很有可能这个网络权限的控制也是在<code>netd</code>对应的<code>BPF</code>中实现的。查看了下<code>/system/netd/bpf_progs/netd.c</code>的代码，确实有一个<code>bpf map</code>来控制<code>socket</code>的创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_BPF_PROG_KVER</span>(<span class="string">&quot;cgroupsock/inet/create&quot;</span>, AID_ROOT, AID_ROOT, inet_socket_create,</span><br><span class="line">                     <span class="built_in">KVER</span>(<span class="number">4</span>, <span class="number">14</span>, <span class="number">0</span>))</span><br><span class="line">(<span class="keyword">struct</span> bpf_sock* sk) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> gid_uid = <span class="built_in">bpf_get_current_uid_gid</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A given app is guaranteed to have the same app ID in all the profiles in</span></span><br><span class="line"><span class="comment">     * which it is installed, and install permission is granted to app for all</span></span><br><span class="line"><span class="comment">     * user at install time so we only check the appId part of a request uid at</span></span><br><span class="line"><span class="comment">     * run time. See UserHandle#isSameApp for detail.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> appId = (gid_uid &amp; <span class="number">0xffffffff</span>) % PER_USER_RANGE;</span><br><span class="line">    <span class="type">uint8_t</span>* permissions = <span class="built_in">bpf_uid_permission_map_lookup_elem</span>(&amp;appId);</span><br><span class="line">    <span class="keyword">if</span> (!permissions) &#123;</span><br><span class="line">        <span class="comment">// UID not in map. Default to just INTERNET permission.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A return value of 1 means allow, everything else means deny.</span></span><br><span class="line">    <span class="keyword">return</span> (*permissions &amp; BPF_PERMISSION_INTERNET) == BPF_PERMISSION_INTERNET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个<code>UID</code>权限<code>map</code>对象正是通过<code>Netd</code>的接口进行设置的，大致的路径如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PermissionMonitor.startMoniotr -&gt; (SystemServer)</span><br><span class="line">    NetdNativeService.trafficSetNetPermForUids --&gt; (Netd)</span><br><span class="line">    TrafficeController.setPermissionForUids</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是说<code>ConnectivityService</code>在启动过程中，通过<code>PermissionMonitor</code>读取到<code>SystemConfig</code>的用户权限配置后，会调用<code>NETD</code>的接口设置对应的<code>UID</code>的网络权限:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">startMonitoring</span><span class="params">()</span> &#123;</span><br><span class="line">    log(<span class="string">&quot;Monitoring&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">userAllContext</span> <span class="operator">=</span> mContext.createContextAsUser(UserHandle.ALL, <span class="number">0</span> <span class="comment">/* flags */</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">IntentFilter</span> <span class="variable">intentFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>();</span><br><span class="line">    intentFilter.addAction(Intent.ACTION_PACKAGE_ADDED);</span><br><span class="line">    intentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);</span><br><span class="line">    intentFilter.addDataScheme(<span class="string">&quot;package&quot;</span>);</span><br><span class="line">    userAllContext.registerReceiver(</span><br><span class="line">            mIntentReceiver, intentFilter, <span class="literal">null</span> <span class="comment">/* broadcastPermission */</span>,</span><br><span class="line">            <span class="literal">null</span> <span class="comment">/* scheduler */</span>);</span><br><span class="line">    ...</span><br><span class="line">    List&lt;PackageInfo&gt; apps = mPackageManager.getInstalledPackages(GET_PERMISSIONS</span><br><span class="line">            | MATCH_ANY_USER);</span><br><span class="line">    <span class="keyword">if</span> (apps == <span class="literal">null</span>) &#123;</span><br><span class="line">        loge(<span class="string">&quot;No apps&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">SparseIntArray</span> <span class="variable">netdPermsUids</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SparseIntArray</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (PackageInfo app : apps) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">uid</span> <span class="operator">=</span> app.applicationInfo != <span class="literal">null</span> ? app.applicationInfo.uid : INVALID_UID;</span><br><span class="line">        <span class="keyword">if</span> (uid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mAllApps.add(UserHandle.getAppId(uid));</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNetwork</span> <span class="operator">=</span> hasNetworkPermission(app);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasRestrictedPermission</span> <span class="operator">=</span> hasRestrictedNetworkPermission(app);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isNetwork || hasRestrictedPermission) &#123;</span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">permission</span> <span class="operator">=</span> mApps.get(UserHandle.getAppId(uid));</span><br><span class="line">            <span class="comment">// If multiple packages share a UID (cf: android:sharedUserId) and ask for different</span></span><br><span class="line">            <span class="comment">// permissions, don&#x27;t downgrade (i.e., if it&#x27;s already SYSTEM, leave it as is).</span></span><br><span class="line">            <span class="keyword">if</span> (permission == <span class="literal">null</span> || permission == NETWORK) &#123;</span><br><span class="line">                mApps.put(UserHandle.getAppId(uid), hasRestrictedPermission);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> unify the management of the permissions into one codepath.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">otherNetdPerms</span> <span class="operator">=</span> getNetdPermissionMask(app.requestedPermissions,</span><br><span class="line">                app.requestedPermissionsFlags);</span><br><span class="line">        netdPermsUids.put(uid, netdPermsUids.get(uid) | otherNetdPerms);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mUsers.addAll(mUserManager.getUserHandles(<span class="literal">true</span> <span class="comment">/* excludeDying */</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> SparseArray&lt;String&gt; netdPermToSystemPerm = <span class="keyword">new</span> <span class="title class_">SparseArray</span>&lt;&gt;();</span><br><span class="line">    netdPermToSystemPerm.put(INetd.PERMISSION_INTERNET, INTERNET);</span><br><span class="line">    netdPermToSystemPerm.put(INetd.PERMISSION_UPDATE_DEVICE_STATS, UPDATE_DEVICE_STATS);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; netdPermToSystemPerm.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">netdPermission</span> <span class="operator">=</span> netdPermToSystemPerm.keyAt(i);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">systemPermission</span> <span class="operator">=</span> netdPermToSystemPerm.valueAt(i);</span><br><span class="line">        <span class="comment">//获取有INTERNET权限的UID</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span>[] hasPermissionUids =</span><br><span class="line">                mSystemConfigManager.getSystemPermissionUids(systemPermission);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; hasPermissionUids.length; j++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">uid</span> <span class="operator">=</span> hasPermissionUids[j];</span><br><span class="line">            netdPermsUids.put(uid, netdPermsUids.get(uid) | netdPermission);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;Users: &quot;</span> + mUsers.size() + <span class="string">&quot;, Apps: &quot;</span> + mApps.size());</span><br><span class="line">    update(mUsers, mApps, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置UID的网络权限</span></span><br><span class="line">    sendPackagePermissionsToNetd(netdPermsUids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，谜底终于解开了。感兴趣的可以查看<code>packages/modules/Connectivity/</code>下<code>PermissionMonitor.java</code>的代码。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近有同学在&lt;code&gt;Android S(12)&lt;/code&gt;上遇到了一个奇怪的网络问题，说自己的&lt;code&gt;audio HAL&lt;/code&gt;服务尝试通过以太网创建&lt;code&gt;socket&lt;/code&gt;与其他局域网的节点通讯时，总是提示&lt;code&gt;Operation Not Permitted&lt;/code&gt;。原先怀疑是&lt;code&gt;Selinux&lt;/code&gt;的问题，但是目前在开发版本中&lt;code&gt;selinux&lt;/code&gt;是完全关闭的；从问题发生的现象看，只有属于&lt;code&gt;audioserver&lt;/code&gt;这个&lt;code&gt;UID&lt;/code&gt;的进程才有问题，其他的如&lt;code&gt;system/root&lt;/code&gt;的进程则没有问题。&lt;/p&gt;
&lt;p&gt;据此，我们可以推断，&lt;code&gt;audioserver&lt;/code&gt;这个&lt;code&gt;UID&lt;/code&gt;的进程没有相关权限，所以导致无法使用局域网的网络。记得在早前的&lt;code&gt;Android&lt;/code&gt;版本中，很多网络系统调用会通过&lt;code&gt;netd&lt;/code&gt;代理进行权限检查，比如&lt;code&gt;socket/connect/bind&lt;/code&gt;等系统调用都会先通过&lt;code&gt;netdClient&lt;/code&gt;这个库的接口进行权限检查，而后才真正进行系统调用。</summary>
    
    
    
    <category term="Android" scheme="https://sniffer.site/categories/Android/"/>
    
    
    <category term="Android" scheme="https://sniffer.site/tags/Android/"/>
    
    <category term="网络使用权限" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>说说系统开发中的康威定律</title>
    <link href="https://sniffer.site/2023/02/27/%E8%AF%B4%E8%AF%B4%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B/"/>
    <id>https://sniffer.site/2023/02/27/%E8%AF%B4%E8%AF%B4%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B/</id>
    <published>2023-02-27T10:30:16.000Z</published>
    <updated>2023-03-23T01:10:55.496Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Work on stuff that matters: </p><ul><li>work on something that matters to you more than money</li><li>create more value than you capture</li><li>take the long view.</li></ul><p> <strong>Tim O’Reilly</strong></p></blockquote><p><img src="https://images.unsplash.com/photo-1487958449943-2429e8be8625?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80" alt="system design board"></p><span id="more"></span><p>最近在跟车载座舱中的紧急通话<code>ECALL</code>功能时，发现最开始的设计方案完全没有考虑到硬件与软件的复用。由于这个方案跨了两个中心的部门，<code>ECALL</code>的初始方案设计中竟然为<code>ECALL</code>增加了额外的一套录音与播放系统，不仅增加了硬件成本，也加大了软件开发的投入，而这样音频系统在座舱<code>SoC</code>上早就已经有一套了。如今，团队又不得不重新提出一个所谓降本的方案，以减少成本。这种系统设计的方案不禁让我联想到软件设计中著名的<a href="https://en.wikipedia.org/wiki/Conway%27s_law">康威定律(<code>Conway&#39;s law</code>)</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization&#x27;s communication structure</span><br><span class="line"></span><br><span class="line">— Melvin E. Conway， 1968</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>翻译过来，康威定律是说，在任何一个组织中诞生的系统, 在很大程度上会被设计成一个跟这个组织(沟通)结构类似的架构，就是说在系统设计的时候，我们自觉或不自觉的构建出了一个跟自己所在团队结构类似的系统框架了。关于康威定律，有一个更为直观的说法来自<a href="https://en.wikipedia.org/wiki/Eric_S._Raymond"><code>Eric Steven Raymond</code></a>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">If you have four groups working on a compiler, you&#x27;ll get a 4-pass compiler</span><br><span class="line"></span><br><span class="line">&lt;如果有四个团队开发一个编译器，最后会得到一个4阶段的编译器&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于汽车这样一个由诸多复杂零部件构成的系统来说，实际开发中涉及到主机厂、各级供应商，跨团队的合作与开发会特别多，所以容易出现这类系统设计的<code>事故</code>，举几个我知道的例子吧:</p><ul><li>自动驾驶团队在选摄像头型号时，只考虑方便训练机器学习模型的类型，没有考虑其他系统，比如座舱控制器也有可能需要行车数据，导致后期在车型上开展类似功能时十分痛苦，做出来的效果跟其他厂商比也差强人意</li><li>同属一个业务的功能，如<code>CarService</code>，由于应用端与系统开发分属在两个团队， 应用的开发在需要提供接口给第三方业务调用时，基于系统的API做了第二次封装，与现有的封装业务属性上基本重合了</li><li>不同团队在同一个平台上、同一个系统上同时进行开发，大家在同样的事情上重复的投入</li></ul><p>那么，我们不禁要问，为什么人们在跨团队合作时会出现这种事后看起来啼笑皆非的情况，做出让人难以置信的决策了？想了想，大致有如下两个原因:</p><ul><li>团队中经常出现屁股决定脑袋的事情，不同部门之间协作容易变成抢业务的情况，尤其是业务存在重叠时更是如此</li><li>做技术决策或者方案设计时，相关的专业人员没有深度参与其中，导致很多声音被埋没了，没有被听见</li></ul><p>从这两点上，我们不妨来推演下，如何避免跨团队设计方案时出现康威定律中的诅咒。一个公司在发展初期，人员比较少，很多业务在大公司都是几十个人承担的，在这里可能就一个人忙前忙后。这样大家做沟通与决策的成本相对而言比较少的。等到公司规模不断扩展，团队人员快速增加，沟通成本增加的同时，也带来了业务分配的问题，最后发现可能有多个团队在做类似或者相同的事情。</p><p>这类问题初期还容易比较根治，到了后期涉及到的人员多时就很难了。业务的重叠或者人员的冗余，说到底是公司技术体系的构建不合理，没有充分做到复用：人员的复用，团队能力的复用，系统设计的复用。所以，理想汽车的<code>CEO</code>李想在讲到公司的组织架构时(视频可以在哔哩哔哩上搜索到，值得看看)，就特别提到了公司体系的建设与构建-我想这大概就是尽可能去做到组织中各个团队不同业务的解耦，尽量避免重复造轮子，增加系统复用的程度，从而提高组织效率，从根源上减少开发成本。又或者，公司初期在组织体系上做的不够完善，欠了债务，那么等到团队初具规模时，一定要下定决心做重构，重新梳理不同业务部门的职能与负责的事情，尽量避免这种团队与业务的耦合扩散到无法收拾的程度。</p><p>关于第二点，在做系统方案设计时，专业声音被淹没的问题，由于涉及到不同专业背景的人，所以可能更难处理。对于一个想要在激烈市场竞争中获得胜利的团队，要想做出更好的产品，做出更明智的决策，让团队成员都有机会发声，强调高效、平等的沟通，打造专业、追求极致的文化氛围之外似乎没有更好的选择了。这是一个系统工程，也是一个想要长期取得领先定位的团队必须要思考面对的问题。只有从方方面面去构建高效、专业、极致的组织文化，才有可能避免这种专业声音石沉大海的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这里借这康威定律讲了自己在系统设计与组织构建中的遇到一些问题，实际上这些问题的原因可能比我看到的要更为复杂多样。系统设计涉及到公司组织架构、技术能力、团队管理、产品定义等多个维度，要想做好其实是一个非常有难度而有挑战的事情。每个想要做好产品，为用户创造价值的团队都需要认真考虑康威定律可能带来的影响。有关康威定律，<code>Martin Fowler</code>写了一篇文章介绍了如何在软件开发如何应对，值得参考下<a href="https://martinfowler.com/bliki/ConwaysLaw.html">Conway’s law</a>。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;Work on stuff that matters: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;work on something that matters to you more than money&lt;/li&gt;
&lt;li&gt;create more value than you capture&lt;/li&gt;
&lt;li&gt;take the long view.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;strong&gt;Tim O’Reilly&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1487958449943-2429e8be8625?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1170&amp;q=80&quot; alt=&quot;system design board&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="软件工程" scheme="https://sniffer.site/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="软件开发" scheme="https://sniffer.site/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="Conway&#39;s Law" scheme="https://sniffer.site/tags/Conway-s-Law/"/>
    
    <category term="康威定律" scheme="https://sniffer.site/tags/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>为什么iperf测试时UDP会出现高丢包率</title>
    <link href="https://sniffer.site/2023/01/10/%E4%B8%BA%E4%BB%80%E4%B9%88iperf%E6%B5%8B%E8%AF%95%E6%97%B6UDP%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%AB%98%E4%B8%A2%E5%8C%85%E7%8E%87/"/>
    <id>https://sniffer.site/2023/01/10/%E4%B8%BA%E4%BB%80%E4%B9%88iperf%E6%B5%8B%E8%AF%95%E6%97%B6UDP%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%AB%98%E4%B8%A2%E5%8C%85%E7%8E%87/</id>
    <published>2023-01-10T07:13:25.000Z</published>
    <updated>2023-01-10T09:23:40.137Z</updated>
    
    <content type="html"><![CDATA[<p>这两天质量的同学反馈说<code>iperf</code>测试时结果很差，跟实际的千兆带宽差别很大。确认了半天，发现内核的各项参数都已经完全按照千兆的目标速率进行配置了，那为什么还是会出现<code>TCP/UDP</code>带宽不足的问题？ 记得当时优化参数时，自己摸底测试的<code>TCP</code>结果挺好的，都达到了预期的<code>900Mbps</code>以上，看起来最近有什么修改导致了这个测试结果差异。</p><p>偶然的一个机会查看内核配置时，发现最近有人打开了<code>trace</code>功能，看起来很可能是这个修改导致了网络性能的下降了。拿早前未开启<code>trace</code>功能的版本一对比，果真是<code>trace</code>功能影响了<code>TCP</code>的带宽。<span id="more"></span>但是测试<code>UDP</code>还是会出现如下结果，看起來好像网络很差(注意对<code>UDP</code>测试需要通过设置<code>-b</code>参数来限制可能的带宽，否则也可能出现测试结果偏差)：</p><ul><li>使用<code>iperf</code>默认的的包大小测试(看源码，对<code>UDP</code>来说，默认的包大小为<code>1024</code>， 最大为<code>65507</code>)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务端: iperf3 -s -p <span class="number">8989</span> -f m</span><br><span class="line">客户端: iperf3 -c <span class="number">172.20</span><span class="number">.2</span><span class="number">.40</span> -p <span class="number">8989</span> -f m -t <span class="number">30</span> -u -b <span class="number">1</span>G</span><br><span class="line"></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-30.00</span>  sec   <span class="number">710</span> MBytes   <span class="number">198</span> Mbits/sec  <span class="number">0.000</span> ms  <span class="number">0</span>/<span class="number">509813</span> (<span class="number">0</span>%)  sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-30.19</span>  sec   <span class="number">701</span> MBytes   <span class="number">195</span> Mbits/sec  <span class="number">0.201</span> ms  <span class="number">6626</span>/<span class="number">509809</span> (<span class="number">1.3</span>%)  receiver</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于<code>UDP</code>没有流控，整体的丢包率<code>1.3%</code>还不错，但带宽明显太小了，只有理论值的<code>1/5</code>不到。从这个结果可以看到，实际带宽不足是因为发送端的速率太小了，导致整个通道未被充分占满。这就好比一个粗大的水管，但实际传输的水流太小了，容量利用率不够。要想提高利用率，只能想法提升发送端的速率。<code>iperf</code>中，我们可以通过<a href="https://serverfault.com/questions/691723/extreme-udp-packet-loss-at-300mbit-14-but-tcp-800mbit-w-o-retransmits">提高包大小来达到这一目的</a>：</p><ul><li>使用最大的<code>UDP</code>包大小(<code>65507</code>)进行测试</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务端: iperf3 -s -p <span class="number">8989</span> -f m</span><br><span class="line">客户端: iperf3 -c <span class="number">172.20</span><span class="number">.2</span><span class="number">.40</span> -p <span class="number">8989</span> -f m -t <span class="number">30</span> -u -b <span class="number">1</span>G -l <span class="number">65507</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ ID] Interval           Transfer     Bitrate         Jitter    Lost/Total Datagrams</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-10.00</span>  sec  <span class="number">1.16</span> GBytes  <span class="number">1000</span> Mbits/sec  <span class="number">0.000</span> ms  <span class="number">0</span>/<span class="number">19079</span> (<span class="number">0</span>%)  sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-10.18</span>  sec   <span class="number">723</span> MBytes   <span class="number">595</span> Mbits/sec  <span class="number">0.282</span> ms  <span class="number">7508</span>/<span class="number">19079</span> (<span class="number">39</span>%)  receiver</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这次测试带宽明显有所提升，但接收端的丢包率却达到了惊人的<code>39%</code>。为什么会出现如此高的丢包率了？这还是要从<code>UDP</code>的传输机制说起了。我们都知道，<a href="http://www.tcpipguide.com/free/t_UDPOverviewHistoryandStandards.htm"><code>UDP</code>是无连接的数据报文传输协议</a>，也没有类似<code>TCP</code>滑动窗口的流量控制机制，因此快速的一方很有可能会淹没慢速的一方。这个时候就需要适当的调整慢速一端的<code>socket</code>缓冲区大小了。</p><p>对于<code>UDP</code>来说，主要有如下几个参数会影响实际传输时<code>socket</code>缓冲区的大小(可以参考内核文档<code>ip-sysctl.txt</code>)：</p><ul><li><code>net.core.wmem_default/net.core.wmem_max</code>: 默认、最大的发送缓冲区大小(bytes)，如果没用通过<code>setsockopt</code>來设置<code>SO_SNDBUF</code>的值，则会使用内核默认的缓冲区大小</li><li><code>net.core.rmem_default/net.core.rmem_max</code>: 默认、最大的接收缓冲区大小(bytes), 类似的，如果没有通过<code>SO_RCVBUF</code>来设置发送缓冲区的值，则使用内核默认的<code>net.core.rmem_default</code>值</li><li><code>net.ipv4.udp_mem=&quot;min pressure max&quot;</code>: 系统中所有<code>UDP</code>连接<code>socket</code>可以使用的最小、压力、最大页数（页大小一般为<code>4K</code>)，默认值一般在系统启动的时候根据当前可用内存计算出来的</li><li><code>net.ipv4.udp_rmem_min/net.ipv4.udp_wmen_min</code>: 系统中单个<code>UDP</code>连接<code>socket</code>可用的最小内存(bytes), 默认是<code>4K</code>。</li></ul><p>要想减少测试中的丢包率，就需要提高慢速端(也就是接收端)的缓冲区大小，确保其有足够的空间来保存接收到的数据，不至于来不及处理而被内核丢弃。我们可以选择在发送端或者接收端设置缓冲区的大小，对于<code>iperf</code>只能通过<code>-w</code>控制客户端的缓冲区大小, 这里我们直接在客户端设置发送缓冲区的大小为<code>10M</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务端: iperf3 -s -p <span class="number">8989</span> -f m</span><br><span class="line">客户端: iperf3 -c <span class="number">172.20</span><span class="number">.2</span><span class="number">.40</span> -p <span class="number">8989</span> -f m -t <span class="number">30</span> -u -b <span class="number">1</span>G -l <span class="number">65507</span> -w <span class="number">10</span>M</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ ID] Interval           Transfer     Bitrate         Jitter    Lost/Total Datagrams</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-10.00</span>  sec  <span class="number">1.16</span> GBytes  <span class="number">1000</span> Mbits/sec  <span class="number">0.000</span> ms  <span class="number">0</span>/<span class="number">19081</span> (<span class="number">0</span>%)  sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-10.19</span>  sec  <span class="number">1.16</span> GBytes   <span class="number">981</span> Mbits/sec  <span class="number">0.593</span> ms  <span class="number">0</span>/<span class="number">19079</span> (<span class="number">0</span>%)  receiver</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，丢包率速率下降了到预期的程度。如果我们要在服务端设置接收缓冲区的大小，可以有两种方式: 一种是通过设置<code>net.core.rmem_default</code>大小，一种是修改<code>iperf3</code>的源码，确保服务端也可以通过<code>-w</code>来设置缓冲区的大小。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>网络的带宽优化涉及了Linux内核协议栈和网卡驱动，充分理解网络数据的传输流程以及<code>TCP/UDP</code>等传输协议的机制，才有可能找到性能的瓶颈。总的来说，这些优化很值得很深入研究，可以让人完整的把各个知识点都梳理串联起来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两天质量的同学反馈说&lt;code&gt;iperf&lt;/code&gt;测试时结果很差，跟实际的千兆带宽差别很大。确认了半天，发现内核的各项参数都已经完全按照千兆的目标速率进行配置了，那为什么还是会出现&lt;code&gt;TCP/UDP&lt;/code&gt;带宽不足的问题？ 记得当时优化参数时，自己摸底测试的&lt;code&gt;TCP&lt;/code&gt;结果挺好的，都达到了预期的&lt;code&gt;900Mbps&lt;/code&gt;以上，看起来最近有什么修改导致了这个测试结果差异。&lt;/p&gt;
&lt;p&gt;偶然的一个机会查看内核配置时，发现最近有人打开了&lt;code&gt;trace&lt;/code&gt;功能，看起来很可能是这个修改导致了网络性能的下降了。拿早前未开启&lt;code&gt;trace&lt;/code&gt;功能的版本一对比，果真是&lt;code&gt;trace&lt;/code&gt;功能影响了&lt;code&gt;TCP&lt;/code&gt;的带宽。</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="iperf" scheme="https://sniffer.site/tags/iperf/"/>
    
    <category term="UDP" scheme="https://sniffer.site/tags/UDP/"/>
    
  </entry>
  
</feed>
