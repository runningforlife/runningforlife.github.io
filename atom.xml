<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasonWang&#39;s Blog</title>
  
  <subtitle>本色做人，角色做事</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sniffer.site/"/>
  <updated>2020-06-04T12:16:49.761Z</updated>
  <id>http://sniffer.site/</id>
  
  <author>
    <name>Jason Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>由Policy Routing引发的一个奇怪问题</title>
    <link href="http://sniffer.site/2020/06/03/%E7%94%B1Policy-Routing%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://sniffer.site/2020/06/03/由Policy-Routing引发的一个奇怪问题/</id>
    <published>2020-06-03T06:05:32.000Z</published>
    <updated>2020-06-04T12:16:49.761Z</updated>
    
    <content type="html"><![CDATA[<p>最近新的项目又开始了, 开始还算顺利, 却不料碰到了一个奇怪的问题. 先来了解下问题的背景. 这个项目里, Android中有两个以太网网口, 一个用于内网通讯<eth0>, 不具备上外网的能力;一个用于外网通讯<eth1>, 使用该网口可以访问互联网. 在网络管理模块的工作完成后, 提交了代码我原本以为可以高枕无忧, 前两天组内的同学跑过来告诉我, 他有个系统服务一直没法通过<eth0>与内网的其他设备上的服务建立TCP链接, 但是网络却一直可以ping通; 而另外的一个开发板上却不存在这个问题. </eth0></eth1></eth0></p><p>开始我有点不相信竟然会有这样的问题, 但事实摆在面前, 我也不好抵赖, 于是自己找来一个板子, 看了下, 才逐渐找到答案. 问题的根源在于Android配置的策略路由<policy routing>规则隐含了一个针对系统默认网络的<code>fwmark</code>规则, 要解决问题, 只要我们将包含了<eth0>内网路由表的路由规则的优先级提升到高于Android隐含的这条规则即可. 虽然找到了解决方案, 但是还是决定花点时间把整个事情的来龙去脉都理清楚. </eth0></policy></p><p>大致分如下几个部分来讲一讲这个问题:</p><ul><li>介绍下什么是Policy Routing&lt;策略路由&gt;</li><li>分析具体的问题, 并给出方案</li><li>从源代码角度来分析下, 为何TCP无法建立, 但ping却可以</li></ul><h2 id="什么是Policy-Routing"><a href="#什么是Policy-Routing" class="headerlink" title="什么是Policy Routing"></a><strong>什么是Policy Routing</strong></h2><p>我们都知道, 传统的Linux路由都是基于目标IP地址来进行路由设置, 策略路由不同的是, 在原有路由表的基础上, 添加一系列具有优先级的规则, 这些规则可以根据数据包的入口&lt;本地或者lo&gt;, 出口, TOS&lt;<code>Type Of Service</code>&gt;, fwmark标签值, 协议以及端口号等来进行路由表的选择, 所有这些策略规则都放在一个称为<code>routing policy database</code><rpdb>的数据库中. 一般, 一条策略路由规则都由<code>selector</code>(选择器)以及<code>action predicate</code>(需要执行的动作)两部分组成; 通过<code>ip rule</code>指令, 我们可以修改/删除系统中的策略路由规则. 例如, 在Ubuntu系统中, 输入<code>ip rule list</code>, 大致是这样的:</rpdb></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">0</span>:from all lookup local </span><br><span class="line"><span class="number">32766</span>:from all lookup main </span><br><span class="line"><span class="number">32767</span>:from all lookup <span class="keyword">default</span></span><br></pre></td></tr></table></figure><p>这些策略路由规则都是内核初始化时默认生成的, 按照规则的优先级大小排列, 数字越小, 优先级越高:</p><ul><li>优先级<code>0</code>: 会匹配任何数据包, 执行的动作是在<code>local</code>路由表<id 255>查找路由</id></li><li>优先级<code>32766</code>: 匹配任何数据包, 执行的动作是在<code>main</code>路由表<id 254>中查找路由</id></li><li>优先级<code>32767</code>: 匹配任何数据包, 执行的动作是在<code>default</code>路由表<id 253>中查找路由</id></li></ul><p>通过<code>man ip rule</code>我们可以查看到更多关于RP规则的信息. 而对于Android来说, 由于需要同时管理多个网络, 并根据网络权限/用户UID等来设置防火墙, 策略路由的规则就复杂了很多, 例如在我的开发板上输入<code>adb shell ip rule list</code>可以看到这么一大串的规则列表:</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/android_ip_rules_list.png" alt="Android Ip Rule list examples"></p><p>这里, <code>eth0</code>就是用来作内网通讯用的网口, 而<code>usb0</code>是用来连接外网的网口, 当前系统默认的默认网络&lt;具有默认路由&gt;即<code>usb0</code>. Android的Netd(负责网络管理的native进程, 可以参考早前的文章了解更多信息<a href="http://sniffer.site/2018/12/18/Android-netd%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">Android Netd详解</a>)会把每个正常工作的网口都建立一个相应的路由表, 路由表的ID就是对应网络的<code>netID</code>&lt;每个网络在创建后都会分配一个唯一的ID&gt;, 例如通过输入<code>ip route show table usb0</code>查看路由表<code>usb0</code>实际是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">default</span> via <span class="number">192.168</span><span class="number">.225</span><span class="number">.1</span> dev usb0 proto <span class="keyword">static</span> </span><br><span class="line"><span class="number">192.168</span><span class="number">.225</span><span class="number">.0</span>/<span class="number">24</span> dev usb0 proto <span class="keyword">static</span> scope link</span><br></pre></td></tr></table></figure><p>这张路由表包含了两个路由规则: 前一个是默认路由, 用于匹配外网数据(非<code>192.168.225.*</code>IP段的都会匹配该路由)的路由；后一个是用于该网卡局域网内IP地址的路由.上图中我们看到的这个RPDB实际是能正常工作的, 就是说通过<code>eth0</code>可以建立TCP连接, ping网络也正常, 后面在分析问题时会再贴出有问题的RPDB.</p><h2 id="网络ping通但无法建立TCP的问题"><a href="#网络ping通但无法建立TCP的问题" class="headerlink" title="网络ping通但无法建立TCP的问题"></a><strong>网络ping通但无法建立TCP的问题</strong></h2><p>出问题时的路由表<code>eth0</code>只有一个路由规则:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">172.20</span><span class="number">.1</span><span class="number">.0</span>/<span class="number">24</span> dev eth0 proto <span class="keyword">static</span> scope link</span><br></pre></td></tr></table></figure><p>相应的RPDB大致如下, 这里要说明的是<code>21300:    from all lookup main</code>这个查找<code>main</code>路由表的规则是需要自己添加的, Android原生代码已经把<code>main</code>表的查找规则剔除了, 对于同时有对个网卡共存的情况, <code>main</code>表是必须的, 否则基于<code>eth0</code>网口的局域网就无法正常ping通.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">0</span>:from all lookup local </span><br><span class="line"><span class="number">10000</span>:from all fwmark <span class="number">0xc0000</span>/<span class="number">0xd0000</span> lookup legacy_system </span><br><span class="line"><span class="number">10500</span>:from all iif lo oif dummy0 uidrange <span class="number">0</span><span class="number">-0</span> lookup dummy0 </span><br><span class="line"><span class="number">10500</span>:from all iif lo oif eth0 uidrange <span class="number">0</span><span class="number">-0</span> lookup eth0 </span><br><span class="line"><span class="number">10500</span>:from all iif lo oif usb0 uidrange <span class="number">0</span><span class="number">-0</span> lookup usb0 </span><br><span class="line"><span class="number">13000</span>:from all fwmark <span class="number">0x10063</span>/<span class="number">0x1ffff</span> iif lo lookup local_network </span><br><span class="line"><span class="number">13000</span>:from all fwmark <span class="number">0x10064</span>/<span class="number">0x1ffff</span> iif lo lookup eth0 </span><br><span class="line"><span class="number">13000</span>:from all fwmark <span class="number">0x10065</span>/<span class="number">0x1ffff</span> iif lo lookup usb0 </span><br><span class="line"><span class="number">14000</span>:from all iif lo oif dummy0 lookup dummy0 </span><br><span class="line"><span class="number">14000</span>:from all iif lo oif eth0 lookup eth0 </span><br><span class="line"><span class="number">14000</span>:from all iif lo oif usb0 lookup usb0 </span><br><span class="line"><span class="number">15000</span>:from all fwmark <span class="number">0x0</span>/<span class="number">0x10000</span> lookup legacy_system </span><br><span class="line"><span class="number">16000</span>:from all fwmark <span class="number">0x0</span>/<span class="number">0x10000</span> lookup legacy_network </span><br><span class="line"><span class="number">17000</span>:from all fwmark <span class="number">0x0</span>/<span class="number">0x10000</span> lookup local_network </span><br><span class="line"><span class="number">19000</span>:from all fwmark <span class="number">0x64</span>/<span class="number">0x1ffff</span> iif lo lookup eth0 </span><br><span class="line"><span class="number">19000</span>:from all fwmark <span class="number">0x65</span>/<span class="number">0x1ffff</span> iif lo lookup usb0 </span><br><span class="line"><span class="number">21300</span>:from all lookup main </span><br><span class="line"><span class="number">22000</span>:from all fwmark <span class="number">0x0</span>/<span class="number">0xffff</span> iif lo lookup usb0 </span><br><span class="line"><span class="number">32000</span>:from all unreachable</span><br></pre></td></tr></table></figure><p>基于上述RPDB规则, 尝试测试内网某个设备的连通性: <code>ping 172.20.1.55</code>有看到回应, 但是如果通过ssh指令<code>ssh -vvv root@172.20.1.55</code>尝试登录到对端, 就会提示<code>No Route to Host</code>, 其他上层TCP连接也没法正常建立成功. 细心的同学可能已经发现, 在之前讲到的那个正常RPDB与这里的异常的RPDB唯一的区别就是在与<code>main</code>路由表查找规则的优先级, 一个是<code>21300</code>, 一个<code>18300</code>, 那么为什么优先级的差异会导致不一样的结果?</p><p>对于一般的TCP连接, 并不会指定连接的网口(通过<code>setsocktopt</code>的<code>SO_BINDTODEVICE</code>选项指定), 所以可以判定那些指定了<code>oif</code>(数据包出口)的<code>ip rule</code>规则应该不会导致问题的发生, 这里我们可以通过<code>ip rule add pref &lt;pref_no&gt; lookup main</code>调整这个规则的优先级, 通过二分查找测试几次就知道了. 在另外一方面, 测试的同学反馈, 如果没有接<code>usb0</code>这个网络设备, 问题就不会存在. 这样这个问题就更清晰了: 跟<code>usb0</code>路由表相关的几条规则是问题的关键. 排除掉指定了<code>oif</code>相关的规则, 只剩下两条:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">13000</span>:from all fwmark <span class="number">0x10065</span>/<span class="number">0x1ffff</span> iif lo lookup usb0 </span><br><span class="line"><span class="number">19000</span>:from all fwmark <span class="number">0x65</span>/<span class="number">0x1ffff</span> iif lo lookup usb0</span><br></pre></td></tr></table></figure><p>删除掉原有的规则<code>ip rule del pref 21300 lookup main</code>, 然后添加一个优先级高于第一条<code>13000</code>的规则<code>ip rule add pref 12800 lookup main</code>, 试验下发现TCP可以正常建立连接, 问题不存在;再次实验, 先删除<code>main</code>路由表对应的规则, 添加一条<code>ip rule add pref 18300 lookup main</code>的规则, 也可以正常建立TCP连接. 于是, 我们可以断定, 优先级为<code>19000</code>这条规则是罪魁祸首.解决问题的方案就是把原来的<code>main</code>查找的优先级高于<code>19000</code>即可.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ip rule add pref <span class="number">18300</span> lookup main</span><br></pre></td></tr></table></figure><p>问题是解决了, 可以为什么会这样了? 这条包含了<code>fwmark</code>的规则为何会让TCP连接没法正常建立而ping又可以了? 还是要<code>read the fucking source code</code>才能找到根本原因了.</p><h2 id="看看该死的源代码"><a href="#看看该死的源代码" class="headerlink" title="看看该死的源代码"></a><strong>看看该死的源代码</strong></h2><p>对于Android来说, 无论是Java的网络请求, 还是native的最终都会通过<code>libc</code>的封装的系统调用来完成. 因此, 第一步就来看看<code>libc</code>中对常用socket API的实现逻辑. 对应的源码位于<code>/bionic/libc</code>. 我们知道, 对于TCP客户端来说, 一般先调用<code>socket</code>创建套接字获取到文件描述符后, 会直接调用<code>connect</code>尝试连接到服务端, 由于创建socket不涉及到路由, 因此就来看看<code>connect</code>的具体调用逻辑. 找到<code>connect.cpp</code>, 代码很简单, 只有一行:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr* addr, <span class="keyword">socklen_t</span> addrlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __netdClientDispatch.connect(sockfd, addr, addrlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数直接是调用了<code>__netdClientDispatch</code>对应的实现, 从函数名字来看, 实际应该是把请求转发给<code>Netd</code>, 不妨接续看代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// private/NetdClientDispatch.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetdClientDispatch</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*accept4)(<span class="keyword">int</span>, struct sockaddr*, <span class="keyword">socklen_t</span>*, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*connect)(<span class="keyword">int</span>, <span class="keyword">const</span> struct sockaddr*, <span class="keyword">socklen_t</span>);</span><br><span class="line">    <span class="keyword">int</span> (*socket)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> (*netIdForResolv)(<span class="keyword">unsigned</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// NetdClientDispatch.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __i386__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __socketcall __attribute__((__cdecl__))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __socketcall</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __socketcall <span class="keyword">int</span> __accept4(<span class="keyword">int</span>, sockaddr*, <span class="keyword">socklen_t</span>*, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __socketcall <span class="keyword">int</span> __connect(<span class="keyword">int</span>, <span class="keyword">const</span> sockaddr*, <span class="keyword">socklen_t</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __socketcall <span class="keyword">int</span> __socket(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="title">fallBackNetIdForResolv</span><span class="params">(<span class="keyword">unsigned</span> netId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> netId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This structure is modified only at startup (when libc.so is loaded) and never</span></span><br><span class="line"><span class="comment">// afterwards, so it's okay that it's read later at runtime without a lock.</span></span><br><span class="line">__LIBC_HIDDEN__ NetdClientDispatch __netdClientDispatch __attribute__((aligned(<span class="number">32</span>))) = &#123;</span><br><span class="line">    __accept4,</span><br><span class="line">    __connect,</span><br><span class="line">    __socket,</span><br><span class="line">    fallBackNetIdForResolv,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__netdClientDispatch</code>实际是封装了几个外部函数而已, 那么<code>__socket/__connect</code>/<code>__accept4</code>这几个函数又在哪里实现的了? 搜索下<code>libc</code>下面的代码, 发现原来在<code>libc</code>初始化的时候, 会加载一个<code>libnetd_client.so</code>的库函数, 然后把相应的实现加载过来:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// NetdClient.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FunctionType&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">netdClientInitFunction</span><span class="params">(<span class="keyword">void</span>* handle, <span class="keyword">const</span> <span class="keyword">char</span>* symbol, FunctionType* function)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*InitFunctionType)</span><span class="params">(FunctionType*)</span></span>;</span><br><span class="line">    InitFunctionType initFunction = <span class="keyword">reinterpret_cast</span>&lt;InitFunctionType&gt;(dlsym(handle, symbol));</span><br><span class="line">    <span class="keyword">if</span> (initFunction != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        initFunction(function);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">netdClientInitImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* netdClientHandle = dlopen(<span class="string">"libnetd_client.so"</span>, RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (netdClientHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// If the library is not available, it's not an error. We'll just use</span></span><br><span class="line">        <span class="comment">// default implementations of functions that it would've overridden.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    netdClientInitFunction(netdClientHandle, <span class="string">"netdClientInitAccept4"</span>,</span><br><span class="line">                          &amp;__netdClientDispatch.accept4);</span><br><span class="line">    netdClientInitFunction(netdClientHandle, <span class="string">"netdClientInitConnect"</span>,</span><br><span class="line">                          &amp;__netdClientDispatch.connect);</span><br><span class="line">    netdClientInitFunction(netdClientHandle, <span class="string">"netdClientInitNetIdForResolv"</span>,</span><br><span class="line">                          &amp;__netdClientDispatch.netIdForResolv);</span><br><span class="line">    netdClientInitFunction(netdClientHandle, <span class="string">"netdClientInitSocket"</span>, &amp;__netdClientDispatch.socket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> netdClientInitOnce = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __<span class="function">LIBC_HIDDEN__ <span class="keyword">void</span> <span class="title">netdClientInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pthread_once(&amp;netdClientInitOnce, netdClientInitImpl)) &#123;</span><br><span class="line">        async_safe_format_log(ANDROID_LOG_ERROR, <span class="string">"netdClient"</span>, <span class="string">"Failed to initialize netd_client"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有兴趣的可以看看<code>libc</code>具体的初始化流程. 这里, 我们直接跳到<code>libnetd_client.so</code>这个库去看看<code>netdClientInitConnect</code>的实现. 共享库<code>libnetd_client.so</code>的代码位于<code>/system/netd/client</code>目录, 其中有个文件<code>NetdClient.cpp</code>即实现了该函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// NetdClient.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netdClientConnect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr* addr, <span class="keyword">socklen_t</span> addrlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> shouldSetFwmark = (sockfd &gt;= <span class="number">0</span>) &amp;&amp; addr</span><br><span class="line">            &amp;&amp; FwmarkClient::shouldSetFwmark(addr-&gt;sa_family);</span><br><span class="line">    <span class="keyword">if</span> (shouldSetFwmark) &#123;</span><br><span class="line">        FwmarkCommand command = &#123;FwmarkCommand::ON_CONNECT, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">int</span> error = FwmarkClient().send(&amp;command, sockfd, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">            errno = -error;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Latency measurement does not include time of sending commands to Fwmark</span></span><br><span class="line">    Stopwatch s;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ret = libcConnect(sockfd, addr, addrlen);</span><br><span class="line">    <span class="comment">// Save errno so it isn't clobbered by sending ON_CONNECT_COMPLETE</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> connectErrno = errno;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> latencyMs = lround(s.timeTaken());</span><br><span class="line">    <span class="comment">// Send an ON_CONNECT_COMPLETE command that includes sockaddr and connect latency for reporting</span></span><br><span class="line">    <span class="keyword">if</span> (shouldSetFwmark &amp;&amp; FwmarkClient::shouldReportConnectComplete(addr-&gt;sa_family)) &#123;</span><br><span class="line">        <span class="function">FwmarkConnectInfo <span class="title">connectInfo</span><span class="params">(ret == <span class="number">0</span> ? <span class="number">0</span> : connectErrno, latencyMs, addr)</span></span>;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> get the netId from the socket mark once we have continuous benchmark runs</span></span><br><span class="line">        FwmarkCommand command = &#123;FwmarkCommand::ON_CONNECT_COMPLETE, <span class="comment">/* netId (ignored) */</span> <span class="number">0</span>,</span><br><span class="line">                                <span class="comment">/* uid (filled in by the server) */</span> <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// Ignore return value since it's only used for logging</span></span><br><span class="line">        FwmarkClient().send(&amp;command, sockfd, &amp;connectInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = connectErrno;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里的<code>Fwmark</code>等字样, 似乎有点眼熟了, 这个函数的逻辑是, 首先要判断一个socket链接是否要打上防火墙标签(Firewall Mark)<code>shouldSetFwmark</code>, 实际上对于TCP的socket来说, 该函数都返回<code>True</code>, 接着会将对应的socketFd通过一个本地<code>fwmarkd</code>这个socket发送给<code>FwmarkServer</code>, 由其负责将socket打上防火墙标签:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> FwmarkServer::processClient(SocketClient* client, <span class="keyword">int</span>* socketFd) &#123;</span><br><span class="line">    FwmarkCommand command;</span><br><span class="line">    FwmarkConnectInfo connectInfo;</span><br><span class="line"></span><br><span class="line">    iovec iov[<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123; &amp;command, <span class="keyword">sizeof</span>(command) &#125;,</span><br><span class="line">        &#123; &amp;connectInfo, <span class="keyword">sizeof</span>(connectInfo) &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    msghdr message;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;message, <span class="number">0</span>, <span class="keyword">sizeof</span>(message));</span><br><span class="line">    message.msg_iov = iov;</span><br><span class="line">    message.msg_iovlen = ARRAY_SIZE(iov);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        cmsghdr cmh;</span><br><span class="line">        <span class="keyword">char</span> cmsg[CMSG_SPACE(<span class="keyword">sizeof</span>(*socketFd))];</span><br><span class="line">    &#125; cmsgu;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(cmsgu.cmsg, <span class="number">0</span>, <span class="keyword">sizeof</span>(cmsgu.cmsg));</span><br><span class="line">    message.msg_control = cmsgu.cmsg;</span><br><span class="line">    message.msg_controllen = <span class="keyword">sizeof</span>(cmsgu.cmsg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> messageLength = TEMP_FAILURE_RETRY(recvmsg(client-&gt;getSocket(), &amp;message, MSG_CMSG_CLOEXEC));</span><br><span class="line">    <span class="keyword">if</span> (messageLength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!((command.cmdId != FwmarkCommand::ON_CONNECT_COMPLETE &amp;&amp; messageLength == <span class="keyword">sizeof</span>(command))</span><br><span class="line">            || (command.cmdId == FwmarkCommand::ON_CONNECT_COMPLETE</span><br><span class="line">            &amp;&amp; messageLength == <span class="keyword">sizeof</span>(command) + <span class="keyword">sizeof</span>(connectInfo)))) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADMSG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前用户是否有网络访问权限</span></span><br><span class="line">    Permission permission = mNetworkController-&gt;getPermissionForUser(client-&gt;getUid());</span><br><span class="line">    ...</span><br><span class="line">    Fwmark fwmark;</span><br><span class="line">    <span class="keyword">socklen_t</span> fwmarkLen = <span class="keyword">sizeof</span>(fwmark.intValue);</span><br><span class="line">    <span class="comment">// 获取当前socket上的fwmark</span></span><br><span class="line">    <span class="keyword">if</span> (getsockopt(*socketFd, SOL_SOCKET, SO_MARK, &amp;fwmark.intValue, &amp;fwmarkLen) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (command.cmdId) &#123;</span><br><span class="line">        <span class="keyword">case</span> FwmarkCommand::ON_ACCEPT: &#123;</span><br><span class="line">            <span class="comment">// Called after a socket accept(). The kernel would've marked the NetId and necessary</span></span><br><span class="line">            <span class="comment">// permissions bits, so we just add the rest of the user's permissions here.</span></span><br><span class="line">            permission = <span class="keyword">static_cast</span>&lt;Permission&gt;(permission | fwmark.permission);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> FwmarkCommand::ON_CONNECT: &#123;</span><br><span class="line">            <span class="comment">// Called before a socket connect() happens. Set an appropriate NetId into the fwmark so</span></span><br><span class="line">            <span class="comment">// that the socket routes consistently over that network. Do this even if the socket</span></span><br><span class="line">            <span class="comment">// already has a NetId, so that calling connect() multiple times still works.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// But if the explicit bit was set, the existing NetId was explicitly preferred (and not</span></span><br><span class="line">            <span class="comment">// a case of connect() being called multiple times). Don't reset the NetId in that case.</span></span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// 这里explicitlySelected为false, 因此实际会选择默认网络的netId</span></span><br><span class="line">            <span class="keyword">if</span> (!fwmark.explicitlySelected) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fwmark.protectedFromVpn) &#123;</span><br><span class="line">                    fwmark.netId = mNetworkController-&gt;getNetworkForConnect(client-&gt;getUid());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mNetworkController-&gt;isVirtualNetwork(fwmark.netId)) &#123;</span><br><span class="line">                    fwmark.netId = mNetworkController-&gt;getDefaultNetwork();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">    fwmark.permission = permission;</span><br><span class="line">    <span class="comment">// 将该socket打上防火墙的标签, 这个实际就是用来给内核选择路由时用的</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(*socketFd, SOL_SOCKET, SO_MARK, &amp;fwmark.intValue,</span><br><span class="line">                  <span class="keyword">sizeof</span>(fwmark.intValue)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步, 我们大概知道, <code>fwmark</code>实际是一个32位的整型数值, 其中网络的<code>netId</code>占了低16位, 网络权限<code>permission</code>占了2位, 这样系统所有的TCP连接都会被打上<code>fwmark</code>. 那么, 内核的RPDB规则又何时被添加过去的了? 我们再来看看<code>Netd</code>的代码.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">union</span> Fwmark &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> intValue;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> netId          : <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">bool</span> explicitlySelected :  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> protectedFromVpn   :  <span class="number">1</span>;</span><br><span class="line">        Permission permission   :  <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">bool</span> uidBillingDone     :  <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    constexpr Fwmark() : intValue(0) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Android对网络路由相关的管理与控制逻辑都放在<code>/system/netd/server/RouteController.cpp</code>中, 找到对应开始引起问题的那个RP规则, 其优先级为<code>19000</code>, 这正好是<code>RULE_PRIORITY_IMPLICIT_NETWORK</code>这个值.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19000:from all fwmark 0x65/0x1ffff iif lo lookup usb0</span><br></pre></td></tr></table></figure><p>搜索这个关键字, 可以看到Netd会在创建无需任何权限的<code>PhysicalNetwork</code>对象时, 会根据网络的netId时生成一条隐性的策略路由规则<code>modifyImplicitNetworkRule</code>: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">WARN_UNUSED_RESULT <span class="keyword">int</span> RouteController::modifyPhysicalNetwork(<span class="keyword">unsigned</span> netId, <span class="keyword">const</span> <span class="keyword">char</span>* interface,</span><br><span class="line">                                                              Permission permission, <span class="keyword">bool</span> add) &#123;</span><br><span class="line">  <span class="comment">//if network id has register interface, other interface route add to the table with interface registered by netid</span></span><br><span class="line">  ....</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">int</span> ret = modifyIncomingPacketMark(netId, interface, permission, add)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">int</span> ret = modifyExplicitNetworkRule(netId, table, permission, INVALID_UID, INVALID_UID,</span><br><span class="line">                                            add)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">int</span> ret = modifyOutputInterfaceRules(interface, table, permission, INVALID_UID, INVALID_UID,</span><br><span class="line">                                            add)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only set implicit rules for networks that don't require permissions.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is so that if the default network ceases to be the default network and then switches</span></span><br><span class="line">    <span class="comment">// from requiring no permissions to requiring permissions, we ensure that apps only use the</span></span><br><span class="line">    <span class="comment">// network if they explicitly select it. This is consistent with destroySocketsLackingPermission</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (permission == PERMISSION_NONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> modifyImplicitNetworkRule(netId, table, add);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数会设置一个值为默认网络<code>netId</code>的<code>fwmark</code>, 也就是我们最开始看到的那条优先级为<code>19000</code>的规则, 并通过类型为<code>NETLINK_ROUTE</code>的netlink向内核配置该规则, 内核就会根据这条规则来匹配上对应的TCP包, 因而就会出现我们最开始的那个问题:使用TCP连接会提示<code>No Route to Host</code>, 那为何ping不存在这个问题了? </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">WARN_UNUSED_RESULT <span class="keyword">int</span> <span class="title">modifyImplicitNetworkRule</span><span class="params">(<span class="keyword">unsigned</span> netId, <span class="keyword">uint32_t</span> table, <span class="keyword">bool</span> add)</span> </span>&#123;</span><br><span class="line">    Fwmark fwmark;</span><br><span class="line">    Fwmark mask;</span><br><span class="line"></span><br><span class="line">    fwmark.netId = netId;</span><br><span class="line">    mask.netId = FWMARK_NET_ID_MASK;</span><br><span class="line"></span><br><span class="line">    fwmark.explicitlySelected = <span class="literal">false</span>;</span><br><span class="line">    mask.explicitlySelected = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    fwmark.permission = PERMISSION_NONE;</span><br><span class="line">    mask.permission = PERMISSION_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> modifyIpRule(add ? RTM_NEWRULE : RTM_DELRULE, RULE_PRIORITY_IMPLICIT_NETWORK, table,</span><br><span class="line">                        fwmark.intValue, mask.intValue, IIF_LOOPBACK, OIF_NONE, INVALID_UID,</span><br><span class="line">                        INVALID_UID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道ping一般是基于<code>IPPROTO_ICMP</code>协议, 实际发送ping的<code>ECHO_REQUEST</code>时, 只需要创建一个<code>socket</code>接口, 然后直接通过<code>sendto</code>发送对应的数据报文就好了;从刚开始的代码知道, libc会把socket相关的请求转发给Netd, 我们直接看Netd中<code>NetdClient.cpp</code>的建立socket相关的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="keyword">atomic_uint</span> <span class="title">netIdForProcess</span><span class="params">(NETID_UNSET)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netdClientSocket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> socketFd = libcSocket(domain, type, protocol);</span><br><span class="line">    <span class="keyword">if</span> (socketFd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> netId = netIdForProcess;</span><br><span class="line">    <span class="keyword">if</span> (netId != NETID_UNSET &amp;&amp; FwmarkClient::shouldSetFwmark(domain)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">int</span> error = setNetworkForSocket(netId, socketFd)) &#123;</span><br><span class="line">            <span class="keyword">return</span> closeFdAndSetErrno(socketFd, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> socketFd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数首先会调用libc创建socket, ping的时候并没有调用<code>setNetworkForProcess</code>指定网络netId, 因此实际路由时会跳过<code>19000</code>这条规则, 使用的是后面<code>21300</code>这个main路由规则来进行路由选择. 至此问题的谜团也算揭开了.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="http://linux-ip.net/html/routing-tables.html#list-routing-route-types" target="_blank" rel="noopener">http://linux-ip.net/html/routing-tables.html#list-routing-route-types</a></li><li><a href="https://www.man7.org/linux/man-pages/man8/ip-rule.8.html" target="_blank" rel="noopener">https://www.man7.org/linux/man-pages/man8/ip-rule.8.html</a></li><li><a href="https://www.drdobbs.com/policy-routing-in-linux/199100936" target="_blank" rel="noopener">https://www.drdobbs.com/policy-routing-in-linux/199100936</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近新的项目又开始了, 开始还算顺利, 却不料碰到了一个奇怪的问题. 先来了解下问题的背景. 这个项目里, Android中有两个以太网网口, 一个用于内网通讯&lt;eth0&gt;, 不具备上外网的能力;一个用于外网通讯&lt;eth1&gt;, 使用该网口可以访问互联网. 在网络管理模块的工
      
    
    </summary>
    
      <category term="Android" scheme="http://sniffer.site/categories/Android/"/>
    
    
      <category term="Policy Routing" scheme="http://sniffer.site/tags/Policy-Routing/"/>
    
      <category term="策略路由" scheme="http://sniffer.site/tags/%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1/"/>
    
      <category term="网络管理" scheme="http://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    
      <category term="Netd" scheme="http://sniffer.site/tags/Netd/"/>
    
  </entry>
  
  <entry>
    <title>软件开发与BUG的那些事儿</title>
    <link href="http://sniffer.site/2020/05/27/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%8EBUG%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://sniffer.site/2020/05/27/软件开发与BUG的那些事儿/</id>
    <published>2020-05-27T02:12:28.000Z</published>
    <updated>2020-06-04T12:23:51.201Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Excellence in any department can be attained only by the labor of a lifetime; it is not to be purchased at a lesser price</p></blockquote><p>前段时间, 看新闻说<a href="https://www.ithome.com/0/484/241.htm" target="_blank" rel="noopener">“微软4万多的软件开发工程师, 每天产生超过30000个BUG”</a>, 当时感觉有点震惊, 然后就哑然失笑. 震惊的是连微软这样厉害的公司, 工程师应该都很优秀, 人才济济, 为何却会每天产生这么多的BUG了? 于是,再想想自己的开发经历, 才恍然明白: 开发人员一旦走进办公室,打开电脑写代码, 就不可避免的要写出BUG来. 与BUG纠缠不清似乎是每个开发人员的宿命.恰逢最近遇到了一个BUG, 让我纠结不已, 痛定思痛, 觉得有必要把自己的开发”心得经验”写下来, 权当是给自己一点警醒, 给自己一点回顾的资料, 分享下自己在开发过程中遇到的困难与挫折, 苦恼与迷惑.</p><ul><li>对业务理解的越深, 你对可能发生的问题就越透彻；认真思考每个需求/每行代码背后蕴含的业务逻辑, 这对于实现更优秀的方案具有重要的作用. 要对你所负责的业务领域的知识有广泛的把握, 这样也能够帮助你快速深入的进入一个全新的领域.</li><li>对于要提交的每个PR(Pull Request), 在提交前自己先过一遍, 检查格式, 检查拼写, 检查PR的描述是否清晰简单明确, 检查功能实现是否与需求一致, 同时还要问问自己这个修改是否有可以优化改进的地方, 是否存在更好的解决策略? 是否有疏漏的地方? 只有完整的走了必须的checklist, 才真正加上代码reviewer.</li><li>在每次实现方案, 提交代码时, 首先要摒弃的是”这个实现很完美, 我敢打包票, 毫无疑问没有问题了”类似这种自信爆棚的观念, 首先要正视可能存在的缺陷, 正视自己当前对于问题的认知可能还有不完善的地方, 把可能存在漏洞的地方在代码实现处comment出来, 这样后面再来看代码时可能会有更好的思路.</li><li>产生的任何BUG都要保持警惕, 而不是防御心态: 总觉得这个BUG不是我的责任, 不会是我代码实现产生的问题, 当别人指出来你的错误时, 不是保持开放的思考, 而是一味的浪费时间与人纠缠争吵, 不敢承认自己思维上存在的问题; 一旦确认了BUG, 就要坦然面对, 而不是藏着掩着;诚实的面对自己犯下的错误, 总结经验教训, 这不仅能让你赢得同事的认可与信任, 也能让领导对你放心.</li><li>不时的想一想你的客户是谁? 你的客户不仅是产品的使用者, 也是你的上司, 你的同事, 你要确保你的每个产出物都具备高质量, 能让使用者感到舒服, 感到可信赖.要对自己所做的每件事情都负责, 对上司交代的任务要反馈; 对同事的问题要多关心;对产品的质量要严格的把控.</li><li>不满足于已有的知识, 不停的学习新的技能, 反复总结打磨自己的知识系统, 长此以往, 你的能力与视野就会得到质的改变；学习的同时, 也要不断的总结, 将所学所思分享给身边的同事, 保持影响力</li><li>软件从业人员经常被工作进度压得传不过气来, 时间紧张, 以至于忽略了锻炼身体. 想要平时尽量产生BUG, 保持良好的生活习惯, 必不可少. 这么看起来, 写好代码, 少产生BUG, 不仅仅是一个逻辑问题, 更是一个程序员自我修养与提高的问题</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;Excellence in any department can be attained only by the labor of a lifetime; it is not to be purch
      
    
    </summary>
    
      <category term="软件工程" scheme="http://sniffer.site/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件开发" scheme="http://sniffer.site/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="BUG" scheme="http://sniffer.site/tags/BUG/"/>
    
      <category term="软件工程" scheme="http://sniffer.site/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="项目管理" scheme="http://sniffer.site/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>从NAPI说一说Linux内核数据的接收流程</title>
    <link href="http://sniffer.site/2020/05/12/%E4%BB%8ENAPI%E8%AF%B4%E4%B8%80%E8%AF%B4Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/"/>
    <id>http://sniffer.site/2020/05/12/从NAPI说一说Linux内核数据的接收流程/</id>
    <published>2020-05-12T10:01:22.000Z</published>
    <updated>2020-05-14T07:39:13.089Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/New_API" target="_blank" rel="noopener">NAPI(New API)</a>是Linux内核针对网络数据传输做出的一个优化措施，其目的是在大量数据传输时， 在收到硬件中断后，通过poll方式将传输过来的数据包统一处理， 通过禁止网络设备中断以减少硬件中断数量((Interrupt Mitigation)，从而实现更高的数据传输。</p><p>基于NAPI接口， 一般的网络传输都有如下几个步骤：</p><ul><li>网络设备驱动加载与初始化（配置IP等）</li><li>数据包从网络侧发送到网卡(Network Interface Controller, NIC)</li><li>通过<a href="https://en.wikipedia.org/wiki/Direct_memory_access" target="_blank" rel="noopener">DMA(Direct Memory Access)</a>，将数据从网卡拷贝到内存的环形缓冲区(ring buffer)</li><li>NIC产生硬件中断告知内核有新的数据包达到了</li><li>网卡驱动收到中断后调用NAPI接口开启poll线程（如果当前没有正在执行的线程）(常规数据传输直接处理NIC的中断时中间一般通过调用<code>netif_rx</code>来发起数据接收）</li><li><code>ksoftirqd</code>（内核启动时每个CPU上都会启动这样一个线程）线程负责调用NAPI的<code>poll</code>接口来获取内存环形缓冲区的数据包</li><li>通过DMA传输到内存中的数据包，最终通过<code>sk_buff</code>的形式传递给上层网络协议栈（TCP/IP层)</li><li>如果支持数据包转发(packet steering)或者NIC本身支持多个接收队列的话, 从网卡过来的数据会在不同的CPU之间进行分发</li><li>网络协议栈处理数据包，并将其发送到对应的<code>socket</code>接收缓冲区</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/network_recieving_process.png" alt="网络数据接收流程"></p><p>下面就结合具体的代码来看看数据是如何一步步接收的（以intel的千兆以太网卡为例<code>kernel/drivers/net/intel/e1000</code>）。</p><h2 id="驱动加载与设备初始化"><a href="#驱动加载与设备初始化" class="headerlink" title="驱动加载与设备初始化"></a><strong>驱动加载与设备初始化</strong></h2><p>看<code>e1000_main.c</code>代码，驱动的初始化首先要做的是注册一个<code>pci</code>设备驱动到内核，这样设备枚举的时候会匹配到该网卡</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">e1000_init_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">pr_info(<span class="string">"%s - version %s\n"</span>, e1000_driver_string, e1000_driver_version);</span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">"%s\n"</span>, e1000_copyright);</span><br><span class="line"></span><br><span class="line">ret = pci_register_driver(&amp;e1000_driver);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(e1000_init_module);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">e1000_driver</span> = &#123;</span></span><br><span class="line">.name     = e1000_driver_name,</span><br><span class="line">.id_table = e1000_pci_tbl,</span><br><span class="line">.probe    = e1000_probe,</span><br><span class="line">.remove   = e1000_remove,</span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line"><span class="comment">/* Power Management Hooks */</span></span><br><span class="line">.suspend  = e1000_suspend,</span><br><span class="line">.resume   = e1000_resume,</span><br><span class="line">#endif</span><br><span class="line">.shutdown = e1000_shutdown,</span><br><span class="line">.err_handler = &amp;e1000_err_handler</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>匹配到网卡后， pci总线会调用驱动的<code>probe</code>函数， 大致会做如下几个事情：</p><ul><li>调用<code>alloc_etherdev</code> 分配一个网络设备对象，并注册到系统中</li><li>通过<code>netif_napi_add</code>添加NAPI的poll接口</li><li>设置网卡寄存器IO映射内存区域</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">e1000_probe</span><span class="params">(struct pci_dev *pdev, <span class="keyword">const</span> struct pci_device_id *ent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ....</span><br><span class="line">err = pci_request_selected_regions(pdev, bars, e1000_driver_name);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> err_pci_reg;</span><br><span class="line"></span><br><span class="line">pci_set_master(pdev);</span><br><span class="line">err = pci_save_state(pdev);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> err_alloc_etherdev;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="comment">// 分配以太网网络对象</span></span><br><span class="line">netdev = alloc_etherdev(<span class="keyword">sizeof</span>(struct e1000_adapter));</span><br><span class="line"><span class="keyword">if</span> (!netdev)</span><br><span class="line"><span class="keyword">goto</span> err_alloc_etherdev;</span><br><span class="line"></span><br><span class="line">SET_NETDEV_DEV(netdev, &amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">pci_set_drvdata(pdev, netdev);</span><br><span class="line">adapter = netdev_priv(netdev);</span><br><span class="line">adapter-&gt;netdev = netdev;</span><br><span class="line">adapter-&gt;pdev = pdev;</span><br><span class="line">adapter-&gt;msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);</span><br><span class="line">adapter-&gt;bars = bars;</span><br><span class="line">adapter-&gt;need_ioport = need_ioport;</span><br><span class="line"></span><br><span class="line">hw = &amp;adapter-&gt;hw;</span><br><span class="line">hw-&gt;back = adapter;</span><br><span class="line"></span><br><span class="line">err = -EIO;</span><br><span class="line"><span class="comment">// 映射寄存器IO区域</span></span><br><span class="line">hw-&gt;hw_addr = pci_ioremap_bar(pdev, BAR_0);</span><br><span class="line"><span class="keyword">if</span> (!hw-&gt;hw_addr)</span><br><span class="line"><span class="keyword">goto</span> err_ioremap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (adapter-&gt;need_ioport) &#123;</span><br><span class="line"><span class="keyword">for</span> (i = BAR_1; i &lt;= BAR_5; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (pci_resource_len(pdev, i) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (pci_resource_flags(pdev, i) &amp; IORESOURCE_IO) &#123;</span><br><span class="line">hw-&gt;io_base = pci_resource_start(pdev, i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* make ready for any if (hw-&gt;...) below */</span></span><br><span class="line">err = e1000_init_hw_struct(adapter, hw);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> err_sw_init;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 设置网络设备对象的操作接口</span></span><br><span class="line">netdev-&gt;netdev_ops = &amp;e1000_netdev_ops;</span><br><span class="line">e1000_set_ethtool_ops(netdev);</span><br><span class="line">netdev-&gt;watchdog_timeo = <span class="number">5</span> * HZ;</span><br><span class="line"><span class="comment">// 添加napi的poll接口</span></span><br><span class="line">netif_napi_add(netdev, &amp;adapter-&gt;napi, e1000_clean, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(netdev-&gt;name, pci_name(pdev), <span class="keyword">sizeof</span>(netdev-&gt;name) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">adapter-&gt;bd_number = cards_found;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* setup the private structure */</span></span><br><span class="line"></span><br><span class="line">err = e1000_sw_init(adapter);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> err_sw_init;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!is_valid_ether_addr(netdev-&gt;dev_addr))</span><br><span class="line">e_err(probe, <span class="string">"Invalid MAC Address\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INIT_DELAYED_WORK(&amp;adapter-&gt;watchdog_task, e1000_watchdog);</span><br><span class="line">INIT_DELAYED_WORK(&amp;adapter-&gt;fifo_stall_task,</span><br><span class="line">  e1000_82547_tx_fifo_stall_task);</span><br><span class="line">INIT_DELAYED_WORK(&amp;adapter-&gt;phy_info_task, e1000_update_phy_info_task);</span><br><span class="line">INIT_WORK(&amp;adapter-&gt;reset_task, e1000_reset_task);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize the wol settings based on the eeprom settings */</span></span><br><span class="line">adapter-&gt;wol = adapter-&gt;eeprom_wol;</span><br><span class="line">device_set_wakeup_enable(&amp;adapter-&gt;pdev-&gt;dev, adapter-&gt;wol);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Auto detect PHY address */</span></span><br><span class="line"><span class="keyword">if</span> (hw-&gt;mac_type == e1000_ce4100) &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">hw-&gt;phy_addr = i;</span><br><span class="line">e1000_read_phy_reg(hw, PHY_ID2, &amp;tmp);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="number">0</span> || tmp == <span class="number">0xFF</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">31</span>)</span><br><span class="line"><span class="keyword">goto</span> err_eeprom;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* reset the hardware with the new settings */</span></span><br><span class="line">e1000_reset(adapter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置网卡名字，注册网络设备对象</span></span><br><span class="line"><span class="built_in">strcpy</span>(netdev-&gt;name, <span class="string">"eth%d"</span>);</span><br><span class="line">err = register_netdev(netdev);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> err_register;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* carrier off reporting is important to ethtool even BEFORE open */</span></span><br><span class="line">netif_carrier_off(netdev);</span><br><span class="line"></span><br><span class="line">e_info(probe, <span class="string">"Intel(R) PRO/1000 Network Connection\n"</span>);</span><br><span class="line"></span><br><span class="line">cards_found++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步网卡还不是可用状态，需要通过手动<code>ifconfig eth0 up/ifconfig eth0 &lt;ip&gt;</code>， 设置网卡为<code>UP</code>时，会调用驱动的<code>ndo_open</code>函数：</p><ul><li>请求硬件中断，并使能该中断</li><li><code>napi_enable</code>开启napi</li><li>启动网络的发送队列，允许发送数据</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">e1000_open</span><span class="params">(struct net_device *netdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_adapter</span> *<span class="title">adapter</span> = <span class="title">netdev_priv</span>(<span class="title">netdev</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_hw</span> *<span class="title">hw</span> = &amp;<span class="title">adapter</span>-&gt;<span class="title">hw</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">netif_carrier_off(netdev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocate transmit descriptors */</span></span><br><span class="line">err = e1000_setup_all_tx_resources(adapter);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocate receive descriptors */</span></span><br><span class="line">err = e1000_setup_all_rx_resources(adapter);</span><br><span class="line"></span><br><span class="line">e1000_power_up_phy(adapter);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">err = e1000_request_irq(adapter);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* From here on the code is the same as e1000_up() */</span></span><br><span class="line">clear_bit(__E1000_DOWN, &amp;adapter-&gt;flags);</span><br><span class="line"></span><br><span class="line">napi_enable(&amp;adapter-&gt;napi);</span><br><span class="line"></span><br><span class="line">e1000_irq_enable(adapter);</span><br><span class="line"></span><br><span class="line">netif_start_queue(netdev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fire a link status change interrupt to start the watchdog */</span></span><br><span class="line">ew32(ICS, E1000_ICS_LSC);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> E1000_SUCCESS;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此时网卡正常工作， 再来看看数据接收的具体流程。</p><h2 id="网卡数据接收"><a href="#网卡数据接收" class="headerlink" title="网卡数据接收"></a><strong>网卡数据接收</strong></h2><p>网卡数据的接收大概有三个步骤：</p><ul><li>网卡发送中断给驱动</li><li>驱动处理函数处理中断，并启动一个<code>napi</code>处理任务</li><li>发送接收数据的软中断<code>NET_RX_SOFTIRQ</code></li><li>内核线程处理网络软中断，将数据包发送给上层协议栈</li></ul><h3 id="处理网卡中断"><a href="#处理网卡中断" class="headerlink" title="处理网卡中断"></a><strong>处理网卡中断</strong></h3><p>在网卡驱动初始化的过程，我们看到驱动会向内核请求中断, 并注册一个中断处理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">e1000_request_irq</span><span class="params">(struct e1000_adapter *adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span> = <span class="title">adapter</span>-&gt;<span class="title">netdev</span>;</span></span><br><span class="line"><span class="keyword">irq_handler_t</span> handler = e1000_intr;</span><br><span class="line"><span class="keyword">int</span> irq_flags = IRQF_SHARED;</span><br><span class="line"></span><br><span class="line">err = request_irq(adapter-&gt;pdev-&gt;irq, handler, irq_flags, netdev-&gt;name,</span><br><span class="line">          netdev);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当网卡产生数据中断后，调用中断处理函数： 对于napi来说，首先要禁止当前网卡的中断，如果当前没有在运行的napi任务，则调度一个新的napi任务<code>__napi_schedule</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> irqreturn_t <span class="title">e1000_intr</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* disable interrupts, without the synchronize_irq bit */</span></span><br><span class="line">ew32(IMC, ~<span class="number">0</span>);</span><br><span class="line">E1000_WRITE_FLUSH();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(napi_schedule_prep(&amp;adapter-&gt;napi))) &#123;</span><br><span class="line">adapter-&gt;total_tx_bytes = <span class="number">0</span>;</span><br><span class="line">adapter-&gt;total_tx_packets = <span class="number">0</span>;</span><br><span class="line">adapter-&gt;total_rx_bytes = <span class="number">0</span>;</span><br><span class="line">adapter-&gt;total_rx_packets = <span class="number">0</span>;</span><br><span class="line">__napi_schedule(&amp;adapter-&gt;napi);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* this really should not happen! if it does it is basically a</span></span><br><span class="line"><span class="comment"> * bug, but not a hard error, so enable ints and continue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;flags))</span><br><span class="line">e1000_irq_enable(adapter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动napi任务，发送软中断"><a href="#启动napi任务，发送软中断" class="headerlink" title="启动napi任务，发送软中断"></a><strong>启动napi任务，发送软中断</strong></h3><p><code>__napi_schedule</code>在<code>/kernel/net/core/dev.c</code>中，其实际做了两件事：</p><ul><li>将<code>napi_struct</code>添加到中断处理CPU的<code>softnet_data</code>对应的poll列表中</li><li>发出一个<code>NET_RX_SOFTIRQ</code>的软中断，让内核线程<code>ksoftirqd</code>来处理对应的该<code>softirq</code>软中断</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> __napi_schedule(struct napi_struct *n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">local_irq_save(flags);</span><br><span class="line">____napi_schedule(this_cpu_ptr(&amp;softnet_data), n);</span><br><span class="line">local_irq_restore(flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> ____napi_schedule(struct softnet_data *sd,</span><br><span class="line">     struct napi_struct *napi)</span><br><span class="line">&#123;</span><br><span class="line">list_add_tail(&amp;napi-&gt;poll_list, &amp;sd-&gt;poll_list);</span><br><span class="line">__raise_softirq_irqoff(NET_RX_SOFTIRQ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__raise_softirq_irqoff</code>函数在<code>/kernel/softirq.c</code>中定义，其实际做的事情就是将当前CPU对应的<code>softirq</code>状态标记为待运行状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> __raise_softirq_irqoff(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span><br><span class="line">&#123;</span><br><span class="line">trace_softirq_raise(nr);</span><br><span class="line">or_softirq_pending(<span class="number">1U</span>L &lt;&lt; nr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理网络软中断"><a href="#处理网络软中断" class="headerlink" title="处理网络软中断"></a><strong>处理网络软中断</strong></h3><p>内核在初始化的时候，每个CPU上都会启动一个专门的<code>ksoftirqd%d</code>（<code>%d</code>对应CPU的ID）内核线程用于处理CPU上的软中断（代码同样在<code>softirq.c</code>)中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">smp_hotplug_thread</span> <span class="title">softirq_threads</span> = &#123;</span></span><br><span class="line">.store= &amp;ksoftirqd,</span><br><span class="line">.thread_should_run= ksoftirqd_should_run,</span><br><span class="line">.thread_fn= run_ksoftirqd,</span><br><span class="line">.thread_comm= <span class="string">"ksoftirqd/%u"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">init <span class="keyword">int</span> <span class="title">spawn_ksoftirqd</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">register_cpu_notifier(&amp;cpu_nfb);</span><br><span class="line"></span><br><span class="line">BUG_ON(smpboot_register_percpu_thread(&amp;softirq_threads));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">early_initcall(spawn_ksoftirqd);</span><br></pre></td></tr></table></figure><p>每个内核线程<code>ksoftirqd</code>实际一直执行的是<code>run_ksoftirqd</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run_ksoftirqd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">local_irq_disable();</span><br><span class="line"><span class="keyword">if</span> (local_softirq_pending()) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We can safely run softirq on inline stack, as we are not deep</span></span><br><span class="line"><span class="comment"> * in the task stack here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__do_softirq();</span><br><span class="line">local_irq_enable();</span><br><span class="line">cond_resched_rcu_qs();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">local_irq_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>__do_softirq</code>检查当前CPU所有待处理的软中断，并调用对应的处理函数<code>softirq_action</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">asmlinkage __visible <span class="keyword">void</span> __softirq_entry __do_softirq(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> ((softirq_bit = ffs(pending))) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vec_nr;</span><br><span class="line"><span class="keyword">int</span> prev_count;</span><br><span class="line"></span><br><span class="line">h += softirq_bit - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">vec_nr = h - softirq_vec;</span><br><span class="line">...</span><br><span class="line">h-&gt;action(h);</span><br><span class="line">...</span><br><span class="line">h++;</span><br><span class="line">pending &gt;&gt;= softirq_bit;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>softirq_action</code>实际是在网络模块初始化的时候注册的(查看<code>/kernel/net/dev.c</code>)中的函数<code>net_dev_init</code>，通过调用<code>open_softirq</code>告知内核启动网络数据传输的两个软中断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">net_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (register_pernet_subsys(&amp;netdev_net_ops))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Initialise the packet receive queues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">for_each_possible_cpu(i) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> = &amp;<span class="title">per_cpu</span>(<span class="title">softnet_data</span>, <span class="title">i</span>);</span></span><br><span class="line"></span><br><span class="line">skb_queue_head_init(&amp;sd-&gt;input_pkt_queue);</span><br><span class="line">skb_queue_head_init(&amp;sd-&gt;process_queue);</span><br><span class="line">INIT_LIST_HEAD(&amp;sd-&gt;poll_list);</span><br><span class="line">sd-&gt;output_queue_tailp = &amp;sd-&gt;output_queue;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RPS</span></span><br><span class="line">sd-&gt;csd.func = rps_trigger_softirq;</span><br><span class="line">sd-&gt;csd.info = sd;</span><br><span class="line">sd-&gt;cpu = i;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">sd-&gt;backlog.poll = process_backlog;</span><br><span class="line">sd-&gt;backlog.weight = weight_p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">open_softirq(NET_TX_SOFTIRQ, net_tx_action);</span><br><span class="line">open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span><br><span class="line"></span><br><span class="line">hotcpu_notifier(dev_cpu_callback, <span class="number">0</span>);</span><br><span class="line">dst_subsys_init();</span><br><span class="line">rc = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就说<code>h-&gt;action</code> 调用的实际是<code>net_rx_action</code>函数： 不断的调用<code>napi_poll</code>获取CPU上的数据包，直到到达单个CPU处理的上限或者所有需要poll的列表完成处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">net_rx_action</span><span class="params">(struct softirq_action *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span> *<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;<span class="built_in">list</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!sd_has_rps_ipi_waiting(sd) &amp;&amp; list_empty(&amp;repoll))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n = list_first_entry(&amp;<span class="built_in">list</span>, struct napi_struct, poll_list);</span><br><span class="line">budget -= napi_poll(n, &amp;repoll);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If softirq window is exhausted then punt.</span></span><br><span class="line"><span class="comment"> * Allow this to run for 2 jiffies since which will allow</span></span><br><span class="line"><span class="comment"> * an average latency of 1.5/HZ.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(budget &lt;= <span class="number">0</span> ||</span><br><span class="line">     time_after_eq(jiffies, time_limit))) &#123;</span><br><span class="line">sd-&gt;time_squeeze++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">local_irq_disable();</span><br><span class="line"></span><br><span class="line">list_splice_tail_init(&amp;sd-&gt;poll_list, &amp;<span class="built_in">list</span>);</span><br><span class="line">list_splice_tail(&amp;repoll, &amp;<span class="built_in">list</span>);</span><br><span class="line">list_splice(&amp;<span class="built_in">list</span>, &amp;sd-&gt;poll_list);</span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;sd-&gt;poll_list))</span><br><span class="line">__raise_softirq_irqoff(NET_RX_SOFTIRQ);</span><br><span class="line"></span><br><span class="line">net_rps_action_and_irq_enable(sd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>napi_poll</code>则调用最初网卡驱动注册的poll函数<code>e1000_clean</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">napi_poll</span><span class="params">(struct napi_struct *n, struct list_head *repoll)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *have;</span><br><span class="line"><span class="keyword">int</span> work, weight;</span><br><span class="line"></span><br><span class="line">list_del_init(&amp;n-&gt;poll_list);</span><br><span class="line"></span><br><span class="line">have = netpoll_poll_lock(n);</span><br><span class="line"></span><br><span class="line">weight = n-&gt;weight;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This NAPI_STATE_SCHED test is for avoiding a race</span></span><br><span class="line"><span class="comment"> * with netpoll's poll_napi().  Only the entity which</span></span><br><span class="line"><span class="comment"> * obtains the lock and sees NAPI_STATE_SCHED set will</span></span><br><span class="line"><span class="comment"> * actually make the -&gt;poll() call.  Therefore we avoid</span></span><br><span class="line"><span class="comment"> * accidentally calling -&gt;poll() when NAPI is not scheduled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">work = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (test_bit(NAPI_STATE_SCHED, &amp;n-&gt;state)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> = <span class="title">this_cpu_ptr</span>(&amp;<span class="title">softnet_data</span>);</span></span><br><span class="line"></span><br><span class="line">sd-&gt;current_napi = n;</span><br><span class="line">work = n-&gt;poll(n, weight);</span><br><span class="line">trace_napi_poll(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> work;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>e1000_clean</code>会将当前CPU中接收到的数据包放到<code>skb_buff</code>列表当中，并将数据发送给上层协议栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">e1000_clean</span><span class="params">(struct napi_struct *napi, <span class="keyword">int</span> budget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_adapter</span> *<span class="title">adapter</span> = <span class="title">container_of</span>(<span class="title">napi</span>, <span class="title">struct</span> <span class="title">e1000_adapter</span>,</span></span><br><span class="line"><span class="class">     <span class="title">napi</span>);</span></span><br><span class="line"><span class="keyword">int</span> tx_clean_complete = <span class="number">0</span>, work_done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">tx_clean_complete = e1000_clean_tx_irq(adapter, &amp;adapter-&gt;tx_ring[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">adapter-&gt;clean_rx(adapter, &amp;adapter-&gt;rx_ring[<span class="number">0</span>], &amp;work_done, budget);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!tx_clean_complete)</span><br><span class="line">work_done = budget;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If budget not fully consumed, exit the polling mode */</span></span><br><span class="line"><span class="keyword">if</span> (work_done &lt; budget) &#123;</span><br><span class="line"><span class="keyword">if</span> (likely(adapter-&gt;itr_setting &amp; <span class="number">3</span>))</span><br><span class="line">e1000_set_itr(adapter);</span><br><span class="line">napi_complete_done(napi, work_done);</span><br><span class="line"><span class="keyword">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;flags))</span><br><span class="line">e1000_irq_enable(adapter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> work_done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将skb-buff-发送给协议栈"><a href="#将skb-buff-发送给协议栈" class="headerlink" title="将skb_buff 发送给协议栈"></a><strong>将<code>skb_buff</code> 发送给协议栈</strong></h3><p><code>e1000_clean_rx_irq</code>不断的从网卡对应的内存环形缓冲区中获取网络数据包，并将数据包以<code>sk_buff</code>的形式传给协议栈进行处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">e1000_clean_rx_irq</span><span class="params">(struct e1000_adapter *adapter,</span></span></span><br><span class="line"><span class="function"><span class="params">       struct e1000_rx_ring *rx_ring,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">int</span> *work_done, <span class="keyword">int</span> work_to_do)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span> = <span class="title">adapter</span>-&gt;<span class="title">netdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_dev</span> *<span class="title">pdev</span> = <span class="title">adapter</span>-&gt;<span class="title">pdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_rx_desc</span> *<span class="title">rx_desc</span>, *<span class="title">next_rxd</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_rx_buffer</span> *<span class="title">buffer_info</span>, *<span class="title">next_buffer</span>;</span></span><br><span class="line">u32 length;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> cleaned_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> cleaned = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> total_rx_bytes=<span class="number">0</span>, total_rx_packets=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">i = rx_ring-&gt;next_to_clean;</span><br><span class="line">rx_desc = E1000_RX_DESC(*rx_ring, i);</span><br><span class="line">buffer_info = &amp;rx_ring-&gt;buffer_info[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (rx_desc-&gt;status &amp; E1000_RXD_STAT_DD) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">u8 *data;</span><br><span class="line">u8 status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*work_done &gt;= work_to_do)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">(*work_done)++;</span><br><span class="line">dma_rmb(); <span class="comment">/* read descriptor and rx_buffer_info after status DD */</span></span><br><span class="line"></span><br><span class="line">status = rx_desc-&gt;status;</span><br><span class="line">length = le16_to_cpu(rx_desc-&gt;length);</span><br><span class="line"></span><br><span class="line">data = buffer_info-&gt;rxbuf.data;</span><br><span class="line">prefetch(data);</span><br><span class="line">skb = e1000_copybreak(adapter, buffer_info, length, data);</span><br><span class="line"><span class="keyword">if</span> (!skb) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> frag_len = e1000_frag_len(adapter);</span><br><span class="line"></span><br><span class="line">skb = build_skb(data - E1000_HEADROOM, frag_len);</span><br><span class="line"><span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">adapter-&gt;alloc_rx_buff_failed++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skb_reserve(skb, E1000_HEADROOM);</span><br><span class="line">dma_unmap_single(&amp;pdev-&gt;dev, buffer_info-&gt;dma,</span><br><span class="line"> adapter-&gt;rx_buffer_len,</span><br><span class="line"> DMA_FROM_DEVICE);</span><br><span class="line">buffer_info-&gt;dma = <span class="number">0</span>;</span><br><span class="line">buffer_info-&gt;rxbuf.data = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (++i == rx_ring-&gt;count) i = <span class="number">0</span>;</span><br><span class="line">next_rxd = E1000_RX_DESC(*rx_ring, i);</span><br><span class="line">prefetch(next_rxd);</span><br><span class="line"></span><br><span class="line">next_buffer = &amp;rx_ring-&gt;buffer_info[i];</span><br><span class="line"></span><br><span class="line">cleaned = <span class="literal">true</span>;</span><br><span class="line">cleaned_count++;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* !EOP means multiple descriptors were used to store a single</span></span><br><span class="line"><span class="comment"> * packet, if thats the case we need to toss it.  In fact, we</span></span><br><span class="line"><span class="comment"> * to toss every packet with the EOP bit clear and the next</span></span><br><span class="line"><span class="comment"> * frame that _does_ have the EOP bit set, as it is by</span></span><br><span class="line"><span class="comment"> * definition only a frame fragment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!(status &amp; E1000_RXD_STAT_EOP)))</span><br><span class="line">adapter-&gt;discarding = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (adapter-&gt;discarding) &#123;</span><br><span class="line"><span class="comment">/* All receives must fit into a single buffer */</span></span><br><span class="line">netdev_dbg(netdev, <span class="string">"Receive packet consumed multiple buffers\n"</span>);</span><br><span class="line">dev_kfree_skb(skb);</span><br><span class="line"><span class="keyword">if</span> (status &amp; E1000_RXD_STAT_EOP)</span><br><span class="line">adapter-&gt;discarding = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">goto</span> next_desc;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">process_skb:</span><br><span class="line">total_rx_bytes += (length - <span class="number">4</span>); <span class="comment">/* don't count FCS */</span></span><br><span class="line">total_rx_packets++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(!(netdev-&gt;features &amp; NETIF_F_RXFCS)))</span><br><span class="line"><span class="comment">/* adjust length to remove Ethernet CRC, this must be</span></span><br><span class="line"><span class="comment"> * done after the TBI_ACCEPT workaround above</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">length -= <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buffer_info-&gt;rxbuf.data == <span class="literal">NULL</span>)</span><br><span class="line">skb_put(skb, length);</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* copybreak skb */</span></span><br><span class="line">skb_trim(skb, length);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Receive Checksum Offload */</span></span><br><span class="line">e1000_rx_checksum(adapter,</span><br><span class="line">  (u32)(status) |</span><br><span class="line">  ((u32)(rx_desc-&gt;errors) &lt;&lt; <span class="number">24</span>),</span><br><span class="line">  le16_to_cpu(rx_desc-&gt;csum), skb);</span><br><span class="line"></span><br><span class="line">e1000_receive_skb(adapter, status, rx_desc-&gt;special, skb);</span><br><span class="line"></span><br><span class="line">next_desc:</span><br><span class="line">rx_desc-&gt;status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* return some buffers to hardware, one at a time is too slow */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(cleaned_count &gt;= E1000_RX_BUFFER_WRITE)) &#123;</span><br><span class="line">adapter-&gt;alloc_rx_buf(adapter, rx_ring, cleaned_count);</span><br><span class="line">cleaned_count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* use prefetched values */</span></span><br><span class="line">rx_desc = next_rxd;</span><br><span class="line">buffer_info = next_buffer;</span><br><span class="line">&#125;</span><br><span class="line">rx_ring-&gt;next_to_clean = i;</span><br><span class="line"></span><br><span class="line">cleaned_count = E1000_DESC_UNUSED(rx_ring);</span><br><span class="line"><span class="keyword">if</span> (cleaned_count)</span><br><span class="line">adapter-&gt;alloc_rx_buf(adapter, rx_ring, cleaned_count);</span><br><span class="line"></span><br><span class="line">adapter-&gt;total_rx_packets += total_rx_packets;</span><br><span class="line">adapter-&gt;total_rx_bytes += total_rx_bytes;</span><br><span class="line">netdev-&gt;stats.rx_bytes += total_rx_bytes;</span><br><span class="line">netdev-&gt;stats.rx_packets += total_rx_packets;</span><br><span class="line"><span class="keyword">return</span> cleaned;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>e1000_receive_skb</code>实际调用<code>napi_gro_receive</code>将数据发送出去：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">e1000_receive_skb</span><span class="params">(struct e1000_adapter *adapter, u8 status,</span></span></span><br><span class="line"><span class="function"><span class="params">      __le16 vlan, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">skb-&gt;protocol = eth_type_trans(skb, adapter-&gt;netdev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status &amp; E1000_RXD_STAT_VP) &#123;</span><br><span class="line">u16 vid = le16_to_cpu(vlan) &amp; E1000_RXD_SPC_VLAN_MASK;</span><br><span class="line"></span><br><span class="line">__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);</span><br><span class="line">&#125;</span><br><span class="line">napi_gro_receive(&amp;adapter-&gt;napi, skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>napi_gro_receive</code>首先会尝试通过<code>GRO</code>（<code>Generic Receive Offload</code>)的方式将数据发送出去，如果网卡本身不支持<code>GRO</code>则会直接将数据报传送给上层协议栈（简单来说GRO就是将数据包累积到一定数量后再传给上层，这样一次性的处理多个数据包从而提升效率，可以参考<a href="https://lwn.net/Articles/358910/)：" target="_blank" rel="noopener">https://lwn.net/Articles/358910/)：</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// kernel/net/dev.c</span></span><br><span class="line"><span class="keyword">gro_result_t</span> napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">trace_napi_gro_receive_entry(skb);</span><br><span class="line"></span><br><span class="line">skb_gro_reset_offset(skb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> napi_skb_finish(dev_gro_receive(napi, skb), skb);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(napi_gro_receive);</span><br></pre></td></tr></table></figure><p>Intel这个网卡没有开启<code>GRO</code>，所以实际<code>dev_gro_receive</code>直接返回了<code>GRO_NORMAL</code>，这样就通过<code>netif_receive_skb_internal</code>处理数据包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> gro_result_t <span class="title">napi_skb_finish</span><span class="params">(<span class="keyword">gro_result_t</span> ret, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> GRO_NORMAL:</span><br><span class="line"><span class="keyword">if</span> (netif_receive_skb_internal(skb))</span><br><span class="line">ret = GRO_DROP;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> GRO_DROP:</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> GRO_MERGED_FREE:</span><br><span class="line"><span class="keyword">if</span> (NAPI_GRO_CB(skb)-&gt;<span class="built_in">free</span> == NAPI_GRO_FREE_STOLEN_HEAD)</span><br><span class="line">napi_skb_free_stolen_head(skb);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__kfree_skb(skb);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> GRO_HELD:</span><br><span class="line"><span class="keyword">case</span> GRO_MERGED:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于多核系统来说，一般数据传输处理的CPU跟中断处理的CPU是一致的，后来随着网卡速度的提升，如果把网卡的数据都放到一个CPU处理的话，会导致CPU负载过大进而导致数据传输的延迟，因此有人提出了RPS(<a href="https://lwn.net/Articles/362339/" target="_blank" rel="noopener">Receive packet steering</a>, 就是将数据包的处理任务均衡的分配到各个CPU；要支持该特性，需要打开配置<code>CONFIG_RPS</code>， 同时在内核的配置中<code>/sys/class/net/ethx/queues/rx-0/rps_cpus</code>中将需要处理数据包的CPU设置为<code>1</code>， 这样在处理数据的时候就会将数据包先放到各个CPU的数据队列中进行处理。</p><p>这里假定该网卡没有配置RPS，接着会调用<code>__netif_receive_skb</code>处理网络数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">netif_receive_skb_internal</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">net_timestamp_check(netdev_tstamp_prequeue, skb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skb_defer_rx_timestamp(skb))</span><br><span class="line"><span class="keyword">return</span> NET_RX_SUCCESS;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RPS</span></span><br><span class="line"><span class="keyword">if</span> (static_key_false(&amp;rps_needed)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rps_dev_flow</span> <span class="title">voidflow</span>, *<span class="title">rflow</span> = &amp;<span class="title">voidflow</span>;</span></span><br><span class="line"><span class="keyword">int</span> cpu = get_rps_cpu(skb-&gt;dev, skb, &amp;rflow);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cpu &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">ret = enqueue_to_backlog(skb, cpu, &amp;rflow-&gt;last_qtail);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">ret = __netif_receive_skb(skb);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__netif_receive_skb</code>实际调用<code>__netif_receive_skb_core</code>处理数据：<code>__netif_receive_skb_core</code>调用内核初始化时注册的协议类型，并调用其回调函数，由相应的协议来处理该数据包</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __netif_receive_skb(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sk_memalloc_socks() &amp;&amp; skb_pfmemalloc(skb)) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pflags = current-&gt;flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PFMEMALLOC skbs are special, they should</span></span><br><span class="line"><span class="comment"> * - be delivered to SOCK_MEMALLOC sockets only</span></span><br><span class="line"><span class="comment"> * - stay away from userspace</span></span><br><span class="line"><span class="comment"> * - have bounded memory usage</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use PF_MEMALLOC as this saves us from propagating the allocation</span></span><br><span class="line"><span class="comment"> * context down to all allocation sites.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">current-&gt;flags |= PF_MEMALLOC;</span><br><span class="line">ret = __netif_receive_skb_core(skb, <span class="literal">true</span>);</span><br><span class="line">tsk_restore_flags(current, pflags, PF_MEMALLOC);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">ret = __netif_receive_skb_core(skb, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __netif_receive_skb_core(struct sk_buff *skb, <span class="keyword">bool</span> pfmemalloc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> *<span class="title">ptype</span>, *<span class="title">pt_prev</span>;</span></span><br><span class="line"><span class="keyword">rx_handler_func_t</span> *rx_handler;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">orig_dev</span>;</span></span><br><span class="line"><span class="keyword">bool</span> deliver_exact = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> ret = NET_RX_DROP;</span><br><span class="line">__be16 type;</span><br><span class="line"></span><br><span class="line">net_timestamp_check(!netdev_tstamp_prequeue, skb);</span><br><span class="line"></span><br><span class="line">trace_netif_receive_skb(skb);</span><br><span class="line"></span><br><span class="line">orig_dev = skb-&gt;dev;</span><br><span class="line"></span><br><span class="line">skb_reset_network_header(skb);</span><br><span class="line"><span class="keyword">if</span> (!skb_transport_header_was_set(skb))</span><br><span class="line">skb_reset_transport_header(skb);</span><br><span class="line">skb_reset_mac_len(skb);</span><br><span class="line"></span><br><span class="line">pt_prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">another_round:</span><br><span class="line">skb-&gt;skb_iif = skb-&gt;dev-&gt;ifindex;</span><br><span class="line"></span><br><span class="line">__this_cpu_inc(softnet_data.processed);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;protocol == cpu_to_be16(ETH_P_8021Q) ||</span><br><span class="line">    skb-&gt;protocol == cpu_to_be16(ETH_P_8021AD)) &#123;</span><br><span class="line">skb = skb_vlan_untag(skb);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 遍历已注册的协议，并调用其回调函数(一般是libpcap通过`AF_PACKET`传入的)</span></span><br><span class="line">list_for_each_entry_rcu(ptype, &amp;ptype_all, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (pt_prev)</span><br><span class="line">ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">pt_prev = ptype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协议栈</span></span><br><span class="line">list_for_each_entry_rcu(ptype, &amp;skb-&gt;dev-&gt;ptype_all, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (pt_prev)</span><br><span class="line">ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">pt_prev = ptype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skip_taps:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_INGRESS</span></span><br><span class="line"><span class="keyword">if</span> (static_key_false(&amp;ingress_needed)) &#123;</span><br><span class="line">skb = handle_ing(skb, &amp;pt_prev, &amp;ret, orig_dev);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nf_ingress(skb, &amp;pt_prev, &amp;ret, orig_dev) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调协议包<code>struct packet_type</code>注册的回调函数，把<code>sk_buff</code>传给该协议层处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">deliver_skb</span><span class="params">(struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct packet_type *pt_prev,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct net_device *orig_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(skb_orphan_frags(skb, GFP_ATOMIC)))</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">atomic_inc(&amp;skb-&gt;users);</span><br><span class="line"><span class="keyword">return</span> pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev, orig_dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有这些<code>struct packet_type</code>实际都是在内核初始化的时候通过<code>dev_add_pack</code>注册的，有兴趣的可以跟踪下对应的代码逻辑。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://lwn.net/Articles/30107/" target="_blank" rel="noopener">Driver porting: Network drivers</a></li><li><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#overview" target="_blank" rel="noopener">https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#overview</a></li><li><a href="https://lwn.net/Articles/358910/" target="_blank" rel="noopener">Generic Receive Offload</a></li><li><a href="https://lwn.net/Articles/362339/" target="_blank" rel="noopener">RPS</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rps" target="_blank" rel="noopener">Redhat RPS</a></li><li><a href="https://blog.csdn.net/lucien_cc/article/details/11731463" target="_blank" rel="noopener">https://blog.csdn.net/lucien_cc/article/details/11731463</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/New_API&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NAPI(New API)&lt;/a&gt;是Linux内核针对网络数据传输做出的一个优化措施，其目的是在大量数据传输时， 在
      
    
    </summary>
    
      <category term="网络协议" scheme="http://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="Linux" scheme="http://sniffer.site/tags/Linux/"/>
    
      <category term="TCP/IP" scheme="http://sniffer.site/tags/TCP-IP/"/>
    
      <category term="NAPI" scheme="http://sniffer.site/tags/NAPI/"/>
    
  </entry>
  
  <entry>
    <title>由新冠病毒想到的一些事情</title>
    <link href="http://sniffer.site/2020/04/04/%E8%AF%B4%E8%AF%B4%E8%BF%99%E6%AC%A1%E6%96%B0%E5%86%A0%E4%BC%A0%E6%9F%93%E7%97%85%E6%83%B3%E5%88%B0%E7%9A%84%E4%BA%8B%E6%83%85/"/>
    <id>http://sniffer.site/2020/04/04/说说这次新冠传染病想到的事情/</id>
    <published>2020-04-04T11:48:27.000Z</published>
    <updated>2020-04-06T03:31:34.658Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Live as everything is a miracle or nothing is miracle</p><p>爱因斯坦</p></blockquote><p>这次新型冠状病毒发展到现在估计已经超出了绝大多数人的预料, 现在国内的疫情基本稳定了, 但国外包括北美, 欧洲大部分国家都处于病毒爆发的高峰期, 截至4月3日全球已经有超过80多万的病毒感染者<a id="more"></a>:</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/convid-19_trend.png" alt="新冠病毒确诊人数趋势图"></p><p>看这个图, 增长速率丝毫没有减缓的迹象, 新冠病毒的传染能力也可见一斑.那何时又是个头?我们不妨通过简单的数学模型来估算下最终可能感染的人数以及疫情控制的大致时间节点.按照生物学的规律, <a href="https://www.khanacademy.org/science/biology/ecology/population-growth-and-regulation/a/exponential-logistic-growth" target="_blank" rel="noopener">一个生物种群数量的增长都遵循S型曲线的增长</a>:</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/s_shaped_curve.png" alt="logistic growth curve"></p><p>图中的横轴表示时间, 纵轴表示生物种群的个数, 将上述增长曲线写成对应的公式大致如下:</p><p>$$ y(t) = \frac{k}{1 + Ae^{-rt}} $$</p><p>这里<code>t</code>是时间, <code>k</code>/<code>A</code>是常数(<code>k</code>的值实际表示了最后可能感染的人数), <code>y(t)</code>即当前感染的人数, <code>r</code>是最大的增长率.参考<a href="https://voice.baidu.com/act/newpneumonia/newpneumonia" target="_blank" rel="noopener">百度疫情</a>给出的数据, 为了简化计算, 从历史数据中大概计算了感染人数的增长率为<code>15%</code>(实际最大的增长率已经超过<code>20%</code>, 这里取了一个中间值);分别取了<code>2020/02/20</code>/<code>2020/04/03</code>两天的的数据, 得到<code>k</code>的值大约为<code>2332345.16</code>, 也就是说最后大概总共有200万左右的感染人数, 据此可以得到一个如下的简单感染人数模型:</p><p>$$ y(t) = \frac{2332345.16}{1 + 2172.67e^{-0.15t}} $$</p><p>画成图形可能看得比较直观, 下图中时间<code>0</code>对应<code>2020/02/20</code>, 从图上来看要等90天之后, 也就是<code>2020/5/20</code>左右疫情才能真正稳定下来, 当然后续控制力度加强可能这个时间会提前.</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/prediction_of_infected_persons.png" alt="病毒感染人数预测"></p><p>在全球化的今天, 这次疫情对每个人来说都有着重大的影响, 对那些因为病毒感染失去亲人朋友的人来说, 更是如此. 还记得当时跟同事讨论这个病毒, 病人的症状跟非典(SARS)很相似, 但官方却迟迟没有给出明确的结论是否存在比较强的感染, 还是含糊其词的说”有限人传人”, 直到后来包不住火了, 才实施封城, 最后还是比病毒的传播慢了半拍.</p><p>从湖北考察回来的管轶教授, 上来就说这次很失望, 很麻烦, 比SARS那会要严重很多, 感染人数至少10倍起, 当时很多人不以为然, 还质疑管教授的立场, 以为他是危言耸听, 出于报复心理才这么说的.但凡真的看过管教授履历的人都知道, 他本人是国际知名的传染病科学家,在这样影响大的传染病面前, 作为一个科学家, 他断不会因为一己之心而放弃对真相与道义的坚守.事情事实上比他预想的还要糟糕.面对这么一个局面, 不得不让人感慨深思.</p><p>自工业革命以来, 人类开始了轰轰烈烈的自然改造, 地上跑的有火车/汽车, 天上有飞机/火箭, 同时还把触角伸向了宇宙, 人类的成功恐怕让人自己都难以不陶醉. 人的权能感也达到了新的高度, 以至于都忘记了自己只是生活在一个小小的星球上的生物而已. 人类虽说成了地球生物的主宰, 活在生物链的最顶端, 享尽了自然的馈赠, 但却少了一份对自然的敬畏之心. 病毒其实早在人类诞生之前就存在了, 时间退回到第一个细胞出现的那一刻, 人和病毒其实都来自于同一个祖先, 只是病毒走了另外一条道路, 而进化成生物体的细胞走了另外一条叉路而已, 恐怕从生物学的角度, 病毒要比人类更了解人类自己, 也更聪明.病毒可以欺骗人类的免疫细胞, 然后自我繁殖变异, 通过人与人的传播, 这种独特的生存方式, 人类估计要花很长的时间精力才能真正研究清楚.</p><p>而再看看这次我们对待新冠病毒的方式, 就知道人类赖以生存的复杂社会体系其实有多么的脆弱.官僚体系的迟钝, 组织机构把个人生命安危置若罔闻, 发生重大危机时, 开始时没有百姓的声音, 最后收场时, 却是那些官员们领取功劳, 宣扬成就的表演, 也无法听到普通人的真实声音. 百姓仿佛一只猴子一般被玩弄于手掌. 如今这样的社会体系中, 政府与组织的权力触角实际已经够大够深了, 个人的空间被压缩挤占, 再这样下去, 实际上每个人都会被裹挟者往前走.难道,我们真的要把所有的隐私与权力都要让度于政府或组织吗? 在集体控制与个人权利之间如何才能达成平衡? 个人又要如何在这样的体系结构下生存?</p><p>从大的方面来讲, 在全球化的今天, 面对这样的危机, 个人是否还能明哲保身? 恐怕很难. 我们都没有机会从这种灾难中挣脱出来, 每个人的生活都与这种全球性的危难紧密相关;人与人之间, 国与国之间只有共同合作与互相帮助才能从危机中走过来, 人类能从进化中胜出, 依靠的也是这种团结与协作.最近, 浏览新闻, 时不时有人在兴高采烈的想着: 这次疫情, 美国估计抗不住了, 我们恐怕要赢了；有人也一直在宣扬, 新冠病毒乃美国的阴谋, 实际疫情在美国老早就发生了, 我们压根就不应该帮助美国.这些怪异的言论, 说的头头是道, 却是毫无道义与来由的说辞.不论新冠病毒来自何方, 但目前从发生的时间来看, 就是从武汉传染出去的, 这个毋庸置疑, 如今病毒扩散的其他国家, 我们作为负责任的大国, 理应尽力去帮助其他国家共同抵抗疫情的进一步恶化. 这首先是出于道义, 然则是出于经济发展与社会稳定的考虑.如果此时不去积极帮助美国在内的国家抗击病毒, 我们的国家形象只会变得更加矮小;而其他国家一日不稳定下来, 依靠出口的企业就难以维系, 社会经济压力就会越大.这样的时刻, 只有合作与协作才有利于彼此, 而不是只考虑到眼前的一己之利.</p><p>再具体到个人, 想要在这样的全球性危机中安稳的过渡, 首先还是要积蓄能量, 不论是学习, 提升个人能力还是锻炼身体都不能落下, 同时还要多做些资金的储备, 不要乱花钱. 这样等疫情缓过来后, 方能找到机会去改变与突破. </p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.khanacademy.org/science/biology/ecology/population-growth-and-regulation/a/exponential-logistic-growth" target="_blank" rel="noopener">https://www.khanacademy.org/science/biology/ecology/population-growth-and-regulation/a/exponential-logistic-growth</a></li><li><a href="https://voice.baidu.com/act/newpneumonia/newpneumonia" target="_blank" rel="noopener">https://voice.baidu.com/act/newpneumonia/newpneumonia</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;Live as everything is a miracle or nothing is miracle&lt;/p&gt;
&lt;p&gt;爱因斯坦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这次新型冠状病毒发展到现在估计已经超出了绝大多数人的预料, 现在国内的疫情基本稳定了, 但国外包括北美, 欧洲大部分国家都处于病毒爆发的高峰期, 截至4月3日全球已经有超过80多万的病毒感染者
    
    </summary>
    
      <category term="社会万象" scheme="http://sniffer.site/categories/%E7%A4%BE%E4%BC%9A%E4%B8%87%E8%B1%A1/"/>
    
    
      <category term="哲学" scheme="http://sniffer.site/tags/%E5%93%B2%E5%AD%A6/"/>
    
      <category term="社会" scheme="http://sniffer.site/tags/%E7%A4%BE%E4%BC%9A/"/>
    
      <category term="思考" scheme="http://sniffer.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Android是如何实现流量统计的?</title>
    <link href="http://sniffer.site/2020/04/01/%E8%AF%B4%E8%AF%B4Android%E4%B8%AD%E7%9A%84%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1/"/>
    <id>http://sniffer.site/2020/04/01/说说Android中的流量统计/</id>
    <published>2020-04-01T07:56:35.000Z</published>
    <updated>2020-04-05T07:44:03.918Z</updated>
    
    <content type="html"><![CDATA[<p>使用Android手机时, 我们不仅可以看到当前系统的流量使用情况, 还可以查看每个应用消耗了多少流量, 借此我们可以发现有那些流氓APP在偷偷在背后消耗流量.那么, Android是具体如何实现流量统计的? 又是如何对每个应用的流量使用进行监控? 这篇文章我们就来看看Android流量统计的具体实现原理.</p><p>大致说来, Android从如何几个方面进行流量统计:</p><ul><li>统计每个网口当前发送/接收的流量数据</li><li>监控每个应用(对应唯一的UID)所消耗的流量</li><li>支持对总的流量配额进行限制, 如达到一定的流量阈值后, 会对网络进行限制</li></ul><p>而具体到每个应用(比如system应用, UID=1000), Android还支持对应用内的每个socket进行标记(tag), 用于区分每个应用(UID)内部具体使用了那些流量.后面, 我们会讲到如何通过标签来区分UID内部的流量.</p><p>下图是Android流量统计的原理框图: 为了实现流量统计, Android在Linux内核增加了一个netfilter模块: <code>xt_qtaguid</code>(源码可以在<code>kernel/net/netfilter</code>中找到), 用于统计当前系统所有流量, 该模块初始化时, 会初始化一个<code>/proc/net/xt_qtaguid</code>目录供用户空间的进程使用;<code>NetworkStatsService</code>系统服务就是周期性的读取该目录的数据来获取当前系统消耗的实时流量的;而如果要对某个特定的<code>socket</code>打上标签, 则需要通过JNI接口调用,然后发请求给<code>netd</code>将该<code>socket</code>标签信息通过接口<code>/proc/net/xt_qtaguid/ctrl</code>写入内核.</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/Android%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="Android流量统计原理图"></p><p>接下来就一起看下Android具体是如何进行流量统计的.</p><h2 id="Android流量统计实现"><a href="#Android流量统计实现" class="headerlink" title="Android流量统计实现"></a><strong>Android流量统计实现</strong></h2><p>Android有一个系统服务<code>NetworkStatsService</code>来负责流量统计管理. 在系统启动的时候会创建该服务, 对其进行初始化: 创建一个<code>NetworkStatsService</code>, 并返回给<code>SystemServer</code>, 服务内有一个线程用于数据统计业务的处理.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NetworkStatsService <span class="title">create</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">            INetworkManagementService networkManager)</span> </span>&#123;</span><br><span class="line">    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</span><br><span class="line">    PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);</span><br><span class="line">    PowerManager.WakeLock wakeLock =</span><br><span class="line">            powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);</span><br><span class="line"></span><br><span class="line">    NetworkStatsService service = <span class="keyword">new</span> NetworkStatsService(context, networkManager, alarmManager,</span><br><span class="line">            wakeLock, getDefaultClock(), TelephonyManager.getDefault(),</span><br><span class="line">            <span class="keyword">new</span> DefaultNetworkStatsSettings(context), <span class="keyword">new</span> NetworkStatsObservers(),</span><br><span class="line">            getDefaultSystemDir(), getDefaultBaseDir());</span><br><span class="line"></span><br><span class="line">    HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(TAG);</span><br><span class="line">    Handler.Callback callback = <span class="keyword">new</span> HandlerCallback(service);</span><br><span class="line">    handlerThread.start();</span><br><span class="line">    Handler handler = <span class="keyword">new</span> Handler(handlerThread.getLooper(), callback);</span><br><span class="line">    service.setHandler(handler, callback);</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等到<code>SystemServer</code>完成对系统服务的初始化后, 会调用<code>NetworkStatsService.systemReady()</code>, 告诉服务可以正常启动了, 启动时<code>NetworkStatsService</code>需要做如下几件事情:</p><ul><li>创建四个流量统计的类型, 实际对应放在<code>/data/system/netstats</code>目录的四个类型的文件而已, 分别用于统计每个网口的消耗的流量(<code>PREFIX_DEV</code>), 视频通话以及热点分享所消耗的流量(<code>PREFIX_XT</code>), 每个用户所消耗的流量(<code>PREFXI_UID</code>)以及每个用户对应的每个标签所消耗的流量(<code>PREFIX_UID_TAG</code>)</li><li>更新每个流量统计数据写入的阈值: 即流量消耗达到某个阈值后, 需要将当前统计数据写入磁盘, 目前默认统一使用的是<code>2MB</code>；接着还要看下是否需要从早前版本中把老的流量统计数据迁移过来</li><li>注册并监听系统广播, 比如定时从系统拉取流量统计数据(<code>ACTION_NETWORK_STATS_POLL</code>), Android默认30分钟拉取一次; 系统用户增加与删除的广播;关机的广播等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mSystemReady = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mStatsLock) &#123;</span><br><span class="line">        <span class="comment">// create data recorders along with historical rotators</span></span><br><span class="line">        mDevRecorder = buildRecorder(PREFIX_DEV, mSettings.getDevConfig(), <span class="keyword">false</span>);</span><br><span class="line">        mXtRecorder = buildRecorder(PREFIX_XT, mSettings.getXtConfig(), <span class="keyword">false</span>);</span><br><span class="line">        mUidRecorder = buildRecorder(PREFIX_UID, mSettings.getUidConfig(), <span class="keyword">false</span>);</span><br><span class="line">        mUidTagRecorder = buildRecorder(PREFIX_UID_TAG, mSettings.getUidTagConfig(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        updatePersistThresholdsLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// upgrade any legacy stats, migrating them to rotated files</span></span><br><span class="line">        maybeUpgradeLegacyStatsLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read historical network stats from disk, since policy service</span></span><br><span class="line">        <span class="comment">// might need them right away.</span></span><br><span class="line">        mXtStatsCached = mXtRecorder.getOrLoadCompleteLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bootstrap initial stats to prevent double-counting later</span></span><br><span class="line">        bootstrapStatsLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// watch for tethering changes</span></span><br><span class="line">    <span class="keyword">final</span> IntentFilter tetherFilter = <span class="keyword">new</span> IntentFilter(ACTION_TETHER_STATE_CHANGED);</span><br><span class="line">    mContext.registerReceiver(mTetherReceiver, tetherFilter, <span class="keyword">null</span>, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen for periodic polling events</span></span><br><span class="line">    <span class="keyword">final</span> IntentFilter pollFilter = <span class="keyword">new</span> IntentFilter(ACTION_NETWORK_STATS_POLL);</span><br><span class="line">    mContext.registerReceiver(mPollReceiver, pollFilter, READ_NETWORK_USAGE_HISTORY, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen for uid removal to clean stats</span></span><br><span class="line">    <span class="keyword">final</span> IntentFilter removedFilter = <span class="keyword">new</span> IntentFilter(ACTION_UID_REMOVED);</span><br><span class="line">    mContext.registerReceiver(mRemovedReceiver, removedFilter, <span class="keyword">null</span>, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen for user changes to clean stats</span></span><br><span class="line">    <span class="keyword">final</span> IntentFilter userFilter = <span class="keyword">new</span> IntentFilter(ACTION_USER_REMOVED);</span><br><span class="line">    mContext.registerReceiver(mUserReceiver, userFilter, <span class="keyword">null</span>, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// persist stats during clean shutdown</span></span><br><span class="line">    <span class="keyword">final</span> IntentFilter shutdownFilter = <span class="keyword">new</span> IntentFilter(ACTION_SHUTDOWN);</span><br><span class="line">    mContext.registerReceiver(mShutdownReceiver, shutdownFilter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mNetworkManager.registerObserver(mAlertObserver);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// ignored; service lives in system_server</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    registerPollAlarmLocked();</span><br><span class="line">    registerGlobalAlert();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NetworkStatsService</code>启动后, 注册了一个定时广播<code>com.android.server.action.NETWORK_STATS_POLL</code>, 每隔一段时间就会定时拉取当前系统消耗的流量统计数据, 收到该广播后, 系统会尝试将统计数据写入到磁盘永久保存下来:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> BroadcastReceiver mPollReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// on background handler thread, and verified UPDATE_DEVICE_STATS</span></span><br><span class="line">        <span class="comment">// permission above.</span></span><br><span class="line">        performPoll(FLAG_PERSIST_ALL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// verify that we're watching global alert</span></span><br><span class="line">        registerGlobalAlert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拉取当前流量数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPoll</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mStatsLock) &#123;</span><br><span class="line">        mWakeLock.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            performPollLocked(flags);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mWakeLock.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法<code>performPollLocked</code>首先会获取当前的统计数据快照, 然后将其自动写入到磁盘<code>/data/system/netstats</code>目录:</p><ul><li><code>recordSnapShotLocked()</code>实际通过<code>NetworkManagementService</code>提供的接口从<code>/proc/net/xt_qtaguid</code>这个目录读取当前的历史统计数据并将其保存到<code>mDevRecorder</code>/<code>mXtRecorder</code>/<code>mUidRecorder</code>中</li><li>根据传入的标志位, 来确定各个<code>NetworkStatsRecorder</code>是否将数据写入磁盘: 可以强制写入(<code>forcePersistLocked</code>), 也可以等到消耗流量达到阈值(就是之前说的<code>2MB</code>)之后再写入(<code>maybePersistLocked</code>)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPollLocked</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSystemReady) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> persistNetwork = (flags &amp; FLAG_PERSIST_NETWORK) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> persistUid = (flags &amp; FLAG_PERSIST_UID) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> persistForce = (flags &amp; FLAG_PERSIST_FORCE) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> consider marking "untrusted" times in historical stats</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTime = mClock.millis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        recordSnapshotLocked(currentTime);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">"problem reading network stats"</span>, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// ignored; service lives in system_server</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// persist any pending data depending on requested flags</span></span><br><span class="line">    <span class="keyword">if</span> (persistForce) &#123;</span><br><span class="line">        mDevRecorder.forcePersistLocked(currentTime);</span><br><span class="line">        mXtRecorder.forcePersistLocked(currentTime);</span><br><span class="line">        mUidRecorder.forcePersistLocked(currentTime);</span><br><span class="line">        mUidTagRecorder.forcePersistLocked(currentTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (persistNetwork) &#123;</span><br><span class="line">            mDevRecorder.maybePersistLocked(currentTime);</span><br><span class="line">            mXtRecorder.maybePersistLocked(currentTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (persistUid) &#123;</span><br><span class="line">            mUidRecorder.maybePersistLocked(currentTime);</span><br><span class="line">            mUidTagRecorder.maybePersistLocked(currentTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后, 我们来看看流量统计的数据是如何写入磁盘, 又如何从磁盘读取的. Android将系统消耗的流量按照时间切割成一段段固定时间长度的统计值(<code>NetworkStatsHistory</code>), 并将其与<code>NetworkIdentitySet</code>(表示一个网口)组成一个统计的哈希列表(<code>NetworkStatsCollection</code>), 然后每次更新当前消耗的流量时, <code>NetworkStatsRecorder</code>都会不断的将数据写入到磁盘:</p><ul><li><code>NetworkStatsRecorder</code>中包含了两个流量统计数据: 当前未写入磁盘的数据(<code>pending</code>)以及开机以来的统计数据(<code>mSinceBoot</code>)</li><li><code>FileRotator</code>负责将<code>NetworkStatsRecorder</code>中的数据定时写入到磁盘, 并按照一定的老化时间来创建新的统计文件, 而且每个统计文件在达到一定的生命周期后, 会自动被删除</li></ul><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/%E6%B5%81%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%BB%E5%86%99.png" alt="流量统计数据的读写"></p><h2 id="利用标签来统计特定Socket流量"><a href="#利用标签来统计特定Socket流量" class="headerlink" title="利用标签来统计特定Socket流量"></a><strong>利用标签来统计特定Socket流量</strong></h2><p><code>TrafficStats</code>中提供了接口, 可以在特定的socket(也可以使用socket对应的文件描述符)上打上标签,从而实现对每个应用你内部的流量消耗进行细分.Android系统已经定义了部分的TAG值, 比如用户DHCP协议的数据(<code>TAG_SYSTEM_DHCP</code>), 用于获取NTP网络时间的流量(<code>TAG_SYSTEM_NTP</code>), 用于探测网络的流量(<code>TAG_SYSTEM_PROBE</code>).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrafficStats</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default tag value for &#123;<span class="doctag">@link</span> DownloadManager&#125; traffic.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_DOWNLOAD = <span class="number">0xFFFFFF01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default tag value for &#123;<span class="doctag">@link</span> MediaPlayer&#125; traffic.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_MEDIA = <span class="number">0xFFFFFF02</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default tag value for &#123;<span class="doctag">@link</span> BackupManager&#125; backup traffic; that is,</span></span><br><span class="line"><span class="comment">    * traffic from the device to the storage backend.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_BACKUP = <span class="number">0xFFFFFF03</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default tag value for &#123;<span class="doctag">@link</span> BackupManager&#125; restore traffic; that is,</span></span><br><span class="line"><span class="comment">    * app data retrieved from the storage backend at install time.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_RESTORE = <span class="number">0xFFFFFF04</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default tag value for code (typically APKs) downloaded by an app store on</span></span><br><span class="line"><span class="comment">    * behalf of the app, such as updates.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_APP = <span class="number">0xFFFFFF05</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_DHCP = <span class="number">0xFFFFFF40</span>;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_NTP = <span class="number">0xFFFFFF41</span>;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_PROBE = <span class="number">0xFFFFFF42</span>;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_NEIGHBOR = <span class="number">0xFFFFFF43</span>;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_GPS = <span class="number">0xFFFFFF44</span>;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_PAC = <span class="number">0xFFFFFF45</span>;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set active tag to use when accounting &#123;<span class="doctag">@link</span> Socket&#125; traffic originating</span></span><br><span class="line"><span class="comment">    * from the current thread. Only one active tag per thread is supported.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Changes only take effect during subsequent calls to</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #tagSocket(Socket)&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Tags between &#123;<span class="doctag">@code</span> 0xFFFFFF00&#125; and &#123;<span class="doctag">@code</span> 0xFFFFFFFF&#125; are reserved and</span></span><br><span class="line"><span class="comment">    * used internally by system services like &#123;<span class="doctag">@link</span> DownloadManager&#125; when</span></span><br><span class="line"><span class="comment">    * performing traffic on behalf of an application.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #clearThreadStatsTag()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setThreadStatsTag</span><span class="params">(<span class="keyword">int</span> tag)</span> </span>&#123;</span><br><span class="line">        NetworkManagementSocketTagger.setThreadSocketStatsTag(tag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set active tag to use when accounting &#123;<span class="doctag">@link</span> Socket&#125; traffic originating</span></span><br><span class="line"><span class="comment">    * from the current thread. Only one active tag per thread is supported.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Changes only take effect during subsequent calls to</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #tagSocket(Socket)&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Tags between &#123;<span class="doctag">@code</span> 0xFFFFFF00&#125; and &#123;<span class="doctag">@code</span> 0xFFFFFFFF&#125; are reserved and</span></span><br><span class="line"><span class="comment">    * used internally by system services like &#123;<span class="doctag">@link</span> DownloadManager&#125; when</span></span><br><span class="line"><span class="comment">    * performing traffic on behalf of an application.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the current tag for the calling thread, which can be used to</span></span><br><span class="line"><span class="comment">    *         restore any existing values after a nested operation is finished</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAndSetThreadStatsTag</span><span class="params">(<span class="keyword">int</span> tag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NetworkManagementSocketTagger.setThreadSocketStatsTag(tag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Tag the given &#123;<span class="doctag">@link</span> Socket&#125; with any statistics parameters active for</span></span><br><span class="line"><span class="comment">   * the current thread. Subsequent calls always replace any existing</span></span><br><span class="line"><span class="comment">   * parameters. When finished, call &#123;<span class="doctag">@link</span> #untagSocket(Socket)&#125; to remove</span></span><br><span class="line"><span class="comment">   * statistics parameters.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> #setThreadStatsTag(int)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tagSocket</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">      SocketTagger.get().tag(socket);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove any statistics parameters from the given &#123;<span class="doctag">@link</span> Socket&#125;.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * In Android 8.1 (API level 27) and lower, a socket is automatically</span></span><br><span class="line"><span class="comment">   * untagged when it's sent to another process using binder IPC with a</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> ParcelFileDescriptor&#125; container. In Android 9.0 (API level 28)</span></span><br><span class="line"><span class="comment">   * and higher, the socket tag is kept when the socket is sent to another</span></span><br><span class="line"><span class="comment">   * process using binder IPC. You can mimic the previous behavior by</span></span><br><span class="line"><span class="comment">   * calling &#123;<span class="doctag">@code</span> untagSocket()&#125; before sending the socket to another</span></span><br><span class="line"><span class="comment">   * process.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">untagSocket</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">      SocketTagger.get().untag(socket);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>要使用一个socket的标签其实很简单, 只要在创建通讯的socket的连接后, 主动调用<code>setThreadStatsTag</code>就可以了, 来看一个示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupSocket</span><span class="params">(<span class="keyword">int</span> sockType, <span class="keyword">int</span> prot, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> writeTimeout, <span class="keyword">long</span> readTimeout, <span class="keyword">int</span> destPort)</span> <span class="keyword">throws</span> ErrnoException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前socket打上PROBE标签</span></span><br><span class="line">    <span class="keyword">int</span> oldTag = TrafficStats.getAndSetThreadStatsTag(TrafficStats.TAG_SYSTEM_PROBE);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mFd = Os.socket(mAddrFamily, sockType, prot);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        TrafficStats.setThreadStatsTag(oldTag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Os.setsockoptTimeval(mFd, SOL_SOCKET, SO_SNDTIMEO, StructTimeval.fromMillis(writeTimeout));</span><br><span class="line">    Os.setsockoptTimeval(mFd, SOL_SOCKET, SO_RCVTIMEO, StructTimeval.fromMillis(readTimeout));</span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(mIface)) &#123;</span><br><span class="line">        Os.setsockoptIfreq(mFd, SOL_SOCKET, SO_BINDTODEVICE, mIface);</span><br><span class="line">    &#125;</span><br><span class="line">    Os.connect(mFd, mTarget, destPort);</span><br><span class="line"></span><br><span class="line">    mSockAddr = Os.getsockname(mFd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要获取某个UID对应的标签数据, 只要调用<code>NetworkStatsManager.java</code>的<code>queryDetailsForUid</code>接口, 传入对应的开始/结束时间就可以了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Query network usage statistics details for a given uid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * #see queryDetailsForUidTagState(int, String, long, long, int, int, int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkStats <span class="title">queryDetailsForUid</span><span class="params">(<span class="keyword">int</span> networkType, String subscriberId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> startTime, <span class="keyword">long</span> endTime, <span class="keyword">int</span> uid)</span> <span class="keyword">throws</span> SecurityException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queryDetailsForUidTagState(networkType, subscriberId, startTime, endTime, uid,</span><br><span class="line">        NetworkStats.Bucket.TAG_NONE, NetworkStats.Bucket.STATE_ALL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Query network usage statistics details for a given uid and tag.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * #see queryDetailsForUidTagState(int, String, long, long, int, int, int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkStats <span class="title">queryDetailsForUidTag</span><span class="params">(<span class="keyword">int</span> networkType, String subscriberId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> startTime, <span class="keyword">long</span> endTime, <span class="keyword">int</span> uid, <span class="keyword">int</span> tag)</span> <span class="keyword">throws</span> SecurityException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queryDetailsForUidTagState(networkType, subscriberId, startTime, endTime, uid,</span><br><span class="line">        tag, NetworkStats.Bucket.STATE_ALL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Android流量统计在9.0还是基于<code>xt_qtaguid</code>来实现的, 后面实际会通过<code>BPF</code>来做(参考文章<a href="http://sniffer.site/2019/11/07/BPF%E4%B8%8EeBPF/">BPF与eBPF</a>).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Android手机时, 我们不仅可以看到当前系统的流量使用情况, 还可以查看每个应用消耗了多少流量, 借此我们可以发现有那些流氓APP在偷偷在背后消耗流量.那么, Android是具体如何实现流量统计的? 又是如何对每个应用的流量使用进行监控? 这篇文章我们就来看看An
      
    
    </summary>
    
      <category term="Android" scheme="http://sniffer.site/categories/Android/"/>
    
    
      <category term="网络管理" scheme="http://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    
      <category term="流量统计" scheme="http://sniffer.site/tags/%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>利用SSH隧道访问局域网</title>
    <link href="http://sniffer.site/2020/02/24/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8SSH%E9%9A%A7%E9%81%93%E8%AE%BF%E9%97%AE%E5%B1%80%E5%9F%9F%E7%BD%91/"/>
    <id>http://sniffer.site/2020/02/24/如何利用SSH隧道访问局域网/</id>
    <published>2020-02-24T07:46:09.000Z</published>
    <updated>2020-03-24T03:41:34.364Z</updated>
    
    <content type="html"><![CDATA[<p>SSH(<a href="https://en.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">Secure SHell</a>)是一种基于加密算法的网络安全协议, 其在TCP/IP协议的基础上通过<a href="https://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="noopener">非对称公钥算法</a>对用户身份进行验证. SSH在网络中有广泛的应用, 比如平常在远程登录时就会用到SSH, Github的代码仓库提交也会基于SSH协议来验证提交者的合法性, 而对常年生活在局域网内的人来说, SSH更多的用途则是搭建穿越防火墙的VPN实现网络自由.</p><p>一台服务器如果有公共域名或者IP地址, 只需要事先将客户端的公钥放到服务器上就可以正常登录, 但如果服务器本身位于防火墙之外(比如某个端口被禁)或者位于NAT(<a href="https://en.wikipedia.org/wiki/Network_address_translation" target="_blank" rel="noopener">Network Address Translation</a>)网关之后, 这个方法就不起作用了. 用过VPN的同志应该比较清楚, 穿透防火墙或者某个局域网的NAT网关, 一般要用到SSH隧道技术(<a href="https://www.ssh.com/ssh/tunneling" target="_blank" rel="noopener">SSH tunneling</a>);SSH隧道技术也被称为端口转发(port forwarding).简单来说, 建立SSH隧道大致有两个流程:</p><ul><li>由位于局域网的设备A向服务器PC发起SSH连接, 建立一个安全加密的通信通道, 并基于该通道监听某个特定的端口</li><li>接着, 服务器基于已有的加密通道再建立一个SSH通信链路,基于这个通道服务器就可以登录到大屏, 执行交互指令</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ssh_login.png" alt="SSH login"></p><blockquote><p>SSH隧道技术的端口转发具体说有两种, 一种叫本地端口转发(local port forwarding), 就是在客户端做端口转发;一种叫远端端口转发(remote port forwarding), 就是在服务端做端口的数据转发, 这篇文章用到的技术是后一种.</p></blockquote><p>这里就来看看如何通过SSH隧道技术来实现对局域网内某个服务器的登录: 局域网内有一台设备A(服务端), 只有私有IP地址, 通过NAT网关访问外部网络, 设备B(客户端)是外部网络的一个PC, 现在要通过该PC(设备B)正常登录到设备A. </p><h2 id="实现SSH隧道功能"><a href="#实现SSH隧道功能" class="headerlink" title="实现SSH隧道功能"></a><strong>实现SSH隧道功能</strong></h2><p>在开启SSH隧道功能之前, 确保客户端/服务器都正常配置了ssh(SSH的客户端程序)/sshd(SSH守护进程):</p><ul><li>ssh: ssh登录的客户端, 负责发起ssh登录请求, 其配置一般放在<code>/etc/ssh/ssh_config</code></li><li><p>sshd: sshd是服务端的守护进程, 负责监听来自客户端的请求, 其配置放在<code>/etc/ssh/sshd_config</code></p><p>为了确保ssh可以正常进行端口转发, 需要打开<code>AllowTcpForwarding</code>:</p></li><li><p>设置<code>AllowTcpForwarding</code>为<code>yes</code>, 确保能够使用端口转发功能</p></li></ul><p>另外SSH密钥交换时要用到主机的密钥(host key), 可以通过<code>ssh-keygen</code>产生, 对于Ubuntu系统来说, 主机密钥一般放在<code>/etc/ssh</code>目录下. </p><p>为了避免每次ssh登录都要输入密码, 可以事先分别在客户端/服务器产生一个rsa密钥对, 并将公钥放到服务器/客户端的<code>/.ssh/authorized_keys</code>中保存下来, 并在执行ssh指令时指定对应的私钥文件, 这样身份验证就会在密钥验证阶段完成无需再输入用户密码了.</p><h3 id="启动sshd"><a href="#启动sshd" class="headerlink" title="启动sshd"></a><strong>启动sshd</strong></h3><p>配置完成后, 如果没有<code>sshd</code>进程, 需要在设备A(服务端)/设备B(用户端)都启动sshd:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sshd -ddd -h /etc/ssh/ssh_host_rsa_key -f /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>其中参数<code>-ddd</code>用于输出调试信息, <code>-h</code>指定host密钥文件, <code>-f</code>指定<code>sshd</code>的配置;启动完成后, 设备就可以正常收到来其他ssh客户端的请求了.</p><h3 id="启动ssh远程登录"><a href="#启动ssh远程登录" class="headerlink" title="启动ssh远程登录"></a><strong>启动ssh远程登录</strong></h3><p>在大屏输入如下指令, 尝试与设备A(客户端)建立SSH链接:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -vvv -TN -i &lt;identity_file&gt; -R 8989:localhost:22 user_name@remote_host</span><br></pre></td></tr></table></figure><p><code>-vvv</code>参数用于输出debug信息, <code></code>-TN<code>告诉ssh在登录后不要开启终端执行指令而是监听某个指定的端口, -i</code>制定身份验证的密钥文件目录, 参数<code>-R</code>指定了远端转发端口的规则: 将来自远端<code>8989</code>的数据都转发到本地的<code>22</code>端口; 执行该命令后, 身份验证通过, 可能会输入服务器密码, 然后我们就可以看到ssh会一直在监听<code>8989</code>这个端口, 接着在设备A(服务器)输入指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -vvv -i &lt;identity_file&gt;  -p 8989 root@localhost</span><br></pre></td></tr></table></figure><p>身份认证完成后, 就可以看到一个输入shell指令的命令窗口, 就算登录完成了.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://www.ssh.com/ssh/tunneling" target="_blank" rel="noopener">https://www.ssh.com/ssh/tunneling</a></li><li><a href="https://www.booleanworld.com/guide-ssh-port-forwarding-tunnelling/" target="_blank" rel="noopener">https://www.booleanworld.com/guide-ssh-port-forwarding-tunnelling/</a></li><li><a href="http://arondight.me/2016/02/17/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" target="_blank" rel="noopener">http://arondight.me/2016/02/17/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</a></li><li><a href="https://en.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Secure_Shell</a></li><li><a href="https://tools.ietf.org/html/rfc4251" target="_blank" rel="noopener">The Secure Shell (SSH) Protocol Architecture</a></li><li><code>man ssh/sshd/sshd_config</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SSH(&lt;a href=&quot;https://en.wikipedia.org/wiki/Secure_Shell&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Secure SHell&lt;/a&gt;)是一种基于加密算法的网络安全协议, 其在TCP/IP协议的基础上
      
    
    </summary>
    
      <category term="网络协议" scheme="http://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="SSH" scheme="http://sniffer.site/tags/SSH/"/>
    
      <category term="远程登录" scheme="http://sniffer.site/tags/%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"/>
    
      <category term="反向隧道" scheme="http://sniffer.site/tags/%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>Recovery模式如何支持ADB</title>
    <link href="http://sniffer.site/2019/12/31/Recovery%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81ADB/"/>
    <id>http://sniffer.site/2019/12/31/Recovery模式如何支持ADB/</id>
    <published>2019-12-31T08:15:41.000Z</published>
    <updated>2020-01-08T05:41:13.588Z</updated>
    
    <content type="html"><![CDATA[<p>这两天顺着recovery模式下一个网络需求, 为了便于调试又在recovery下做了ADB功能. 在Android早期的如4.4版本, recovery模式下支持ADB配置起来比较简单(支持<code>adb devices</code>/<code>adb reboot</code>/<code>adb pull/push</code>等常用指令), 但在Android 9.0下USB辅助设备一般都通过<code>configfs</code>的方式来配置了, 因此相对来说要适配的东西就多一些, 如果额外要适配<code>adb shell</code>命令, 则要修改<code>adbd</code>的源代码了.这篇文章就来看看如何在Recovery模式下解决这几个问题.</p><p>在进入正题之前, 先了解下USB相关的基础知识.</p><p>USB全称是<a href="https://en.wikipedia.org/wiki/USB" target="_blank" rel="noopener"><code>Universal Serial Bus</code></a>, 是一种广泛用于主机与外设之间的连接的串行总线.USB设备使用的是一种层级的结构, 最多可支持多达127个设备, 每个USB设备对应一个功能(<code>function</code>), 比如USB打印机提供了打印服务; 存储设备则提供了存储数据的功能.</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/usb_system_architecture.png" alt="USB system architecture"></p><p>Android中的USB支持<a href="https://en.wikipedia.org/wiki/USB_On-The-Go" target="_blank" rel="noopener">OTG(On The Go)</a>, 因此有两种模式, 一种是Android自身作为host,可以接入其他USB设备;一种是Android作为peripheral设备, Android可以连接到PC端, 比如要查看Android设备的存储内容时, 使用ADB时都必须将Android设置为<code>peripheral</code>模式.ADB是Android中用于开发调试的一个工具, 更详细的说明可以参考官网的说明<a href="https://developer.android.com/studio/command-line/adb" target="_blank" rel="noopener">Android Debuge Bridge</a>.</p><h2 id="Recovery下的ADB"><a href="#Recovery下的ADB" class="headerlink" title="Recovery下的ADB"></a>Recovery下的ADB</h2><p>适配的第一步是首先看看源码. 进入Recovery的代码<code>/bootable/recovery</code>下面有一个<code>README.md</code>的文档, 里边有大致说明了如何在recovery下使用ADB. 对<code>USESRDEBUG/ENG</code>版本, 默认是启动了<code>adbd</code>, 并且对于<code>recovery</code>模式通过<code>adb devices</code>看到的是一个如下设备:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">1234567890abcdef    recovery</span><br></pre></td></tr></table></figure><p>还需要明确的一点是, 在recovery模式下, 只有部分adb指令可用, 比如<code>adb root</code>/<code>adb push/pull</code>, 如果要使用<code>adb shell</code>需要把<code>/system</code>分区挂载上来.看起来一切都比较简单了, 可通过<code>adb reboot recovery</code>之后却无法找到设备, 在PC端查看<code>dmesg</code>也没有任何USB设备枚举上来. </p><p>继续看文档, 上面说到, 如果设备使用了<code>configfs</code>这个配置文件系统的话, 需要设置相关的配置.那问题可能就出在这里: 使用了<code>configfs</code>来配置USB设备, 但是在recovery模式没有正常配置.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">If device is using [configfs](https://www.kernel.org/doc/Documentation/usb/gadget_configfs.txt),</span><br><span class="line">check if configfs has been properly set up in init rc scripts. See the [example</span><br><span class="line">configuration](https://android.googlesource.com/device/google/wahoo/+/master/init.recovery.hardware.rc)</span><br><span class="line">for Pixel 2 devices. Note that the flag set via sysfs (i.e. the one above) is no-op when using</span><br><span class="line">configfs.</span><br></pre></td></tr></table></figure><p>简单来说, 在Linux中, <code>USB Gadget</code>是一个具有UDC(<code>USB Device Controller</code>)的可以连接到一个USB Host的设备, 其通常具有串口通讯/数据存储的功能.而对于Host来说, 一个<code>USB Gadget</code>就是一个配置的集合而已, 每个配置包含很多接口, 也被称为功能(functions). 目前Linux已经包含了很多功能供<code>USB Gadgets</code>使用, 具体可以参看Linux的源码<code>/kernel/drivers/usb/gadget</code>. </p><p>那么具体来说ADB适配要经历哪几个步骤了? 接下来就来看一看recovery下适配ADB需要做的事情.</p><h2 id="Recovery下的ADB适配"><a href="#Recovery下的ADB适配" class="headerlink" title="Recovery下的ADB适配"></a>Recovery下的ADB适配</h2><ul><li><strong>挂载FunctionFs将USB用于ADB通信</strong></li></ul><p>在recovery代码目录<code>/bootable/recovery/etc/init.rc</code>中对ADB对应的<code>FunctionFs</code>做了配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">on fs</span><br><span class="line">    write /sys/class/android_usb/android0/f_ffs/aliases adb</span><br><span class="line">    mkdir /dev/usb-ffs 0770 shell shell</span><br><span class="line">    mkdir /dev/usb-ffs/adb 0770 shell shell</span><br><span class="line">    mount functionfs adb /dev/usb-ffs/adb uid=2000,gid=2000</span><br></pre></td></tr></table></figure><p>这个有什么用了?看ADB的源码(<code>/system/core/daemon</code>), 大致可以看到, 只有挂载了<code>functionfs</code>, ADB才能基于USB的<code>ep0</code>端口进行通讯:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// /dev/usb-ffs/adb/ep0 (main.cpp)</span></span><br><span class="line"><span class="keyword">if</span> (access(USB_FFS_ADB_EP0, F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Listen on USB.</span></span><br><span class="line">    usb_init();</span><br><span class="line">    is_usb = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usb.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usb_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dummy_fd = adb_open(<span class="string">"/dev/null"</span>, O_WRONLY);</span><br><span class="line">  CHECK_NE(dummy_fd, <span class="number">-1</span>);</span><br><span class="line">  usb_ffs_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usb.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usb_ffs_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D(<span class="string">"[ usb_init - using FunctionFS ]"</span>);</span><br><span class="line"></span><br><span class="line">    usb_handle* h = <span class="keyword">new</span> usb_handle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (android::base::GetBoolProperty(<span class="string">"sys.usb.ffs.aio_compat"</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// Devices on older kernels (&lt; 3.18) will not have aio support for ffs</span></span><br><span class="line">        <span class="comment">// unless backported. Fall back on the non-aio functions instead.</span></span><br><span class="line">        h-&gt;write = usb_ffs_write;</span><br><span class="line">        h-&gt;read = usb_ffs_read;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        h-&gt;write = usb_ffs_aio_write;</span><br><span class="line">        h-&gt;read = usb_ffs_aio_read;</span><br><span class="line">        aio_block_init(&amp;h-&gt;read_aiob);</span><br><span class="line">        aio_block_init(&amp;h-&gt;write_aiob);</span><br><span class="line">    &#125;</span><br><span class="line">    h-&gt;kick = usb_ffs_kick;</span><br><span class="line">    h-&gt;close = usb_ffs_close;</span><br><span class="line"></span><br><span class="line">    D(<span class="string">"[ usb_init - starting thread ]"</span>);</span><br><span class="line">    <span class="built_in">std</span>::thread(usb_ffs_open_thread, h).detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要了解USB<code>FunctionFs</code>的同学可以参考Linux的文档<code>https://www.kernel.org/doc/Documentation/usb/functionfs.txt</code>.</p><ul><li><strong>创建ADB相关的功能配置</strong></li></ul><p>挂载<code>configfs</code>到某个目录, 并生成ADB相关的配置, 主要是USB的ProductID/VendorID以及设备序列号等信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">on init</span><br><span class="line">    mount configfs none /config</span><br><span class="line">    mkdir /config/usb_gadget/g1 0770 shell shell</span><br><span class="line">    write /config/usb_gadget/g1/idVendor &lt;youre_usb_vendor_id&gt;</span><br><span class="line">    write /config/usb_gadget/g1/idProduct &lt;youre_usb_product_id&gt;</span><br><span class="line">    mkdir /config/usb_gadget/g1/strings/0x409 0770</span><br><span class="line">    write /config/usb_gadget/g1/strings/0x409/serialnumber $&#123;ro.serialno&#125;</span><br><span class="line">    write /config/usb_gadget/g1/strings/0x409/manufacturer $&#123;ro.product.manufacturer&#125;</span><br><span class="line">    write /config/usb_gadget/g1/strings/0x409/product $&#123;ro.product.model&#125;</span><br><span class="line">    mkdir /config/usb_gadget/g1/functions/ffs.adb</span><br><span class="line">    write /config/usb_gadget/g1/os_desc/use 1</span><br><span class="line">    setprop sys.usb.configfs 1</span><br></pre></td></tr></table></figure><p>配置完成后, <code>/config/usb_gadget/g1</code>目录下大致如下:</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/usb_gadgets_configfs.png" alt="usb gadget configfs"></p><ul><li><strong>使能对应的USB Gadgets</strong></li></ul><p>在Android设备文件目录<code>/sys/class/udc</code>找到对应USB设备控制器的名称, 将其写入到对应的配置, 从而使得USB主机端可以正常枚举到该USB设备:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">on property:sys.usb.ffs.ready=1</span><br><span class="line">    mkdir /config/usb_gadget/g1/configs/b.1 0777 shell shell</span><br><span class="line">    symlink /config/usb_gadget/g1/configs/b.1 /config/usb_gadget/g1/os_desc/b.1</span><br><span class="line">    mkdir /config/usb_gadget/g1/configs/b.1/strings/0x409 0770 shell shell</span><br><span class="line">    write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration &quot;adb&quot;</span><br><span class="line">    symlink /config/usb_gadget/g1/functions/ffs.adb /config/usb_gadget/g1/configs/b.1/f1</span><br><span class="line">    write /config/usb_gadget/g1/UDC &quot;a800000.dwc3&quot;  # 这里写入对应的UDC名字</span><br></pre></td></tr></table></figure><p>配置完成后, 重新打包下BOOT分区, 刷写后, 输入<code>adb devices</code>可以看到:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List of devices attached </span><br><span class="line">1297270arecovery</span><br></pre></td></tr></table></figure><p>说明修改起作用了, 但目前输入<code>adb shell</code>还是会提示<code>/system/bin/sh</code>目前找不到的错误, 原因是recovery并没有正常挂载<code>system</code>分区, 那么有没有可能不挂载<code>system</code>分区同时又能使用<code>adb shell</code>了? 看<code>/bootable/recovery/etc/init.rc</code>, recovery下实际有集成了一个命令工具集合<code>busybox</code>, 通过<code>busybox</code>我们应该也可以实现类似与正常模式下<code>/system/bin/sh</code>的功能, 这就需要修改Android中ADBD的源码了, 具体可以看下<code>/system/core/adb/shell_serivce.cpp</code>中的代码逻辑.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://www.linux-usb.org/" target="_blank" rel="noopener">Linux USB相关的资料文档</a></li><li><a href="https://www.beyondlogic.org/usbnutshell/usb3.shtml#USBFunctions" target="_blank" rel="noopener">USB Nutshell</a></li><li><a href="https://www.kernel.org/doc/Documentation/usb/gadget_configfs.txt" target="_blank" rel="noopener">USB Gadget Configfs</a></li><li><a href="https://www.kernel.org/doc/Documentation/usb/functionfs.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/usb/functionfs.txt</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天顺着recovery模式下一个网络需求, 为了便于调试又在recovery下做了ADB功能. 在Android早期的如4.4版本, recovery模式下支持ADB配置起来比较简单(支持&lt;code&gt;adb devices&lt;/code&gt;/&lt;code&gt;adb reboot
      
    
    </summary>
    
      <category term="Android" scheme="http://sniffer.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://sniffer.site/tags/Android/"/>
    
      <category term="Recovery" scheme="http://sniffer.site/tags/Recovery/"/>
    
      <category term="ADB" scheme="http://sniffer.site/tags/ADB/"/>
    
  </entry>
  
  <entry>
    <title>SELinux在Android中的应用</title>
    <link href="http://sniffer.site/2019/12/07/Selinux%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://sniffer.site/2019/12/07/Selinux在Android中的应用/</id>
    <published>2019-12-07T10:00:37.000Z</published>
    <updated>2019-12-07T10:03:00.481Z</updated>
    
    <content type="html"><![CDATA[<p>SELinux(<a href="https://en.wikipedia.org/wiki/Security-Enhanced_Linux" target="_blank" rel="noopener">Security Enhanced Linux</a>)是Linux下的安全控制机制, 为进程访问系统资源提供了访问控制(access control)策略. 早期, Linux基于用户身份/用户组的DAC(<a href="https://en.wikipedia.org/wiki/Discretionary_access_control" target="_blank" rel="noopener">Discretionary Access Control</a>作为访问控制策略: 每个进程都有所属的UID, 每个文件都有所属的UID/GID以及文件模式(读写执行等), 一个进程是否可以访问某个文件就是基于UID/GID/文件模式来管理的.换句话说,只要某个资源序属于该用于或该用户组, 则该用户对该资源具有绝对控制权力, 这样一旦用户获得了root权限, 那么整个系统就成了肉鸡. 可见, DAC的安全控制策略比较粗放.</p><p>SELinux最初是由美国Utah大学与NSA(National Security Agency)的安全小组研究出来的<a href="http://freecomputerbooks.com/books/The_SELinux_Notebook-4th_Edition.pdf" target="_blank" rel="noopener">安全框架FLASK</a>演变而来, 后被合入到Linux 2.6版本.相较于DAC, SELinux采用的是更细粒度的MAC(<a href="https://en.wikipedia.org/wiki/Mandatory_access_control" target="_blank" rel="noopener">Mandatory Access Control</a>).对于DAC而言, 资源的权限是由每个用户自己控制的, 而MAC则将所有的权限收拢, 由一个统一的管理者(SELinux)统一来分配所有的资源权限, 如果访问者没有事先分配到某个资源的权限, 则不会允许访问.这样即使是root用户也要收到安全策略的约束. Android在4.3开始引入SELinux, 到了5.0版本之后, 则开始全面支持了.</p><p>在SELinux机制下, Android中所有的对象(进程/文件/socket/property)都打上了标签(label), 进程访问对象时, SELinux根据事先配置好的安全策略(security policy)判断访问者是否有权限. </p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/selinux_policy_concepts.png" alt="selinux policy concepts"></p><p>另外, Android系统是同时支持DAC与SELinux的, 就是说, 在一个进程访问某个资源时,会按照如下规则进行权限控制:</p><ul><li>首先根据DAC规则, 检查进程权限, 是否具有对应资源的读写/执行权限, 如果没有则拒绝执行;</li><li>如果DAC规则检查通过, 则执行SELinux安全规则的检查, 如果不通过,则拒绝访问.</li></ul><h2 id="初识SELinux"><a href="#初识SELinux" class="headerlink" title="初识SELinux"></a><strong>初识SELinux</strong></h2><p>SELinux的首要原则是: 任何未被声明允许执行的都会被拒绝, 其有两种运行模式:</p><ul><li><code>Permissive</code>模式: 访问控制的策略不会强制执行, 但是会被日志记录下来</li><li><code>Enforcing</code>模式: 访问控制策略会被强制执行并被记录下来</li></ul><p>在Android下可以通过 <code>adb getenforce</code>来查看当前SELinux处于何种模式, 也可以通过<code>adb setenforce</code>来设置SELinux的模式(USER版本默认是<code>enforcing</code>, USERDEBUG/ENG可以设置模式):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">adb setenforce 0 // permissive模式</span><br><span class="line">adb setenforce 1 // enforcing模式</span><br></pre></td></tr></table></figure><p>在SELinux中, 主要有Subject/Object/Object Manager/Security Server等几个核心的组成部分(见下图):</p><ul><li><code>Subject</code>: 在SELinux中, <code>Subject</code>是一个进程, 每个<code>Subject</code>都有与之关联的一个安全上下文(<code>security context</code>); <code>Subject</code>负责发起访问某个对象的请求,比如读文件/建立socket链接</li><li><code>Object</code>: 一个对象就是一个资源, 比如文件, socket, pipes以及网络接口；每个对象都由一个类型标识其用途(file, socket), 并且与一个权限(permissions)集合关联, 该权限集合描述了对象能提供什么样的服务(比如read/write/send等)</li><li><code>Object Manager</code>: 对象管理者负责管理所有对象以及这些对象上能够执行的动作</li><li><code>Access Vecctor Cache</code>: 用于缓存Security Server的访问决策,以改善系统性能</li><li><code>Security Server</code>: 安全服务器根据安全策略来决定某个对象上的动作是否被执行</li><li><code>Security Policy</code>: 用于描述SELinux的访问规则</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/selinux_core_components.png" alt="SELinux components"></p><p>接下来我们看看SELinux具体是如何给每个对象打标签以及实现安全策略规则的.</p><h3 id="标签-label-与策略规则"><a href="#标签-label-与策略规则" class="headerlink" title="标签(label)与策略规则"></a><strong>标签(label)与策略规则</strong></h3><p>SELinux是通过标签(label)来匹配执行动作以及策略的.标签决定了何种动作是允许被执行的, socket/文件/进程都有自己的标签. SELinux的访问控制就是根据各个对象上的的标签来决定的, 而策略文件则定义了这些对象是如何相互交互的.</p><p>一个标签通常有如下的形式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">user:role:type:mls_level</span><br></pre></td></tr></table></figure><p>这样一个标签也通常被成为<code>Security Context</code>. 在Android中, 通常不用关心<code>user</code>/<code>role</code>/<code>msl_level</code>, <code>user</code>一般只有<code>u</code>, <code>role</code>对于进程来说是<code>r</code>, 对其他对象是<code>object_r</code>, <code>msl_level</code>是<code>s0</code>, 而<code>type</code>则用来标识对象的类型, 其决定了该对象的所具备的能力, 因此Android中的SELinux又称为基于TE(<code>Type Enforcement</code>)的安全机制, 在Android中, 所有的SELinux策略文件都以<code>te</code>结尾.</p><p>通过<code>ls/ps</code>指令中加入<code>-Z</code>参数, 可以查看文件/进程的SELinux状态, 如输入<code>ls -aZ /init*</code>查看<code>init</code>文件夹的标签:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ls_z_file_context.png" alt="ls -z示例"></p><p>上图中的<code>init</code>可执行程序以及文件夹都是在<code>/system/sepolicy/private/file_contexts</code>中定义的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Data files</span><br><span class="line">/adb_keys           u:object_r:adb_keys_file:s0</span><br><span class="line">/build\.prop        u:object_r:rootfs:s0</span><br><span class="line">/default\.prop      u:object_r:rootfs:s0</span><br><span class="line">/fstab\..*          u:object_r:rootfs:s0</span><br><span class="line">/init\..*           u:object_r:rootfs:s0</span><br><span class="line">/res(/.*)?          u:object_r:rootfs:s0</span><br><span class="line">/selinux_version    u:object_r:rootfs:s0</span><br><span class="line">/ueventd\..*        u:object_r:rootfs:s0</span><br><span class="line">/verity_key         u:object_r:rootfs:s0</span><br><span class="line"></span><br><span class="line"># Executables</span><br><span class="line">/charger            u:object_r:rootfs:s0</span><br><span class="line">/init               u:object_r:init_exec:s0</span><br><span class="line">/sbin(/.*)?         u:object_r:rootfs:s0</span><br></pre></td></tr></table></figure><p>同样输入<code>ps -Z</code>可以查看进程的标签:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ps_z_security_context.png" alt="ps -Z"></p><p>策略规则(policy rules)决定了进程是如何访问对象的, 其通常是如下格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">allow domains types:classes permissions</span><br></pre></td></tr></table></figure><p>这里, </p><ul><li><code>Domain</code>: 域是一个进程或一组进程的标签,也被成为域类型</li><li><code>Type</code>: 对象的标签(如file/socket等)或者一个对象集合</li><li><code>Class</code>: 访问对象的类型</li><li><code>Permission</code>: 请求的权限(read/write)</li></ul><p>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">allow appdomain app_data_file:file rw_file_perms;</span><br></pre></td></tr></table></figure><p>这个规则的意思是允许所有应用域的进程访问标签为<code>app_data_file</code>的文件. 所有这些规则需要依赖于<code>global_macros</code>/<code>te_macros</code>的宏定义(位于<code>/system/sepolicy</code>目录下). 除了像上面的规则指定某个特定的域或类型, 也可以通过指定一个属性(<code>attribute</code>)来表示一组域或类型;当通过一个规则有属性时, 会被自动扩展成为了相应的域或类型. 按照上述方式写成的规则如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RULE_VARIANT SOURCE_TYPES TARGET_TYPES: CLASSES PERMISSIONS</span><br></pre></td></tr></table></figure><p>在这个规则下, 只要一个<code>Subject</code>标识了<code>SOURCE_TYPES</code>就可以有权在类型为<code>CLASSES</code>/标签为<code>TAEGET_TYPES</code>的对象上执行任何在<code>PERMISSONS</code>中声明的操作.例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">allow domain null_device:chr_file &#123; getattr open read ioctl write&#125;;</span><br></pre></td></tr></table></figure><p>这个条规则意思是允许任何有<code>domain</code>域的进程访问<code>null_device</code>类型(对应<code>/dev/null</code>)的字符设备.最后我们来看下Android是如何应用SELinux的.</p><h2 id="SELiunx在Android中的应用"><a href="#SELiunx在Android中的应用" class="headerlink" title="SELiunx在Android中的应用"></a><strong>SELiunx在Android中的应用</strong></h2><p>Android的SELinux配置(以下均以Android P 9.0的代码为例)在Android源码中有两个目录: </p><ul><li><code>/system/sepolicy</code></li><li><code>/device/&lt;manufactory&gt;/&lt;device-name&gt;/sepolicy</code></li></ul><p>而<code>/system/sepolicy</code>主要是Android原生已有的SELinux文件, 包括所有SELinux标签以及策略文件<code>.te</code>的定义, 一般不做修改;<code>/device</code>目录下的SELinux配置通过编译宏<code>BOARD_SEPOLICY_DIRS</code>引入, 所有SELinux相关的编译都要依靠<code>/system/sepolicy/Android.mk</code>这个makefile. 具体来说, SELinux的配置大致有如下几个部分:</p><table><thead><tr><th>配置目录</th><th>说明</th></tr></thead><tbody><tr><td>/system/sepolicy/public</td><td>包含了系统sepolicy相关的API</td></tr><tr><td>/system/sepolicy/private</td><td>包含了系统sepolicy的具体实现(与vendor无关)</td></tr><tr><td>/system/sepolicy/vendor</td><td>提供给厂商(vendor)自由实现的配置</td></tr><tr><td>BOARD_SEPOLICY_DIRS</td><td>包含厂商sepolicy的定制化配置</td></tr></tbody></table><p>所有以<code>.te</code>结尾的都是安全策略文件, 其定义了对象的域(domain)和类型(types); 而SELinux标签文件(也称为SELinux context文件), 大致有<a href="https://source.android.com/security/selinux/implement.html#key_files" target="_blank" rel="noopener">如下几种</a>:</p><ul><li><code>file_contexts</code>: 为用户空间的文件分配标签</li><li><code>genfs_contexts</code>: 为不支持扩展属性的文件分配标签(如<code>proc</code>/<code>vfat</code>)</li><li><code>property_contexts</code>: 为Android所有属性分配标签,<code>init</code>进程在初始化时会读取该配置 </li><li><code>service_contexts</code>: 为Android所有binder服务分配标签, 用于控制哪些进程可以注册/查找这些服务</li><li><code>seapp_contexts</code>: 为<code>/data/data</code>目录下的应用分配标签, 应用启动时<code>zygote</code>进程以及在应用安装时<code>installd</code>都会读取该配置</li><li><code>mac_permissions.xml</code>: 根据应用的签名(也可能包括包名)分配<code>seinfo tag</code>;<code>seinfo tag</code>在<code>seapp_contexts</code>文件中可以当作一个密钥用于分配特定的标签给所有的应用. 该配置在<code>system_sever</code>启动时会被读取</li></ul><p>那么, 这些SELinux的标签配置以及策略文件是如何编译的? 大致有两个编译路径,所有的<code>file_contexts</code>标签文件都会编译生成一个<code>file_contexts.bin</code>;而其他的如<code>security_classes</code>/<code>*.te</code>/<code>genfs_contexts</code>/<code>port_contexts</code>等文件都会编译生成一个<code>sepolicy</code>的二进制文件, 整体的编译逻辑如下图所示:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/selinux_android_build.png" alt="SELinux build logic"></p><p>有关SELinux在Android的编译可以参考<a href="https://source.android.com/security/selinux/build" target="_blank" rel="noopener">https://source.android.com/security/selinux/build</a>. </p><p>有了SELinux的基础知识, 要如何修改或者添加SELinux规则? 一般, 通过<code>dmesg | grep avc</code>或则<code>logcat | grep avc</code>查看系统当前的SELinux访问的记录, 如果出现<code>avc: denied</code>等字样, 说明有进程违反了安全策略, 举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[   42.357295] selinux: avc:  denied  &#123; set &#125; for property=net.usb0.dns1 pid=473 uid=0 gid=0 scontext=u:r:network_manager:s0 tcontext=u:object_r:system_prop:s0 tclass=proper1</span><br></pre></td></tr></table></figure><p>这个访问拒绝的提示说明, 进程<code>473</code>(network_manager)的标签<code>u:r:network_manager:s0</code>不具备访问标签为<code>u:object_r:system_prop:s0</code>, 类型为<code>system_prop</code>的属性值, 需要添加安全规则:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">set_prop(network_manager, system_prop)</span><br></pre></td></tr></table></figure><p>再次编译验证后就不会出现访问拒绝的日志了.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://source.android.com/security/selinux/images/SELinux_Treble.pdf" target="_blank" rel="noopener">SELinux for Android</a></li><li><a href="https://source.android.com/security/selinux/build" target="_blank" rel="noopener">SEAndroid的介绍</a></li><li><a href="http://freecomputerbooks.com/books/The_SELinux_Notebook-4th_Edition.pdf" target="_blank" rel="noopener">SELinux NoteBook</a></li><li><a href="http://www.cs.columbia.edu/~lierranli/coms6998-7Spring2014/papers/SEAndroid-NDSS2013.pdf" target="_blank" rel="noopener">SELinux在Android应用的挑战与问题</a></li><li><a href="https://wiki.gentoo.org/wiki/SELinux/Quick_introduction#SELinux_policy" target="_blank" rel="noopener">Introduction to SELinux</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SELinux(&lt;a href=&quot;https://en.wikipedia.org/wiki/Security-Enhanced_Linux&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Security Enhanced Linux&lt;/a&gt;)是Linux
      
    
    </summary>
    
      <category term="Android" scheme="http://sniffer.site/categories/Android/"/>
    
      <category term="Security" scheme="http://sniffer.site/categories/Android/Security/"/>
    
    
      <category term="Android" scheme="http://sniffer.site/tags/Android/"/>
    
      <category term="SELinux" scheme="http://sniffer.site/tags/SELinux/"/>
    
      <category term="Security" scheme="http://sniffer.site/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>BPF与eBPF</title>
    <link href="http://sniffer.site/2019/11/07/BPF%E4%B8%8EeBPF/"/>
    <id>http://sniffer.site/2019/11/07/BPF与eBPF/</id>
    <published>2019-11-07T11:35:03.000Z</published>
    <updated>2020-02-18T09:13:19.285Z</updated>
    
    <content type="html"><![CDATA[<p>最近了解Linux的性能优化时, 偶然接触到了BPF(<a href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter" target="_blank" rel="noopener">Berkeley Packet Filter</a>)这个有意思的东西, 觉得很好玩.把学到的一些基本原理与知识记录下来, 算是一个初步的总结. 这篇文章主要从如下几个方面介绍下BPF <a id="more"></a>:</p><ul><li>BPF的原理</li><li>什么是eBPF</li><li>如何在Linux中使用BPF</li></ul><p>用过<code>tcpdump</code>的同学应该都了解<code>pcap</code>, 实际上<code>pcap</code>就是基于BPF来实现网络数据包的过滤的. <code>tcpdump</code>的原理如下图所示: <code>tcpdump</code>将包过滤的表达式, 如查看某个网口所有udp包, 输入<code>tcpdump -n -i eth0 udp</code>, 这个表达式通过PCAP库编译成伪机器字节码后, 通过系统调用发送给内核(内核中有对应的机器码解释器)解释执行, 这样只要系统有udp包, 内核都会过滤出来转发给用户进程<code>tcpdump</code>:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcpdump%E5%8E%9F%E7%90%86.png" alt="how tcpdump works"></p><p>BPF全称Berkeley Packet Filters, 最初是Steven MaCanne, Van Jacobson在文章<a href="http://www.tcpdump.org/papers/bpf-usenix93.pdf" target="_blank" rel="noopener">‘The BSD Packet Filter: A New Architecture for User-level Packet Capture’</a>中提出的一种基于BSD Unix操作系统的包过滤器, 其原理是将包过滤的表达式编译成特定伪机器码后, 由Kernel中的虚拟机执行; 每当网卡中有数据包过来时, 将其拷贝发送给BPF模块, 由BPF根据对应的过滤条件将过滤后的包发送给用户进程:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/how_bpf_works.png" alt="how BPF works"></p><blockquote><p>针对tcpdump, linux有专门用于包过滤的表达式, 参考<code>pcap-filter</code></p></blockquote><p>BPF在Linux中的发展大致经历三个阶段: </p><ul><li>Linux 2.1.75最初的实现基于原有的socket接口, 被称为<a href="https://www.kernel.org/doc/Documentation/networking/filter.txt" target="_blank" rel="noopener"><code>Linux Socket Filter</code></a>(LSF)</li><li>Linux 3.0版本中,在BPF中加入JIT(<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="noopener"><code>Just-In-Time Compiler</code></a>), 提升BPF的性能与速度 </li><li>Linux 3.15开始将BPF扩展成为通用的模块, BPF不仅可用于数据包过滤, 也可以用来进行内核事件跟踪/应用性能调优/流量控制(Traffic Control)等, 代码也统一整合到了<code>/kernel/bpf</code>, 这也是目前被称为eBPF(extended BPF)的原因, 而早前的BPF实现则被称为cBPF(classic BPF).</li></ul><p>首先来看下传统的cBPF是如何实现的.</p><h2 id="cBPF"><a href="#cBPF" class="headerlink" title="cBPF"></a><strong>cBPF</strong></h2><p>BPF最初的BSD实现方案是通过打开一个字符设备<code>/dev/bpf*</code>(<code>/dev/bpf0</code>, <code>/dev/bpf1</code> etc), 再通过<code>ioctl</code>来控制该设备, 而Linux内核则基于现有的<code>socket</code>接口加入新的选项<code>SO_ATTACH_FILTER/SO_DETACH_FILTER</code>来执行系统调用, 具体的代码实现在<a href="https://elixir.bootlin.com/linux/v3.10.107/source/net/core/filter.c" target="_blank" rel="noopener"><code>/net/core/filter.c</code></a>. 通过一个简单的示例来看下cBPF是如何工作的.</p><ul><li>首先通过<code>tcpdump</code>指令来产生数据包的过滤代码: <code>tcpdump dst port 53 -dd</code>(这里过滤所有目标端口为53的数据包)</li><li>然后创建一个<code>AF_PACKET</code>(用于接收所有的数据包)的<code>socket</code>用于向kernel传递过滤代码, 并接收过滤后的数据包</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// tcpdump dst port 53 -dd</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter_code</span>[] = &#123;</span></span><br><span class="line">    &#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000c</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0x000086dd</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x30</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000014</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0x00000084</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x00000006</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">17</span>, <span class="number">0x00000011</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000036</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">0x00000035</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000038</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">0x00000035</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">0x00000800</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x30</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000017</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0x00000084</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x00000006</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0x00000011</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000014</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x45</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0x00001fff</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0xb1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000e</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x48</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000e</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0x00000035</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x48</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000010</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x00000035</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00040000</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000000</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">bpf</span> = &#123;</span></span><br><span class="line">    .len = <span class="keyword">sizeof</span>(filter_code)/(<span class="keyword">sizeof</span>(struct sock_filter)),</span><br><span class="line">    .filter = filter_code,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock_fd, bytes;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip_header</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> src_addr[INET_ADDRSTRLEN], dst_addr[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">char</span> *iface_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s iface_name\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. create socket</span></span><br><span class="line">    sock_fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line">    <span class="keyword">if</span> (sock_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket created failure"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    iface_name = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sll_ifindex = if_nametoindex(iface_name);</span><br><span class="line">    addr.sll_family = AF_PACKET;</span><br><span class="line">    addr.sll_protocol = htons(ETH_P_ALL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. attach filter (no need to call bind)</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sock_fd, SOL_SOCKET, SO_ATTACH_FILTER, &amp;bpf, <span class="keyword">sizeof</span>(bpf)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"attaching filter failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bytes = recv(sock_fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytes &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"received data failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ip_header = (struct iphdr *) (buf + <span class="keyword">sizeof</span>(struct ether_header));</span><br><span class="line">        inet_ntop(AF_INET, &amp;ip_header-&gt;saddr, src_addr, <span class="keyword">sizeof</span>(src_addr));</span><br><span class="line">        inet_ntop(AF_INET, &amp;ip_header-&gt;daddr, dst_addr, <span class="keyword">sizeof</span>(dst_addr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"IPv%d proto=%d src=%s dest=%s\n"</span>, </span><br><span class="line">                ip_header-&gt;version, ip_header-&gt;protocol, src_addr, dst_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚才说到在Linux 3.0版本中BPF加入了JIT; JIT能够提升伪机器码的执行效率. 从执行流程来说, 主要区别在于传入内核的<code>socket_filter</code>伪机器代码都会通过<code>bpf_jit_compile</code>进行优化处理, 然后再通过字节码解释器执行. 具体来说, 不同的平台<a href="https://elixir.bootlin.com/linux/v3.10.107/ident/bpf_jit_compile" target="_blank" rel="noopener"><code>bpf_jit_compile</code></a>的实现不一样, 内核中的代码路径位于<code>arch/&lt;platform&gt;/net/</code>, 感兴趣的可以跳转到<a href="https://elixir.bootlin.com/linux/v3.10.107/ident/bpf_jit_compile" target="_blank" rel="noopener">这里</a>看下.</p><h2 id="eBPF"><a href="#eBPF" class="headerlink" title="eBPF"></a><strong>eBPF</strong></h2><p><code>eBPF</code>即<a href="https://lwn.net/Articles/603983/" target="_blank" rel="noopener"><code>extended BPF</code></a>, 顾名思义是对原有BPF进行了扩展, 这样不仅BPF可以用来过滤网络数据包(tcpdump/XDP), 也可以用于性能分析, 将BPF代码插入到内核的跟踪点(<code>tracepoints</code>), <code>kprobes</code>, <code>perf</code>事件, 收集相应的数据.除了扩展了cBPF的功能外, eBPF另一个不同于cBPF的地方在于调用的方式: eBPF提供了一个统一的<code>bpf()</code>系统调用来执行相应的操作,同时应用与内核的数据传递也统一通过<code>map</code>这种数据结构来进行. 比如用<code>BPF_MAP_CREATE</code>命令来创建一个eBPF的map对象(不同的内核事件对应的map类型不同):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure><p>我们可以通过<a href="http://man7.org/linux/man-pages/man2/bpf.2.html" target="_blank" rel="noopener"><code>man bpf</code></a>来查看<code>bpf</code>系统调用的具体用法. eBPF对于内核的开发, 以及性能分析无疑是一大利器, 先通过具体的实例来看一看如何使用eBPF(Linux源码中有很多示例<a href="https://elixir.bootlin.com/linux/latest/source/samples/bpf" target="_blank" rel="noopener"><code>samples/bpf</code></a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_sock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sock = <span class="number">-1</span>, map_fd, prog_fd, i, key;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">0</span>, tcp_cnt, udp_cnt, icmp_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个bpf的array map用于保存结果</span></span><br><span class="line">  map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(key), <span class="keyword">sizeof</span>(value), <span class="number">256</span>);</span><br><span class="line">  <span class="keyword">if</span> (map_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"failed to create map '%s'\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// eBPF对应的伪机器码</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] = &#123;</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),</span><br><span class="line">    BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr, protocol) <span class="comment">/* R0 = ip-&gt;proto */</span>),</span><br><span class="line">    BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, <span class="number">-4</span>), <span class="comment">/* *(u32 *)(fp - 4) = r0 */</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>), <span class="comment">/* r2 = fp - 4 */</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_1, map_fd),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem),</span><br><span class="line">    BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, <span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_1, <span class="number">1</span>), <span class="comment">/* r1 = 1 */</span></span><br><span class="line">    BPF_RAW_INSN(BPF_STX | BPF_XADD | BPF_DW, BPF_REG_0, BPF_REG_1, <span class="number">0</span>, <span class="number">0</span>), <span class="comment">/* xadd r0 += r1 */</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>), <span class="comment">/* r0 = 0 */</span></span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载eBPF伪机器码到内核</span></span><br><span class="line">  prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, <span class="keyword">sizeof</span>(prog),</span><br><span class="line">        <span class="string">"GPL"</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (prog_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"failed to load prog '%s'\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sock = open_raw_sock(<span class="string">"lo"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将该eBPF的伪代码绑定到某个socket上</span></span><br><span class="line">  <span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd,</span><br><span class="line">          <span class="keyword">sizeof</span>(prog_fd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查询过滤得到的结果</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    key = IPPROTO_TCP;</span><br><span class="line">    assert(bpf_lookup_elem(map_fd, &amp;key, &amp;tcp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_UDP;</span><br><span class="line">    assert(bpf_lookup_elem(map_fd, &amp;key, &amp;udp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_ICMP;</span><br><span class="line">    assert(bpf_lookup_elem(map_fd, &amp;key, &amp;icmp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"TCP %lld UDP %lld ICMP %lld packets\n"</span>,</span><br><span class="line">          tcp_cnt, udp_cnt, icmp_cnt);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">  <span class="comment">/* maps, programs, raw sockets will auto cleanup on process exit */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到,对于eBPF而言, 大概有如下几个执行步骤:</p><ul><li>编写ePBF伪机器代码</li><li>调用<code>bpf</code>创建对应的map对象, 并将伪机器码加载到内核</li><li>内核对加载得到伪机器码进行优化/校验, 验证其是否合法(是否有非法指令等)</li><li>用户程序通过<code>bpf</code>的接口读取内核事件的结果</li></ul><p>这个例子用的是类似汇编语言的方式来实现eBPF伪机器代码, 这个对于非专业的开发者来说实在有点痛苦. 那么, 能否通过其他高级语言来编写eBPF的代码了? 这就要用到专门的编译器<a href="https://en.wikipedia.org/wiki/LLVM" target="_blank" rel="noopener"><code>LLVM</code>(Lower Level Virtual Machine)</a>了.通过<code>LLVM</code>, 我们只需要将需要执行的eBPF代码用C语言编写好后, 将其编译成<code>elf</code>格式的镜像(image)文件, 然后通过<code>libelf</code>库加载解析后, 装载到内核中执行. 如果去看<a href="https://elixir.bootlin.com/linux/latest/source/samples/bpf" target="_blank" rel="noopener"><code>samples/bpf</code></a>中的其他示例, 都是通过类似的方式实现的.</p><p>了解了eBPF大致的执行流程, 我们一起来看下eBPF原理的框架简图(eBPF涉及的内核知识比较多, 刚开始建立一个整体的框架有助于理解):</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ebpf_architecture.png" alt="eBPF architecture"></p><h2 id="BCC"><a href="#BCC" class="headerlink" title="BCC"></a><strong>BCC</strong></h2><p>即使有现成的编译工具LLVM, 有加载解析elf的库, 但对大部分开发者来说, 日常并没有太多时间精力一步步来开发这些eBPF工具与代码. 于是, 一些大牛们便搞出了一套<a href="https://github.com/iovisor/bcc" target="_blank" rel="noopener">BCC(BPF Compilation Collection)</a>的eBPF工具集合, 这个工具集合把所有eBPF内核代码编写/编译以及错误处理的流程都封装好了, 使用时只需通过python/Lua等脚本语言进行调用,这里从BCC的示例中选出一个简单的例子, 可以看到BCC极大的简化了eBPF的开发与使用流程:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Copyright (c) PLUMgrid, Inc.</span></span><br><span class="line"><span class="comment"># Licensed under the Apache License, Version 2.0 (the "License")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run in project examples directory with:</span></span><br><span class="line"><span class="comment"># sudo ./hello_world.py"</span></span><br><span class="line"><span class="comment"># see trace_fields.py for a longer example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每当发生`clone`系统调用时, 该脚本都会打印`hello world`</span></span><br><span class="line"><span class="comment"># This may not work for 4.17 on x64, you need replace kprobe__sys_clone with kprobe____x64_sys_clone</span></span><br><span class="line">BPF(text=<span class="string">'int kprobe__sys_clone(void *ctx) &#123; bpf_trace_printk("Hello, World!\\n"); return 0; &#125;'</span>).trace_print()</span><br></pre></td></tr></table></figure><p>如果Linux内核版本在4.4以上(如Ubuntu 16.04等), 可以通过如下指令安装BCC使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># echo "deb [trusted=yes] https://repo.iovisor.org/apt/xenial xenial-nightly main" | \</span></span><br><span class="line">    sudo tee /etc/apt/sources.list.d/iovisor.list</span><br><span class="line"><span class="comment"># sudo apt-get update</span></span><br><span class="line"><span class="comment"># sudo apt-get install bpfcc-tools# or the old package name: bcc-tools</span></span><br></pre></td></tr></table></figure><p>相应的, BCC的工具会安装到<code>/usr/share/bcc/tools</code>下面.更多BCC功能的解锁说明可以参考<a href="http://www.brendangregg.com/ebpf.html" target="_blank" rel="noopener">Brendan D.Gregg性能优化大牛的eBPF介绍</a>以及BCC的[官网]<a href="https://github.com/iovisor/bcc)" target="_blank" rel="noopener">https://github.com/iovisor/bcc)</a>. 安装完成后, 无论是对CPU, 内存, 磁盘I/O还是网络数据的传输都可以利用这一套工具进行监控了.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html" target="_blank" rel="noopener">Breadan Gregg大牛的博客, 性能优化的大牛</a></li><li><a href="http://man7.org/linux/man-pages/man2/bpf.2.html" target="_blank" rel="noopener">BPF系统调用的说明</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html" target="_blank" rel="noopener">BPF的很详尽的介绍资料</a></li><li><a href="https://www.kernel.org/doc/Documentation/networking/filter.txt" target="_blank" rel="noopener">Linux BPF实现的说明</a></li><li><a href="https://llvm.org/" target="_blank" rel="noopener">LLVM开源项目的官网</a></li><li><a href="https://github.com/iovisor/bcc" target="_blank" rel="noopener">BCC Github主页, 如何使用/安装/开发资料很全面</a></li><li><a href="https://lwn.net/Articles/742082/" target="_blank" rel="noopener">BCC入门级介绍</a></li><li><a href="https://github.com/zoidbergwill/awesome-ebpf" target="_blank" rel="noopener">收集了很多eBPF相关的资料</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近了解Linux的性能优化时, 偶然接触到了BPF(&lt;a href=&quot;https://en.wikipedia.org/wiki/Berkeley_Packet_Filter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Berkeley Packet Filter&lt;/a&gt;)这个有意思的东西, 觉得很好玩.把学到的一些基本原理与知识记录下来, 算是一个初步的总结. 这篇文章主要从如下几个方面介绍下BPF
    
    </summary>
    
      <category term="网络协议" scheme="http://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="Linux" scheme="http://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/Linux/"/>
    
    
      <category term="Berkeley Packet Filters" scheme="http://sniffer.site/tags/Berkeley-Packet-Filters/"/>
    
      <category term="extended Berkeley Packet Filters" scheme="http://sniffer.site/tags/extended-Berkeley-Packet-Filters/"/>
    
      <category term="性能优化" scheme="http://sniffer.site/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>说说Process.waitfor()引起的进程阻塞问题</title>
    <link href="http://sniffer.site/2019/09/04/%E8%AF%B4%E8%AF%B4Process-waitfor-%E5%BC%95%E8%B5%B7%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98/"/>
    <id>http://sniffer.site/2019/09/04/说说Process-waitfor-引起的进程阻塞问题/</id>
    <published>2019-09-04T08:35:16.000Z</published>
    <updated>2019-09-05T01:58:12.601Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到一个看似很怪异的问题, 在两个APP上调用同样的本地指令得到的结果却大相径庭; 看源代码, 这个本地进程做的事情其实并不复杂:</p><ul><li>从一个串口<code>/dev/ttyUSBX</code>读取数据</li><li>将数据写入到本地目录(读缓存大小为1KB)</li></ul><p>本地进程的代码逻辑其实相当简单: 主线程起来后主动创建一个负责读/写的子线程, 然后通过<code>pthread_join</code>主动等待子线程完成后退出.</p><p>问题是, 应用A调用的时保存的日志大小雷打不动的停留在不到4M就停止了, 而应用B可以一直写数据. 看应用A调用时, 通过<code>debuggerd -b &lt;tid&gt;</code>查看本地进程的堆栈, 大概是这样的:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/process_stack.jpg" alt="process stack"></p><p>说明此时本地进程一直在”卡”在写数据上了, 那到底卡在哪里了? 查看<code>cat /proc/&lt;pid&gt;/wchan</code>(也可以通过<code>strace -p &lt;pid&gt;</code>来查看目前进程所调用的系统调用), 就是本地进程的正在执行的系统调用, 发现是<code>pipe_wait</code>, 这个是怎么回事? 本地进程本身并不会用到pipe来进行数据的传输, 那很可能是Java父进程与本地进程之间的数据通信管道了. </p><p>回到最开始的问题, 为何两个APP调用同样的指令会有如此大的差异了? 我们再来看看应用A与应用B之间执行的代码到底有多少的差异?</p><ul><li>应用A的调用逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">Process process = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    process = Runtime.getRuntime().exec(COMMAND);</span><br><span class="line">    process.waitFor();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(process != <span class="keyword">null</span>) &#123;</span><br><span class="line">        process.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>应用B的调用逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Process process = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    process = Runtime.getRuntime().exec(COMMAND);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(process != <span class="keyword">null</span>) &#123;</span><br><span class="line">        process.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么一对比, 看起来问题是出在<code>Process.waitfor()</code>上了, 看了网上一个类似的案例<code>https://www.cnblogs.com/embedded-linux/p/6986525.html</code>, 顿时觉得豁然开朗, 这个不就是我碰到问题末!  看 <code>java.lang.Process</code>的文档说明(这里只拿了最关键的一段话): </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">By default, the created process does not have its own terminal</span><br><span class="line">or console.  All its standard I/O (i.e. stdin, stdout, stderr)</span><br><span class="line">operations will be redirected to the parent process, where they can</span><br><span class="line">be accessed via the streams obtained using the methods</span><br><span class="line">&#123;@link #getOutputStream()&#125;,</span><br><span class="line">&#123;@link #getInputStream()&#125;, and</span><br><span class="line"> &#123;@link #getErrorStream()&#125;.</span><br><span class="line">The parent process uses these streams to feed input to and get output</span><br><span class="line">from the process.  Because some native platforms only provide</span><br><span class="line">limited buffer size for standard input and output streams, failure</span><br><span class="line">to promptly write the input stream or read the output stream of</span><br><span class="line">the process may cause the process to block, or even deadlock.</span><br></pre></td></tr></table></figure><p>这段话的大概意思是, 通过Java创建的本地子进程本身是没有标准输入/输出以及错误流的, 这三个流都会被重定向到父进程; 父进程则通过<code>Process.getInputStream()/getOutputStream</code>等来获取子进程的流, 而如果父进程如果一直不读取子进程的输出流, 由于平台本身的输入输出流的缓冲大小是有限的, 此时子进程就可能阻塞, 甚至死锁(如果父进程也在等待子进程的话). 这样看起来, 问题的原因就很明显了:  应用A没有处理子进程的输出流, 且调用了<code>Process.waitfor()</code>, 由于本地进程一直在打印输出日志, 导致输出缓冲区满了之后发生阻塞, 而父进程并不知道子进程发生了阻塞, 一直傻傻的等.现在看来, 调用任何接口之前看<strong>看文档</strong>总是有益的, 至少在定位分析问题的时候可以少走弯路.</p><p>我们先来看下Java调用本地进程的整个处理流程, 再来看具体如何解决这个问题.  调用<code>Runtime.exec(cmd)</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String prog)</span> <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> exec(prog, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String prog, String[] envp, File directory)</span> <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line"><span class="comment">// Sanity checks</span></span><br><span class="line"><span class="keyword">if</span> (prog == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"prog == null"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (prog.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"prog is empty"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Break down into tokens, as described in Java docs</span></span><br><span class="line">StringTokenizer tokenizer = <span class="keyword">new</span> StringTokenizer(prog);</span><br><span class="line"><span class="keyword">int</span> length = tokenizer.countTokens();</span><br><span class="line">String[] progArray = <span class="keyword">new</span> String[length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    progArray[i] = tokenizer.nextToken();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delegate</span></span><br><span class="line"><span class="keyword">return</span> exec(progArray, envp, directory);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String[] progArray, String[] envp, File directory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// ProcessManager is responsible for all argument checking.</span></span><br><span class="line">      <span class="keyword">return</span> ProcessManager.getInstance().exec(progArray, envp, directory, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接着调用<code>ProcessManager.getInstance().exec()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes a process and returns an object representing it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String[] taintedCommand, String[] taintedEnvironment, File workingDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> redirectErrorStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure we throw the same exceptions as the RI.</span></span><br><span class="line">    <span class="keyword">if</span> (taintedCommand == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"taintedCommand == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (taintedCommand.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"taintedCommand.length == 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle security and safety by copying mutable inputs and checking them.</span></span><br><span class="line">    String[] command = taintedCommand.clone();</span><br><span class="line">    String[] environment = taintedEnvironment != <span class="keyword">null</span> ? taintedEnvironment.clone() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check we're not passing null Strings to the native exec.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; command.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (command[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"taintedCommand["</span> + i + <span class="string">"] == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The environment is allowed to be null or empty, but no element may be null.</span></span><br><span class="line">    <span class="keyword">if</span> (environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; environment.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (environment[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"taintedEnvironment["</span> + i + <span class="string">"] == null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FileDescriptor in = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    FileDescriptor out = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    FileDescriptor err = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line"></span><br><span class="line">    String workingPath = (workingDirectory == <span class="keyword">null</span>)</span><br><span class="line">            ? <span class="keyword">null</span></span><br><span class="line">            : workingDirectory.getPath();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure onExit() doesn't access the process map before we add our</span></span><br><span class="line">    <span class="comment">// entry.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (processReferences) &#123;</span><br><span class="line">        <span class="keyword">int</span> pid;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用JNI方法, 创建一个子进程, 并返回对应的PID</span></span><br><span class="line">            pid = exec(command, environment, workingPath, in, out, err, redirectErrorStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            IOException wrapper = <span class="keyword">new</span> IOException(<span class="string">"Error running exec()."</span></span><br><span class="line">                    + <span class="string">" Command: "</span> + Arrays.toString(command)</span><br><span class="line">                    + <span class="string">" Working Directory: "</span> + workingDirectory</span><br><span class="line">                    + <span class="string">" Environment: "</span> + Arrays.toString(environment));</span><br><span class="line">            wrapper.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> wrapper;</span><br><span class="line">        &#125;</span><br><span class="line">        ProcessImpl process = <span class="keyword">new</span> ProcessImpl(pid, in, out, err);</span><br><span class="line">        ProcessReference processReference = <span class="keyword">new</span> ProcessReference(process, referenceQueue);</span><br><span class="line">        processReferences.put(pid, processReference);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This will wake up the child monitor thread in case there</span></span><br><span class="line"><span class="comment">         * weren't previously any children to wait on.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        processReferences.notifyAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> process;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看下对应的JNI方法<code>java_lang_ProcessManager.cpp</code>,  看到<code>ExecuteProcess</code>中将子进程的输入输出以及错误流均重定向到pipe的一端, 而pipe的另一端则对应着父进程的输出输入以及错误流, 这样一看子进程所阻塞的函数<code>pipe_wait</code>正是因为输出流缓冲满了, 无法再继续写了(那么, 可能还有疑问? 为何本地进程一直要写pipe了, 手动输入命令调用下就知道, 这个本地进程一直变态的在打印自己写入数据的文件名到标准输出).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ProcessManager_exec</span><span class="params">(JNIEnv* env, jclass, jobjectArray javaCommands,</span></span></span><br><span class="line"><span class="function"><span class="params">                         jobjectArray javaEnvironment, jstring javaWorkingDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">                         jobject inDescriptor, jobject outDescriptor, jobject errDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">                         jboolean redirectErrorStream)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">ExecStrings <span class="title">commands</span><span class="params">(env, javaCommands)</span></span>;</span><br><span class="line">  <span class="function">ExecStrings <span class="title">environment</span><span class="params">(env, javaEnvironment)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Extract working directory string.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* workingDirectory = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (javaWorkingDirectory != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    workingDirectory = env-&gt;GetStringUTFChars(javaWorkingDirectory, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pid_t</span> result = ExecuteProcess(env, commands.get(), environment.get(), workingDirectory,</span><br><span class="line">                        inDescriptor, outDescriptor, errDescriptor, redirectErrorStream);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clean up working directory string.</span></span><br><span class="line">  <span class="keyword">if</span> (javaWorkingDirectory != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(javaWorkingDirectory, workingDirectory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Executes a command in a child process. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ExecuteProcess</span><span class="params">(JNIEnv* env, <span class="keyword">char</span>** commands, <span class="keyword">char</span>** environment,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">char</span>* workingDirectory, jobject inDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">                    jobject outDescriptor, jobject errDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">                    jboolean redirectErrorStream)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create 4 pipes: stdin, stdout, stderr, and an exec() status pipe.</span></span><br><span class="line">  <span class="keyword">int</span> pipes[PIPE_COUNT * <span class="number">2</span>] = &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_COUNT; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipes + i * <span class="number">2</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      jniThrowIOException(env, errno);</span><br><span class="line">      ClosePipes(pipes, <span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> stdinIn = pipes[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> stdinOut = pipes[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> stdoutIn = pipes[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> stdoutOut = pipes[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">int</span> stderrIn = pipes[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span> stderrOut = pipes[<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">int</span> statusIn = pipes[<span class="number">6</span>];</span><br><span class="line">  <span class="keyword">int</span> statusOut = pipes[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pid_t</span> childPid = fork();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If fork() failed...</span></span><br><span class="line">  <span class="keyword">if</span> (childPid == <span class="number">-1</span>) &#123;</span><br><span class="line">    jniThrowIOException(env, errno);</span><br><span class="line">    ClosePipes(pipes, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is the child process...</span></span><br><span class="line">  <span class="keyword">if</span> (childPid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Note: We cannot malloc(3) or free(3) after this point!</span></span><br><span class="line">    <span class="comment">// A thread in the parent that no longer exists in the child may have held the heap lock</span></span><br><span class="line">    <span class="comment">// when we forked, so an attempt to malloc(3) or free(3) would result in deadlock.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace stdin, out, and err with pipes.</span></span><br><span class="line">    dup2(stdinIn, <span class="number">0</span>);</span><br><span class="line">    dup2(stdoutOut, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (redirectErrorStream) &#123;</span><br><span class="line">      dup2(stdoutOut, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dup2(stderrOut, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close all but statusOut. This saves some work in the next step.</span></span><br><span class="line">    ClosePipes(pipes, statusOut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make statusOut automatically close if execvp() succeeds.</span></span><br><span class="line">    fcntl(statusOut, F_SETFD, FD_CLOEXEC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close remaining unwanted open fds.</span></span><br><span class="line">    CloseNonStandardFds(statusOut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch to working directory.</span></span><br><span class="line">    <span class="keyword">if</span> (workingDirectory != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (chdir(workingDirectory) == <span class="number">-1</span>) &#123;</span><br><span class="line">AbortChild(statusOut);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up environment.</span></span><br><span class="line">    <span class="keyword">if</span> (environment != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">extern</span> <span class="keyword">char</span>** environ; <span class="comment">// Standard, but not in any header file.</span></span><br><span class="line">      environ = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute process. By convention, the first argument in the arg array</span></span><br><span class="line">    <span class="comment">// should be the command itself.</span></span><br><span class="line">    execvp(commands[<span class="number">0</span>], commands);</span><br><span class="line">    AbortChild(statusOut);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is the parent process.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Close child's pipe ends.</span></span><br><span class="line">  close(stdinIn);</span><br><span class="line">  close(stdoutOut);</span><br><span class="line">  close(stderrOut);</span><br><span class="line">  close(statusOut);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check status pipe for an error code. If execvp(2) succeeds, the other</span></span><br><span class="line">  <span class="comment">// end of the pipe should automatically close, in which case, we'll read</span></span><br><span class="line">  <span class="comment">// nothing.</span></span><br><span class="line">  <span class="keyword">int</span> child_errno;</span><br><span class="line">  <span class="keyword">ssize_t</span> count = TEMP_FAILURE_RETRY(read(statusIn, &amp;child_errno, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">  close(statusIn);</span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// chdir(2) or execvp(2) in the child failed.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> track which so we can be more specific in the detail message.</span></span><br><span class="line">    jniThrowIOException(env, child_errno);</span><br><span class="line"></span><br><span class="line">    close(stdoutIn);</span><br><span class="line">    close(stdinOut);</span><br><span class="line">    close(stderrIn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reap our zombie child right away.</span></span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> rc = TEMP_FAILURE_RETRY(waitpid(childPid, &amp;status, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">-1</span>) &#123;</span><br><span class="line">      ALOGW(<span class="string">"waitpid on failed exec failed: %s"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill in file descriptor wrappers.</span></span><br><span class="line">  jniSetFileDescriptorOfFD(env, inDescriptor, stdoutIn);</span><br><span class="line">  jniSetFileDescriptorOfFD(env, outDescriptor, stdinOut);</span><br><span class="line">  jniSetFileDescriptorOfFD(env, errDescriptor, stderrIn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> childPid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有兴趣还可以继续看下kernel的代码<code>fs/pipe.c</code>是如何实现<code>pipe_write/pipe_read</code>以及<code>pipe_wait</code>是如何发生的.</p><p>这么一看代码流程, 如何解决这个问题的思路也有了, 大致有这么几种:</p><ul><li>直接在Java代码中去掉<code>Process.waitfor()</code>, 这个方法可能还是会有导致子进程阻塞的风险, 虽然不会死锁</li><li>在新的线程中读取子线程的输出流:<code>Process.getInputStream()</code>, 这样确保子进程不会被阻塞</li><li>直接将子进程的流全部丢弃(如果本身不感兴趣的话)</li><li>要写本地进程的人把所有这些不必要的打印全部去掉(这个最好不要当作终极解决方案)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近碰到一个看似很怪异的问题, 在两个APP上调用同样的本地指令得到的结果却大相径庭; 看源代码, 这个本地进程做的事情其实并不复杂:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从一个串口&lt;code&gt;/dev/ttyUSBX&lt;/code&gt;读取数据&lt;/li&gt;
&lt;li&gt;将数据写入到本地目录(读
      
    
    </summary>
    
      <category term="Java" scheme="http://sniffer.site/categories/Java/"/>
    
    
      <category term="Java" scheme="http://sniffer.site/tags/Java/"/>
    
      <category term="Process" scheme="http://sniffer.site/tags/Process/"/>
    
      <category term="waitfor" scheme="http://sniffer.site/tags/waitfor/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊TCP协议</title>
    <link href="http://sniffer.site/2019/07/30/%E8%81%8A%E4%B8%80%E8%81%8ATCP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://sniffer.site/2019/07/30/聊一聊TCP协议/</id>
    <published>2019-07-30T06:01:35.000Z</published>
    <updated>2019-09-05T01:56:37.026Z</updated>
    
    <content type="html"><![CDATA[<p>TCP(<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener">Transmission Control Protocol</a>)即传输控制协议, 位于TCP/IP协议栈的第三层传输层, 与UDP不同的是, TCP号称提供有链接的(connection-oriented), 可靠的(reliable)字节流服务, 很多其他应用层协议如HTTP/SMTP/MQTT都是基于TCP协议实现.</p><p>这篇文章我们就从定义的角度来看一看TCP协议的具体工作原理. 首先看下有链接的(<code>connection-oriented</code>)具体含义.</p><p>TCP在发送数据之前, 第一件事情就是要在通信的双方建立一个通信的链路, 这个有点像日常生活中的打电话: A向B发起通话请求, B确认后双方建立通信链接才能正式通话. TCP也一样, 在发送任何数据之前必须要建立链接(connection), 这个建立通信链接的过程就是我们常说的”三次握手”；同样, 如果要想结束通信, 也需要有一个挥手的过程(四次挥手).有关TCP链接的建立与关闭可以参考之前的一篇文章(<a href="http://sniffer.site/2019/07/15/TCP%E9%93%BE%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB/">TCP的链接建立与状态迁移</a>). 那么, TCP建立链接主要完成哪几件事情了?</p><ul><li>交换双方的ISN(Initial Sequence Number): ISN的作用(后面在讲重传时会再讲到)是用来确保每个TCP数据包都是唯一的, 接收端如果收到了重复包可以根据每个包的序列号来实现去重</li><li>确认发送数据的MSS(Maximum Segment Size): MSS是TCP能发送的数据的最大值, 通过TCP头中的<code>options</code>交换, 默认值是536, 一般是当前系统MTU(Maximum Transmission Unit)的值减去TCP/IP协议头的大小之和(40byte), 其与MTU关系如下图所示</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcp-mss.png" alt="MSS vs MTU"></p><ul><li>接收窗口的大小: 在TCP头中有一个<code>window</code>项, 用来告诉对端自己接收缓冲区的大小, 这个窗口在拥塞与流量控制中扮演着十分重要的角色, 用于告诉发送方最大可以发送的数据大小</li></ul><p>通信双方在三次握手完成之后, 都知道了对方的初始序列号(<code>ISN</code>), 接收窗口大小以及MSS, 这样发送方就可以开始愉快的发送数据了. 接着讲第二个方面: TCP是如何做到要数据的可靠(<code>reliable</code>)传输的? 为了实现这一目标,TCP需要解决很多问题: </p><ol><li><p>数据在网络上丢包了如何办? TCP对于每个数据包都有个定时器, 如果接收方长时间没有回应, 在定时器超是后就会发起重传, 那么如何选择这个定时器的时长? 重传时间(Retransmission Timeout, RTO)太长, 导致数据传输效率太低; RTO太短, 则可能导致重传的数据包太多, 引发更大的网络拥堵.</p></li><li><p>发送方如何来控制自己数据的发送速率, 确保接收方能够处理的过来. 发送方不能不顾一切的发送数据, 而不管接收方是否有足够的空间来接受数据. 因此, TCP在接收方忙/没有足够空间接收数据时都会主动降低发送速度, 让接收方可以有机会及时恢复.这个是TCP流量控制(<code>flow control</code>)需要做的事情</p></li><li><p>如果网络发生拥塞, TCP应该如何处理?发送端不能不顾及网络带宽以及拥堵状态而只管发送数据包, 进而影响其他用户正常使用网络.为了体现网络使用的公平性, 确保不同用户能够都能均衡的使用网络, 减少用户之间的相互干扰, TCP通过多种拥塞控制(<code>Congestion Control</code>)手段来减少网络拥堵, 并且在发生拥堵时尝试尽快恢复.</p></li></ol><p>具体说来TCP主要通过如下几个方式来解决上述几个问题:</p><ul><li>重传时间的计算: 如何实时调整RTO(<code>retransmission timeout</code>)的大小, 确保重传的频率在合适的范围</li><li>流量控制(<code>flow control</code>): 通过滑动窗口(<code>sliding window</code>)机制来实现数据发送的流量控制</li><li>拥塞控制(<code>Congestion Control</code>): 拥塞控制主要有 (1) 慢启动 ; (2) 拥塞避免； (3) 拥塞发生； (4) 快速恢复. 在后面会一一介绍这几个算法的原理.</li></ul><h2 id="何时重传"><a href="#何时重传" class="headerlink" title="何时重传"></a>何时重传</h2><p>为了确保数据的可靠传达, TCP每发送一个数据包, 接收方都要回应一个ACK包, 发送方在发送完一个数据包后就会启动一个重传定时器(<code>retransmission timer</code>), 如果在定时器超时后都未能收到对方的ACK包, 就会重传. 那么如何发送方如何知道重传的超时时间(<code>Retransmission Timeout</code>, RTO)? (在TCP的标准协议文档<a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC793</a>中给出了一个低通滤波的计算方式, 式中<code>alpha</code>一般为0.9, <code>RTT</code>(Round Trip Time)表示测量得到的返程时间, <code>R</code>表示平滑后的RTT:  $$ R = \alpha R + (1 - \alpha) RTT$$</p><p>而RTO是在平滑后的RTT乘以一个系数<code>beta</code>(一般取值为2)得到:</p><p>$$ RTO = \beta R $$</p><p>按照上述的计算得到RTO, 由于采用低通滤波,因而没有考虑到在网络发生波动(比如网络拥堵, 路由故障等)等情况下RTT变大的情况, 导致不必要的重传, 反而带来更大的网络负载, 导致网络陷入持久的拥堵.针对该问题, Jacobson在1988年提出了一个改进的RTO计算方法(<a href="https://ee.lbl.gov/papers/congavoid.pdf" target="_blank" rel="noopener">链接</a>, 该算法考虑到了由于网络波动导致的延迟, 因此可以更准确的反映网络拥塞状态:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/how_rto_calculated.png" alt="rto"></p><p>上述公式, <code>MRTT</code>代表实际测量得到的RTT, <code>SRTT</code>表示平滑后的RTT值, D实际表示的是RTT的平均方差(不是平方差), <code>g</code>一般设为1/8(0.125), 而<code>h</code>设为0.25.对于发生了重传的情况, RTO一般会通过<a href="https://en.wikipedia.org/wiki/Exponential_backoff" target="_blank" rel="noopener">指数回退</a>的方式进行倍乘(Karn and Partridge 1987).</p><h2 id="流量控制-如何控制发送速率"><a href="#流量控制-如何控制发送速率" class="headerlink" title="流量控制: 如何控制发送速率"></a><strong>流量控制: 如何控制发送速率</strong></h2><p>收发数据的两端常常在网络带宽以及性能上都存在差异, (快的)发送方如果不控制发送的速度, 可能会让处在慢速网络中的接收方不知所措.因此, 为了实现数据的可靠传输, TCP需要根据接收方的信息及时调整发送速率, 这个控制发送流量的技术就是著名的滑动窗口(<code>sliding window</code>)协议.简单地讲, 滑动窗口是要根据接收方的可用<code>window</code>(TCP缓存)的大小来达到调整接收方流量大小的目的, 下图是一个滑动窗口示意图(图片来自<a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-7.htm" target="_blank" rel="noopener">TCP/IP Guide</a>):</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcpswwindows.png" alt="TCP sliding window"></p><p>图中的数据主要分为4个部分:</p><ul><li>‘#1’: 表示已经发送的数据, 并且收到了ACK</li><li>‘#2’: 表示发送了的数据, 但是没有收到ACK确认</li><li>‘#3’: 尚未发送的数据(接收方还有空间)</li><li>‘#4’: 不可发送的数据(接收方没有足够空间, 无能为力)</li></ul><p>当发送了部分<code>#3</code>的数据更新后的滑动窗口如下图所示(图片来自<a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-7.htm" target="_blank" rel="noopener">TCPIP Guide</a>):</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcpswaftersendnow.png" alt="TCP after sliding window"></p><p>可以看到此时<code>可用的部分窗口</code>大小变成了0, 后续要等到接收方确认了<code>#2</code>部分的数据后, 窗口才会继续往前滑动.那么TCP协议是如何在数据传输过程中调整窗口大小(<code>window size</code>)的了? 了解TCP协议的人应该记得, 在TCP协议头有一个专门的字段<code>window</code>用于通信的两端来告知对方当前窗口的大小(能接收多少数据), 而通过<code>socket</code>的<code>SO_RCVBUF</code>参数可以来设置通信时接收缓冲区的大小(<a href="http://man7.org/linux/man-pages/man7/socket.7.html" target="_blank" rel="noopener">socket(7)</a>). 下图是一个接发数据过程通信两端TCP窗口大小的更新过程:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcpswflow.png" alt="TCP window size update"></p><ul><li>在发送数据的开始, 接收端会在三次握手时告知发送端自己的<code>window size</code>(图中为360)</li><li>随着发送端不断发送数据, 接收端的<code>window</code>会逐渐减少, 直到为0, 此时发送端会暂停发送数据</li></ul><p>问题来了, 如果接收方的<code>window</code>为0, 要如何处理?对于接收端, 在接收缓冲区可用后(如应用从读取了部分数据), 会发送一个<code>window update</code>的ACK包, 那万一这个ACK在传输过程中丢失了怎么办? 这样就会导致发送端的TCP无法正常关闭, 因此需要通过在发送端每隔一段时间就发送一个<code>Zero Window Probe</code>的探测包, 来获取接收端窗口的状态, 关于ZWP的说明可以参考(<a href="https://tools.ietf.org/html/rfc1122#page-92" target="_blank" rel="noopener">RFC1122</a>)的讨论.</p><h3 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a><strong>Silly Window Syndrome</strong></h3><p>Silly Window Syndrome(中译为<code>糊涂窗口综合症</code>)的意思是, 接收端的应用可能每次都只拿走很少的一部分(比如几个字节)的数据, 因此每次<code>window update</code>后发送端也只会发送几个字节的数据, 而我们知道, 光TCP+IP两个协议头都需要40个字节的空间,这样的传输效率看起来太低了.针对该问题, 有两种策略:</p><ul><li><p>如果问题发生在接收端(接收端处理太慢等), 则可以在<code>window</code>小于某个值时, 直接向发送端ACK一个<code>window=0</code>的包, 告诉发送端暂停发送, 等<code>window</code>大于某个值(比如<code>MSS/2</code>)时再发送<code>window update</code>包让发送方继续发送数据;</p></li><li><p>而如果问题发生在发送方,则可以考虑Nagle在1984年提出的<code>Nagle Algorithm</code><a href="https://tools.ietf.org/html/rfc896" target="_blank" rel="noopener">RFC896</a>: 对于一个TCP连接, 只要还有一个数据包的没有被确认, 就将应用发送的数据缓存下来, 直到接收到该数据包的ACK之后才允许发送新的数据.这样TCP就尽可能的发送”大”的数据包, 而不是发送多个小包, 导致效率降低. 但对于某些交互式应用如<code>Telenet/SSH/Rlogin</code>, 为了避免延时带来的交互延时, 通常需要关闭<code>Nagle</code>算法, 可以通过socket的选项参数<code>TCP_NODELAY</code>来关闭该算法, 从而提升交互体验.</p></li></ul><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><strong>拥塞控制</strong></h2><p>TCP的滑动窗口很好的控制了接收端与发送端的包速率,  但并没有考虑到中间网络如路由器/交换机拥塞/故障引发的网络拥堵, 为了避免网络拥塞引起网络瘫痪(<code>congestion collapse</code>), TCP需要对网络的拥塞信号做出反应(发生丢包/包乱序等). 总的说来, TCP的拥塞控制(<code>congestion control</code>)是为了: </p><ul><li>(1) 尽可能减少拥塞导致的网络瘫痪(如某个路由节点由于不堪重负崩溃或者卡死)；</li><li>(2) 网络使用的公平性(<code>faireness</code>): TCP的目标是尽可能使每个网络的使用者都达到比较好的体验, 避免某一个发送端或者接收端过度的占用网络带宽. </li></ul><p>在RFC5681(<a href="https://tools.ietf.org/html/rfc5681" target="_blank" rel="noopener"><code>TCP Congestion Control</code></a>)中总结了四个拥塞控制算法:</p><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a><strong>慢启动</strong></h3><p>TCP慢启动(<code>slow start</code>)的意思是开始发送数据时, 尽量逐步增加发送的数据量, 而不是最开始就发送一个大的数据包, 这样试探性的发送数据可以减少网络拥塞.为了实现慢启动以及拥塞避免(与慢启动配套的算法, 接下来会讲到), 需要引入两个状态变量: (1) 拥塞窗口(<code>congestion window</code>) <code>cwnd</code>; (2) 慢启动阈值(<code>slow start threshold</code>) <code>ssthresh</code>, 这个阈值用于慢启动与拥塞避免两个算法之间的切换.</p><p>慢启动算法的大致步骤如下:</p><ol><li>将<code>cwnd</code>设为1, 表示一个MSS大小(<a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf" target="_blank" rel="noopener">目前一般Linux系统都按照Google的建议</a>将该值设为10)</li><li>每次接收到一个ACK后, <code>cwnd += 1</code></li></ol><p>这样收到一个ACK后,<code>cwnd</code>变为2,接着会发出两个MSS的数据包, ACK会变成4, 最终发送的包数量呈指数上升.等到<code>cwnd &gt; ssthresh</code>, 则进入拥塞避免阶段, TCP会根据收发包的丢包重传的情况, 适当调整<code>cwnd</code>的值, 确保不要让网络变得过度拥堵.</p><h2 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a><strong>拥塞避免</strong></h2><p>当<code>cwnd &gt; ssthresh</code>时, TCP进入拥塞避免(<code>congestion avoidance</code>), 此时<code>cwnd</code>会进入线性调整阶段:</p><ol><li><code>sshthresh</code>的值大小一般初始化为65535(<code>0x7ffffff</code>)</li><li>cwnd += 1/cwnd(参考[<a href="https://tools.ietf.org/html/rfc5681]" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc5681]</a></li><li>每过一个RTT, 则<code>cwnd = cwnd + 1</code></li></ol><p>当发生RTO重传时, 需要减少<code>sshthresh</code>的值, 同时减少<code>cwnd</code>的值: </p><ul><li><code>sshthresh = max(FlightSize/2, 2*MSS)</code></li><li><code>cwnd = 1</code></li></ul><p>这样在重传之后TCP又进入了慢启动模式, 逐步增加发送数据包的速率.</p><h2 id="快速重传与快速恢复"><a href="#快速重传与快速恢复" class="headerlink" title="快速重传与快速恢复"></a><strong>快速重传与快速恢复</strong></h2><p>先来了解下快速重传(<code>fast restransmition</code>)与快速恢复(<code>fast recovery</code>)的具体含义:</p><ul><li>快速重传: 在TCP接收到连续3次DACK(<code>duplicate ACK</code>)后, 主动重传丢失的数据包, 而不是等到RTO超时</li><li>快速恢复: 当TCP完成快速重传后, 会进入拥塞避免而不是慢启动, 这样确保发送的流量在适当的拥塞之后保持稳定</li></ul><p>一般来说, 快速重传与快速恢复是同一起实现的, 具体的流程如下:</p><ul><li>如果连续收到三个DACk包, 则重传丢失的数据包</li><li>更新拥塞窗口以及慢启动阈值: <code>sshthresh = max(FlightSize/2, 2*MSS)</code> 以及<code>cwnd = ssthresh + 3 * MSS</code></li><li>后续每收到一个DACK, 增加将拥塞窗口加一: <code>cwnd = cwnd + 1</code></li><li>如果收到ACK, 则<code>cwnd = sshthresh</code>, 这样TCP会再次进入拥塞控制</li></ul><p>实际TCP针对丢包与重传的情况还有很多改善型算法, 详细可以参考<a href="https://tools.ietf.org/html/rfc5681" target="_blank" rel="noopener">RFC5681</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://www.tcpipguide.com/free/t_TCPWindowSizeAdjustmentandFlowControl-2.htm" target="_blank" rel="noopener">TCP流量控制</a></li><li><a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo.htm" target="_blank" rel="noopener">TCP滑动窗口</a></li><li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">TCP的那些事情, 耗子叔的力作</a></li><li><a href="https://tools.ietf.org/html/rfc2914" target="_blank" rel="noopener">Congestion Control Principles</a></li><li><a href="https://tools.ietf.org/html/rfc7414" target="_blank" rel="noopener">TCP roadmap</a></li><li><a href="https://tools.ietf.org/html/rfc5681" target="_blank" rel="noopener">TCP congestion control</a></li><li><a href="https://tools.ietf.org/html/rfc1122" target="_blank" rel="noopener">TCP/IP协议的各种问题的总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCP(&lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Transmission Control Protocol&lt;/a
      
    
    </summary>
    
      <category term="网络协议" scheme="http://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="TCP" scheme="http://sniffer.site/tags/TCP/"/>
    
      <category term="拥塞控制" scheme="http://sniffer.site/tags/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>TCP链接建立与状态迁移</title>
    <link href="http://sniffer.site/2019/07/15/TCP%E9%93%BE%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB/"/>
    <id>http://sniffer.site/2019/07/15/TCP链接建立与状态迁移/</id>
    <published>2019-07-15T07:17:03.000Z</published>
    <updated>2019-07-15T08:38:09.533Z</updated>
    
    <content type="html"><![CDATA[<p>学习TCP协议的第一步是要了解熟悉TCP的三次握手/四次挥手以及状态迁移图. 这篇文章用三个图展示TCP链接的建立与关闭以及状态的迁移.</p><h2 id="TCP状态迁移"><a href="#TCP状态迁移" class="headerlink" title="TCP状态迁移"></a><strong>TCP状态迁移</strong></h2><p>根据TCP协议的文档<a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC793</a>, 一个TCP链接有下图中的几个状态(图中实粗线为Client端的正常情况下状态迁移图, 虚线为Server端正常情况下的状态迁移图):</p><ul><li><code>CLOSED</code>: TCP链接的初始状态, 表示没有任何链接</li><li><code>LISTEN</code>: (服务端)等待来自远程客户端的请求</li><li><code>SYN_SENT</code>: 发送了一个建立TCP链接的SYN请求, 等待对端返回结果</li><li><code>SYN_RCVD</code>: 收到了TCP建立链接的SYN包, 等待对方的回应(ACK)</li><li><code>ESTABLISHED</code>: TCP链接建立成功, 从这里开始可以交换数据包了</li><li><code>FIN_WAIT1</code>: 应用进程关闭了TCP链接(发送FIN包), 并等待对端的响应</li><li><code>FIN_WAIT2</code>: 接收到关闭回应后, 等待对端结束TCP链接(等待FIN包)</li><li><code>CLOSING</code>: 如果两端同时接收到了FIN包, 则进入该状态</li><li><code>CLOSE_WAIT</code>:处于被动关闭一端接受到FIN请求后, 等待本地进程的关闭TCP链接</li><li><code>LAST_ACK</code>: 服务端本地进程关闭TCP链接后, 发送FIN包, 等待回应</li><li><code>TIME_WAIT</code>: 等待2*MSL(TCP包的最大存活时间)后关闭该TCP链接, 等待足够长的时间是为了确保最后关闭链接的ACK包有足够长的时间达到对端, 如果对端未能收到该包, 则会重传FIN包, 这样对端也可以重传ACK包, 一般MSL为60s</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/TCP_state_transition.png" alt="TCP state transition"></p><h2 id="TCP三次握手与四次挥手"><a href="#TCP三次握手与四次挥手" class="headerlink" title="TCP三次握手与四次挥手"></a><strong>TCP三次握手与四次挥手</strong></h2><p>正常情况下, TCP的三次握手与四次挥手如下图所示:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcp_three_way_handeshake.png" alt="TCP connection establish/close"></p><h2 id="同时关闭时的TCP状态变化"><a href="#同时关闭时的TCP状态变化" class="headerlink" title="同时关闭时的TCP状态变化"></a><strong>同时关闭时的TCP状态变化</strong></h2><p>如果TCP通信的两端同时请求关闭链接, 流程如下图所示:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcp_simutaneous_close.png" alt="TCP simutaneous close"></p><p>关于TCP协议的参考资料:</p><ul><li>RFC793: 这是有关TCP协议的标准文本, 信息的源头</li><li>&lt;TCP/IP详解 卷1&gt;: W. Richard Stevens的经典, 必看</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习TCP协议的第一步是要了解熟悉TCP的三次握手/四次挥手以及状态迁移图. 这篇文章用三个图展示TCP链接的建立与关闭以及状态的迁移.&lt;/p&gt;
&lt;h2 id=&quot;TCP状态迁移&quot;&gt;&lt;a href=&quot;#TCP状态迁移&quot; class=&quot;headerlink&quot; title=&quot;TC
      
    
    </summary>
    
      <category term="网络协议" scheme="http://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="TCP" scheme="http://sniffer.site/tags/TCP/"/>
    
      <category term="三次握手" scheme="http://sniffer.site/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    
      <category term="四次挥手" scheme="http://sniffer.site/tags/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>PPP拨号时拿到错误DNS的问题解析</title>
    <link href="http://sniffer.site/2019/07/05/PPP%E6%8B%A8%E5%8F%B7%E6%97%B6%E6%8B%BF%E5%88%B0%E9%94%99%E8%AF%AFDNS%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://sniffer.site/2019/07/05/PPP拨号时拿到错误DNS的问题/</id>
    <published>2019-07-05T09:56:32.000Z</published>
    <updated>2020-05-19T11:34:47.922Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到一个PPP拨号拿到了假的DNS地址<code>10.11.12.13/14</code>, 之前也发生过一次, 但是一直没有有效的日志, 所以就简单粗暴的做了一个方案: 在PPP拨号进行网络参数协商时, 如果发现拿到了<code>10.11.12.13/14</code>这样的DNS地址就修改为指定的运营商DNS地址. 本来以为万事大吉了, 没想到运营商DNS一改, 问题又暴露了, 好在重现抓到了现场日志, 终于找到了原因. 网上看有原来也有不少人碰到了类似现象(<a href="https://bugzilla.redhat.com/show_bug.cgi?id=467004#c31)" target="_blank" rel="noopener">https://bugzilla.redhat.com/show_bug.cgi?id=467004#c31)</a>, 在这里简要的描述下整个问题的来龙去脉并给出几种可能的解决方案.</p><p>在介绍这个问题的根因之前, 先来了解下PPP协议的一些基本概念.</p><h2 id="PPP协议介绍"><a href="#PPP协议介绍" class="headerlink" title="PPP协议介绍"></a><strong>PPP协议介绍</strong></h2><p>PPP(Point-to-Point Protocol)是在SLIP(Serial Line Internet Protocol)的基础上发展而来, 其通过在终端与远端(remote peer)之间建立一个IPPP数据链路, 将终端设备接入网络. 早些年上网的时候, 把一个<a href="https://en.wikipedia.org/wiki/Asymmetric_digital_subscriber_line" target="_blank" rel="noopener">ADSL</a> modem跟电脑连接后, 拿着运营商给的用户名与密码, 然后拨号接入互联网,这里边用到的协议就是<a href="https://en.wikipedia.org/wiki/Point-to-Point_Protocol_over_Ethernet" target="_blank" rel="noopener">PPP</a>.</p><p>PPP协议位于TCP/IP协议栈的第二层-数据链路层(见下图), 其主要有三个部分组成:</p><ul><li>包封装: 如何将网络报文如IP报文封装成类似与HDLC的格式</li><li>LCP协议: Link Control Protocol, 负责建立数据链路, 验证用户身份以及测试链路的连通状态</li><li>NCP协议: Network Control Protocol, 负责适配其他协议, 如针对IP协议有IPCP协议, 该协议的功能是从网络侧拿到IP地址以及DNS地址 </li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/PPP_stack.png" alt="PPP in TCP/IP stack"></p><p>一般来说, PPP拨号上网有如下几个阶段:</p><ul><li>链路建立阶段(Establish): LCP协议负责建立数据链路, 建立链路过程主要是协商数据的压缩格式以及最大传输单元MRU(Maximum Receive Unit, 类似于MTU)</li><li>身份验证阶段(Authenticate): 主要是通过PAP/CHAP等协议验证用户的身份(用户名与密码)</li><li>网络阶段(Network): 协商网络参数, 如IP地址, DNS地址等. 网络阶段完成后, 就可以真正进行数据报文的接发了.</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/PPP_phase_diagram.jpg" alt="PPP phone diagram"></p><p>在NCP阶段, PPP拨号进行参数协商过程中一般都有如下几个指令: <code>Configure-Request</code>(发起参数协商), <code>Configure-Ack</code>(如果同意该参数则发送ACK给对端), <code>Configure-Nak</code>(如果参数合法, 但是有不同意对方的某些参数, 则发送NAK给对端), <code>Configure-Reject</code>(如果不同意对方发送过来的参数, 则直接发送Reject), 具体可以参考RFC1661的文档(<a href="https://tools.ietf.org/html/rfc1661" target="_blank" rel="noopener">rfc1661</a>).下图是一个完整基于IPCP协议的消息交换过程:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ipcp_process.png" alt="IPCP process"></p><p>有了这些知识背景, 就来看下具体的问题是怎么样的.</p><h2 id="假DNS问题的来由"><a href="#假DNS问题的来由" class="headerlink" title="假DNS问题的来由"></a><strong>假DNS问题的来由</strong></h2><p>问题发生终端大致的网络架构如下图所示:终端通过modem与运营商的LNS节点建立一个PPP的链路, 然后通过该链路接入私有网络:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ppp_mobile_network_architecture.png" alt="ppp network architecture"></p><blockquote><p>图中的<code>LAC</code>/<code>LNS</code>分别指<code>L2TP Access Concentrator</code>/<code>L2TP Network Server</code>， 参考<a href="https://en.wikipedia.org/wiki/Layer_2_Tunneling_Protocol" target="_blank" rel="noopener">Wikipedia</a></p></blockquote><p>这里系统使用的是高通的modem, 在LTE网络下使用PPP拨号从运营商网关拿IP/DNS地址. PPP拨号时, 实际已经通过了身份验证, 但在IPCP协议进行参数协商时, 前面一直拿到了<code>10.11.12.13/14</code>这样的DNS地址, 后面运营商下发了正确的DNS地址, modem也未能把正确的DNS地址发送过来, PPPD拨号的过程日志如下, </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.024</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : <span class="keyword">using</span> channel <span class="number">3</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.024</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [LCP ConfReq id=<span class="number">0x1</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;magic <span class="number">0x6c3c9df8</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.024</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [LCP ConfReq id=<span class="number">0x3</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;auth pap&gt; &lt;magic <span class="number">0xf2cb3c8d</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.024</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [LCP ConfAck id=<span class="number">0x3</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;auth pap&gt; &lt;magic <span class="number">0xf2cb3c8d</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.024</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [LCP ConfAck id=<span class="number">0x1</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;magic <span class="number">0x6c3c9df8</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [LCP DiscReq id=<span class="number">0x4</span> magic=<span class="number">0xf2cb3c8d</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [PAP AuthAck id=<span class="number">0x1</span> <span class="string">""</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> I pppd    : PAP authentication succeeded</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [CCP ConfReq id=<span class="number">0x1</span> &lt;deflate <span class="number">15</span>&gt; &lt;deflate(old#) <span class="number">15</span>&gt; &lt;bsd v1 <span class="number">15</span>&gt;]</span><br><span class="line"><span class="comment">// IPCP开始协商IP地址, DNS地址等参数</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x1</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns3 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [LCP ProtRej id=<span class="number">0x5</span> <span class="number">80</span> fd <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0f</span> <span class="number">1</span>a <span class="number">04</span> <span class="number">78</span> <span class="number">00</span> <span class="number">18</span> <span class="number">04</span> <span class="number">78</span> <span class="number">00</span> <span class="number">15</span> <span class="number">03</span> <span class="number">2f</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">38.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x1</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">38.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x2</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">39.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x2</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">39.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x3</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">40.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x3</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">40.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x4</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">41.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x4</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">41.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x5</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">42.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x5</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">42.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x6</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">43.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x6</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">43.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x7</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">44.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x7</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">44.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x8</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x8</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x9</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="comment">// 到现在才收到远端(remote peer)的IP协商请求</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfReq id=<span class="number">0x2</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfNak id=<span class="number">0x2</span> &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfRej id=<span class="number">0x9</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0xa</span> &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfReq id=<span class="number">0x3</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfAck id=<span class="number">0x3</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0xa</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0xb</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfAck id=<span class="number">0xb</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> W pppd    : Could <span class="keyword">not</span> determine remote IP address: defaulting to <span class="number">10.64</span><span class="number">.64</span><span class="number">.64</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.654</span>  <span class="number">3183</span>  <span class="number">3183</span> I pppd    : local  IP address <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.654</span>  <span class="number">3183</span>  <span class="number">3183</span> I pppd    : remote IP address <span class="number">10.64</span><span class="number">.64</span><span class="number">.64</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.654</span>  <span class="number">3183</span>  <span class="number">3183</span> I pppd    : primary   DNS address <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.654</span>  <span class="number">3183</span>  <span class="number">3183</span> I pppd    : secondary DNS address <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.654</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : Script /etc/ppp/ip-up started (pid <span class="number">3229</span>)</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.714</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : Script /etc/ppp/ip-up finished (pid <span class="number">3229</span>), status = <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>可以看到在第一次PPP参数协商时, PPPD就收到了这样的配置, 这里<code>ms-wins</code>参数是针对微软的客户端产生的配置(在Linux系统下并没有什么作用):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">38.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x1</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br></pre></td></tr></table></figure><p>再来对比下正常的PPPD拨号的情况, PPPD拨号时首先很快就收到了<code>IPCP ConfReq id=0x0</code>的请求, 这个请求是告诉客户端可以发起IP地址的协商了, 于是客户端就发了<code>NAK</code>包告诉服务端自己的IP地址是空的<code>sent [IPCP ConfNak id=0x0 &lt;addr 0.0.0.0&gt;]</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : <span class="keyword">using</span> channel <span class="number">1</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [LCP ConfReq id=<span class="number">0x1</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;magic <span class="number">0x2d6bff1</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [LCP ConfReq id=<span class="number">0x0</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;auth pap&gt; &lt;magic <span class="number">0xf2cab769</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [LCP ConfAck id=<span class="number">0x0</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;auth pap&gt; &lt;magic <span class="number">0xf2cab769</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [LCP ConfAck id=<span class="number">0x1</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;magic <span class="number">0x2d6bff1</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [LCP DiscReq id=<span class="number">0x1</span> magic=<span class="number">0xf2cab769</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [PAP AuthAck id=<span class="number">0x1</span> <span class="string">""</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> I pppd    : PAP authentication succeeded</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [CCP ConfReq id=<span class="number">0x1</span> &lt;deflate <span class="number">15</span>&gt; &lt;deflate(old#) <span class="number">15</span>&gt; &lt;bsd v1 <span class="number">15</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x1</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns3 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [LCP ProtRej id=<span class="number">0x2</span> <span class="number">80</span> fd <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0f</span> <span class="number">1</span>a <span class="number">04</span> <span class="number">78</span> <span class="number">00</span> <span class="number">18</span> <span class="number">04</span> <span class="number">78</span> <span class="number">00</span> <span class="number">15</span> <span class="number">03</span> <span class="number">2f</span>]</span><br><span class="line"><span class="comment">// 很快收到IP地址协商请求</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [IPCP ConfReq id=<span class="number">0x0</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [IPCP ConfNak id=<span class="number">0x0</span> &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [IPCP ConfRej id=<span class="number">0x1</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x2</span> &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns3 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [IPCP ConfReq id=<span class="number">0x1</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [IPCP ConfAck id=<span class="number">0x1</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x2</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x3</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [IPCP ConfAck id=<span class="number">0x3</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> W pppd    : Could <span class="keyword">not</span> determine remote IP address: defaulting to <span class="number">10.64</span><span class="number">.64</span><span class="number">.64</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.980</span>  <span class="number">1643</span>  <span class="number">1643</span> I pppd    : local  IP address <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.980</span>  <span class="number">1643</span>  <span class="number">1643</span> I pppd    : remote IP address <span class="number">10.64</span><span class="number">.64</span><span class="number">.64</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.980</span>  <span class="number">1643</span>  <span class="number">1643</span> I pppd    : primary   DNS address <span class="number">211.</span>xxx.xxx.xxx</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.980</span>  <span class="number">1643</span>  <span class="number">1643</span> I pppd    : secondary DNS address <span class="number">211.</span>xxx.xxx.xxx</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.980</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : Script /etc/ppp/ip-up started (pid <span class="number">1682</span>)</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">02.060</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : Script /etc/ppp/ip-up finished (pid <span class="number">1682</span>), status = <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>接着又发了一个地址配置的请求, 在收到服务端的配置后,并相互确认后最终拿到了正确的IP地址/DNS地址:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sent [IPCP ConfReq id=<span class="number">0x2</span> &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns3 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line">rcvd [IPCP ConfNak id=<span class="number">0x2</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br><span class="line">sent [IPCP ConfReq id=<span class="number">0x3</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br><span class="line">rcvd [IPCP ConfAck id=<span class="number">0x3</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br></pre></td></tr></table></figure><p>单纯从PPPD拨号的LOG来看, 流程上就有不小的差异: 异常情况迟迟收不到远端(这是是运营商的服务器)的IP地址协商的请求<code>ConfReq</code>, 而发出去的<code>IPCP ConfReq</code>参数协商请求一直拿到了假的DNS地址<code>10.11.12.13/14</code>(这个地址实际是modem产生的不是来自网络), 对端回过来的地址一直都是全零<code>0.0.0.0</code>, 导致客户端一直发送<code>ConfReq</code>,直到远端(remote peer)的<code>NAK</code>超过最大的次数(PPPD代码默认是5)后,才停止DNS的协商过程(看pppd的代码是默认关闭了对DNS的协商请求).</p><p>那么问题的根源在哪里了? 抓了modem的日志给供应商分析才发现, 本端(local peer)在PDN(Packet Data Network)数据链接尚未建立的情况下(相当于终端与运营商还没有建立物理上的通路)就去发起IPCP参数协商了, 此时modem还没有拿到IP地址和DNS地址, 因此就给了一个假的DNS地址了. 等到几秒钟后PDN建立成功, 运营商网络正常下发分配的IP地址与DNS地址后, modem却没有主动下发正确的DNS地址, 而本端的pppd也没有再次请求DNS地址, 这样到了PPP拨号完成本地拿到的始终是一个假的DNS地址.</p><p>找到了问题的原因之后, 解决问题就好办了. 大概有这么几个解决方案:</p><ol><li>在modem侧修改: 如果PDN链接建立成功后, 主动下发正确的DNS地址(运营商给的DNS地址)</li><li>在本端的PPPD中修改: 如果发现拿到的DNS地址为<code>10.11.12.13/14</code>, 则在接收到远端的<code>NAK</code>时将该地址拒绝, 并且在下次参数协商时主动告诉远端自己没有拿到DNS地址, 这样远端会在下一个<code>NAK</code>中主动将正确的DNS发送过来(如果已经有了的话)</li><li>在PPPD拨号时将参数<code>connect-delay</code>设置为<code>5000</code>(5s, 默认是<code>1000</code>), 这个相当于尽量等待PDN的链接, 等成功后再进行参数协商. 这个方案只能在一定程度上缓解问题发生的概率, 并不能从根本上解决问题.</li><li>如果收到假的DNS地址<code>10.11.12.13/14</code>, 则强制修改为正确的运营商DNS地址(如果运营商DNS地址发生变化, 又会出问题, 不是终极解决方案)</li></ol><p>目前采用了方案二, 初步验证可以拿到正确的DNS地址.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近碰到一个PPP拨号拿到了假的DNS地址&lt;code&gt;10.11.12.13/14&lt;/code&gt;, 之前也发生过一次, 但是一直没有有效的日志, 所以就简单粗暴的做了一个方案: 在PPP拨号进行网络参数协商时, 如果发现拿到了&lt;code&gt;10.11.12.13/14&lt;/co
      
    
    </summary>
    
      <category term="网络协议" scheme="http://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="PPP" scheme="http://sniffer.site/tags/PPP/"/>
    
      <category term="DNS" scheme="http://sniffer.site/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>如何在Android Studio中添加自定义framework.jar?</title>
    <link href="http://sniffer.site/2019/02/26/%E5%9C%A8Android-Studio%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89framework-jar/"/>
    <id>http://sniffer.site/2019/02/26/在Android-Studio中添加自定义framework-jar/</id>
    <published>2019-02-26T12:12:26.000Z</published>
    <updated>2019-02-27T08:50:42.088Z</updated>
    
    <content type="html"><![CDATA[<p>这两天有一个新的功能需求要实现, 要在Android原生代码的<code>Settings</code>(代码目录<code>android/frameworks/base/core/java/android/provider</code>)数据库添加一个新的数据项, 一个系统应用(独立于Android系统源码编译)需要引用该数据项. 那么, 怎么将新的数据项引用到系统应用中了? &lt;! – more –&gt;</p><blockquote><p>备注: 以下所有的示例都基于Android Studio 3.2/操作系统Ubuntu 18.04.1</p></blockquote><p>首先, 在Android源码中修改完成后, 执行本地编译, 在<code>/android/out</code>目录下, 找到编译产生的新的<code>framework</code>模块的<code>jar</code>包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes-full-debug.jar</span><br></pre></td></tr></table></figure><p>最开始, 打开该<code>jar</code>包, 将<code>/android/provider/</code>目录下的所有<code>class</code>文件复制到<code>Android Studio</code>中的SDK的<code>platforms/android-23</code>, 重新<code>clean/build</code>一次, 项目中对新建的数据项的符号引用立刻就正常了.但一提交到远程服务器, 后台编译出错, 提示找不到符号了~~~what!</p><p>马上就要发布版本了, 怎么办?只好硬着头皮找其他法子了…参考了网上已有的很多文档, 编译一直报错. 不得已开始想着要通过广播的形式来替换掉现有的通过<code>ContentProvider</code>的方式, 这样就避开修改Android SDK了, 但广播存在这么几个问题:</p><ul><li>任何人都可以监听接收该广播, 安全性与性能都大打折扣;</li><li>如果接收方线程阻塞, 会导致广播超时, 造成应用ANR</li></ul><p>整个需求的方案已经定了, 再去该明显会被打回的, 而且就该功能的实现而言, 只有在某个状态变化时, 才要求告知上层, 这个正是<code>ContentProvider</code>可以达成的逻辑. 转了一圈, 只好又回到原来的方案. 跟同事沟通了配置的方法, 编译终于通过, 但是验证测试时又碰到了问题….这里记录下来整个过程, 也算是为后来的Android SDK定制积攒点经验.</p><h2 id="添加framework-jar到AS"><a href="#添加framework-jar到AS" class="headerlink" title="添加framework.jar到AS"></a><strong>添加framework.jar到AS</strong></h2><p>将编译好的Android框架层jar包<code>framework.jar</code>放到<code>/app/libs/</code>下面, 然后在应用<code>app</code>的配置<code>build.gradle</code>下面添加一个依赖项, 这里的<code>provided</code>表示该依赖只在编译时起作用, 不会把对应的jar文件编译到最终的APK中去:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    provided files(&apos;libs/framework.jar&apos;)</span><br><span class="line">    //compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将framework-jar设置为bootclass"><a href="#将framework-jar设置为bootclass" class="headerlink" title="将framework.jar设置为bootclass"></a><strong>将framework.jar设置为bootclass</strong></h2><p>为了让库生效, 需要在编译开始时, 将<code>framework.jar</code>设置为当前所有子项目的启动文件(boot class):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 设置为bootclass</span><br><span class="line">    gradle.projectsEvaluated &#123;</span><br><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">    options.compilerArgs &lt;&lt; &apos;-Xbootclasspath/p:app/libs/framework.jar&apos;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时, 还需要在<code>app/build.gradle</code>中添加一个编译的类路径(class path):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">project.afterEvaluate &#123;</span><br><span class="line">    JavaCompile javaTask = project.tasks.compileDebugAndroidTestJavaWithJavac</span><br><span class="line">    if (javaTask) &#123;</span><br><span class="line">FileCollection dependentFiles = javaTask.getClasspath()</span><br><span class="line">dependentFiles = dependentFiles.plus(project.files(&apos;libs/framework.jar&apos;))</span><br><span class="line">javaTask.setClasspath(dependentFiles)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上的大部分资料都说到了这一步就好了, 但是这时看引用的Java文件中, 仍然提示找不到新的符号, 重新看了下网络上的教程, 原来还需要更改下<code>app.iml</code>中的引用先后顺序.</p><h2 id="修改app-iml中的库引用顺序"><a href="#修改app-iml中的库引用顺序" class="headerlink" title="修改app.iml中的库引用顺序"></a><strong>修改app.iml中的库引用顺序</strong></h2><p><code>app.iml</code>包含了某个项目的信息以及依赖状态, 找到<code>framework.jar</code>以及<code>Android SDK</code>对应的<code>&lt;orderEntry&gt;</code>, 将<code>framework.jar</code>对应的调整到<code>Android SDK</code>之前就可以了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;orderEntry type=&quot;sourceFolder&quot; forTests=&quot;false&quot; /&gt;</span><br><span class="line">&lt;orderEntry type=&quot;library&quot; exported=&quot;&quot; name=&quot;app/libs/framework.jar:unspecified@jar&quot; level=&quot;project&quot; /&gt;</span><br><span class="line">....</span><br><span class="line">&lt;orderEntry type=&quot;module&quot; module-name=&quot;lib_config&quot; exported=&quot;&quot; /&gt;</span><br><span class="line">&lt;orderEntry type=&quot;jdk&quot; jdkName=&quot;Android API 23 Platform&quot; jdkType=&quot;Android SDK&quot; /&gt;</span><br></pre></td></tr></table></figure><p>在实际操作过程, 注意不要在<code>app/build.gradle</code>中添加如下两个配置, 不然编译虽然可以通过, 但是执行时会出现异常:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    provided files(&apos;libs/framework.jar&apos;)</span><br><span class="line">    //compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://developer.android.com/studio/build/gradle-tips" target="_blank" rel="noopener">https://developer.android.com/studio/build/gradle-tips</a></li><li><a href="http://google.github.io/android-gradle-dsl/" target="_blank" rel="noopener">http://google.github.io/android-gradle-dsl/</a></li><li><a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="noopener">https://docs.gradle.org/current/dsl/</a></li><li><a href="https://docs.gradle.org/current/userguide/userguide_single.html" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/userguide_single.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天有一个新的功能需求要实现, 要在Android原生代码的&lt;code&gt;Settings&lt;/code&gt;(代码目录&lt;code&gt;android/frameworks/base/core/java/android/provider&lt;/code&gt;)数据库添加一个新的数据项, 一个
      
    
    </summary>
    
      <category term="Android" scheme="http://sniffer.site/categories/Android/"/>
    
    
      <category term="Android studio" scheme="http://sniffer.site/tags/Android-studio/"/>
    
      <category term="Android framework" scheme="http://sniffer.site/tags/Android-framework/"/>
    
  </entry>
  
  <entry>
    <title>Linux下常用网络工具使用总结</title>
    <link href="http://sniffer.site/2019/01/17/Linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://sniffer.site/2019/01/17/Linux下常用网络工具使用总结/</id>
    <published>2019-01-17T10:23:08.000Z</published>
    <updated>2020-04-23T01:46:59.008Z</updated>
    
    <content type="html"><![CDATA[<p>平时在Android/Ubuntu这样的Linux系统中, 经常跟网络打交道, 不可避免的要使用网络工具来定位问题；这里对Linux常用的网络工具进行简单的总结, 方便后续查阅使用. 主要看看以下几个常用的网络工具 <a id="more"></a>:</p><ul><li><strong>ping</strong>: 基于ICMP协议, 发送ICMP数据包用于测试网络连通状态</li><li><strong>traceroute</strong>: 基于UDP/ICMP/TCP协议用于跟踪网络连通状态, 打印达到目标地址的路由信息</li><li><strong>tcpdump</strong> : 用于抓取tcp/ip包, 分析网络问题的必需神器</li><li><strong>iproute2</strong> : 查看/添加/删除当前路由信息</li><li><strong>netstat</strong>: 查看网络状态</li><li><strong>netcfg</strong>: 配置网口(使能网口以及配置IP等)</li><li><strong>iptables</strong>: 网络数据包的过滤以及防火墙策略配置</li><li><strong>netcat</strong>: 用于快速建立TCP/UDP链接,检测网络的连通性</li><li><strong>iPerf</strong>: 网络性能测试工具, 用来衡量网络吞吐量/带宽</li><li><strong>tc</strong>: Traffic Control, 用于显示/修改网卡配置的工具</li><li><strong>curl</strong>: 基于<a href="https://curl.haxx.se/libcurl/" target="_blank" rel="noopener">libcurl</a>的数据传输工具, 支持HTTP/HTTPS/FTP/RTMP/RTSP/SCP等常见协议</li><li><strong>iw</strong>: 用于显示/设置WiFi设备接口的工具, 比如展示当前设备WiFi热点信息, 主动扫描周围WiFi热点等</li></ul><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a><strong>ping</strong></h2><p>ping通过向目标节点发送ICMP的<code>ECHO_REQUEST</code>包来测试目标地址的可达性与连通性；向目标地址发送<code>ECHO_REQUEST</code>包后, 如果正常接收到<code>ECHO_RESPONSE</code>, 则说明网络是连通的; 但如果没有接收到任何回应,并不能说明网络的不通, 有可能是请求或者响应在某个地方丢失了.通过ping的洪峰测试模式, 持续发包到目标地址, 也可以查看当前网络状态, 如RTT(Round-trip time)时间, 网络的丢包率等信息.</p><p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ping_usage.png" alt="ping usage"></p><p>一般测试中常用的参数有如下几个:</p><ul><li><code>-c</code>: 设置发多少个<code>ECHO_REQUEST</code>包</li><li><code>-i</code>: 两个包之间的时间间隔, 默认是1s</li><li><code>-I</code>: 指定数据包出去的端口</li><li><code>-w</code>: ping测试的超时时间, 多久结束</li><li><code>-f</code>: 洪峰测试, 持续(两个包的时间间隔为0)向目标主机发送数据包</li><li><code>-s</code>: 指定发送数据包的大小</li><li><code>-M</code>: 选择Path MTU发现策略， 有三个选择： <code>do</code>代表不要对数据包进行分片， <code>want</code>表示执行PMTU发现， 但是可以在本地进行数据包的分片，<pre><code>`dont`表示不要设置分片标志位（可以分片）</code></pre></li></ul><p>示例: 向某个域名发送10包,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ping -c 10 www.google.com</span><br></pre></td></tr></table></figure><p>持续向某个主机连续20s发送数据包, 并指定出口为<code>wlp5s0</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ping -f -w 20 -I wlp5s0 www.google.com</span><br></pre></td></tr></table></figure><p>通过指定包大小以及PMTU的策略，可以用来发现某个路径上最大的MTU大概是多少：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ping -v -w 20 -M do -s 1460 www.baidu.com</span><br></pre></td></tr></table></figure><p>一般, ping测试完成后, 会打印发生了多少个包, 接收的包个数以及丢包率, 总的测试时间以及RTT:</p><p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ping_output.png" alt="ping output"></p><h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a><strong>traceroute</strong></h2><p>traceroute能够跟踪打印通往某个网络主机的路由信息, 用于定位网络不通时,在哪个路由节点发生的异常. traceroute利用的是IP协议中的包的TTL(Time-To-Live)字段不断发送”探针”包;其首先会向网络发送一个TTL为1的包, 返回后接着向网络发送一个TTL为2的包, 以此持续发送, 直到最后到达目标主机或者超时为止.traceroute的参数较多, 可以通过<code>man traceroute</code>或者<code>traceroute --help</code>查看具体的用法.</p><p>示例, 查找到达<code>www.google.com</code>的路由:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">traceroute www.google.com</span><br></pre></td></tr></table></figure><h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a><strong>tcpdump</strong></h2><p>tcpdump用于抓取网络数据包的利器, 最初的版本是由Van Jacobson, Sally Floyd, Vern Paxson在1988年编码, 后来在各种操作系统中都得到了广泛的使用, 更多详细信息可以参考<a href="https://www.tcpdump.org/" target="_blank" rel="noopener">https://www.tcpdump.org/</a>；如果你使用的是Linux系统, 可以通过<code>man tcpdump</code>来查看tcpdump的具体使用信息. 这里来看下Linux下的tcpdump工具具体如何使用.</p><p>以Ubuntu系统为例, tcpdump有很多参数:</p><p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcpdump_synopsis.png" alt="Tcpdump命令参数"> </p><p>常用的参数主要有如下几个:</p><ul><li><code>-i *interface*/--interface=*interface*</code>: 设置需要抓包的网口, 在Ubuntu系统可以通过<code>ifconfig</code>查看每个网络接口信息; 在Android下可以通过<code>busybox ifconfig</code>查看;</li><li><code>-n</code>: 不要将IP地址转换成域名;</li><li><code>-s *snaplen*/ --snapshot--length=*snaplen*</code>: 为了保持兼容性, 一般将该值设为0;</li><li><code>-w *file*</code>: 保存网络数据包到某个文件;</li><li><code>expression</code>: 表达式,  由于网络数据包的过滤, 关于表达式的语法格式可以参考<code>man pcap-filter</code>;</li></ul><p>示例: 比如我要抓取某个端口<code>wlp5s0</code>上的所有数据包, 可以使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tcpdump -i wlp5s0 -s 0 -n -w ~/all.pcap</span><br></pre></td></tr></table></figure><p>如果只是想看某个端口指定一个协议, 如tcp的数据包, 则可以:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tcpdump -i wlp5s0 -s 0 -w ip proto \\tcp</span><br></pre></td></tr></table></figure><p>这里<code>ip proto \\tcp</code>就是包过滤的表达式, 具体的写法可以参考<code>man pcap-filter</code>或者<a href="http://alumni.cs.ucr.edu/~marios/ethereal-tcpdump.pdf" target="_blank" rel="noopener">http://alumni.cs.ucr.edu/~marios/ethereal-tcpdump.pdf</a></p><h2 id="iproute2"><a href="#iproute2" class="headerlink" title="iproute2"></a><strong>iproute2</strong></h2><p>看名字大概也知道<a href="https://en.wikipedia.org/wiki/Iproute2" target="_blank" rel="noopener"><code>iproute2</code></a>这个是用来管理linux系统路由表的, 但在这个工具系列中其实也集成了其他有用的功能, 比如地址/链路的管理, 查看ARP信息, 配置网络接口信息以及配置策略路由(policy routing)等(<code>man ip</code>查看对应信息), 对于Ubuntu系统可以通过<code>man ip-route</code>来查看如何使用<code>iproute</code>:</p><p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ip-route-usage.png" alt="ip-route usage"> </p><p>示例: 想看下系统的路由表, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ip route  # 等价于 ip route show default</span><br></pre></td></tr></table></figure><p>如果想要看某个具体的路由表信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ip route show table main  # local, main, or all</span><br></pre></td></tr></table></figure><p>那么, 如果要在某个路由表中添加一项路由信息, 如何操作?假定现在, 需要在<code>main</code>路由表中对应的端口<code>ppp0</code>中添加一个目标ip为<code>211.137.20.302</code>的路由:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ip route add table main scope link dev ppp0 211.137.20.302</span><br></pre></td></tr></table></figure><p>想要删除路由表中的某一项, 语法跟路由表添加很相似:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ip route del table main scope link dev ppp0 211.137.20.302</span><br></pre></td></tr></table></figure><p>在某个网口上添加默认路由:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add default proto static scope link dev wlp5s0</span><br></pre></td></tr></table></figure><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a><strong>netstat</strong></h2><p>netstat主要用来看路由表, 当前网络链接状态以及网络数据统计等,  最新的Linux系统已经使用<code>ip</code>(<code>man ip</code>)来替代(具体的信息可以通过<code>man netstat</code>查看).不过在Android的busybox中仍然可以发挥作用:</p><p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/netstat_usage.png" alt="netstat usage"> </p><p>例如输入<code>adb shell busybox netstat -rn</code>显示路由表:</p><p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/netstat_routing_table.png" alt="netstat routing table"></p><h2 id="netcfg"><a href="#netcfg" class="headerlink" title="netcfg"></a><strong>netcfg</strong></h2><p>在Ubuntu系统中并没有看到<code>netcfg</code>工具, Android里边有一个<code>netcfg</code>工具用于配置网口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">usage: netcfg [&lt;interface&gt; &#123;dhcp|up|down&#125;]</span><br></pre></td></tr></table></figure><p>通过ADB命令<code>adb shell netcfg</code>可以查看当前网口的配置:</p><p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/netcfg_output.png" alt="netcfg output"> </p><p>如果要在Android中配置一个以太网口(Ethernet), 确保驱动加载完成后, 输入以下指令即可:</p><ol><li>使能网口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">netcfg &lt;interface&gt; up</span><br></pre></td></tr></table></figure><ol start="2"><li>通过DHCP获取IP地址</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">netcfg &lt;interface&gt; dhcp</span><br></pre></td></tr></table></figure><h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a><strong>iptables</strong></h2><p>iptables是netfilter(<a href="https://www.netfilter.org/)在用户空间的工具" target="_blank" rel="noopener">https://www.netfilter.org/)在用户空间的工具</a>, 可以用来读网络数据包进行转发, 拦截, 过滤以及修改. 简单说来, netfilter是在tcp/ip的内核传输路径添加各种hooks函数,如PREROUTING, INPUT, FORWARD, OUTPUT, POSTROUTING; 这些hooks函数负责将数据包发送个各个队列(tables), 示意图如下: </p><p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/Iptables_packet_flow.png" alt="iptables-netfilter flow"></p><p>在Linux中内置的tables有如下几个:</p><ul><li><strong>Filter</strong>: 用于数据包过滤(接收或者丢弃)</li><li><strong>Nat</strong>: IP地址转换, 有源地址(snat), 目标地址(dnat)以及masquerade(装饰)三种</li><li><strong>Managle</strong>: 修改数据包的头(ttl/tos等)</li><li><strong>Raw</strong>: 主要用于配置链接跟踪(connection tracking)</li></ul><p>在Ubuntu系统中, 输入<code>man iptables</code>可以查看iptables的具体用法:</p><p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/iptables-usage.png" alt="iptables usage"></p><p>比如要查看当前iptables规则, 可以通过<code>iptables --list</code>; 一般<code>iptables</code>命令有如下几个部分组成:</p><p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/iptables_general_structure.png" alt="iptables command structure"></p><p>假定你现在需要拦截所有来自某个IP地址的数据包, 可以这样操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">iptables -A INPUT -s 182.23.23.23 -i wlp5s0 -j DROP</span><br></pre></td></tr></table></figure><p>如果只是想丢弃某种协议的数据包, 比如UDP, 则可以指定协议类型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">iptables -A INPUT -s 182.23.23.23 -i wlp5s0 -j DROP -p udp</span><br></pre></td></tr></table></figure><p>查看当前规则的流量使用情况可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">iptables -L -v -n</span><br></pre></td></tr></table></figure><p>通过iptables的规则链条, 我们可以很方便的构造一系列防火墙规则, 看起来是非常强大的一个工具了. 很值得学习~</p><h2 id="netcat"><a href="#netcat" class="headerlink" title="netcat"></a><strong>netcat</strong></h2><p><code>netcat</code>通常简写成<code>nc</code>, 是一个用于建立TCP/UDP连接的小工具, 在Linux下<code>netcat -h</code>或者<code>nc -h</code>都可以查看其使用说明；Android也包含了一个缩减版的<code>netcat</code>, 可以通过<code>nc -h</code>查看. 以Ubuntu为例, 通常<code>nc</code>有如下几个参数:</p><p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/nc_usage.png" alt="netcat usage"></p><p>比如要测试下跟google的TCP连接是否正常(设置<code>-v</code>可以输出连接的状态信息):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nc -v www.google.com 80</span><br></pre></td></tr></table></figure><p>类似的, 也可以建立一个UDP连接:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -v -u www.google.com 80</span><br></pre></td></tr></table></figure><p><code>netcat</code>有个比较有用的功能就是扫描某个主机给定范围的端口是否正常可连接: 如下这个指令用来查看网关<code>192.168.225.1</code>上<code>1-10000</code>的端口是否可用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nc -v -z 192.168.225.1 1-10000</span><br></pre></td></tr></table></figure><p>如果我们想要测试两个主机给定端口的连通性,可以按照如下步骤操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#在HOST1监听2323这个端口</span><br><span class="line">nc -v -l -p 2323 </span><br><span class="line"></span><br><span class="line">#在HOST2上主动连接2323这个端口</span><br><span class="line">nc -v -X connect 192.168.225.1 2323</span><br></pre></td></tr></table></figure><p>关于<code>nc</code>更多有趣的应用, 可以到官网上查看 <a href="http://nc110.sourceforge.net/" target="_blank" rel="noopener">http://nc110.sourceforge.net/</a>.</p><h2 id="iPerf"><a href="#iPerf" class="headerlink" title="iPerf"></a><strong>iPerf</strong></h2><p>iPerf是一个基于TCP/UPD协议的网络测试工具, 常用来测试网络吞吐量以及带宽. 在测试时需要客户端与服务端都支持. 目前有iperf3/iperf2两个版本, 相关文档参考<a href="https://iperf.fr/iperf-doc.php" target="_blank" rel="noopener">https://iperf.fr/iperf-doc.php</a>. 这里我们基于iperf2介绍下如何来使用iperf.</p><p>iPerf的参数主要分为三类, 一类是通用参数, 如参数格式, 多线程测试等；一类是客户端使用的参数, 如目标地址；一类是服务端的参数, 如基于UDP或者通过Daemon进程执行等.</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/iperf_usage.png" alt="iperf usage"></p><p>比如简单来测试下网络带宽(<code>ping.online.net</code>是免费用来测试网络的服务器):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">iperf -f M -m -c ping.online.net</span><br></pre></td></tr></table></figure><p>测试完成后, 会输出如下信息:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/iperf_test_result.png" alt="iperf test output"></p><p>这里只是简单引出iperf的使用方法, 更多使用场景可以到官网上看看文档<a href="https://iperf.fr/" target="_blank" rel="noopener">https://iperf.fr/</a>.</p><h2 id="tc"><a href="#tc" class="headerlink" title="tc"></a><strong>tc</strong></h2><p>tc即<code>Traffic Control</code>, 可以显示/修改网卡的配置, 如设置网卡的延时, 传输速率, 控制包的传输顺序等, 在linux上输入<code>man tc</code>可以查看具体的使用说明:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tc_synopsis.png" alt="tc usage"></p><p>比如要看下当前网卡队列的状态, 可以输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tc -s qdisc show dev eth0</span><br></pre></td></tr></table></figure><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a><strong>curl</strong></h2><p><code>curl</code>一般用于客户端数据的下载传输, 目前支持Web协议如HTTP(S)/FTP到视频流传输协议如RTMP/RTSP等, 其使用起来也非常简单:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl [options...] &lt;url&gt;</span><br></pre></td></tr></table></figure><p>比如要尝试下载某个网页:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">curl -v www.baidu.com</span><br></pre></td></tr></table></figure><p>这里<code>-v</code>会输出更多的过程信息:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/curl_examples.png" alt="curl examples result"></p><h2 id="iw"><a href="#iw" class="headerlink" title="iw"></a><strong>iw</strong></h2><p><code>iw</code>常用于WiFi设备的管理, 配置, 通过<code>man iw</code>可以看到相关的使用说明:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/iw_usage.png" alt="iw usage"></p><p>要查看所有相关命令的使用可以输入<code>iw help</code>.如要查看当前设备WiFi信息, 可以输入<code>iw dev</code>. 通过:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">iw &lt;wlan_interface&gt; info</span><br></pre></td></tr></table></figure><p>可以查看到当前连接的WiFi热点信息, 如果要扫描附近的WiFi热点, 可以通过<code>iw &lt;wlan_interface&gt; scan</code>, 这样会得到一个完整的热点列表.</p><p>以上便是常用几个网络工具的总结了, 大家有什么好的Linux工具可以推荐下~以后持续更新</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="http://stud.netgroup.uniroma2.it/cgrl/2018/slides/5-netfilter.pdf" target="_blank" rel="noopener">http://stud.netgroup.uniroma2.it/cgrl/2018/slides/5-netfilter.pdf</a></li><li><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Netfilter</a></li><li><a href="https://iperf.fr/(iPerf官网)" target="_blank" rel="noopener">https://iperf.fr/(iPerf官网)</a></li><li><a href="http://linux-ip.net/html/tools-ip-route.html" target="_blank" rel="noopener">http://linux-ip.net/html/tools-ip-route.html</a></li><li><a href="https://en.wikipedia.org/wiki/Iptables" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Iptables</a></li><li><a href="https://linux.die.net/man/8/tc" target="_blank" rel="noopener">https://linux.die.net/man/8/tc</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时在Android/Ubuntu这样的Linux系统中, 经常跟网络打交道, 不可避免的要使用网络工具来定位问题；这里对Linux常用的网络工具进行简单的总结, 方便后续查阅使用. 主要看看以下几个常用的网络工具
    
    </summary>
    
      <category term="Linux" scheme="http://sniffer.site/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://sniffer.site/tags/Linux/"/>
    
      <category term="Network tools" scheme="http://sniffer.site/tags/Network-tools/"/>
    
      <category term="ip route" scheme="http://sniffer.site/tags/ip-route/"/>
    
      <category term="tcpdump" scheme="http://sniffer.site/tags/tcpdump/"/>
    
      <category term="iptables" scheme="http://sniffer.site/tags/iptables/"/>
    
      <category term="iperf" scheme="http://sniffer.site/tags/iperf/"/>
    
  </entry>
  
  <entry>
    <title>成王败寇与丛林法则-看纪录片&lt;英国史&gt;有感</title>
    <link href="http://sniffer.site/2019/01/04/%E6%88%90%E7%8E%8B%E8%B4%A5%E5%AF%87%E4%B8%8E%E4%B8%9B%E6%9E%97%E6%B3%95%E5%88%99-%E7%9C%8B%E7%BA%AA%E5%BD%95%E7%89%87-%E8%8B%B1%E5%9B%BD%E5%8F%B2-%E6%9C%89%E6%84%9F/"/>
    <id>http://sniffer.site/2019/01/04/成王败寇与丛林法则-看纪录片-英国史-有感/</id>
    <published>2019-01-04T03:22:40.000Z</published>
    <updated>2019-05-06T08:24:33.839Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>People donot see; they only recognize. And what they donot recognize remains invisible to them</p><p>Simon Leys</p></blockquote><p>最近断断续续的看完了BBC的《英国史》(<a href="https://open.163.com/movie/2016/2/S/O/MBF6MO64J_MBF6NAPSO.html" target="_blank" rel="noopener">网易公开课链接</a>)，从史前文明讲到宗教改革;从罗马帝国的征服讲到光荣革命, 加上醇厚的英式英语, 整个纪录片看起来十分的有趣而汤气回肠。在英国人看来，国王只是上帝在人间的代表，执行着上帝的意志，而不是独揽大权的独裁者。纵然，英国历史上也出现过暴君，但最终并没有什么好下场，弄不好还被送上断头台，掉了脑袋。<a id="more"></a>印象深刻的是，在英国内战期间，当乡绅<a href="https://zh.wikipedia.org/wiki/%E5%A5%A5%E5%88%A9%E5%BC%97%C2%B7%E5%85%8B%E4%BC%A6%E5%A8%81%E5%B0%94" target="_blank" rel="noopener">克伦威尔</a>赶走暴君，掌握军权之后，并没有依靠独裁加冕成为国王，而是给自己冠上了护国公。这就告诉人民，国王是上帝的代表，是荣誉与信仰的象征，有血统而赋有担当与责任，并不是每个出生草莽之辈能戴上王冠，纵使像克伦威尔这样的乡绅也不能。这种贵族式的统治，加上议会这种代表民主与自由的分权机构，英国终于成为了欧洲乃至世界近代历史的领头羊，将人类文明带入新的高度。</p><p>再对比中国历史上的权力游戏，却是截然不同的画面。当秦朝末年，人民被折腾的苦不堪言时，陈胜吴广说的是“王侯将相宁有种乎”，他秦始皇能做一国之君，我陈胜吴广为何不能？陈胜吴广起义也绝非为了执行上帝的意志，消除社会不公平，而是挣脱套牢在他们自己身上的枷锁。这个即便是到了近代的太平天国起义也是如此。他们揭竿而起并不是为了某种上帝的意志与信念而战，也不是为了某种信仰而赴汤蹈火，而是做另一个秦始皇，在万人之上，成为人人害怕而崇拜的对象，成为坐拥万千宾妃的皇上。这里，看不到任何关于荣誉与尊严，看不到任何对于自由与民主的追求，有的只是对成王败寇的推崇，以及“宁可我负天下人，不可天下人负我”的自私与偏狭。从这个角度看，五千年历史一直上演的都是弱肉强食，适者生存的丛林游戏。没有对人的荣誉与尊严的保护，没有对社会不公制度性的建设，没有对自由与人性的追求,野蛮从未消失过。</p><p>记得小时候长辈劝年轻人要努力读书时, 常会说一句”吃得苦中苦, 方为人上人”.我们读书学习, 只是成为”人上人”而已, 所谓”学而优则仕”, 一切的努力付出都只是为了成为”统治阶层”的一员.这种功利与对权力的极力推崇的态度在当今的社会依然屡见不鲜.可回顾下人类文明的发展历程, 所有的社会或文化的变革最终都指向一个目标:把人类自身从各种束缚中解脱出来, 解放人性,让人可以发挥自己的创造潜能.文艺复兴也好, 工业革命与信息技术革命, 再到影响了千千万万国人的改革开放而言, 都是为了去除套牢在人心上的枷锁,解放压抑沉闷的人性, 让每个个体都有机会发挥自身的才能与智慧.到今天, 中国进行改革开放40年来, 经济一直在高速发展, 可是社会的发展却相对停滞, 人们讨论最多的是如何挣钱, 如何谋取财富;大部分人满足于吃喝玩乐, 对于社会公平与精神追求要么无所追求, 要么有心无力.在发生问题时, 小到个人, 大到一个企业或者组织, 再到政府,都在极力推卸责任;不管是立法, 司法还是执法, 整个社会对于个体权利的保护都远远不够, 在遇到实际的法律问题时常常只能依靠道德来衡量, 显得十分捉襟见肘.</p><p>历经40年的发展, 普遍程度上, 我们的生活水平都有了质的提高,工业化建设也有了长足的进步.如果我们的社会想要进一步发展, 想要涌现更大的活力, 我们的古老的文明想要焕发更多的生命力, 整个国家从上至下都必须进行一次思想观念的解放:不能再仅仅满足于口号上的民族复兴/伟大使命, 而是要实实在在的作出变革, 放开对个人的束缚, 放开对自由的限制,更多的激发个人的活力.不过, 从目前来看, 我们的最高领导者似乎还在老路上沉浸不可自拔, 所谓的变革实际上显得困难重重.历史再一次将中国摆在了有趣的十字路口, 如何选择是每一个中国人都要思考的问题.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;People donot see; they only recognize. And what they donot recognize remains invisible to them&lt;/p&gt;
&lt;p&gt;Simon Leys&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近断断续续的看完了BBC的《英国史》(&lt;a href=&quot;https://open.163.com/movie/2016/2/S/O/MBF6MO64J_MBF6NAPSO.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网易公开课链接&lt;/a&gt;)，从史前文明讲到宗教改革;从罗马帝国的征服讲到光荣革命, 加上醇厚的英式英语, 整个纪录片看起来十分的有趣而汤气回肠。在英国人看来，国王只是上帝在人间的代表，执行着上帝的意志，而不是独揽大权的独裁者。纵然，英国历史上也出现过暴君，但最终并没有什么好下场，弄不好还被送上断头台，掉了脑袋。
    
    </summary>
    
      <category term="思考" scheme="http://sniffer.site/categories/%E6%80%9D%E8%80%83/"/>
    
      <category term="读书笔记" scheme="http://sniffer.site/categories/%E6%80%9D%E8%80%83/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="英国史" scheme="http://sniffer.site/tags/%E8%8B%B1%E5%9B%BD%E5%8F%B2/"/>
    
      <category term="丛林法则" scheme="http://sniffer.site/tags/%E4%B8%9B%E6%9E%97%E6%B3%95%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Android netd工作原理详解</title>
    <link href="http://sniffer.site/2018/12/18/Android-netd%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>http://sniffer.site/2018/12/18/Android-netd工作原理详解/</id>
    <published>2018-12-18T03:46:28.000Z</published>
    <updated>2019-10-18T11:55:49.558Z</updated>
    
    <content type="html"><![CDATA[<p>NETD是Android一个专门管理网络链接, 路由以及iptables的系统Daemon进程, 其在系统启动时加载 <a id="more"></a>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">service netd /system/bin/netd</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">netd</span> <span class="title">stream</span> 0660 <span class="title">root</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">dnsproxyd</span> <span class="title">stream</span> 0660 <span class="title">root</span> <span class="title">inet</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">mdns</span> <span class="title">stream</span> 0660 <span class="title">root</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">fwmarkd</span> <span class="title">stream</span> 0660 <span class="title">root</span> <span class="title">inet</span></span></span><br></pre></td></tr></table></figure><p>启动netd时, 会创建四个socket,用于其他进程与netd进行通信:</p><ul><li><code>netd</code>: 用于控制网口状态, 路由表</li><li><code>dnsproxyd</code>: DNS代理的控制与配置</li><li><code>mdns</code>: 多播DNS的控制(参考RFC<a href="https://tools.ietf.org/html/rfc6762" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6762</a>)</li><li><code>fwmarkd</code>: iptables的(fwmark)策略路由的配置(<a href="http://www.policyrouting.org/PolicyRoutingBook/ONLINE/CH06.web.html" target="_blank" rel="noopener">策略路由</a></li></ul><p>总的说来, netd进程在Android中间层服务<code>ConnectivityManagerSerivce</code>以及内核之间建立了一个沟通的桥梁:</p><ul><li>对Java层系统服务<code>ConnectivityManagerService</code>,<code>netd</code>通过socket接口为其提供了控制指令的通道</li><li>对内核, <code>netd</code>通过netlink socket与内核进行数据/指令的收发, 并将来自内核的消息发送给上层</li></ul><p>接下来, 本文从三个方面来看下<code>netd</code>的具体工作原理与实现.</p><ul><li><code>netd</code>的初始化与启动</li><li><code>ConnectivityManagerSerivce</code>与<code>netd</code>的交互</li><li><code>netd</code>与内核的交互</li></ul><blockquote><p>关于netlink socket可以参考: <a href="http://qos.ittc.ku.edu/netlink/html/node4.html" target="_blank" rel="noopener">http://qos.ittc.ku.edu/netlink/html/node4.html</a></p></blockquote><h2 id="netd的启动与初始化"><a href="#netd的启动与初始化" class="headerlink" title="netd的启动与初始化"></a><strong>netd的启动与初始化</strong></h2><p>netd进程启动时, 主要处理做以下事情:</p><ul><li>创建一个<code>NetlinkManager</code>, 用于管理与内核通信的netlink连接</li><li>初始化网络控制类, 如路由控制<code>RouteController</code>, 带宽控制<code>BandwidthController</code></li><li>启动各类事件监听类: <code>DnsProxyListener</code>监听DNS代理; <code>CommandListener</code>监听来自<code>NetworkManagement</code>的指令</li><li>启动NetdHwService, 为HAL层提供接口</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> android::net::gCtls;</span><br><span class="line">    Stopwatch s;</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"Netd 1.0 starting"</span>);</span><br><span class="line"></span><br><span class="line">    blockSigpipe();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    NetlinkManager *nm = NetlinkManager::Instance();</span><br><span class="line">    <span class="keyword">if</span> (nm == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">ALOGE(<span class="string">"Unable to create NetlinkManager"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gCtls = <span class="keyword">new</span> android::net::Controllers();</span><br><span class="line">    gCtls-&gt;init();</span><br><span class="line"></span><br><span class="line">    CommandListener cl;</span><br><span class="line">    nm-&gt;setBroadcaster((SocketListener *) &amp;cl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nm-&gt;start()) &#123;</span><br><span class="line">ALOGE(<span class="string">"Unable to start NetlinkManager (%s)"</span>, strerror(errno));</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;NFLogListener&gt; logListener;</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">auto</span> result = makeNFLogListener();</span><br><span class="line"><span class="keyword">if</span> (!isOk(result)) &#123;</span><br><span class="line">    ALOGE(<span class="string">"Unable to create NFLogListener: %s"</span>, toString(result).c_str());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">logListener = <span class="built_in">std</span>::move(result.value());</span><br><span class="line"><span class="keyword">auto</span> status = gCtls-&gt;wakeupCtrl.init(logListener.get());</span><br><span class="line"><span class="keyword">if</span> (!isOk(result)) &#123;</span><br><span class="line">    ALOGE(<span class="string">"Unable to init WakeupController: %s"</span>, toString(result).c_str());</span><br><span class="line">    <span class="comment">// We can still continue without wakeup packet logging.</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set local DNS mode, to prevent bionic from proxying</span></span><br><span class="line">    <span class="comment">// back to this service, recursively.</span></span><br><span class="line">    setenv(<span class="string">"ANDROID_DNS_MODE"</span>, <span class="string">"local"</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="function">DnsProxyListener <span class="title">dpl</span><span class="params">(&amp;gCtls-&gt;netCtrl, &amp;gCtls-&gt;eventReporter)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (dpl.startListener()) &#123;</span><br><span class="line">ALOGE(<span class="string">"Unable to start DnsProxyListener (%s)"</span>, strerror(errno));</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MDnsSdListener mdnsl;</span><br><span class="line">    <span class="keyword">if</span> (mdnsl.startListener()) &#123;</span><br><span class="line">ALOGE(<span class="string">"Unable to start MDnsSdListener (%s)"</span>, strerror(errno));</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">FwmarkServer <span class="title">fwmarkServer</span><span class="params">(&amp;gCtls-&gt;netCtrl, &amp;gCtls-&gt;eventReporter)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (fwmarkServer.startListener()) &#123;</span><br><span class="line">ALOGE(<span class="string">"Unable to start FwmarkServer (%s)"</span>, strerror(errno));</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stopwatch subTime;</span><br><span class="line">    <span class="keyword">status_t</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = NetdNativeService::start()) != android::OK) &#123;</span><br><span class="line">ALOGE(<span class="string">"Unable to start NetdNativeService: %d"</span>, ret);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGI(<span class="string">"Registering NetdNativeService: %.1fms"</span>, subTime.getTimeAndReset());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now that we're up, we can respond to commands. Starting the listener also tells</span></span><br><span class="line"><span class="comment">     * NetworkManagementService that we are up and that our binder interface is ready.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (cl.startListener()) &#123;</span><br><span class="line">ALOGE(<span class="string">"Unable to start CommandListener (%s)"</span>, strerror(errno));</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGI(<span class="string">"Starting CommandListener: %.1fms"</span>, subTime.getTimeAndReset());</span><br><span class="line"></span><br><span class="line">    write_pid_file();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that netd is ready to process commands, advertise service</span></span><br><span class="line">    <span class="comment">// availability for HAL clients.</span></span><br><span class="line">    NetdHwService mHwSvc;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mHwSvc.start()) != android::OK) &#123;</span><br><span class="line">ALOGE(<span class="string">"Unable to start NetdHwService: %d"</span>, ret);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGI(<span class="string">"Registering NetdHwService: %.1fms"</span>, subTime.getTimeAndReset());</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"Netd started in %dms"</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s.timeTaken()));</span><br><span class="line"></span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"Netd exiting"</span>);</span><br><span class="line"></span><br><span class="line">    remove_pid_file();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CommandListener</code>用于接收处理来自上层<code>NetworkManagementService</code>指令, 在<code>netd</code>启动时, 会监听<code>netd</code>这个socket, 并允许最多4个客户端请求的处理:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> SocketListener::startListener() &#123;</span><br><span class="line">    <span class="keyword">return</span> startListener(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SocketListener::startListener(<span class="keyword">int</span> backlog) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mSocketName &amp;&amp; mSock == <span class="number">-1</span>) &#123;</span><br><span class="line">SLOGE(<span class="string">"Failed to start unbound listener"</span>);</span><br><span class="line">errno = EINVAL;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSocketName) &#123;</span><br><span class="line"><span class="keyword">if</span> ((mSock = android_get_control_socket(mSocketName)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">SLOGE(<span class="string">"Obtaining file descriptor socket '%s' failed: %s"</span>,</span><br><span class="line">mSocketName, strerror(errno));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">SLOGV(<span class="string">"got mSock = %d for %s"</span>, mSock, mSocketName);</span><br><span class="line">fcntl(mSock, F_SETFD, FD_CLOEXEC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mListen &amp;&amp; listen(mSock, backlog) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">SLOGE(<span class="string">"Unable to listen on socket (%s)"</span>, strerror(errno));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mListen)</span><br><span class="line">mClients-&gt;push_back(<span class="keyword">new</span> SocketClient(mSock, <span class="literal">false</span>, mUseCmdNum));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(mCtrlPipe)) &#123;</span><br><span class="line">SLOGE(<span class="string">"pipe failed (%s)"</span>, strerror(errno));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;mThread, <span class="literal">NULL</span>, SocketListener::threadStart, <span class="keyword">this</span>)) &#123;</span><br><span class="line">SLOGE(<span class="string">"pthread_create (%s)"</span>, strerror(errno));</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个专门的线程用于处理来自上层客户端的命令请求:</p><ul><li>检查控制pipe的数据,是否有必要停止监听;</li><li>监听来自客户端的请求, 如果有, 则新建一个<code>SocketClient</code>保存下来</li><li>从已有的<code>SocketClient</code>中检查是否有可用的数据, 如果有则通过<code>onDataAvailable</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> *SocketListener::threadStart(<span class="keyword">void</span> *obj) &#123;</span><br><span class="line">    SocketListener *me = <span class="keyword">reinterpret_cast</span>&lt;SocketListener *&gt;(obj);</span><br><span class="line"></span><br><span class="line">    me-&gt;runListener();</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SocketListener::runListener() &#123;</span><br><span class="line"></span><br><span class="line">    SocketClientCollection pendingList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">SocketClientCollection::iterator it;</span><br><span class="line">fd_set read_fds;</span><br><span class="line"><span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">FD_ZERO(&amp;read_fds);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mListen) &#123;</span><br><span class="line">    max = mSock;</span><br><span class="line">    FD_SET(mSock, &amp;read_fds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FD_SET(mCtrlPipe[<span class="number">0</span>], &amp;read_fds);</span><br><span class="line"><span class="keyword">if</span> (mCtrlPipe[<span class="number">0</span>] &gt; max)</span><br><span class="line">    max = mCtrlPipe[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;mClientsLock);</span><br><span class="line"><span class="keyword">for</span> (it = mClients-&gt;begin(); it != mClients-&gt;end(); ++it) &#123;</span><br><span class="line">    <span class="comment">// NB: calling out to an other object with mClientsLock held (safe)</span></span><br><span class="line">    <span class="keyword">int</span> fd = (*it)-&gt;getSocket();</span><br><span class="line">    FD_SET(fd, &amp;read_fds);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt; max) &#123;</span><br><span class="line">        max = fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;mClientsLock);</span><br><span class="line">SLOGV(<span class="string">"mListen=%d, max=%d, mSocketName=%s"</span>, mListen, max, mSocketName);</span><br><span class="line"><span class="keyword">if</span> ((rc = select(max + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    SLOGE(<span class="string">"select failed (%s) mListen=%d, max=%d"</span>, strerror(errno), mListen, max);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!rc)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(mCtrlPipe[<span class="number">0</span>], &amp;read_fds)) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = CtrlPipe_Shutdown;</span><br><span class="line">    TEMP_FAILURE_RETRY(read(mCtrlPipe[<span class="number">0</span>], &amp;c, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (c == CtrlPipe_Shutdown) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mListen &amp;&amp; FD_ISSET(mSock, &amp;read_fds)) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = TEMP_FAILURE_RETRY(accept4(mSock, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, SOCK_CLOEXEC));</span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        SLOGE(<span class="string">"accept failed (%s)"</span>, strerror(errno));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_lock(&amp;mClientsLock);</span><br><span class="line">    mClients-&gt;push_back(<span class="keyword">new</span> SocketClient(c, <span class="literal">true</span>, mUseCmdNum));</span><br><span class="line">    pthread_mutex_unlock(&amp;mClientsLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add all active clients to the pending list first */</span></span><br><span class="line">pendingList.clear();</span><br><span class="line">pthread_mutex_lock(&amp;mClientsLock);</span><br><span class="line"><span class="keyword">for</span> (it = mClients-&gt;begin(); it != mClients-&gt;end(); ++it) &#123;</span><br><span class="line">    SocketClient* c = *it;</span><br><span class="line">    <span class="comment">// NB: calling out to an other object with mClientsLock held (safe)</span></span><br><span class="line">    <span class="keyword">int</span> fd = c-&gt;getSocket();</span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(fd, &amp;read_fds)) &#123;</span><br><span class="line">        pendingList.push_back(c);</span><br><span class="line">        c-&gt;incRef();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;mClientsLock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Process the pending list, since it is owned by the thread,</span></span><br><span class="line"><span class="comment"> * there is no need to lock it */</span></span><br><span class="line"><span class="keyword">while</span> (!pendingList.empty()) &#123;</span><br><span class="line">    <span class="comment">/* Pop the first item from the list */</span></span><br><span class="line">    it = pendingList.begin();</span><br><span class="line">    SocketClient* c = *it;</span><br><span class="line">    pendingList.erase(it);</span><br><span class="line">    <span class="comment">/* Process it, if false is returned, remove from list */</span></span><br><span class="line">    <span class="keyword">if</span> (!onDataAvailable(c)) &#123;</span><br><span class="line">        release(c, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    c-&gt;decRef();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>netd启动完成后, 就可以处理来自中间层的指令请求以及与内核进行交互了.</p><h2 id="netd与NetworkManagerService的交互"><a href="#netd与NetworkManagerService的交互" class="headerlink" title="netd与NetworkManagerService的交互"></a><strong>netd与NetworkManagerService的交互</strong></h2><p><code>SystemServer</code>进程启动时,  创建<code>NetworkManagementService</code>(以下简称(<code>NMS</code>)),  此时<code>NMS</code>会主动与<code>netd</code>建立socket链接:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// SystemServer.java</span></span><br><span class="line">       <span class="keyword">if</span> (!disableNetwork) &#123;</span><br><span class="line">           traceBeginAndSlog(<span class="string">"StartNetworkManagementService"</span>);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               networkManagement = NetworkManagementService.create(context);</span><br><span class="line">               ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               reportWtf(<span class="string">"starting NetworkManagement Service"</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">           traceEnd();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>创建NMS时, 启动一个新的线程用于与netd通信,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> NetworkManagementService <span class="title">create</span><span class="params">(Context context, String socket)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">final</span> NetworkManagementService service = <span class="keyword">new</span> NetworkManagementService(context, socket);</span><br><span class="line"><span class="keyword">final</span> CountDownLatch connectedSignal = service.mConnectedSignal;</span><br><span class="line"><span class="keyword">if</span> (DBG) Slog.d(TAG, <span class="string">"Creating NetworkManagementService"</span>);</span><br><span class="line">service.mThread.start();</span><br><span class="line"><span class="keyword">if</span> (DBG) Slog.d(TAG, <span class="string">"Awaiting socket connection"</span>);</span><br><span class="line">connectedSignal.await();</span><br><span class="line">service.connectNativeNetdService();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">NetworkManagementService</span><span class="params">(Context context, String socket)</span> </span>&#123;</span><br><span class="line">mContext = context;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make sure this is on the same looper as our NativeDaemonConnector for sync purposes</span></span><br><span class="line">mFgHandler = <span class="keyword">new</span> Handler(FgThread.get().getLooper());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don't need this wake lock, since we now have a time stamp for when</span></span><br><span class="line"><span class="comment">// the network actually went inactive.  (It might be nice to still do this,</span></span><br><span class="line"><span class="comment">// but I don't want to do it through the power manager because that pollutes the</span></span><br><span class="line"><span class="comment">// battery stats history with pointless noise.)</span></span><br><span class="line"><span class="comment">//PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);</span></span><br><span class="line">PowerManager.WakeLock wl = <span class="keyword">null</span>; <span class="comment">//pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, NETD_TAG);</span></span><br><span class="line"></span><br><span class="line">mConnector = <span class="keyword">new</span> NativeDaemonConnector(</span><br><span class="line"><span class="keyword">new</span> NetdCallbackReceiver(), socket, <span class="number">10</span>, NETD_TAG, <span class="number">160</span>, wl,</span><br><span class="line">FgThread.get().getLooper());</span><br><span class="line">mThread = <span class="keyword">new</span> Thread(mConnector, NETD_TAG);</span><br><span class="line"></span><br><span class="line">mDaemonHandler = <span class="keyword">new</span> Handler(FgThread.get().getLooper());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add ourself to the Watchdog monitors.</span></span><br><span class="line">Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">LocalServices.addService(NetworkManagementInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (mTetheringStatsProviders) &#123;</span><br><span class="line">    mTetheringStatsProviders.put(<span class="keyword">new</span> NetdTetheringStatsProvider(), <span class="string">"netd"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NMS通过<code>NativeDaemonConnector</code>与<code>netd</code>建立socket通信, <code>NativeDaemonConnector</code>主要做两个事情:</p><ul><li>与<code>netd</code>建立一个数据链接</li><li>不断读取socket中的数据流: 一种是<code>netd</code>主动上报的命令, 一种是NMS发送给<code>netd</code>后的指令的响应</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    mCallbackHandler = new Handler(mLooper, this);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            listenToSocket();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            loge(&quot;Error in NativeDaemonConnector: &quot; + e);</span><br><span class="line">            SystemClock.sleep(5000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void listenToSocket() throws IOException &#123;</span><br><span class="line">    LocalSocket socket = null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        socket = new LocalSocket();</span><br><span class="line">        LocalSocketAddress address = determineSocketAddress();</span><br><span class="line"></span><br><span class="line">        socket.connect(address);</span><br><span class="line"></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        synchronized (mDaemonLock) &#123;</span><br><span class="line">            mOutputStream = socket.getOutputStream();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCallbacks.onDaemonConnected();</span><br><span class="line"></span><br><span class="line">        FileDescriptor[] fdList = null;</span><br><span class="line">        byte[] buffer = new byte[BUFFER_SIZE];</span><br><span class="line">        int start = 0;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            int count = inputStream.read(buffer, start, BUFFER_SIZE - start);</span><br><span class="line">            if (count &lt; 0) &#123;</span><br><span class="line">                loge(&quot;got &quot; + count + &quot; reading with start = &quot; + start);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            fdList = socket.getAncillaryFileDescriptors();</span><br><span class="line"></span><br><span class="line">            // Add our starting point to the count and reset the start.</span><br><span class="line">            count += start;</span><br><span class="line">            start = 0;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                if (buffer[i] == 0) &#123;</span><br><span class="line">                    // Note - do not log this raw message since it may contain</span><br><span class="line">                    // sensitive data</span><br><span class="line">                    final String rawEvent = new String(</span><br><span class="line">                            buffer, start, i - start, StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">                    boolean releaseWl = false;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        final NativeDaemonEvent event =</span><br><span class="line">                                NativeDaemonEvent.parseRawEvent(rawEvent, fdList);</span><br><span class="line"></span><br><span class="line">                        log(&quot;RCV &lt;- &#123;&quot; + event + &quot;&#125;&quot;);</span><br><span class="line"></span><br><span class="line">                        if (event.isClassUnsolicited()) &#123;</span><br><span class="line">                            Message msg = mCallbackHandler.obtainMessage(</span><br><span class="line">                                    event.getCode(), uptimeMillisInt(), 0, event.getRawEvent());</span><br><span class="line">                            if (mCallbackHandler.sendMessage(msg)) &#123;</span><br><span class="line">                                releaseWl = false;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            mResponseQueue.add(event.getCmdNumber(), event);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">                        log(&quot;Problem parsing message &quot; + e);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        if (releaseWl) &#123;</span><br><span class="line">                            mWakeLock.release();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    start = i + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // We should end at the amount we read. If not, compact then</span><br><span class="line">            // buffer and read again.</span><br><span class="line">            if (start != count) &#123;</span><br><span class="line">                final int remaining = BUFFER_SIZE - start;</span><br><span class="line">                System.arraycopy(buffer, start, buffer, 0, remaining);</span><br><span class="line">                start = remaining;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                start = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        loge(&quot;Communications error: &quot; + ex);</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        synchronized (mDaemonLock) &#123;</span><br><span class="line">            if (mOutputStream != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    loge(&quot;closing stream for &quot; + mSocket);</span><br><span class="line">                    mOutputStream.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    loge(&quot;Failed closing output stream: &quot; + e);</span><br><span class="line">                &#125;</span><br><span class="line">                mOutputStream = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (socket != null) &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            loge(&quot;Failed closing socket: &quot; + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>socket链接建立完成之后, NMS与<code>netd</code>可以相互通信, 发送指令与数据了. NMS通过<code>NativeDaemonConnector</code>执行相应的指令, 比如NMS设置网络接口的配置(打开/关闭网口):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterfaceConfig</span><span class="params">(String iface, InterfaceConfiguration cfg)</span> </span>&#123;</span><br><span class="line">    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);</span><br><span class="line">    LinkAddress linkAddr = cfg.getLinkAddress();</span><br><span class="line">    <span class="keyword">if</span> (linkAddr == <span class="keyword">null</span> || linkAddr.getAddress() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Null LinkAddress given"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Command cmd = <span class="keyword">new</span> Command(<span class="string">"interface"</span>, <span class="string">"setcfg"</span>, iface,</span><br><span class="line">            linkAddr.getAddress().getHostAddress(),</span><br><span class="line">            linkAddr.getPrefixLength());</span><br><span class="line">    <span class="keyword">for</span> (String flag : cfg.getFlags()) &#123;</span><br><span class="line">        cmd.appendArg(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mConnector.execute(cmd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NativeDaemonConnectorException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowAsParcelableException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NativeDaemonConnector</code>会将每个指令都指定一个唯一的序列, 并将其响应放到一个阻塞队列, 等待<code>netd</code>返回指令的结果, 如果超过指定的超时时间, 则抛出一个超时的异常.</p><p>在第一部分时, 讲到<code>SocketListener</code>拿到上层发过来的指令后, 会将其分发给对应的指令类进行处理(看<code>SocketListener</code>的子类<code>FrameworkListener</code>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">bool</span> FrameworkListener::onDataAvailable(SocketClient *c) &#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[CMD_BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = TEMP_FAILURE_RETRY(read(c-&gt;getSocket(), buffer, <span class="keyword">sizeof</span>(buffer)));</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">SLOGE(<span class="string">"read() failed (%s)"</span>, strerror(errno));</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!len) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer[len<span class="number">-1</span>] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">SLOGW(<span class="string">"String is not zero-terminated"</span>);</span><br><span class="line">android_errorWriteLog(<span class="number">0x534e4554</span>, <span class="string">"29831647"</span>);</span><br><span class="line">c-&gt;sendMsg(<span class="number">500</span>, <span class="string">"Command too large for buffer"</span>, <span class="literal">false</span>);</span><br><span class="line">mSkipToNextNullByte = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (buffer[i] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">    <span class="comment">/* IMPORTANT: dispatchCommand() expects a zero-terminated string */</span></span><br><span class="line">    <span class="keyword">if</span> (mSkipToNextNullByte) &#123;</span><br><span class="line">        mSkipToNextNullByte = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dispatchCommand(c, buffer + offset);</span><br><span class="line">    &#125;</span><br><span class="line">    offset = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mSkipToNextNullByte = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>dispatchCommmand</code>会检查所有指令处理类, 匹配相应的类去执行指令:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> FrameworkListener::dispatchCommand(SocketClient *cli, <span class="keyword">char</span> *data) &#123;</span><br><span class="line">    FrameworkCommandCollection::iterator i;</span><br><span class="line">    <span class="keyword">int</span> argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *argv[FrameworkListener::CMD_ARGS_MAX];</span><br><span class="line">    <span class="keyword">char</span> tmp[CMD_BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *p = data;</span><br><span class="line">    <span class="keyword">char</span> *q = tmp;</span><br><span class="line">    <span class="keyword">char</span> *qlimit = tmp + <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> esc = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> quote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> haveCmdNum = !mWithSeq;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(argv, <span class="number">0</span>, <span class="keyword">sizeof</span>(argv));</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    ...</span><br><span class="line">    *q = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= CMD_ARGS_MAX)</span><br><span class="line"><span class="keyword">goto</span> overflow;</span><br><span class="line">    argv[argc++] = strdup(tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (quote) &#123;</span><br><span class="line">cli-&gt;sendMsg(<span class="number">500</span>, <span class="string">"Unclosed quotes error"</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errorRate &amp;&amp; (++mCommandCount % errorRate == <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="comment">/* ignore this command - let the timeout handler handle it */</span></span><br><span class="line">SLOGE(<span class="string">"Faking a timeout"</span>);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = mCommands-&gt;begin(); i != mCommands-&gt;end(); ++i) &#123;</span><br><span class="line">FrameworkCommand *c = *i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], c-&gt;getCommand())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;runCommand(cli, argc, argv)) &#123;</span><br><span class="line">        SLOGW(<span class="string">"Handler '%s' error (%s)"</span>, c-&gt;getCommand(), strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cli-&gt;sendMsg(<span class="number">500</span>, <span class="string">"Command not recognized"</span>, <span class="literal">false</span>);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++)</span><br><span class="line"><span class="built_in">free</span>(argv[j]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">overflow:</span><br><span class="line">    cli-&gt;sendMsg(<span class="number">500</span>, <span class="string">"Command too long"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这里执行的是, 网络接口相关的设置, 因此会调用<code>InterfaceCmd</code>来执行该指令.</p><h2 id="NETD与内核进行交互"><a href="#NETD与内核进行交互" class="headerlink" title="NETD与内核进行交互"></a><strong>NETD与内核进行交互</strong></h2><p>NETD通过<code>netlink</code>事件与内核进行消息的交换.在第一部分时看到, <code>netd</code>启动时, 会配置socket与内核进行通信:</p><ul><li>一个netlink事件是<code>NETLINK_KOBJECT_UEVENT</code>: 用于内核向<code>netd</code>发生消息, 如网口的状态变化;</li><li>一个netlink事件是<code>NETLINK_ROUTE</code>:用于接收路由信息, 如路由表的更新与删除;</li><li>一个netlink事件是<code>NETLINK_NFLOG</code>:用于接收数据流量使用配额的消息, 如数据使用超限;</li><li>一个netlink事件是<code>NETLINK_NETFILTER</code>用于接收包过滤(netfilter)的消息;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> NetlinkManager::start() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((mUeventHandler = setupSocket(&amp;mUeventSock, NETLINK_KOBJECT_UEVENT,</span><br><span class="line"> <span class="number">0xffffffff</span>, NetlinkListener::NETLINK_FORMAT_ASCII, <span class="literal">false</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mRouteHandler = setupSocket(&amp;mRouteSock, NETLINK_ROUTE,</span><br><span class="line">                             RTMGRP_LINK |</span><br><span class="line">                             RTMGRP_IPV4_IFADDR |</span><br><span class="line">                             RTMGRP_IPV6_IFADDR |</span><br><span class="line">                             RTMGRP_IPV6_ROUTE |</span><br><span class="line">                             (<span class="number">1</span> &lt;&lt; (RTNLGRP_ND_USEROPT - <span class="number">1</span>)),</span><br><span class="line"> NetlinkListener::NETLINK_FORMAT_BINARY, <span class="literal">false</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mQuotaHandler = setupSocket(&amp;mQuotaSock, NETLINK_NFLOG,</span><br><span class="line">    NFLOG_QUOTA_GROUP, NetlinkListener::NETLINK_FORMAT_BINARY, <span class="literal">false</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">ALOGW(<span class="string">"Unable to open qlog quota socket, check if xt_quota2 can send via UeventHandler"</span>);</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> return -1 once the emulator gets a new kernel.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mStrictHandler = setupSocket(&amp;mStrictSock, NETLINK_NETFILTER,</span><br><span class="line">    <span class="number">0</span>, NetlinkListener::NETLINK_FORMAT_BINARY_UNICAST, <span class="literal">true</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">ALOGE(<span class="string">"Unable to open strict socket"</span>);</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> return -1 once the emulator gets a new kernel.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个netlink的socket都会新建一个<code>NetlinkHandler</code>, 用于处理内核的消息, 并将该消息广播给上层:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> NetlinkHandler::onEvent(NetlinkEvent *evt) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *subsys = evt-&gt;getSubsystem();</span><br><span class="line">    <span class="keyword">if</span> (!subsys) &#123;</span><br><span class="line">ALOGW(<span class="string">"No subsystem found in netlink event"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(subsys, <span class="string">"net"</span>)) &#123;</span><br><span class="line">NetlinkEvent::Action action = evt-&gt;getAction();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *iface = evt-&gt;findParam(<span class="string">"INTERFACE"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (action == NetlinkEvent::Action::kAdd) &#123;</span><br><span class="line">    notifyInterfaceAdded(iface);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == NetlinkEvent::Action::kRemove) &#123;</span><br><span class="line">    notifyInterfaceRemoved(iface);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == NetlinkEvent::Action::kChange) &#123;</span><br><span class="line">    evt-&gt;dump();</span><br><span class="line">    notifyInterfaceChanged(<span class="string">"nana"</span>, <span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == NetlinkEvent::Action::kLinkUp) &#123;</span><br><span class="line">    notifyInterfaceLinkChanged(iface, <span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == NetlinkEvent::Action::kLinkDown) &#123;</span><br><span class="line">    notifyInterfaceLinkChanged(iface, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == NetlinkEvent::Action::kAddressUpdated ||</span><br><span class="line">           action == NetlinkEvent::Action::kAddressRemoved) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *address = evt-&gt;findParam(<span class="string">"ADDRESS"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *flags = evt-&gt;findParam(<span class="string">"FLAGS"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *scope = evt-&gt;findParam(<span class="string">"SCOPE"</span>);</span><br><span class="line">    <span class="keyword">if</span> (action == NetlinkEvent::Action::kAddressRemoved &amp;&amp; iface &amp;&amp; address) &#123;</span><br><span class="line">        <span class="comment">// Note: if this interface was deleted, iface is "" and we don't notify.</span></span><br><span class="line">        SockDiag sd;</span><br><span class="line">        <span class="keyword">if</span> (sd.open()) &#123;</span><br><span class="line">            <span class="keyword">char</span> addrstr[INET6_ADDRSTRLEN];</span><br><span class="line">            <span class="built_in">strncpy</span>(addrstr, address, <span class="keyword">sizeof</span>(addrstr));</span><br><span class="line">            <span class="keyword">char</span> *slash = <span class="built_in">strchr</span>(addrstr, <span class="string">'/'</span>);</span><br><span class="line">            <span class="keyword">if</span> (slash) &#123;</span><br><span class="line">                *slash = <span class="string">'\0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ret = sd.destroySockets(addrstr);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">"Error destroying sockets: %s"</span>, strerror(ret));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGE(<span class="string">"Error opening NETLINK_SOCK_DIAG socket: %s"</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iface &amp;&amp; iface[<span class="number">0</span>] &amp;&amp; address &amp;&amp; flags &amp;&amp; scope) &#123;</span><br><span class="line">        notifyAddressChanged(action, address, iface, flags, scope);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == NetlinkEvent::Action::kRdnss) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *lifetime = evt-&gt;findParam(<span class="string">"LIFETIME"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *servers = evt-&gt;findParam(<span class="string">"SERVERS"</span>);</span><br><span class="line">    <span class="keyword">if</span> (lifetime &amp;&amp; servers) &#123;</span><br><span class="line">        notifyInterfaceDnsServers(iface, lifetime, servers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == NetlinkEvent::Action::kRouteUpdated ||</span><br><span class="line">           action == NetlinkEvent::Action::kRouteRemoved) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *route = evt-&gt;findParam(<span class="string">"ROUTE"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *gateway = evt-&gt;findParam(<span class="string">"GATEWAY"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *iface = evt-&gt;findParam(<span class="string">"INTERFACE"</span>);</span><br><span class="line">    <span class="keyword">if</span> (route &amp;&amp; (gateway || iface)) &#123;</span><br><span class="line">        notifyRouteChange(action, route, gateway, iface);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(subsys, <span class="string">"qlog"</span>) || !<span class="built_in">strcmp</span>(subsys, <span class="string">"xt_quota2"</span>)) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *alertName = evt-&gt;findParam(<span class="string">"ALERT_NAME"</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *iface = evt-&gt;findParam(<span class="string">"INTERFACE"</span>);</span><br><span class="line">notifyQuotaLimitReached(alertName, iface);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(subsys, <span class="string">"strict"</span>)) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *uid = evt-&gt;findParam(<span class="string">"UID"</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *hex = evt-&gt;findParam(<span class="string">"HEX"</span>);</span><br><span class="line">notifyStrictCleartext(uid, hex);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(subsys, <span class="string">"xt_idletimer"</span>)) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *label = evt-&gt;findParam(<span class="string">"INTERFACE"</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *state = evt-&gt;findParam(<span class="string">"STATE"</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *timestamp = evt-&gt;findParam(<span class="string">"TIME_NS"</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *uid = evt-&gt;findParam(<span class="string">"UID"</span>);</span><br><span class="line"><span class="keyword">if</span> (state)</span><br><span class="line">    notifyInterfaceClassActivity(label, !<span class="built_in">strcmp</span>(<span class="string">"active"</span>, state),</span><br><span class="line">                                 timestamp, uid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://linux-ip.net/html/index.html" target="_blank" rel="noopener">http://linux-ip.net/html/index.html</a></li><li><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Netfilter</a></li><li><a href="http://people.netfilter.org/pablo/docs/login.pdf" target="_blank" rel="noopener">netfilter connection tracking system</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NETD是Android一个专门管理网络链接, 路由以及iptables的系统Daemon进程, 其在系统启动时加载
    
    </summary>
    
      <category term="Android" scheme="http://sniffer.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://sniffer.site/tags/Android/"/>
    
      <category term="netd" scheme="http://sniffer.site/tags/netd/"/>
    
      <category term="NetworkManagerService" scheme="http://sniffer.site/tags/NetworkManagerService/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式及其应用</title>
    <link href="http://sniffer.site/2018/11/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://sniffer.site/2018/11/30/正则表达式及其在Java中的应用/</id>
    <published>2018-11-30T13:03:42.000Z</published>
    <updated>2019-11-01T01:19:31.823Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式(<em>regular expression</em>)是指一种操作字符串的搜索模式/模板(<code>Pattern Template</code>)，可用于文本的搜索、编辑等操作。如下是一个正则表达式：</p><pre><code>^[0-9]</code></pre><p>其定义了一个搜索非数字字符的模式。正则表达式在如Shell(sed/gawk)/Python/Java等语言中都有广泛的应用.</p><h2 id="正则表达式规则"><a href="#正则表达式规则" class="headerlink" title="正则表达式规则"></a><strong>正则表达式规则</strong></h2><h3 id="字符匹配符"><a href="#字符匹配符" class="headerlink" title="字符匹配符"></a><strong>字符匹配符</strong></h3><p>下表是常用的字符匹配符：</p><blockquote><p><strong>表1 字符匹配符</strong></p></blockquote><table><thead><tr><th>正则表达式</th><th>说明</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配任意字符</td></tr><tr><td><code>^</code></td><td>一行的开始</td></tr><tr><td><code>$</code></td><td>是否一行的末尾</td></tr><tr><td><code>[]</code></td><td>匹配在<code>[ch]</code>中的任意一个字符</td></tr><tr><td><code>()</code></td><td>从正则表达式匹配结果中产生子字符串, <code>ma(tri)?x</code>匹配<code>max</code>或者<code>matrix</code></td></tr><tr><td><code>/</code></td><td><code>Oct (1st / 2nd)</code>匹配 <code>Oct 1st</code>或者<code>Oct 2nd</code></td></tr><tr><td><code>\</code></td><td>转义字符, 将特殊字符转义, 如<code>a\.b</code>匹配的是<code>a.b</code>而不是<code>ajb</code></td></tr><tr><td><code>^regex</code></td><td>在一行的开始出匹配regex</td></tr><tr><td><code>regex$</code></td><td>在一行的末尾匹配regex</td></tr><tr><td><code>[abc]</code></td><td>匹配字符a或b或c</td></tr><tr><td><code>[abc][vz]</code></td><td>匹配a/b/c后跟v/z的字符串</td></tr><tr><td><code>[^abc]</code></td><td>匹配除了a/b/c之外的任意字符</td></tr><tr><td><code>[a-d]</code></td><td>匹配a到d之间的字符</td></tr><tr><td><code>[0-8]</code></td><td>匹配0到8之间的数字</td></tr><tr><td><code>XZ</code></td><td>搜索 XZ</td></tr><tr><td><code>x/z</code></td><td>搜索 X 或者 Z</td></tr></tbody></table><blockquote><p>由于hexo排版的原因, 上表中<code>/</code>实际为 <code>|</code></p></blockquote><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a><strong>元字符</strong></h3><p>为了简化表达式规则，正则表达式提供了几种元字符(<em>meta characters</em>)：</p><blockquote><p><strong>表2 元字符</strong></p></blockquote><table><thead><tr><th>正则表达式</th><th>说明</th></tr></thead><tbody><tr><td><code>\d</code></td><td>任意数字,<code>[0-9]</code>的简写</td></tr><tr><td><code>\D</code></td><td>非数字匹配，<code>[^0-9]</code>的简写</td></tr><tr><td><code>\s</code></td><td>空白字符，<code>[ \t\n\x0b\r\f]</code>的简写</td></tr><tr><td><code>\S</code></td><td>非空白字符，<code>[^\s]</code>的简写</td></tr><tr><td><code>\w</code></td><td>单词匹配符，<code>[a-zA-Z_0-9]</code>的简写</td></tr><tr><td><code>\W</code></td><td>非单词匹配符，<code>[^\w]</code>的简写</td></tr><tr><td><code>\S+</code></td><td>多个非空白字符</td></tr><tr><td><code>\b</code></td><td>单词<code>[a-zA-Z0-9_]</code>边界字符匹配</td></tr><tr><td><code>\r</code></td><td>回车符</td></tr></tbody></table><h3 id="数量匹配符"><a href="#数量匹配符" class="headerlink" title="数量匹配符"></a><strong>数量匹配符</strong></h3><p>另外，正则表达式还提供了<em>数量匹配符</em>(<em>Quantifier</em>),用于标识一个元素出现的频次，主要有以下几种：</p><blockquote><p><strong>表3 数量匹配符</strong></p></blockquote><table><thead><tr><th>正则表达式</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>*</code></td><td>出现次数 &gt;= 0,等同<code>{0,}</code></td><td><code>x*</code> 查找零个或者多个字符x; <code>.*</code>匹配任意字符串</td></tr><tr><td><code>+</code></td><td>出现次数 &gt;= 1,等同 <code>{1,}</code></td><td><code>x+</code> 匹配出现次数大于1的字符x</td></tr><tr><td><code>?</code></td><td>出现次数不多于1次，等同<code>{0,1}</code></td><td><code>x?</code> 查找出现次数不大于1次的字符x</td></tr><tr><td><code>{n}</code></td><td>出现次数为 n</td><td><code>\d{3}</code> 搜索长度为3的数字字符串</td></tr><tr><td><code>{n1,n2}</code></td><td>出现次数在 n1 与 n2 之间</td><td><code>\d{1,4}</code> 数字字符长度在1 ~ 4之间的字符串</td></tr><tr><td><code>*?</code></td><td><code>?</code>放在一个数量匹配符的后面时，定义为一个“懒惰数量匹配符” (<em>reluctant/lazy quantifier</em>),该匹配符找到最小的一个匹配，然后搜索到第一个匹配字符时，即不再搜索</td><td><code>s.*?o</code> 匹配 <code>*stacko*verflow</code>, 而<code>s.*o</code>匹配的是<code>*stackoverflo*w</code></td></tr></tbody></table><h3 id="给定正则表达式的模式"><a href="#给定正则表达式的模式" class="headerlink" title="给定正则表达式的模式"></a><strong>给定正则表达式的模式</strong></h3><p>可以在一个正则表达式的开始给定一个模式修改符(<em>mode modifiers</em>):</p><ul><li><code>(?i)</code> 使正则表达式不区分大小写</li><li><code>(?s)</code> 单行模式,匹配包括换行符在内的所有字符(<em>makes the dot match all characters, including line breaks</em>)</li><li><code>(?m)</code> 多行模式(<em>makes the caret and dollar match at the start and end of each line in the subject string.</em>)</li></ul><blockquote><p>若需要指定多种模式，则将其组合在一起即可: <code>(?ism)</code></p></blockquote><h2 id="正则表达式的应用"><a href="#正则表达式的应用" class="headerlink" title="正则表达式的应用"></a><strong>正则表达式的应用</strong></h2><h3 id="在shell脚本中使用正则表达式"><a href="#在shell脚本中使用正则表达式" class="headerlink" title="在shell脚本中使用正则表达式"></a><strong>在shell脚本中使用正则表达式</strong></h3><p>在shell脚本命令<code>find</code>, <code>grep</code>中, 经常需要使用正则表达式来查找字符:</p><p>比如在ifconfig中查找ip地址:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ifconfig | grep -E "[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;"</span><br></pre></td></tr></table></figure><p>在tcpdump中过滤IP地址:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tcpdump | grep -E "[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;"</span><br></pre></td></tr></table></figure><p>在某个文件中查找所有单词:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat xxx.log | grep -E &quot;[a-zA-Z+]</span><br></pre></td></tr></table></figure><h3 id="在Java中使用正则表达式"><a href="#在Java中使用正则表达式" class="headerlink" title="在Java中使用正则表达式"></a><strong>在Java中使用正则表达式</strong></h3><p>Java中的 <code>String</code> 支持正则表达式来操作字符串，这给文本操作带来了很大的方便：</p><blockquote><p><strong>表4 String中的正则表达式方法</strong></p></blockquote><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>str.matches(&quot;regex&quot;)</code></td><td>判断字符串<code>str</code>是否与<code>regex</code>相匹配</td></tr><tr><td><code>str.split(&quot;regex&quot;)</code></td><td>通过<code>regex</code>分割字符串<code>str</code></td></tr><tr><td><code>str.replaceFirst(&quot;regex&quot;,&quot;replacement&quot;)</code></td><td>用<code>replacement</code>替换字符串中第一次出现 <code>regex</code>的字符串</td></tr><tr><td><code>str.replaceAll(&quot;regex&quot;,&quot;replacement&quot;)</code></td><td>用于<code>replacement</code>替换所有匹配<code>regex</code>的字符串</td></tr></tbody></table><p><strong>参考示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">package</span> de.vogella.regex.test;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexTestStrings</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXAMPLE_TEST = <span class="string">"This is my small example "</span></span><br><span class="line">    + <span class="string">"string which I'm going to "</span> + <span class="string">"use for pattern matching."</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  System.out.println(EXAMPLE_TEST.matches(<span class="string">"\\w.*"</span>));</span><br><span class="line">  String[] splitString = (EXAMPLE_TEST.split(<span class="string">"\\s+"</span>));</span><br><span class="line">System.out.println(splitString.length);<span class="comment">// should be 14</span></span><br><span class="line">   <span class="keyword">for</span> (String string : splitString) &#123;</span><br><span class="line">     System.out.println(string);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// replace all whitespace with tabs</span></span><br><span class="line">  System.out.println(EXAMPLE_TEST.replaceAll(<span class="string">"\\s+"</span>, <span class="string">"\t"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>: 在Java中斜杠<code>\</code>是一个转义字符，因此为了得到单个的斜杠字符，需要用<code>\\</code>来实现</p></blockquote><h3 id="Pattern-Matcher"><a href="#Pattern-Matcher" class="headerlink" title="Pattern/Matcher"></a><strong>Pattern/Matcher</strong></h3><p>对于更高级的应用，Java提供了两个类<strong>Pattern</strong>(<em>java.util.regex.Pattern</em>) 和 <strong>Matcher</strong> (<em>java.util.regex.Matcher</em>): </p><ol><li>首先，使用 <strong>Pattern</strong> 得到对应的正则表达式；</li><li>然后，利用 <strong>Matcher</strong> 来操作相应的字符串</li></ol><p><strong>参考示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegularExpression</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String regx = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> Pattern pattern = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> Matcher matcher = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">// regular expression test</span></span><br><span class="line">String input =  <span class="keyword">new</span> String(<span class="string">"here 2016, now we encounter very confusing things. On the one hand, we human beings feel "</span></span><br><span class="line">+ <span class="string">"very confident, but on the other hand, we are so fucking lost in our self-built world! we do waste our energy"</span></span><br><span class="line">+ <span class="string">"and time  on useless things. We are totally lost."</span>);</span><br><span class="line"></span><br><span class="line">String regDigit = <span class="keyword">new</span> String(<span class="string">"\\d"</span>);</span><br><span class="line">String regChars = <span class="keyword">new</span> String(<span class="string">"hand|useless"</span>);</span><br><span class="line">String regWild = <span class="keyword">new</span> String(<span class="string">"[^af]"</span>);</span><br><span class="line">String regWord = <span class="keyword">new</span> String(<span class="string">"\\w"</span>);</span><br><span class="line">String regTimes = <span class="keyword">new</span> String(<span class="string">"[a-z]&#123;5&#125;"</span>);</span><br><span class="line"></span><br><span class="line">RegularExpression reg = <span class="keyword">new</span> RegularExpression(regDigit);</span><br><span class="line">reg.getMatcherResult(input);</span><br><span class="line"></span><br><span class="line">reg.setRegx(regChars);</span><br><span class="line">reg.getMatcherResult(input);</span><br><span class="line"></span><br><span class="line">reg.setRegx(regWild);</span><br><span class="line">reg.getMatcherResult(input);</span><br><span class="line"></span><br><span class="line">reg.setRegx(regWord);</span><br><span class="line">reg.getMatcherResult(input);</span><br><span class="line"></span><br><span class="line">reg.setRegx(regTimes);</span><br><span class="line">reg.getMatcherResult(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RegularExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RegularExpression</span><span class="params">(String reg)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.regx = reg;</span><br><span class="line"><span class="keyword">this</span>.pattern = Pattern.compile(regx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMatcherResult</span><span class="params">(String in)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"current regression expression is "</span> + regx);</span><br><span class="line"><span class="keyword">this</span>.matcher = pattern.matcher(in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">System.out.println(matcher.group());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegx</span><span class="params">(String regx)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.regx = regx;</span><br><span class="line"><span class="keyword">this</span>.pattern = Pattern.compile(regx);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则表达式注意事项"><a href="#正则表达式注意事项" class="headerlink" title="正则表达式注意事项"></a>正则表达式注意事项</h2><ul><li>正则表达式区分大小写</li><li>正则表达式模式会匹配数据流中文本的任何位置, 因此要注意模式的开头与结尾</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><strong>参考文章</strong></h2><ul><li><a href="http://www.vogella.com/tutorials/JavaRegularExpressions/article.html" target="_blank" rel="noopener">http://www.vogella.com/tutorials/JavaRegularExpressions/article.html</a></li><li><a href="http://www.ntu.edu.sg/home/ehchua/programming/howto/regexe.html" target="_blank" rel="noopener">http://www.ntu.edu.sg/home/ehchua/programming/howto/regexe.html</a></li><li><a href="https://www.regular-expressions.info/repeat.html" target="_blank" rel="noopener">https://www.regular-expressions.info/repeat.html</a></li><li><a href="https://www.gnu.org/software/gawk/manual/gawk.html" target="_blank" rel="noopener">GAWK manual</a></li><li><a href="https://www.gnu.org/software/sed/manual/sed.html" target="_blank" rel="noopener">Sed manual</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式(&lt;em&gt;regular expression&lt;/em&gt;)是指一种操作字符串的搜索模式/模板(&lt;code&gt;Pattern Template&lt;/code&gt;)，可用于文本的搜索、编辑等操作。如下是一个正则表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;^[0-9]
&lt;/cod
      
    
    </summary>
    
      <category term="Regular Expression" scheme="http://sniffer.site/categories/Regular-Expression/"/>
    
    
      <category term="正则表达式" scheme="http://sniffer.site/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="Regular Expression" scheme="http://sniffer.site/tags/Regular-Expression/"/>
    
  </entry>
  
  <entry>
    <title>socket编程与IO multiplexing</title>
    <link href="http://sniffer.site/2018/07/21/socket%E7%BC%96%E7%A8%8B%E4%B8%8EIO%E5%A4%8D%E7%94%A8/"/>
    <id>http://sniffer.site/2018/07/21/socket编程与IO复用/</id>
    <published>2018-07-21T14:46:49.000Z</published>
    <updated>2019-09-23T03:25:09.284Z</updated>
    
    <content type="html"><![CDATA[<p>socket通常用于跨进程通信(Inter-Process Communication,IPC)，由于其最早BSD Unix发行版中使用，因此也叫做<a href="https://en.wikipedia.org/wiki/Berkeley_sockets" target="_blank" rel="noopener">Barkeley sockets</a>。socket封装了底层网络通信协议细节，为上层应用提供了一个统一的接口，按照使用的“域”不同，又分为用于网络通信的internet socket以及用于本地进程通信的Unix domain socket<a id="more"></a>。</p><p>那么，如何利用socket实现IPC通信了？在多个客户端的情况下，服务端要如何实现同时响应多个客户请求了，即如何实现多个IO端口的监听(I/O multiplex)？这篇文章，就来看看这两个问题。首先，来看下socket编程的一些基本知识。</p><h2 id="socket编程基础"><a href="#socket编程基础" class="headerlink" title="socket编程基础"></a><strong>socket编程基础</strong></h2><p>一个socket由三个元素唯一确定：</p><ul><li>internet地址(如果是Unix domain socket,则对应一个本地文件名)</li><li>端到端的协议类型(面向连接的TCP或者无连接的UDP）</li><li>用于确定传送数据应用的端口号（port）</li></ul><p>在使用socket前，首先需要通过系统调用<code>socket</code>创建一个socket对象，并返回该socket对应的文件描述符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>创建一个socket需要指定三个参数:</p><ul><li>通信域，确定协议族，比如<code>AF_UNIX/AF_LOCAL</code>用于本地通信；<code>AF_INET/AF_INET6</code>基于TCP/IP协议族，用于网络通信;<code>AF_NETLINK</code>用于进程与内核通信；<code>AF_APPLETALK</code>用于AppleTalk通信</li><li>socket类型：<code>SOCK_STREAM</code>提供了序列化、可靠、全双工的字节流通信；<code>SOCK_DGRAM</code>提供了无连接、不可靠的数据报文通信</li><li>协议：指定使用的协议类型，比如是TCP（<code>IPPROTO_TCP</code>)还是UDP(<code>IPPROTO_UDP</code>)，其在<code>sys/un.h</code>中定义；</li></ul><p>| 有关socket参数的具体说明，可参考<a href="http://www.man7.org/linux/man-pages/man2/socket.2.html" target="_blank" rel="noopener">http://www.man7.org/linux/man-pages/man2/socket.2.html</a></p><p>下图是一个基于TCP协议的socket通信流程图(包括握手与挥手流程，这里只说明三次握手流程）：</p><ul><li>对于客户端与服务端进程，都需要通过<code>socket(int, int, int)</code>来创建一个socket，得到一个socket文件描述符用于后续的通信；</li><li>在服务端，首先要将创建的socket文件描述符与本的某个地址进行绑定，并监听该地址对应的文件，并通过<code>accept</code>接口准备接受来自客户端的通信请求；</li><li>在客户端，通过调用<code>connect</code>尝试与服务端建立通信链路，在此过程中，客户端与服务端会进行三次握手来建立一个连接；</li><li>至此，一个全双工的通信链接就建立完成了，客户端与服务端都可以同时向对方发送数据了</li></ul><p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/socketflow.png" alt="SocketFlow"></p><p>按照上述流程，来看看一个client/server的socket通信示例: 客户端不断发送消息给服务端，服务端接受到消息后，原封不动的将其发送给客户端</p><ul><li>客户端代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">char</span>* SERVER_ADDR = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_BUF_SIZE = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> socket_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"><span class="comment">/** 1. create a TCP based socket */</span></span><br><span class="line">    socket_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">"cannot create socket"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line"><span class="comment">/** 2. set network address of the server */</span></span><br><span class="line">    sa.sin_family = AF_INET; <span class="comment">/* address familiy*/</span></span><br><span class="line">    sa.sin_port = htons(atoi(argv[<span class="number">1</span>])); <span class="comment">/* address port */</span></span><br><span class="line">    sa.sin_addr.s_addr = inet_addr(SERVER_ADDR); <span class="comment">/* internet address */</span></span><br><span class="line"><span class="comment">/** 3. try to connect server */</span></span><br><span class="line">    <span class="keyword">if</span> (connect(socket_fd, (struct sockaddr*) &amp;sa, <span class="keyword">sizeof</span>(sa)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">"connect failure"</span>);</span><br><span class="line">close(socket_fd);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client: server is connected\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[MAX_BUF_SIZE]; </span><br><span class="line">    <span class="comment">/* keep sending message to server */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">fgets(buf, MAX_BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, <span class="string">"quit"</span>, <span class="number">4</span>) == <span class="number">0</span> || <span class="built_in">strncmp</span>(buf, <span class="string">"q"</span>, <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"quit\n"</span>);</span><br><span class="line">write(socket_fd, <span class="string">"quit"</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Client: %s\n"</span>, buf);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"><span class="keyword">if</span> (send(socket_fd, buf, len, <span class="number">0</span>) != len) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"client: send message error\n"</span>);</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, MAX_BUF_SIZE);</span><br><span class="line"><span class="keyword">if</span> (recv(socket_fd, buf, MAX_BUF_SIZE, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fail to receive message from server\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Server:%s"</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(socket_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>服务端代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> SERVER_PORT = <span class="number">2100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PENDING = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_RCV_BUF = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buf[MAX_RCV_BUF];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> socket_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((socket_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fail to create socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sa.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">/** htonl/htons 将host字节序转为network字节序 */</span></span><br><span class="line">    sa.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">/* INADDR_ANY表示该端口可接受任何入境消息 */</span></span><br><span class="line">    sa.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将socket与地址进行绑定*/</span></span><br><span class="line">    <span class="keyword">if</span> (bind(socket_fd, (struct sockaddr*) &amp;sa, <span class="keyword">sizeof</span>(sa)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fail to bind socket address\n"</span>);   </span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 监听socket */</span></span><br><span class="line">    <span class="keyword">if</span> (listen(socket_fd, MAX_PENDING) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fail to listen port\n"</span>);  </span><br><span class="line">        <span class="keyword">goto</span> errout; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"server is started\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; ;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* accept any requests from clients */</span></span><br><span class="line">        <span class="keyword">int</span> connect_fd = accept(socket_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (connect_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"fail to accept"</span>);</span><br><span class="line">            <span class="keyword">goto</span> errout;      </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* keep receving message from client */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(connect_fd, buf, MAX_RCV_BUF) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"fail to read"</span>);  </span><br><span class="line">                <span class="keyword">break</span>;         </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf)] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Client: %s\n"</span>, buf);</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (write(connect_fd, buf, <span class="built_in">strlen</span>(buf)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"fail to send to client\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, <span class="string">"quit"</span>, <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"talk is done*_*\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(connect_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">    close(socket_fd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务端，如果等待请求队列中有client的请求，则<code>accept</code>返回一个新的fd用于数据的读写；如果没有，则阻塞当前进程直到有客户请求为止。因此，上述服务端是无法同时响应多个客户请求的。如果服务端需要同时响应多个客户请求，不阻塞当前进程，则需要使用<code>select</code>或者<code>poll/epoll</code>来监听socket，如果有客户请求，kernel会及时通知用户进程；对每个客户请求，服务端可通过启动新的进程与线程来处理。作为演示，这里使用下面的方法来解决进程阻塞以及多个客户请求的问题：</p><ul><li>服务端进程同时监听多个端口，客户端可通过不同的端口向服务端发送数据</li><li>分别使用<code>select</code>或者<code>poll/epoll</code>来监听这些端口，对于每个请求都启动一个新的线程进行处理</li></ul><h2 id="IO复用：服务端如何同时处理多个客户请求"><a href="#IO复用：服务端如何同时处理多个客户请求" class="headerlink" title="IO复用：服务端如何同时处理多个客户请求"></a>IO复用：服务端如何同时处理多个客户请求</h2><p>目前在Linux下，常见的IO复用(I/O multiplexing)方式有:</p><ul><li><code>select</code>: 可监听的文件描述符(fd)最大不超过1024(由<code>_SC_OPEN_MAX</code>确定）；</li><li><code>poll</code>:对监听的fd个数没有限制，但是随着fd数目的增加，性能也会随着下降，因为每次收到有可用fd事件时，poll都需要遍历整个监听集合；</li><li><code>epoll</code>: 对监听的fd个数无限制，不同与poll的地方时，epoll监听返回的是一个可用fd的集合，而不是整个监听fd的集合，因此效率上比poll更高；</li></ul><p>接下来，就具体看看这种IO复用方式如何处理服务端的请求。</p><p>为了监听多个端口，需要在服务端进程启动时，创建多个socket:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Usage %s &lt;port_1&gt; &lt;port_2&gt; ... \n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* io multiplex */</span></span><br><span class="line">    fd_set sockset;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    <span class="comment">/* is server running */</span></span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* max file descriptors of socket */</span></span><br><span class="line">    <span class="keyword">int</span> maxFd = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">int</span>* serverSock;</span><br><span class="line">    <span class="keyword">int</span> portNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    serverSock = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((argc - <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[i]);</span><br><span class="line">serverSock[portNum++] = createServerSocket(port);</span><br><span class="line">maxFd = serverSock[portNum<span class="number">-1</span>] &gt; maxFd ? serverSock[portNum<span class="number">-1</span>] : maxFd;</span><br><span class="line">    &#125;</span><br><span class="line">   ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，利用<code>select</code>或者<code>poll</code>或者<code>epoll</code>来实现上述端口的监听：</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a><strong><code>select</code></strong></h3><p>使用<code>select</code>需要做以下几个事情：</p><ul><li>创建一个fd集合: <code>fd_set sockset;</code></li><li>每次使用前都需要将其清空:<code>FD_ZERO(&amp;sockset);</code></li><li>将所要监听的fd保存到<code>sockset</code>中: <code>FD_SET(serverSock[p], &amp;sockset);</code></li><li>设置监听的超时时间，监听对应的fd集合：<code>select(maxFd + 1, &amp;sockset, NULL, NULL, &amp;timeout)</code>,如果该调用返回-1则意味着超时，否则表示有新的IO事件了，可通过<code>FD_ISSET(serverSock[p], &amp;sockset)</code>来检查对应的fd是否处于可读写的状态</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span>(running) &#123;</span><br><span class="line"><span class="comment">/* this must be reset for every time select() is called */</span></span><br><span class="line">FD_ZERO(&amp;sockset);</span><br><span class="line">FD_SET(STDIN_FILENO, &amp;sockset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; portNum; ++p) &#123;</span><br><span class="line">    FD_SET(serverSock[p], &amp;sockset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* timeout for select IO */</span></span><br><span class="line"><span class="comment">/* must be called every time select() is called */</span></span><br><span class="line">timeout.tv_sec = DEFAULT_TIMEOUT;</span><br><span class="line">timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select(maxFd + <span class="number">1</span>, &amp;sockset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fail to get ready fd for %d seconds, waiting...again"</span>, DEFAULT_TIMEOUT);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;sockset)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server is gonna to shut down\n"</span>);</span><br><span class="line">        running = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; portNum; ++p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(serverSock[p], &amp;sockset)) &#123;</span><br><span class="line">            <span class="keyword">pthread_t</span> tid;</span><br><span class="line">            <span class="keyword">int</span> clientFd = acceptConnection(serverSock[p]);</span><br><span class="line">            <span class="comment">/* create pthread to handle client request */</span></span><br><span class="line">            pthread_create(&amp;tid, <span class="literal">NULL</span>, (<span class="keyword">void</span>*)handleRequest, (<span class="keyword">void</span>*)&amp;clientFd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>| select linux man page: <a href="http://man7.org/linux/man-pages/man2/select.2.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man2/select.2.html</a></p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a><strong><code>poll</code></strong></h3><p>poll有一个专门的数据结构<code>pollfd</code>来记录监听的fd: 其由三部分组成，一个是监听的fd，一个是需要监听的事件，比如<code>POLLIN/POLLPRI</code>；一个监听返回的事件，比如‵POLLOUT/POLLERR/POLLHUP`，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line"><span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line"><span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用poll来监听多个IO事件，需要：</p><ul><li>创建一个<code>pollfd</code>数组用于保存监听的fd集合: <code>struct pollfd pollFds[MAX_PORTS];</code></li><li><p>将需要监听的fd添加到该集合:</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">pollFds[i].fd = createServerSocket(atoi(argv[i]));</span><br><span class="line">pollFds[i].events = POLLIN;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>指定超时时间，监听fd集合: <code>int ready = poll(pollFds, maxFds, MAX_POLL_TIMEOUT);</code>, 如果返回小于0的值，则表示出现了错误；如果返回值为0，则表示超时，返回一个大于0的值，表示当前可用的fd的个数</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (running) &#123;</span><br><span class="line">    <span class="keyword">int</span> ready = poll(pollFds, maxFds, MAX_POLL_TIMEOUT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ready &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fail to poll"</span>);</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ready == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//printf("timeout\n");</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, MAX_BUF_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxFds; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pollFds[i].fd &gt; <span class="number">0</span> &amp;&amp; (pollFds[i].events &amp; POLLIN)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pollFds[i].fd == STDIN_FILENO) &#123;</span><br><span class="line">                    <span class="comment">// read from stdin stream</span></span><br><span class="line">                    <span class="keyword">if</span> (fgets(buf, MAX_BUF_SIZE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        perror(<span class="string">"fail to read stdin"</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">                    <span class="keyword">if</span> (send(pollFds[i].fd, buf, len , <span class="number">0</span>) != len) &#123;</span><br><span class="line">                        perror(<span class="string">"fail to send data"</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> fd = acceptConnection(pollFds[i].fd);</span><br><span class="line">                    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        perror(<span class="string">"fail to accept connection"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">                        <span class="keyword">if</span> (pthread_create(&amp;tid, <span class="literal">NULL</span>, handleRequst, (<span class="keyword">void</span>*)&amp;fd) != <span class="number">0</span>) &#123;</span><br><span class="line">                            perror(<span class="string">"fail to create handle thread"</span>);</span><br><span class="line">                            close(fd);</span><br><span class="line">                            <span class="keyword">goto</span> errout;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>| poll man page： <a href="http://man7.org/linux/man-pages/man2/poll.2.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man2/poll.2.html</a></p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><strong><code>epoll</code></strong></h3><p>epoll使用一个数据结构<code>epoll_event</code>来描述所监听的fd集合:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">            <span class="keyword">void</span>    *ptr;</span><br><span class="line">            <span class="keyword">int</span>      fd;</span><br><span class="line">            <span class="keyword">uint32_t</span> u32;</span><br><span class="line">            <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        &#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">            <span class="keyword">uint32_t</span>     events;    <span class="comment">/* Epoll events */</span></span><br><span class="line">            <span class="keyword">epoll_data_t</span> data;      <span class="comment">/* User data variable */</span></span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>这里的<code>events</code>表示所发生的事件类型，有<code>EPOLLIN/EPOLLOUT/EPOLLHUP</code>，这里的取值跟poll中的事件基本一致。使用epoll的步骤:</p><ul><li>声明两个epoll_event集合,一个用于监听，一个用于监听返回: <code>struct epoll_event polledEv[MAX_PORTS], readyEv[MAX_PORTS];</code></li><li>在kernel创建一个epoll的fd: <code>int epollFd = epoll_create1(0);</code></li><li>将需要监听的fd保存到epoll_event中：<code>epoll_ctl(epollFd, EPOLL_CTL_ADD, sockFd, &amp;polledEv[i])</code></li><li>等待可用的集合: <code>int ready = epoll_wait(epollFd, readyEv, MAX_PORTS, 5);</code>， 返回小于零表示出现错误；返回0表示超时；返回大于0，表示当前有多少个可用的文件描述符。相应的集合保存到<code>readyEv</code>中，因此只需要遍历这个子集即可得到对应可用的fd</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">polledEv</span>[<span class="title">MAX_PORTS</span>], <span class="title">readyEv</span>[<span class="title">MAX_PORTS</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">polledEv[i].data.fd = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> epollFd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (epollFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">"fail to create epoll for stdin"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  polledEv[<span class="number">0</span>].data.fd = STDIN_FILENO;</span><br><span class="line">  polledEv[<span class="number">0</span>].events = EPOLLIN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (epoll_ctl(epollFd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;polledEv[<span class="number">0</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">"epoll_ctl: stdin"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> sockFd = createServerSocket(atoi(argv[i]));</span><br><span class="line"><span class="keyword">if</span> (sockFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">"fail to create socket"</span>);</span><br><span class="line"><span class="keyword">continue</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">polledEv[i].data.fd = sockFd;</span><br><span class="line">polledEv[i].events = EPOLLIN;</span><br><span class="line"><span class="keyword">if</span> (epoll_ctl(epollFd, EPOLL_CTL_ADD, sockFd, &amp;polledEv[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">"epoll_ctl"</span>);</span><br><span class="line">close(sockFd);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line"><span class="keyword">int</span> ready = epoll_wait(epollFd, readyEv, MAX_PORTS, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (ready &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">"epoll_wait:"</span>);</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ready == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//printf("timeout\n")</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ready; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> fd = acceptConnecton(readyEv[i].data.fd);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">"fail to accept request"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">if</span> (pthread_create(&amp;tid, <span class="literal">NULL</span>, handleRequest, (<span class="keyword">void</span>*)&amp;fd) != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">"fail to create handle thread"</span>);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>| epoll man page: <a href="http://man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man7/epoll.7.html</a></p><p>最后，对于每个客户请求，都创建一个新的线程来处理请求：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = *((<span class="keyword">int</span>*)args);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"handleRequest(): from fd=%d\n"</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[MAX_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (recv(fd, buf, MAX_BUF_SIZE, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fail to receive message from client\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Client(%d): %s\n"</span>, fd, buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">buf[len] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (send(fd, buf, len, <span class="number">0</span>) != len) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fail to echo"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里分别采用<code>select</code>，<code>poll</code>以及<code>epoll</code>在服务端监听客户IO事件，只是作为演示学习用，实际服务器端使用的是更为复杂的IO复用模型，更多相关的资料可参考C10K: <a href="http://www.kegel.com/c10k.html。" target="_blank" rel="noopener">http://www.kegel.com/c10k.html。</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_71/rzab6/howdosockets.htm" target="_blank" rel="noopener">https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_71/rzab6/howdosockets.htm</a></li><li><a href="http://beej.us/guide/bgipc/html/multi/index.html" target="_blank" rel="noopener">http://beej.us/guide/bgipc/html/multi/index.html</a></li><li><a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">http://www.kegel.com/c10k.html</a></li><li><a href="https://lwn.net/Articles/13918/" target="_blank" rel="noopener">LWN email list: epoll as a system call</a></li><li><a href="https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html" target="_blank" rel="noopener">https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html</a></li><li><a href="https://lwn.net/Articles/14168/" target="_blank" rel="noopener">https://lwn.net/Articles/14168/</a></li><li><a href="https://www.programering.com/a/MzN4IDMwATM.html" target="_blank" rel="noopener">https://www.programering.com/a/MzN4IDMwATM.html</a></li><li><a href="https://notes.shichao.io/unp/ch6/" target="_blank" rel="noopener">https://notes.shichao.io/unp/ch6/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;socket通常用于跨进程通信(Inter-Process Communication,IPC)，由于其最早BSD Unix发行版中使用，因此也叫做&lt;a href=&quot;https://en.wikipedia.org/wiki/Berkeley_sockets&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Barkeley sockets&lt;/a&gt;。socket封装了底层网络通信协议细节，为上层应用提供了一个统一的接口，按照使用的“域”不同，又分为用于网络通信的internet socket以及用于本地进程通信的Unix domain socket
    
    </summary>
    
      <category term="Linux" scheme="http://sniffer.site/categories/Linux/"/>
    
    
      <category term="socket programming" scheme="http://sniffer.site/tags/socket-programming/"/>
    
      <category term="I/O multiplexing" scheme="http://sniffer.site/tags/I-O-multiplexing/"/>
    
      <category term="network programming" scheme="http://sniffer.site/tags/network-programming/"/>
    
  </entry>
  
  <entry>
    <title>关于技术发展的一些思考</title>
    <link href="http://sniffer.site/2018/06/22/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://sniffer.site/2018/06/22/关于技术发展的一些思考/</id>
    <published>2018-06-22T14:42:21.000Z</published>
    <updated>2019-11-07T11:47:15.539Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>社会或法律就是这样或者应当这样起源的。它们给弱者新的桎梏， 给富人以新的力量。</p><p>   卢梭</p></blockquote><p>最近一年，在智能终端出现的第十一个年头，有关5G/物联网/车联网，人工智能/深度学习方面的消息层出不穷，一场新的技术变革正在悄然来临，人们的生活方式与思维方式也如智能终端出现时那样注定要被深刻的被影响与改变。<a id="more"></a></p><p>在Android终端做了将近四年的开发，对移动通信行业有了一定的了解。从2G到3G再到4G(<a href="https://en.wikipedia.org/wiki/LTE_(telecommunication" target="_blank" rel="noopener">LTE</a>))，移动通信技术正在加速变化。未来，随着<a href="https://en.wikipedia.org/wiki/5G" target="_blank" rel="noopener">5G</a>的大规模商用，传统的CS(<a href="http://sniffer.site/2017/11/20/Circuit-Switching-Packet-Switching/">Circuit Switching</a>)网络业务终将告别历史舞台，我们所熟知的2G/3G网络将不可避免的被抛弃，而终端所有的通讯应用，无论是打电话，发短信等传统业务，还是像IMS/VOLTE等视频业务都会统一到一个通信方式上来:PS(<a href="http://sniffer.site/2017/11/20/Circuit-Switching-Packet-Switching/">Packet Switching</a>)。LTE（4G)与5G本质上都只有PS一种数据传输模式了，但LTE为了支持CS语音通话，还会支持CSFB，SRVCC以实现LTE网络与CS网络的平滑过渡。那么，为何5G能够带来如此多的话题与想象了?4G与5G又有那些根本上的差异？相比LTE网络，5G速度更快（峰值速度可达100Mbit/s),延时更小（数据建立过程只需1ms左右），单位面积可接入的设备密度更高(每平方公里可达10<sup>6</sup>接入设备), 移动性更强（移动速度最高可到500km/h仍然可以保证通信质量）。</p><p>具体来说, 5G提供了比4G更丰富的应用场景:</p><ul><li>eMBB(enhanced Mobile Broadband): 提供更快速的连接, 更高的吞吐量, 更大的容量. 适用于大量用户集中的场景, 比如大型活动场所(体育馆/演唱会等)</li><li>URLLC(Ultra Reliable Low Latency Communications): 提供低于10ms延迟的链接, 适用于需要低延迟的场景, 如自动驾驶</li><li>mMTC(Massive Machine-Type Communications): 大规模低功耗设备的互联, 适用于大量IoT设备的相互通讯</li></ul><p>5G的到来，让智能终端与设备链接有了更多的想象空间：</p><ul><li>物联网（Internet of Things): 有了5G ， 万物皆可连接网络，成为产生数据的节点，也有了消费数据的能力；</li><li>智能家居成为每个家庭的标配，让人们的生活更加方便舒适；</li><li>车联网(Internet of Vehicle): 汽车不再仅仅是一个出行工具，还是网络的一部分，为人们的出行做出优化，为用户带来更多的便捷；借助自动驾驶，长途自驾出行不再是件痛苦的事情；</li><li>在高铁上，不用担心没有网络了，5G网络在终端高速移动的情况下仍然可以保持良好的服务与体验；</li><li>工业生产设备也可以通过5G网络连接上网络，把采集到的数据采集到数据中心节点上，为工业生产流程优化提供决策支持；</li></ul><p>无论是芯片厂商还是网络设备厂商，都对5G的商用做了诸多的畅想：</p><ul><li><a href="https://www.ericsson.com/en/5g" target="_blank" rel="noopener">Ericsson</a> </li><li><a href="https://www.qualcomm.com/invention/5g" target="_blank" rel="noopener">Qualcomm</a> </li><li><a href="http://www.huawei.com/minisite/5g/en/" target="_blank" rel="noopener">Huawei</a> </li></ul><p>大量的设备链接意味着产生的数据量也会成倍的增加。有了海量的数据我们可以做些什么了？通过数据，个人与企业都可以对自己的决策做出更多的优化。个人可以通过追踪身体指标来把握自己的身体健康状态，保持自己与家庭设备时刻连接的状态；互联网企业通过深度学习与大规模数据的挖掘来发掘用户行为，为企业决策提供更多支持；工业企业通过大数据可以控制与优化生产流程，提升效益，创造更多的价值。未来，无疑是一个数据流与信息流的社会。人们的生活依赖于数据的支撑，也离不开数据。</p><p>对于大部分个人与中小企业而言，数据的存放与挖掘都需要依赖于大企业提供服务。很多的基础功能与服务都可以通过<a href="https://en.wikipedia.org/wiki/Cloud_computing" target="_blank" rel="noopener">云计算</a> 来实现。今天，人们已经可以通过云端来部署诸如数据存储，网页托管，内容分发以及视频直播，未来，很多常见的智能设备所拥有的功能都可能通过云化来实现；人们不再需要一个“笨重”的移动设备，而是一个很“轻”的终端，这个终端只是一个服务的入口，所有的应用甚至操作系统都放在云端，核心的计算与功能都通过云端来实现，人们实际操作的是一个虚拟的云端设备。这有点类似于今天的浏览器，人们通过浏览器可以得到各种各样的服务，而无须安装其他的应用软件。云无处不在，成为像水、电一样的基础设施服务。</p><p>可以想见，在不远的未来，5G与物联网， 云，大数据以及人工智能将成为科技发展的引擎，在更深程度的影响与改变人类的生活与思维方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;社会或法律就是这样或者应当这样起源的。它们给弱者新的桎梏， 给富人以新的力量。&lt;/p&gt;
&lt;p&gt;   卢梭&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近一年，在智能终端出现的第十一个年头，有关5G/物联网/车联网，人工智能/深度学习方面的消息层出不穷，一场新的技术变革正在悄然来临，人们的生活方式与思维方式也如智能终端出现时那样注定要被深刻的被影响与改变。
    
    </summary>
    
      <category term="思考" scheme="http://sniffer.site/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="技术" scheme="http://sniffer.site/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="5G" scheme="http://sniffer.site/tags/5G/"/>
    
      <category term="人工智能" scheme="http://sniffer.site/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
</feed>
