<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasonWang&#39;s Blog</title>
  
  <subtitle>本色做人，角色做事</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sniffer.site/"/>
  <updated>2021-02-25T03:03:54.615Z</updated>
  <id>http://sniffer.site/</id>
  
  <author>
    <name>Jason Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ADB是如何工作的</title>
    <link href="http://sniffer.site/2021/02/20/ADB%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <id>http://sniffer.site/2021/02/20/ADB是如何工作的/</id>
    <published>2021-02-20T10:33:02.000Z</published>
    <updated>2021-02-25T03:03:54.615Z</updated>
    
    <content type="html"><![CDATA[<p>这两天隔壁部门的同事反馈说新项目上, 车机(Android系统)上挂载的USB外设(一个可以上网的TBOX设备)无法通过ADB(Android Debug Bridge)进行连接. 心里有点纳闷, USB不都识别到了吗, 上次也把ADB相关的客户端都移植过去了, 为啥还会识别不到设备了? 只得从头开始理下ADB相关的代码与逻辑.先来看看ADB的基本原理.</p><p>ADB(全称Android Debug Bridge)是Android上用途十分广泛的调试工具, 可用于与开发设备进行连接;ADB命令既可以用来主机与设备之间传输文件, 也可以通过SHELL命令对设备进行操作. 如下所示, 是ADB的一个工作原理图:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/how_adb_works.png" alt="How ADB works"></p><p>可以看到, ADB主要有3个部分组成:</p><ul><li>ADB clients: 客户端程序, 运行在开发设备上, 用于发送指令, 用户可以通过adb shell/devices来激活客户端</li><li>ADBD: 守护进程, 作为后台进程运行在调试设备上, 一般在系统启动的时候加载</li><li>ADB server: 服务端进程, 运行在开发设备上, 负责ADBD与客户端进程的通讯, 由ADB客户端负责加载</li></ul><p>对于模拟设备, ADB server与ADB一般是通过TCP/IP协议建立的通讯链接; 对于外接的USB调试设备, 则可以选择通过USB/TCP两种方式进行连接. 一般来说, 一个ADB指令的执行需要经过如下几个步骤:</p><ul><li>用户输入<code>adb shell/devices</code>时, 会判断是否有<code>ADB server</code>进程存在,如果没有就启动一个进程</li><li>ADB server通过TCP 5037端口监听来自客户进程请求, 在初始化的时候, 如果使用的是TCP连接模式, ADB Server会通过扫面一个固定的TCP端口范围<code>5555 ~ 5585</code>中的奇数号来尝试连接到目标调试设备;如果是USB连接模式, 则会通过扫描当前已连接的USB设备, 从中找出用于ADB通讯的接口用于通讯. 不指定连接模式, 则会扫描所有的设备</li><li>ADB server找到设备并建立连接后, 就可以把来自客户端的请求发送给调试设备的ADBD进程了, 由ADBD来执行用户的请求并返回结果</li></ul><p>这里就从源码的角度具体分析下ADB的具体执行流程(主要以USB连接模式为例). 在分析具体的流程之前, 不妨来简单看看Android ADB的代码结构. 以Android Pie代码为例:</p><ul><li>ADB的源码位于<code>/system/core/adb</code>, 客户端代码位于<code>client</code>目录, 而ADBD的代码则位于<code>daemon</code>目录</li><li>根目录下的代码包含了客户端/服务端以及守护进程的共用的逻辑; 查看共用代码部分时, 定义了<code>ADB_HOST</code>宏的表示是需要在HOST端执行的代码逻辑(包括客户端以及服务端), 其他则是调试设备上ADBD的逻辑.</li></ul><h2 id="ADB客户端-服务进程的启动"><a href="#ADB客户端-服务进程的启动" class="headerlink" title="ADB客户端/服务进程的启动"></a><strong>ADB客户端/服务进程的启动</strong></h2><p>查看<code>client</code>下面的代码, 有个main函数, 就是输入<code>adb shell//devices</code>执行的入口:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    adb_trace_init(argv);</span><br><span class="line">    <span class="keyword">return</span> adb_commandline(argc - <span class="number">1</span>, <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>**&gt;(argv + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>adb_commandline</code>最终会调用函数<code>adb_connect</code>尝试连接服务进程, 如果当前没有服务进程,则启动一个新的进程, 然后读取服务端返回的结果, 直接看下<code>adb_connect</code> 的逻辑:</p><ul><li>首先尝试连接服务端进程, 没有, 则通过<code>launch_server</code>启动一个新的进程</li><li>启动完成后, 通过<code>_adb_connect</code>连接到服务进程</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">adb_connect</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; service, <span class="built_in">std</span>::<span class="built_in">string</span>* error)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// first query the adb server's version</span></span><br><span class="line">    <span class="keyword">int</span> fd = _adb_connect(<span class="string">"host:version"</span>, error);</span><br><span class="line"></span><br><span class="line">    D(<span class="string">"adb_connect: service %s"</span>, service.c_str());</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-2</span> &amp;&amp; !is_local_socket_spec(__adb_server_socket_spec)) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"* cannot start server on remote host\n"</span>);</span><br><span class="line"><span class="comment">// error is the original network connection error</span></span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fd == <span class="number">-2</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"* daemon not running; starting now at %s\n"</span>, __adb_server_socket_spec);</span><br><span class="line">    start_server:</span><br><span class="line"><span class="keyword">if</span> (launch_server(__adb_server_socket_spec)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"* failed to start daemon\n"</span>);</span><br><span class="line">    <span class="comment">// launch_server() has already printed detailed error info, so just</span></span><br><span class="line">    <span class="comment">// return a generic error string about the overall adb_connect()</span></span><br><span class="line">    <span class="comment">// that the caller requested.</span></span><br><span class="line">    *error = <span class="string">"cannot connect to daemon"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"* daemon started successfully\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The server will wait until it detects all of its connected devices before acking.</span></span><br><span class="line"><span class="comment">// Fall through to _adb_connect.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// If a server is already running, check its version matches.</span></span><br><span class="line"><span class="keyword">int</span> version = ADB_SERVER_VERSION - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we have a file descriptor, then parse version result.</span></span><br><span class="line"><span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> version_string;</span><br><span class="line">    <span class="keyword">if</span> (!ReadProtocolString(fd, &amp;version_string, error)) &#123;</span><br><span class="line">        adb_close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReadOrderlyShutdown(fd);</span><br><span class="line">    adb_close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(&amp;version_string[<span class="number">0</span>], <span class="string">"%04x"</span>, &amp;version) != <span class="number">1</span>) &#123;</span><br><span class="line">        *error = android::base::StringPrintf(<span class="string">"cannot parse version string: %s"</span>,</span><br><span class="line">                                             version_string.c_str());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If fd is -1 check for "unknown host service" which would</span></span><br><span class="line">    <span class="comment">// indicate a version of adb that does not support the</span></span><br><span class="line">    <span class="comment">// version command, in which case we should fall-through to kill it.</span></span><br><span class="line">    <span class="keyword">if</span> (*error != <span class="string">"unknown host service"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (version != ADB_SERVER_VERSION) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"adb server version (%d) doesn't match this client (%d); killing...\n"</span>,</span><br><span class="line">            version, ADB_SERVER_VERSION);</span><br><span class="line">    adb_kill_server();</span><br><span class="line">    <span class="keyword">goto</span> start_server;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the command is start-server, we are done.</span></span><br><span class="line">    <span class="keyword">if</span> (service == <span class="string">"host:start-server"</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = _adb_connect(service, error);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">D(<span class="string">"_adb_connect error: %s"</span>, error-&gt;c_str());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(fd == <span class="number">-2</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"* daemon still not running\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    D(<span class="string">"adb_connect: return fd %d"</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<code>launch_server</code> linux部分的实现, 其实际的入口与客户端的函数入口是一样的, 只是参数不一样而已: 服务端启动完成之后, 发送<code>OK</code>的状态给客户端, 告知其启动完成.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (pipe(fd)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pipe failed in launch_server, errno: %d\n"</span>, errno);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> path = android::base::GetExecutablePath();</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// child side of the fork</span></span><br><span class="line"></span><br><span class="line">    adb_close(fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> reply_fd[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(reply_fd, <span class="keyword">sizeof</span>(reply_fd), <span class="string">"%d"</span>, fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    <span class="keyword">int</span> result = execl(path.c_str(), <span class="string">"adb"</span>, <span class="string">"-L"</span>, socket_spec.c_str(), <span class="string">"fork-server"</span>, <span class="string">"server"</span>,</span><br><span class="line">                       <span class="string">"--reply-fd"</span>, reply_fd, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// this should not return</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"adb: execl returned %d: %s\n"</span>, result, strerror(errno));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// parent side of the fork</span></span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">3</span>] = &#123;&#125;;</span><br><span class="line">    <span class="comment">// wait for the "OK\n" message</span></span><br><span class="line">    adb_close(fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> ret = adb_read(fd[<span class="number">0</span>], temp, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> saved_errno = errno;</span><br><span class="line">    adb_close(fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"could not read ok from ADB Server, errno = %d\n"</span>, saved_errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">3</span> || temp[<span class="number">0</span>] != <span class="string">'O'</span> || temp[<span class="number">1</span>] != <span class="string">'K'</span> || temp[<span class="number">2</span>] != <span class="string">'\n'</span>) &#123;</span><br><span class="line">        ReportServerStartupFailure(pid);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设备的识别与扫描"><a href="#设备的识别与扫描" class="headerlink" title="设备的识别与扫描"></a><strong>设备的识别与扫描</strong></h2><p>我们重点来看下ADB SERVER是如何扫描设备的. 执行服务端进程后, 调用<code>adb_server_main</code>函数来执行服务端的逻辑:</p><ul><li><code>usb_init</code>扫描USB设备</li><li><code>adb_wait_for_device_initialization</code>等待扫描完成后, 发送<code>OK</code>给客户端进程</li><li><code>fdevent_loop</code> 进入循环, 等待来自客户端的请求</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">adb_server_main</span><span class="params">(<span class="keyword">int</span> is_daemon, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; socket_spec, <span class="keyword">int</span> ack_reply_fd)</span> </span>&#123;</span><br><span class="line">    signal(SIGINT, [](<span class="keyword">int</span>) &#123;</span><br><span class="line">        fdevent_run_on_main_thread([]() &#123; <span class="built_in">exit</span>(<span class="number">0</span>); &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* leak = getenv(<span class="string">"ADB_LEAK"</span>);</span><br><span class="line">    <span class="keyword">if</span> (leak &amp;&amp; <span class="built_in">strcmp</span>(leak, <span class="string">"1"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        intentionally_leak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_transport_registration();</span><br><span class="line">    init_mdns_transport_discovery();</span><br><span class="line"></span><br><span class="line">    usb_init();</span><br><span class="line">    local_init(DEFAULT_ADB_LOCAL_TRANSPORT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we told a previous adb server to quit because of version mismatch, we can get to this</span></span><br><span class="line">    <span class="comment">// point before it's finished exiting. Retry for a while to give it some time.</span></span><br><span class="line">    <span class="keyword">while</span> (install_listener(socket_spec, <span class="string">"*smartsocket*"</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, &amp;error) !=</span><br><span class="line">           INSTALL_STATUS_OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::chrono::steady_clock::now() - start &gt; <span class="number">0.5</span>s) &#123;</span><br><span class="line">            fatal(<span class="string">"could not install *smartsocket* listener: %s"</span>, error.c_str());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">100</span>ms);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    adb_auth_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_daemon) &#123;</span><br><span class="line">        <span class="comment">// Start a new session for the daemon. Do this here instead of after the fork so</span></span><br><span class="line">        <span class="comment">// that a ctrl-c between the "starting server" and "done starting server" messages</span></span><br><span class="line">        <span class="comment">// gets a chance to terminate the server.</span></span><br><span class="line">        <span class="comment">// setsid will fail with EPERM if it's already been a lead process of new session.</span></span><br><span class="line">        <span class="comment">// Ignore such error.</span></span><br><span class="line">        <span class="keyword">if</span> (setsid() == <span class="number">-1</span> &amp;&amp; errno != EPERM) &#123;</span><br><span class="line">            fatal(<span class="string">"setsid() failed: %s"</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait for the USB scan to complete before notifying the parent that we're up.</span></span><br><span class="line">        <span class="comment">// We need to perform this in a thread, because we would otherwise block the event loop.</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="function">thread <span class="title">notify_thread</span><span class="params">([ack_reply_fd]() &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            adb_wait_for_device_initialization();</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">// Any error output written to stderr now goes to adb.log. We could</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">// keep around a copy of the stderr fd and use that to write any errors</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">// encountered by the following code, but that is probably overkill.</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">// TODO(danalbert): Can't use SendOkay because we're sending "OK\n", not</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">// "OKAY".</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">if</span> (!android::base::WriteStringToFd(<span class="string">"OK\n"</span>, ack_reply_fd)) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                fatal_errno(<span class="string">"error writing ACK to fd %d"</span>, ack_reply_fd);</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            unix_close(ack_reply_fd);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span></span>;</span><br><span class="line">        notify_thread.detach();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    D(<span class="string">"Event loop starting"</span>);</span><br><span class="line">    fdevent_loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里着重看下USB设备的扫描<code>usb_init</code>&lt;<code>usb_dispatch.cpp</code>&gt;, 对ADB客户端/服务端都不是使用<code>libusb</code>来识别USB设备, 直接看<code>linux</code>下的实现<code>usb_linux.cpp</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usb_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (should_use_libusb()) &#123;</span><br><span class="line">LOG(DEBUG) &lt;&lt; <span class="string">"using libusb backend"</span>;</span><br><span class="line">libusb::usb_init();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">LOG(DEBUG) &lt;&lt; <span class="string">"using native backend"</span>;</span><br><span class="line">native::usb_init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>usb_init</code>主要是启动一个设备查找的线程, 用于不断识别接入的USB设备而已. 到这里, 我们大概知道了如何查找到USB设备并且读取设备的配置: 通过遍历<code>/dev/bus/usb</code>下面的节点, 即对应USB设备的字符设备, USB设备的信息就可以通过这些字符设备读取到. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">device_poll_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    adb_thread_setname(<span class="string">"device poll"</span>);</span><br><span class="line">    D(<span class="string">"Created device thread"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Use inotify.</span></span><br><span class="line">find_usb_device(<span class="string">"/dev/bus/usb"</span>, register_device);</span><br><span class="line">kick_disconnected_devices();</span><br><span class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="number">1</span>s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usb_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">actions</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;actions, <span class="number">0</span>, <span class="keyword">sizeof</span>(actions));</span><br><span class="line">    sigemptyset(&amp;actions.sa_mask);</span><br><span class="line">    actions.sa_flags = <span class="number">0</span>;</span><br><span class="line">    actions.sa_handler = [](<span class="keyword">int</span>) &#123;&#125;;</span><br><span class="line">    sigaction(SIGALRM, &amp;actions, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::thread(device_poll_thread).detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于ADB设备节点来说, 其有特殊的类别以及协议, 因此需要通过<code>is_adb_interface</code>来过滤掉非ADB的设备.感兴趣的可以仔细看下<code>find_usb_device</code>这个函数看下具体的设备查找流程.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADB_CLASS 0xff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADB_SUBCLASS 0x42</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADB_PROTOCOL 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_adb_interface</span><span class="params">(<span class="keyword">int</span> usb_class, <span class="keyword">int</span> usb_subclass, <span class="keyword">int</span> usb_protocol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (usb_class == ADB_CLASS &amp;&amp; usb_subclass == ADB_SUBCLASS &amp;&amp; usb_protocol == ADB_PROTOCOL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无法识别ADB设备的问题"><a href="#无法识别ADB设备的问题" class="headerlink" title="无法识别ADB设备的问题"></a><strong>无法识别ADB设备的问题</strong></h2><p>梳理了ADB的一些代码, 我们大致知道对于客户端来说,在USB模式下, 只是通过一个特定的USB设备节点来与调试设备通讯, 那么, 客户端找不到设备的原因就只有两个(如前所述, HOST端已经识别到了调试设备):</p><ul><li>客户端的配置有问题</li><li>调试设备的ADB配置有问题</li></ul><p>可问题在于, 同样的设备在PC上是可以正常识别到并使用ADB的, 那么可以基本可以确信调试设备上的ADB配置是没有问题的;关于如何在调试设备上适配ADB, 大家可以参考之前的一篇文章<a href="http://sniffer.site/2019/12/31/Recovery%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81ADB/">Recovery下如何配置ADB</a>. 那么, 问题就可以聚焦在客户端的配置上了.</p><p>对比下正常的配置与异常的配置, 发现异常的配置tty设备枚举到了5个(从<code>ttyUSB0</code>到<code>ttyUSB4</code>), 而正常只有4个(<code>ttyUSB0</code>到<code>ttyUSB3</code>), 进入<code>/sys/bus/usb/devices</code>找到对应的<code>ttyUSB4</code> 设备, 看了下相应的配置,<br><code>bInterfaceClass</code>/<code>bInterfaceProtocol</code>/<code>bInterfaceSubClass</code>与上述ADB的配置是完全一致的, <code>interface</code>的结果为<code>ADB interface</code>. 现在应该可以肯定, 这个多出来的<code>ttyUSB4</code> 串口设备应该就是用于ADB通讯的设备, 但是不知道为何被枚举成了串口. 看看串口驱动源码(<code>drivers/usb/serial/option.c</code>):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">option_probe</span><span class="params">(struct usb_serial *serial,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_interface_descriptor</span> *<span class="title">iface_desc</span> =</span></span><br><span class="line"><span class="class">&amp;<span class="title">serial</span>-&gt;<span class="title">interface</span>-&gt;<span class="title">cur_altsetting</span>-&gt;<span class="title">desc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device_descriptor</span> *<span class="title">dev_desc</span> = &amp;<span class="title">serial</span>-&gt;<span class="title">dev</span>-&gt;<span class="title">descriptor</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> device_flags = id-&gt;driver_info;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Never bind to the CD-Rom emulation interface*/</span></span><br><span class="line"><span class="keyword">if</span> (iface_desc-&gt;bInterfaceClass == <span class="number">0x08</span>)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don't bind reserved interfaces (like network ones) which often have</span></span><br><span class="line"><span class="comment"> * the same class/subclass/protocol as the serial interfaces.  Look at</span></span><br><span class="line"><span class="comment"> * the Windows driver .INF files for reserved interface numbers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (device_flags &amp; RSVD(iface_desc-&gt;bInterfaceNumber))</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don't bind network interface on Samsung GT-B3730, it is handled by</span></span><br><span class="line"><span class="comment"> * a separate module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (dev_desc-&gt;idVendor == cpu_to_le16(SAMSUNG_VENDOR_ID) &amp;&amp;</span><br><span class="line">    dev_desc-&gt;idProduct == cpu_to_le16(SAMSUNG_PRODUCT_GT_B3730) &amp;&amp;</span><br><span class="line">    iface_desc-&gt;bInterfaceClass != USB_CLASS_CDC_DATA)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里明确指出了, 有些保留(<code>RSVD)</code>的端口不需要枚举, 从这里我们大致可以推测问题的原因: ADB对应的设备节点被枚举成了串口, 导致ADB服务端无法与调试设备进行连接通讯. 就是说, 只要把对应端口号的设备保留下来即可. 找到调试设备VID/PID所在的地方, 加上<code>RSVD</code>标志即可:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123; USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_AG35), </span><br><span class="line">.driver_info = RSVD(<span class="number">4</span>)&#125;,  <span class="comment">// 4 对应设备的节点数字, bInterfaceNumber</span></span><br></pre></td></tr></table></figure><p>修改后, 就可以看到<code>adb devices</code>有设备列出了.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://developer.android.com/studio/command-line/adb" target="_blank" rel="noopener">https://developer.android.com/studio/command-line/adb</a></li><li><a href="https://events.static.linuxfound.org/images/stories/pdf/lf_abs12_kobayashi.pdf" target="_blank" rel="noopener">https://events.static.linuxfound.org/images/stories/pdf/lf_abs12_kobayashi.pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天隔壁部门的同事反馈说新项目上, 车机(Android系统)上挂载的USB外设(一个可以上网的TBOX设备)无法通过ADB(Android Debug Bridge)进行连接. 心里有点纳闷, USB不都识别到了吗, 上次也把ADB相关的客户端都移植过去了, 为啥还会识
      
    
    </summary>
    
      <category term="Android" scheme="http://sniffer.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://sniffer.site/tags/Android/"/>
    
      <category term="ADB" scheme="http://sniffer.site/tags/ADB/"/>
    
      <category term="Android Debug Bridge" scheme="http://sniffer.site/tags/Android-Debug-Bridge/"/>
    
  </entry>
  
  <entry>
    <title>&lt;我的工程格言&gt;[译]</title>
    <link href="http://sniffer.site/2021/01/08/%E8%AF%91-%E6%88%91%E7%9A%84%E5%B7%A5%E7%A8%8B%E6%A0%BC%E8%A8%80/"/>
    <id>http://sniffer.site/2021/01/08/译-我的工程格言/</id>
    <published>2021-01-08T08:08:04.000Z</published>
    <updated>2021-02-25T03:04:25.029Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>The major problems of our work are not so much technological as sociological in nature</p><p>  《people-ware:productive projects/teams》</p></blockquote><p>几个月前，我做了一个有关个人工程格言的演讲-大致讲了过去几年来在写代码，打磨产品(building things)以及跟人合作时,积累的一些有用而且一般来说都是正确的想法。<a id="more"></a></p><p>格言是一个很有意思的单词，但是从词源学的角度追根溯源，<code>axiom</code>来自希腊语<a href="https://en.wiktionary.org/wiki/%E1%BC%80%CE%BE%CE%AF%CF%89%CE%BC%CE%B1" target="_blank" rel="noopener"><code>ἀξίωμα</code></a>, 含义是“合适或值得思考的想法”。我喜欢这个说法，将我格言中的每一项都当作是值得深思的。</p><p>当然，他们都是根据我过往经验并且我认为有用的工程格言。你的个人经验可能有所不同。也许你已经了解了<code>zero termination</code>（C字符串通常用0结尾），抑或有比<code>scissors to remove bugs</code>更好的工具。</p><p>不管怎样，我以为通过简要的阐述将格言清单列出来是件有趣的事情。有些表述可能相当平淡，但还是希望有人可以因此产生更多深入的思考或者有趣的不同意见。</p><blockquote><p>这里只翻译了几个我认为比较重要的条目，有兴趣的可以直接看原文<a href="https://martinrue.com/my-engineering-axioms/" target="_blank" rel="noopener">My Engineer Axioms</a></p></blockquote><h2 id="1-Change-is-contant"><a href="#1-Change-is-contant" class="headerlink" title="1. Change is contant"></a><strong>1. Change is contant</strong></h2><p>这条不应该有太多的争议。几乎万事万物都时刻在变化，包括变化本身（又想起那句“世界永远不变的是变化本身”）。我们不仅要认识到我们应对变化的能力至关重要，同时要意识到我们怎么做好一件事（时间，成本，质量，可靠性）通常是我们竞争力的衡量标准。</p><h2 id="2-Your-product-is-an-asset-but-code-is-a-liability"><a href="#2-Your-product-is-an-asset-but-code-is-a-liability" class="headerlink" title="2. Your product is an asset, but code is a liability"></a><strong>2. Your product is an asset, but code is a liability</strong></h2><p>你的产品解决了客户的问题，因此是你的资产。而代码本身是你创造这个资产的负债。代码越多，就需要更多的阅读，测试，修改以及理解。当你将此与格言1联系在一起时，这一点尤为明显。保守地接受新的代码（包括对外部代码的依赖）。最好的代码是你什么都不用写。</p><h2 id="3-Duplication-is-less-costly-than-premature-abstraction"><a href="#3-Duplication-is-less-costly-than-premature-abstraction" class="headerlink" title="3. Duplication is less costly than premature abstraction"></a><strong>3. Duplication is less costly than premature abstraction</strong></h2><p>除非你十分确信抽象由于能解决一个实际/抽象的问题，能带来足够的收益，否则不要轻易做。等待并且学习更多（掌握足够信息后再做决策）。在此之前，重复的代码有益于避免依赖，这会让代码更容易修改或者删除。过早的抽象可能通过依赖或间接的方式引入复杂度，这个可能会成为未来你应对改变的一个瓶颈。</p><h2 id="4-Code-should-be-easy-to-delete"><a href="#4-Code-should-be-easy-to-delete" class="headerlink" title="4. Code should be easy to delete"></a><strong>4. Code should be easy to delete</strong></h2><p>写的代码应该是可以随时移除的，从某种角度来说就是要“解耦”.可以肯定的说，并不是所有代码都需要保持同样的可移除状态，但最小化依赖，通过好的接口提供清晰的边界，并且慎重考虑整体的系统设计以便某些部分可以更容易的删除/修改。我以前听说有人使用“花出去的代码”而不是“写好的代码”，我喜欢这种表述;我倾向于说，删除代码就是减少未来的成本。</p><h2 id="5-Existing-Code-exerts-a-powerful-influence"><a href="#5-Existing-Code-exerts-a-powerful-influence" class="headerlink" title="5. Existing Code exerts a powerful influence "></a><strong>5. Existing Code exerts a powerful influence </strong></h2><p>一段代码存在就表明它是正确的，必要的。希望如此，但实际情况并不总是这样。我们需要保持两份信心去修改它，有能力推断是否我们应该修改它。不要让代码存在本身制造一种它不可被删除的疑惑。就像第4条说的那样，代码应该总是很容易的删除，而且一个好的系统设计应该使我们可以理解我们是否需要它。</p><h2 id="6-Accidental-complexity-is-one-of-the-biggest-risks"><a href="#6-Accidental-complexity-is-one-of-the-biggest-risks" class="headerlink" title="6. Accidental complexity is one of the biggest risks"></a><strong>6. Accidental complexity is one of the biggest risks</strong></h2><p>偶然性的复杂度是指那些本可以避免，却由于诸如糟糕的设计，错误的决策或者未将简单作为系统设计的首要原则等因素引入的复杂。如果简单不是一个目标，偶然的复杂则可能随着系统的扩展而出现，会逐渐的对几乎所有事情产生负面影响，从修改系统到理解设计背后的逻辑。2006年有一篇关于次主题的文章<a href="http://curtclifton.net/papers/MoseleyMarks06a.pdf" target="_blank" rel="noopener">跳出焦油坑(out of tar pit)</a>值得一读。</p><blockquote><p>后面几条(7 ~ 10) 都是关于团队协作以及如何与人沟通的，只翻译了部分，其余可以参考原文</p></blockquote><h2 id="7-Technical-execellence-can-be-shadowned-by-bad-personal-skills"><a href="#7-Technical-execellence-can-be-shadowned-by-bad-personal-skills" class="headerlink" title=" 7. Technical execellence can be shadowned by bad personal skills"></a><strong> 7. Technical execellence can be shadowned by bad personal skills</strong></h2><p>除非你单独工作，否则真正起作用的不仅仅是个人解决技术问题/写好代码的能力。相反，如果你使身边的人不开心或者效率变低，这些能力实际影响更小。正如写好代码需要学习，你必须学习如何与人相处。同理心是其中很重要的部分，要认识到每个人都并不相同-主动关心别人，理解他人，帮助别人，并请求他人的帮助，保持友好。努力成为一个别人愿意共事的工程师。</p><ul><li>(8) You are not your code. Be kind to the coder, not to the code</li><li>(9) Treat people who know less than you with respect and patience</li><li>(10) The only true authority stems from knowledge, not from position</li><li>(11) Teaching is a form of learning in disguise</li></ul><h2 id="12-Lift-the-skills-of-people-around-you-not-just-yourself"><a href="#12-Lift-the-skills-of-people-around-you-not-just-yourself" class="headerlink" title="12. Lift the skills of people around you, not just yourself"></a><strong>12. Lift the skills of people around you, not just yourself</strong></h2><p>优秀的团队绝不会因为一个厉害的就变得优秀。团队之所以优秀是因为每个人都互相挑战对方，每个人都相互成长。当你学习到某个有意思的东西，分享出来-帮助团队其他人变得更好。当其他人做同样的事情时，每个人都从中受益，没有人会落后。这样做可以获得更多的乐趣。第二点好处参考第11条。</p><h2 id="13-The-longer-you-wait-the-more-you’ll-know"><a href="#13-The-longer-you-wait-the-more-you’ll-know" class="headerlink" title="13. The longer you wait the more you’ll know "></a><strong>13. The longer you wait the more you’ll know </strong></h2><p>我一直学习这一点，努力避免快速决策的内在冲动。事实上，对于非核心的决策，延迟越久，等到需要做决定时，获取到的信息就越多。当然你不能总是拖延决策，但是常常可以这么做;最不济的来说，你应该至少要考虑当前是否知道问题的答案是否可以接受。</p><h2 id="14-A-good-type-system-is-worth-its-weight-plus-some"><a href="#14-A-good-type-system-is-worth-its-weight-plus-some" class="headerlink" title="14. A good type system is worth its weight plus some"></a><strong>14. A good type system is worth its weight plus some</strong></h2><p>有关编程语言类型的（略过）</p><h2 id="15-The-right-team-of-people-trumps-everything-else"><a href="#15-The-right-team-of-people-trumps-everything-else" class="headerlink" title="15. The right team of people trumps everything else"></a><strong>15. The right team of people trumps everything else</strong></h2><p>有一个彼此愿意工作在一起创造好的产品的团队，会使很多其他问题更容易处理。这里的”对“其实是相当主观，情景相关的，但至少是秩闻一样。同理心，尊重，友谊一直是我待过的优秀团队的特质。</p><h2 id="16-Stick-to-boring-technology-unless-there’s-a-good-reason-not-to"><a href="#16-Stick-to-boring-technology-unless-there’s-a-good-reason-not-to" class="headerlink" title="16. Stick to boring technology, unless there’s a good reason not to"></a><strong>16. Stick to boring technology, unless there’s a good reason not to</strong></h2><p>无聊的技术通常更老，更好的被理解。为了更有效的使用这些技术，更好的理解其失败的模式，人们曾经有过通过挣扎的经历，因此通常更容易找到知道如何进行最佳实践的人跟资源。我很喜欢<code>Dan Mackinley</code>的<a href="https://mcfunley.com/choose-boring-technology" target="_blank" rel="noopener"><code>Innovation tokens</code></a>的想法; 你只需要3个无聊的技术。用它们来构建新的东西-最好是那些可以提升核心竞争力的东西。不要超过3个，否则会增加（技术）从未到达稳定与成熟的风险。</p><h2 id="17-Have-the-smallest-team-possible-but-no-smaller-Grow-it-carefully"><a href="#17-Have-the-smallest-team-possible-but-no-smaller-Grow-it-carefully" class="headerlink" title="17. Have the smallest team possible, but no smaller. Grow it carefully"></a><strong>17. Have the smallest team possible, but no smaller. Grow it carefully</strong></h2><p>小团队可以更有效的合作，减少沟通摩擦（个人表述，原文翻译略）</p><h2 id="18-Rest"><a href="#18-Rest" class="headerlink" title="18. Rest"></a><strong>18. Rest</strong></h2><p>长期996实在不够明智，除了身心疲惫，可能你也失去了自我学习与成长的时间与机会。偶尔996,平时多注意锻炼身体，放松自己（个人表述，原文翻译略）</p><h2 id="19-Don’t-pick-a-solution-until-you’ve-thought-of-at-least-one-more"><a href="#19-Don’t-pick-a-solution-until-you’ve-thought-of-at-least-one-more" class="headerlink" title="19. Don’t pick a solution until you’ve thought of at least one more"></a><strong>19. Don’t pick a solution until you’ve thought of at least one more</strong></h2><p>在找到了一个问题的答案之前，不要匆忙解决问题，而是要尝试多几个解决方案，充分考虑各个条件的平衡（trade-off)。（个人表述，原文翻译略）</p><h2 id="20-Have-opinions-but-avoid-expressing-them-in-ways-that-cause-other-people-to-believe-you-won’t-change-them"><a href="#20-Have-opinions-but-avoid-expressing-them-in-ways-that-cause-other-people-to-believe-you-won’t-change-them" class="headerlink" title="20. Have opinions, but avoid expressing them in ways that cause other people to believe you won’t change them"></a><strong>20. Have opinions, but avoid expressing them in ways that cause other people to believe you won’t change them</strong></h2><p>表达观点是不要太过肯定，不是100%确定，而是留有余地，为后续的沟通保持一定的空间（个人表述，原文翻译略）</p><h2 id="21-It’s-OK-to-say-“I-don’t-know”-or-“I-need-to-research-that-before-I-have-an-answer”"><a href="#21-It’s-OK-to-say-“I-don’t-know”-or-“I-need-to-research-that-before-I-have-an-answer”" class="headerlink" title="21. It’s OK to say “I don’t know” or “I need to research that before I have an answer”"></a><strong>21. It’s OK to say “I don’t know” or “I need to research that before I have an answer”</strong></h2><p>承认自己不知道某件事情，并不丢人;当你不知道某件事情，表示你愿意与对方一起探讨问题，是一种更为友好的姿态（个人表述，原文翻译略）</p><h2 id="22-Writing-throwaway-code-to-explore-a-problem-space-is-underrated"><a href="#22-Writing-throwaway-code-to-explore-a-problem-space-is-underrated" class="headerlink" title="22. Writing throwaway code to explore a problem space is underrated"></a><strong>22. Writing throwaway code to explore a problem space is underrated</strong></h2><p>如果你对某个问题理解不够，允许自己犯错，写一些尝试性的代码，你可以学的更快（个人表述，原文翻译略）</p><h2 id="23-Manage-state-carefully"><a href="#23-Manage-state-carefully" class="headerlink" title="23. Manage state carefully"></a><strong>23. Manage state carefully</strong></h2><p>管理好代码中的状态，认真对待系统中状态的变化（个人表述，原文翻译略）</p><h2 id="24-It’s-all-about-trade-offs"><a href="#24-It’s-all-about-trade-offs" class="headerlink" title="24. It’s all about trade-offs"></a><strong>24. It’s all about trade-offs</strong></h2><p>所有的工程决策都包含中某种平衡; 仔细考虑这些平衡，在你想要修改某个已有的代码设计时，考虑这一点，这样你可能会做出更好的决策（个人表述，原文翻译略）</p><h2 id="25-A-good-design-is-one-in-which-you-can-change-your-mind-without-changing-too-much-code"><a href="#25-A-good-design-is-one-in-which-you-can-change-your-mind-without-changing-too-much-code" class="headerlink" title="25. A good design is one in which you can change your mind without changing too much code"></a><strong>25. A good design is one in which you can change your mind without changing too much code</strong></h2><p>世界不变的永远是变化本身。代码要面向未来的变化，系统设计要能适应未来的变化（对标产品，新特性等）（个人表述，原文翻译略）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;The major problems of our work are not so much technological as sociological in nature&lt;/p&gt;
&lt;p&gt;  《people-ware:productive projects/teams》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;几个月前，我做了一个有关个人工程格言的演讲-大致讲了过去几年来在写代码，打磨产品(building things)以及跟人合作时,积累的一些有用而且一般来说都是正确的想法。
    
    </summary>
    
      <category term="软件工程" scheme="http://sniffer.site/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件开发" scheme="http://sniffer.site/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="软件工程" scheme="http://sniffer.site/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="项目管理" scheme="http://sniffer.site/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
      <category term="团队协作" scheme="http://sniffer.site/tags/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>不得不说的2020</title>
    <link href="http://sniffer.site/2021/01/03/%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%842020/"/>
    <id>http://sniffer.site/2021/01/03/不得不说的2020/</id>
    <published>2021-01-03T01:45:53.000Z</published>
    <updated>2021-01-26T08:26:11.824Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>心灵是自己的地方，在那里可以把地狱变成天堂，也可以把天堂变成地狱</p><p>  约翰-弥尔顿《失乐园》</p></blockquote><p>2020年已然成为过往，但过去一年发生的种种却影响尤在，注定会成为很多人人生中的转折点：忽然而至的病毒导致经济颓败，很多公司工厂倒闭，有人失去了工作; 更悲伤的是，很多人因为新冠病毒失去了生命/亲人。中国的疫情虽说已经得到控制，最初的悲观情绪已经慢慢散去，人们开始了正常的生活，但欧美、印度等国家却还深陷病毒传播的泥沼，感染人数/死亡人数仍然居高不下。这是人类历史的悲怆之年。<a id="more"></a>不知道要等多久那些受到创伤的个人，家庭才能从疫情的阴霾当中走出来。但愿美好能很快就降临到不幸的人间;但愿快乐的日子又会像疫情之前一样带给每个人希望与甜美。</p><p>对我而言，这一年也可谓波折不断，身体与思想都经历了考验。因为女儿刚出生，疫情开始严重之时，我正在老家休假，所以并没有感受到太明显的变化;唯一不同的是，原本预计半个月休假回GZ，最后足足休息了一个月才回去。即便回到GZ，远程办公了大半个月才真正回到公司开始正常的工作。毫无疑问，疫情的发展速度超过了大多数人的想象，我们都有点措手不及。公司上下也对未来的预期变得悲观，有些部门甚至开始了裁撤人员。大家内心里有点不安与焦虑。但沉浸在危机之中的人，却往往容易忽略：每一次危机当中往往也蕴藏了巨大的机会。事实证明，这种悲观情绪被过度的渲染了;几个月后，公司融到了足够的资金，市场对于整个新能源市场的认知也发生了天翻地覆的变化，乐观与热情开始在行业内蔓延。看看蔚来的股价，从年初不到3美金，直接窜升到如今的超过45美金，真是跌宕起伏。这种过山车式的变化，对我来说是一次全新的体验，是认知上的巨大冲击。从这个角度来说，2020也是难忘的一年，不得不说的一年。</p><p>且把这一年的得失与感悟都写下来，当是对往后的勉励。</p><h2 id="拥抱变化，保持学习的心态"><a href="#拥抱变化，保持学习的心态" class="headerlink" title="拥抱变化，保持学习的心态"></a><strong>拥抱变化，保持学习的心态</strong></h2><p>一直以来，我都保持积极努力的姿态，平时会要求自己看书，学习，并尝试着提升自己各方面的能力。日积月累，虽有效果，但实则收效有限。我反思过，却未能找到真正的原因，也并没有完全实现自己理想中的突破。直到这次疫情在公司中经历行业的动荡与变化，才让我醒悟过来。为何我没能看到这些事后看来如此明显的趋势？为何我早早的把很多可能性排除在外，而只选择了一种更为保守与稳妥却实际不可能的可能了？为何我这么长时间都没有走出思维的舒适圈，拓宽自己视野的边界？从理论上来说，人的思维不应该有任何边界才对，可一直以来我都给自己设定了框架与边界，并且坚守了下来。这让我过的安稳舒适，却也让我失去了成长的机会。</p><p>高瓴资本创始人张磊一直强调说：世界永远不变的是变化本身。面对变化，面对新生事物，面对与以往认知不同甚至相抵触的东西时，我们要做的不是排斥，不是质疑，不是置之不理，而是要保持开放的思维方式，努力理解变化与新事物背后的历史与逻辑，努力去把握它，直到完全理解。对于未知的变化/事物，不要急于下结论，而是要”让子弹飞一会“，掌握了足够充分的信息后再做判断。意识到自己的无知，并不断的学习调整，才能在剧烈变化的环境中看到机会，并不断自我成长。</p><p>庄子说：吾生也有涯，而知也无涯;以有涯随无涯，怠矣。乔布斯也曾说：keep hugry, keep folish。面对不断变化的世界，面对未来的诸多不确定性，面对不断涌现的新生事物，不应该排斥，而是要积极拥抱，保持好奇之心，保持空杯与学习的心态，不断调整自我认知，不断探索各种可能，如此，方能最大程度的把握属于自己的机会，获得源源不断的成长动力。</p><h2 id="学会投资"><a href="#学会投资" class="headerlink" title="学会投资"></a><strong>学会投资</strong></h2><p>程序员的圈子里经常讨论的话题是996，35岁职场焦虑，中年危机等等，再加上家庭责任，这些重担压在身上，让大家都有种难以摆脱的浮躁与压力。处在软件开发这种快速变化的行业，我们这些程序员确实要承受不一样的压力与工作强度。但总的来说，软件尤其是互联网行业还在快速发展当中，人才缺口很大，只要足够努力用心，我们还是会有机会选择。对个人来说，改变不了大环境，那就努力改变自己; 改变不了行业的观念与风气，那就努力让自己变得更优秀。</p><p>这次突然的疫情，打破了往日正常的生活节奏，也让我意识到生活并不会像预期一样顺风顺水，而是充满了诸多的不确定性。如何应对这种不确定性，在发生外部风险时如何减少对自己的影响确是我之前很少思考的问题。平日高强度的工作，锻炼身体却越来越少，每次体检都看到不断升高的血脂/尿酸水平也在不断提醒自己该去运动运动了。因此，今年开始要重拾运动的习惯。确保每周都有锻炼，改善体质，注意平时的饮食，丰富自己的食物来源，减少油脂的摄入。健康的身体与充沛的精力只是抵御风险的第一步。在这之外，重要的还要学会财务投资。</p><p>财务投资迫使你学习基本的经济知识，了解世界经济的运作方式，去观察身边的经济现象，这是一种理解现代世界的必须途径。同时，也要看到，自2008年美国金融危机以来，几乎全球所有国家都在进行量化宽松的政策，货币发行量连年上升，这种超发的货币实际上是政府通过印钞机变相的掠夺你放在银行里的存款。因此，要抵消这些货币带来的通货膨胀，正确的财务投资必不可少。这是今年要重点去学习积累的一个方向：不能只是依赖单一的收入来源，而是要努力尝试财务投资，让自己有额外稳定的收益。</p><h2 id="与时间做朋友，专注长期价值"><a href="#与时间做朋友，专注长期价值" class="headerlink" title="与时间做朋友，专注长期价值"></a><strong>与时间做朋友，专注长期价值</strong></h2><p>软件行业发展迅猛，几乎每一年都有新事物涌现，从云计算，到加密货币，再到人工智能，这些热门的概念催生了很多的需求，也带来了所谓的风口。但作为一个普通的程序员，结合自己的职业发展，如何面对这些风口？虽说每个风口都代表着巨大的机遇，但个人的时间精力毕竟有限，与其盲目的追逐热门技术，不如踏踏实实做好基础的工作，把关键性的基础技术把握牢固，然后在心力有余的情况下，选择拓展技术边界。</p><p>要把基础知识系统性的学好，构建一个完整的技术框架，绝非短时间就能完成的，而是需要我们做好长期投入的准备，不断去累积，不断的学习总结，做到融会贯通。先争取在一个小的领域成为专家，深耕下去，然后再选择一个值得长期投入的方向，逐渐的拓展技术的领地，有深度的同时，也要有足够的广度。</p><p>与时间为友，不是只关心短期收益，追求立竿见影的效果，而是要注重长期的价值，把学好技术当作人生的追求。</p><p>2021已经来临，自律，延迟满足，不断积累，相信新的一年能有更大的突破。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;心灵是自己的地方，在那里可以把地狱变成天堂，也可以把天堂变成地狱&lt;/p&gt;
&lt;p&gt;  约翰-弥尔顿《失乐园》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2020年已然成为过往，但过去一年发生的种种却影响尤在，注定会成为很多人人生中的转折点：忽然而至的病毒导致经济颓败，很多公司工厂倒闭，有人失去了工作; 更悲伤的是，很多人因为新冠病毒失去了生命/亲人。中国的疫情虽说已经得到控制，最初的悲观情绪已经慢慢散去，人们开始了正常的生活，但欧美、印度等国家却还深陷病毒传播的泥沼，感染人数/死亡人数仍然居高不下。这是人类历史的悲怆之年。
    
    </summary>
    
      <category term="思考" scheme="http://sniffer.site/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="2020" scheme="http://sniffer.site/tags/2020/"/>
    
      <category term="新冠病毒" scheme="http://sniffer.site/tags/%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92/"/>
    
      <category term="个人成长" scheme="http://sniffer.site/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>MAC与PHY调试遇到的那些坑</title>
    <link href="http://sniffer.site/2020/12/31/MAC%E4%B8%8EPHY%E8%B0%83%E8%AF%95%E9%81%87%E5%88%B0%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://sniffer.site/2020/12/31/MAC与PHY调试遇到的那些坑/</id>
    <published>2020-12-31T02:31:14.000Z</published>
    <updated>2021-02-25T03:08:13.257Z</updated>
    
    <content type="html"><![CDATA[<p>这次新平台采用了与之前不同的以太网方案， MAC是内置在SoC(System On Chip)上，而PHY采用了Marvell的一款100Mps的车规级的芯片，MAC/PHY的驱动都要重新开发适配，工作难度比之前预想的要大了很多，完成时间比预想的慢了近一个星期。<a id="more"></a>不过，往后看，这种直接与硬件打交道的经验很能锻炼人，在一定程度改善了我对系统的认知与理解。这篇文章重点在梳理总结下车在以太网MAC/PHY遇到的一些问题，以及Linux下MAC/PHY驱动的一些基本流程。</p><p>大致分为如下几个部分：</p><ul><li>MAC/PHY的基础知识</li><li>Linux下MAC/PHY驱动的加载流程</li><li>车载以太网MAC/PHY调试的一些经验总结</li></ul><h2 id="MAC-PHY的基本概念"><a href="#MAC-PHY的基本概念" class="headerlink" title="MAC/PHY的基本概念"></a><strong>MAC/PHY的基本概念</strong></h2><p>MAC即媒介访问控制层(<a href="https://en.wikipedia.org/wiki/Medium_access_control" target="_blank" rel="noopener">Media Access Control</a>, 位于TCP/IP协议栈的第二层-数据链路层，用于数据传输过程的数据流控制，其将上层IP数据包分割成适合于物理层传输的数据帧，并负责数据传输的冲突管理。按照 IEEE Std 802-2001 上的定义，MAC主要做如下几个事情：</p><ul><li>数据帧的封装与识别</li><li>根据MAC地址来与目标主机进行通讯</li><li>检测数据传输错误（MAC帧中有一个FCS, Frame Checksum Sequence)</li><li>物理媒介的访问控制，半双工情况下需要进行传输冲突控制，如<a href="https://en.wikipedia.org/wiki/Carrier-sense_multiple_access_with_collision_detection" target="_blank" rel="noopener">CSMA/CD</a></li></ul><p>而PHY（Physical layer)即物理层， 其主要负责物理信号的传输， 其通过线束（如光纤/铜线）与其他设备进行连接。一个PHY芯片主要包含了两个部分: PCS(Physical Coding Sublayer), PMD(Physical Medium Dependent), 对车载PHY芯片来说，通常还包含了一个PMA(Physical Media Attachment)子层, 位于PCS与PMD之间; 下图是一个以太网的大致结构图：</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ethernet_model.jpg" alt="MAC/PHY structure"></p><p>那么，MAC与PHY是具体如何通讯的？ 其通讯接口实际分控制接口与数据接口。控制接口是用于访问控制PHY的寄存器的<a href="https://en.wikipedia.org/wiki/Management_Data_Input/Output" target="_blank" rel="noopener">MDIO(Management Data Input/Output)</a>/MDC(Management Data Clock)， 其中MDIO是数据传输用，而MDC是为MDIO的访问提供时序。MDIO最初是在IEEE RFC802.3中定义，只有Clause22一种标准，允许MAC访问32个PHY的32个寄存器;后来，为了适应千兆以太网PHY，提供了clause45协议，最多支持65,536个寄存器的访问，同时兼容clause22的方式来访问clause45的寄存器。下图是Clause22协议访问PHY寄存器的帧结构: </p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/mdio-clause22.png" alt="clause22 protocol frame"></p><p>其中：</p><ul><li>ST(2bits): SOF(start of frame), 对Clause22来说是01</li><li>OP(2bits): 操作码， 读或写(01-write/10-read)</li><li>PHYADDR(5bits): PHY的物理地址，这个与硬件配置有关</li><li>REGADDR(5bits): 32位寄存器地址</li><li>TA(2bits): 从STA(MAC)到MMD(PHY)总线使用权切换所需要的翻转时间(turnaround time)</li><li>DATA(16bits): 数据，写寄存器是MAC将数据放到该位置; 读寄存器时PHY将结果放入该位置</li></ul><p>更多关于MDIO的两种协议Clause22/Cluase45的信息可以参考：<a href="https://www.totalphase.com/support/articles/200349206-MDIO-Background" target="_blank" rel="noopener">MDIO background</a></p><p>除了控制接口，MAC/PHY之间还有数据传输的接口MII<a href="https://en.wikipedia.org/wiki/Media-independent_interface" target="_blank" rel="noopener">(Media Independent Interface)</a>, 针对不同的应用场景，目前已有RMII(Reduced MII), GMII(Gigabit MII), RGMII(Reduced Gigabit MII), SGMII(Serial Gigabit MII), XGMII(10-gigabit MII)等多种接口。</p><h2 id="Linux中MAC-PHY驱动的启动流程"><a href="#Linux中MAC-PHY驱动的启动流程" class="headerlink" title="Linux中MAC/PHY驱动的启动流程"></a><strong>Linux中MAC/PHY驱动的启动流程</strong></h2><p>这里讲MAC/PHY驱动，不会涉及具体的芯片，只分析MAC/PHY启动的关键流程。总的来说， MAC/PHY启动大致有几个步骤：</p><ul><li>内核加载MAC驱动</li><li>MAC驱动对MAC/PHY芯片上电，并读取PHY的状态寄存器确认PHY正常上电</li><li>MAC注册一个MDIO总线对象，提供PHY寄存器操作的接口</li><li>MAC获取到MDIO总线上的PHY设备，并将其与MAC对应的网络设备进行连接</li><li>用户进程进行了interface up的操作并配置IP，MAC与PHY可以准备接发数据</li></ul><p>这里只讲述下与硬件平台无关的核心部分流程（中间三个部分）：</p><h3 id="MDIO总线访问接口注册"><a href="#MDIO总线访问接口注册" class="headerlink" title="MDIO总线访问接口注册"></a><strong>MDIO总线访问接口注册</strong></h3><p>在MAC/PHY都正常上电后， MAC驱动需要注册一个MDIO的总线接口供后续PHY驱动读写寄存器使用，接口位于<code>include/linux/phy.h</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct mii_bus *<span class="title">mdiobus_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mdiobus_alloc_size(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mdiobus_alloc_size(0)</code>为<code>mii_bus</code>对象分配内存空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">struct mii_bus *<span class="title">mdiobus_alloc_size</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mii_bus</span> *<span class="title">bus</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> aligned_size = ALIGN(<span class="keyword">sizeof</span>(*bus), NETDEV_ALIGN);</span><br><span class="line"><span class="keyword">size_t</span> alloc_size;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If we alloc extra space, it should be aligned */</span></span><br><span class="line"><span class="keyword">if</span> (size)</span><br><span class="line">alloc_size = aligned_size + size;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">alloc_size = <span class="keyword">sizeof</span>(*bus);</span><br><span class="line"></span><br><span class="line">bus = kzalloc(alloc_size, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!bus)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">bus-&gt;state = MDIOBUS_ALLOCATED;</span><br><span class="line"><span class="keyword">if</span> (size)</span><br><span class="line">bus-&gt;priv = (<span class="keyword">void</span> *)bus + aligned_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialise the interrupts to polling */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PHY_MAX_ADDR; i++)</span><br><span class="line">bus-&gt;irq[i] = PHY_POLL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bus;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(mdiobus_alloc_size);</span><br></pre></td></tr></table></figure><p>这个结构<code>miii_bus</code>对象即是MAC与PHY之间控制访问的接口，主要包括了用于访问PHY寄存器的函数<code>read/write</code>以及用于PHY芯片软复位的<code>reset</code>函数，这三个函数通常需要在MAC驱动根据实际的PHY寄存器访问协议来实现;另外还包括了mdio总线所包含的所有PHY设备<code>mdio_map</code>（最多支持32个PHY）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The Bus class for PHYs.  Devices which provide access to</span></span><br><span class="line"><span class="comment"> * PHYs should register using this structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mii_bus</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">char</span> id[MII_BUS_ID_SIZE];</span><br><span class="line"><span class="keyword">void</span> *priv;</span><br><span class="line"><span class="keyword">int</span> (*read)(struct mii_bus *bus, <span class="keyword">int</span> addr, <span class="keyword">int</span> regnum);</span><br><span class="line"><span class="keyword">int</span> (*write)(struct mii_bus *bus, <span class="keyword">int</span> addr, <span class="keyword">int</span> regnum, u16 val);</span><br><span class="line"><span class="keyword">int</span> (*reset)(struct mii_bus *bus);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A lock to ensure that only one thing can read/write</span></span><br><span class="line"><span class="comment"> * the MDIO bus at a time</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mdio_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">MDIOBUS_ALLOCATED = <span class="number">1</span>,</span><br><span class="line">MDIOBUS_REGISTERED,</span><br><span class="line">MDIOBUS_UNREGISTERED,</span><br><span class="line">MDIOBUS_RELEASED,</span><br><span class="line">&#125; state;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* list of all PHYs on bus */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mdio_device</span> *<span class="title">mdio_map</span>[<span class="title">PHY_MAX_ADDR</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PHY addresses to be ignored when probing */</span></span><br><span class="line">u32 phy_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PHY addresses to ignore the TA/read failure */</span></span><br><span class="line">u32 phy_ignore_ta_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * An array of interrupts, each PHY's interrupt at the index</span></span><br><span class="line"><span class="comment"> * matching its address</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> irq[PHY_MAX_ADDR];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO reset pulse width in microseconds */</span></span><br><span class="line"><span class="keyword">int</span> reset_delay_us;</span><br><span class="line"><span class="comment">/* RESET GPIO descriptor pointer */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">reset_gpiod</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化完<code>mii_bus</code>后， MAC驱动会通过<code>mdiobus_register</code>注册该对象; 在这里，做的最重要的一个事情就是扫描所有MDIO下面的PHY设备，并将其保存到<code>mdio_map</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> __mdiobus_register(struct mii_bus *bus, struct <span class="keyword">module</span> *owner)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mdio_device</span> *<span class="title">mdiodev</span>;</span></span><br><span class="line"><span class="keyword">int</span> i, err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == bus || <span class="literal">NULL</span> == bus-&gt;name ||</span><br><span class="line">    <span class="literal">NULL</span> == bus-&gt;read || <span class="literal">NULL</span> == bus-&gt;write)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">BUG_ON(bus-&gt;state != MDIOBUS_ALLOCATED &amp;&amp;</span><br><span class="line">       bus-&gt;state != MDIOBUS_UNREGISTERED);</span><br><span class="line"></span><br><span class="line">bus-&gt;owner = owner;</span><br><span class="line">bus-&gt;dev.parent = bus-&gt;parent;</span><br><span class="line">bus-&gt;dev.class = &amp;mdio_bus_class;</span><br><span class="line">bus-&gt;dev.groups = <span class="literal">NULL</span>;</span><br><span class="line">dev_set_name(&amp;bus-&gt;dev, <span class="string">"%s"</span>, bus-&gt;id);</span><br><span class="line"></span><br><span class="line">err = device_register(&amp;bus-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">pr_err(<span class="string">"mii_bus %s failed to register\n"</span>, bus-&gt;id);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutex_init(&amp;bus-&gt;mdio_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* de-assert bus level PHY GPIO reset */</span></span><br><span class="line">gpiod = devm_gpiod_get_optional(&amp;bus-&gt;dev, <span class="string">"reset"</span>, GPIOD_OUT_LOW);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(gpiod)) &#123;</span><br><span class="line">dev_err(&amp;bus-&gt;dev, <span class="string">"mii_bus %s couldn't get reset GPIO\n"</span>,</span><br><span class="line">bus-&gt;id);</span><br><span class="line">device_del(&amp;bus-&gt;dev);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(gpiod);</span><br><span class="line">&#125; <span class="keyword">else</span><span class="keyword">if</span> (gpiod) &#123;</span><br><span class="line">bus-&gt;reset_gpiod = gpiod;</span><br><span class="line"></span><br><span class="line">gpiod_set_value_cansleep(gpiod, <span class="number">1</span>);</span><br><span class="line">udelay(bus-&gt;reset_delay_us);</span><br><span class="line">gpiod_set_value_cansleep(gpiod, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bus-&gt;reset)</span><br><span class="line">bus-&gt;reset(bus);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描所有PHY设备</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PHY_MAX_ADDR; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((bus-&gt;phy_mask &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">phy_device</span> *<span class="title">phydev</span>;</span></span><br><span class="line"></span><br><span class="line">phydev = mdiobus_scan(bus, i);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(phydev) &amp;&amp; (PTR_ERR(phydev) != -ENODEV)) &#123;</span><br><span class="line">err = PTR_ERR(phydev);</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);</span><br><span class="line"></span><br><span class="line">bus-&gt;state = MDIOBUS_REGISTERED;</span><br><span class="line">pr_info(<span class="string">"%s: probed\n"</span>, bus-&gt;name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line"><span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">mdiodev = bus-&gt;mdio_map[i];</span><br><span class="line"><span class="keyword">if</span> (!mdiodev)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">mdiodev-&gt;device_remove(mdiodev);</span><br><span class="line">mdiodev-&gt;device_free(mdiodev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Put PHYs in RESET to save power */</span></span><br><span class="line"><span class="keyword">if</span> (bus-&gt;reset_gpiod)</span><br><span class="line">gpiod_set_value_cansleep(bus-&gt;reset_gpiod, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">device_del(&amp;bus-&gt;dev);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扫描MIDO总线的PHY设备"><a href="#扫描MIDO总线的PHY设备" class="headerlink" title="扫描MIDO总线的PHY设备"></a><strong>扫描MIDO总线的PHY设备</strong></h3><p>函数<code>mdiobus_scan</code>首先调用<code>get_phy_device</code>获取指定地址上的PHY设备ID,并创建一个 <code>phy_device</code>对象，然后通过<code>phy_device_register</code>初始化创建的<code>phy_device</code>对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">struct phy_device *<span class="title">mdiobus_scan</span><span class="params">(struct mii_bus *bus, <span class="keyword">int</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">phy_device</span> *<span class="title">phydev</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">phydev = get_phy_device(bus, addr, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(phydev))</span><br><span class="line"><span class="keyword">return</span> phydev;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For DT, see if the auto-probed phy has a correspoding child</span></span><br><span class="line"><span class="comment"> * in the bus node, and set the of_node pointer in this case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">of_mdiobus_link_mdiodev(bus, &amp;phydev-&gt;mdio);</span><br><span class="line"></span><br><span class="line">err = phy_device_register(phydev);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">phy_device_free(phydev);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> phydev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>get_phy_id</code>通过读取<code>MII_PHYSID1/MII_PHYSID2</code>两个PHY的ID寄存器获取PHY的ID，这里<code>mdiobus_read</code>正是之前MAC实现的<code>mii_bus</code>的中的<code>read</code>接口，如果该接口实现有问题，MAC就无法正常与PHY进行通讯。另外需要注意的是，默认情况下，Linux都是基于MDIO的Clause22协议来访问PHY的寄存器的（调试PHY驱动的时候需要留意）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_phy_id</span><span class="params">(struct mii_bus *bus, <span class="keyword">int</span> addr, u32 *phy_id,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">bool</span> is_c45, struct phy_c45_device_ids *c45_ids)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> phy_reg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_c45)</span><br><span class="line"><span class="keyword">return</span> get_phy_c45_ids(bus, addr, phy_id, c45_ids);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Grab the bits from PHYIR1, and put them in the upper half */</span></span><br><span class="line">phy_reg = mdiobus_read(bus, addr, MII_PHYSID1);</span><br><span class="line"><span class="keyword">if</span> (phy_reg &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line">*phy_id = (phy_reg &amp; <span class="number">0xffff</span>) &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Grab the bits from PHYIR2, and put them in the lower half */</span></span><br><span class="line">phy_reg = mdiobus_read(bus, addr, MII_PHYSID2);</span><br><span class="line"><span class="keyword">if</span> (phy_reg &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line">*phy_id |= (phy_reg &amp; <span class="number">0xffff</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扫描到PHY后，将其注册到对应的<code>mii_bus</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phy_device_register</span><span class="params">(struct phy_device *phydev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = mdiobus_register_device(&amp;phydev-&gt;mdio);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Run all of the fixups for this PHY */</span></span><br><span class="line">err = phy_scan_fixups(phydev);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">pr_err(<span class="string">"PHY %d failed to initialize\n"</span>, phydev-&gt;mdio.addr);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">phydev-&gt;mdio.dev.groups = phy_dev_groups;</span><br><span class="line"></span><br><span class="line">err = device_add(&amp;phydev-&gt;mdio.dev);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">pr_err(<span class="string">"PHY %d failed to add\n"</span>, phydev-&gt;mdio.addr);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">mdiobus_unregister_device(&amp;phydev-&gt;mdio);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MAC与PHY进行匹配连接"><a href="#MAC与PHY进行匹配连接" class="headerlink" title="MAC与PHY进行匹配连接"></a><strong>MAC与PHY进行匹配连接</strong></h3><p>通过<code>mdiobus_get_phy</code>这个接口，MAC获取到当前MDIO总线上对应物理地址的PHY设备，然后通过<code>phy_connect_direct</code>将MAC对应的网络设备与PHY设备进行连接绑定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * phy_connect_direct - connect an ethernet device to a specific phy_device</span></span><br><span class="line"><span class="comment"> * @dev: the network device to connect</span></span><br><span class="line"><span class="comment"> * @phydev: the pointer to the phy device</span></span><br><span class="line"><span class="comment"> * @handler: callback function for state change notifications</span></span><br><span class="line"><span class="comment"> * @interface: PHY device's interface</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phy_connect_direct</span><span class="params">(struct net_device *dev, struct phy_device *phydev,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">void</span> (*handler)(struct net_device *),</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">phy_interface_t</span> interface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dev)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">rc = phy_attach_direct(dev, phydev, phydev-&gt;dev_flags, interface);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">phy_prepare_link(phydev, handler);</span><br><span class="line">phy_start_machine(phydev);</span><br><span class="line"><span class="keyword">if</span> (phydev-&gt;irq &gt; <span class="number">0</span>)</span><br><span class="line">phy_start_interrupts(phydev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将MAC网络设备与PHY进行绑定，并进行初始化，如进行PHY的软复位; 这里要注意的时，PHY的驱动要根据PHYID提前做好适配，不然这里的<code>d-&gt;driver</code>值未空，就无法正常进行phy的初始化了，网络自然无法正常工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phy_attach_direct</span><span class="params">(struct net_device *dev, struct phy_device *phydev,</span></span></span><br><span class="line"><span class="function"><span class="params">      u32 flags, <span class="keyword">phy_interface_t</span> interface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">ndev_owner</span> = <span class="title">dev</span>-&gt;<span class="title">dev</span>.<span class="title">parent</span>-&gt;<span class="title">driver</span>-&gt;<span class="title">owner</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mii_bus</span> *<span class="title">bus</span> = <span class="title">phydev</span>-&gt;<span class="title">mdio</span>.<span class="title">bus</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">d</span> = &amp;<span class="title">phydev</span>-&gt;<span class="title">mdio</span>.<span class="title">dev</span>;</span></span><br><span class="line"><span class="keyword">bool</span> using_genphy = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">get_device(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Assume that if there is no driver, that it doesn't</span></span><br><span class="line"><span class="comment"> * exist, and we should use the genphy driver.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!d-&gt;driver) &#123;</span><br><span class="line"><span class="keyword">if</span> (phydev-&gt;is_c45)</span><br><span class="line">d-&gt;driver = &amp;genphy_10g_driver.mdiodrv.driver;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">d-&gt;driver = &amp;genphy_driver.mdiodrv.driver;</span><br><span class="line"></span><br><span class="line">using_genphy = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!try_module_get(d-&gt;driver-&gt;owner)) &#123;</span><br><span class="line">dev_err(&amp;dev-&gt;dev, <span class="string">"failed to get the device driver module\n"</span>);</span><br><span class="line">err = -EIO;</span><br><span class="line"><span class="keyword">goto</span> error_put_device;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (using_genphy) &#123;</span><br><span class="line">err = d-&gt;driver-&gt;probe(d);</span><br><span class="line"><span class="keyword">if</span> (err &gt;= <span class="number">0</span>)</span><br><span class="line">err = device_bind_driver(d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> error_module_put;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">phydev-&gt;phy_link_change = phy_link_change;</span><br><span class="line">phydev-&gt;attached_dev = dev;</span><br><span class="line">dev-&gt;phydev = phydev;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Some Ethernet drivers try to connect to a PHY device before</span></span><br><span class="line"><span class="comment"> * calling register_netdevice() -&gt; netdev_register_kobject() and</span></span><br><span class="line"><span class="comment"> * does the dev-&gt;dev.kobj initialization. Here we only check for</span></span><br><span class="line"><span class="comment"> * success which indicates that the network device kobject is</span></span><br><span class="line"><span class="comment"> * ready. Once we do that we still need to keep track of whether</span></span><br><span class="line"><span class="comment"> * links were successfully set up or not for phy_detach() to</span></span><br><span class="line"><span class="comment"> * remove them accordingly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">phydev-&gt;sysfs_links = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">err = sysfs_create_link(&amp;phydev-&gt;mdio.dev.kobj, &amp;dev-&gt;dev.kobj,</span><br><span class="line"><span class="string">"attached_dev"</span>);</span><br><span class="line"><span class="keyword">if</span> (!err) &#123;</span><br><span class="line">err = sysfs_create_link_nowarn(&amp;dev-&gt;dev.kobj,</span><br><span class="line">       &amp;phydev-&gt;mdio.dev.kobj,</span><br><span class="line">       <span class="string">"phydev"</span>);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">dev_err(&amp;dev-&gt;dev, <span class="string">"could not add device link to %s err %d\n"</span>,</span><br><span class="line">kobject_name(&amp;phydev-&gt;mdio.dev.kobj),</span><br><span class="line">err);</span><br><span class="line"><span class="comment">/* non-fatal - some net drivers can use one netdevice</span></span><br><span class="line"><span class="comment"> * with more then one phy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">phydev-&gt;sysfs_links = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">phydev-&gt;dev_flags = flags;</span><br><span class="line"></span><br><span class="line">phydev-&gt;interface = interface;</span><br><span class="line"></span><br><span class="line">phydev-&gt;state = PHY_READY;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initial carrier state is off as the phy is about to be</span></span><br><span class="line"><span class="comment"> * (re)initialized.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">netif_carrier_off(phydev-&gt;attached_dev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do initial configuration here, now that</span></span><br><span class="line"><span class="comment"> * we have certain key parameters</span></span><br><span class="line"><span class="comment"> * (dev_flags and interface)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">err = phy_init_hw(phydev);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">phy_resume(phydev);</span><br><span class="line">phy_led_triggers_register(phydev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关PHY驱动与PHY设备如何进行匹配的实现细节，可以参考Linux内核的文档:</p><blockquote><p>/kernel/msm-4.14/Documentation/driver-model/*.txt</p></blockquote><h2 id="MAC-PHY调试容易踩到的坑"><a href="#MAC-PHY调试容易踩到的坑" class="headerlink" title="MAC/PHY调试容易踩到的坑"></a><strong>MAC/PHY调试容易踩到的坑</strong></h2><p>一般来说，MAC跟PHY的连接有这么几种形式：</p><ul><li>MAC/PHY都采用独立的芯片，MAC通过PCI总线接入到系统</li><li>MAC集成到SoC上，PHY采用外接芯片的形式</li><li>MAC/PHY集成在一个芯片上，然后通过PCI总线接入到系统</li></ul><blockquote><p>现在也开始采用另外一种连接方式: MAC集成到SoC上, 与一个Switch的MAC端口直连(不再有PHY设备了), 即MAC直连, 这种只需要在MAC驱动添加一个虚拟的FIXED PHY, EMAC就可以正常工作, 可以参考<a href="https://patchwork.kernel.org/project/linux-arm-kernel/patch/1373902450-11857-2-git-send-email-thomas.petazzoni@free-electrons.com/" target="_blank" rel="noopener">FIXED PHY driver</a>；或者Linux源代码&lt;drivers/of/of_mdio.c&gt;</p></blockquote><p>对现如今集成度越来越高的系统来说，很多SoC都会采用将MAC集成到系统，采用EMAC(Embedded  MAC)的形式，这样简化了硬件与软件的设计，对于开发人员来说最主要的工作就是PHY驱动以及相关协议的适配了。由于之前对MAC/PHY驱动的工作接触不多，这次是第一次完全从零开发以太网驱动，遇到了不少坑，总结下主要有如下几点：</p><ul><li>MAC/PHY之间的通讯实际上都是标准的MDIO/MII接口，相对而言都比较成熟了，驱动适配首先还是要确保使用的接口，比如是RGMII还是GMII，两者要一致; 另外速率要保持一致，比如MAC配置成100Mbps，同样PHY要对应是100Mbps，否则以太网可能没法工作</li><li>如今的PHY都支持千兆网速了，所以很多PHY都开始支持clause45的协议寄存器的访问，有些PHY是clause22/clause45都支持，有些PHY则只支持clause45,这个是比较容易出问题的地方。使用正确的MDIO协议访问寄存器才能正常读到PHY芯片的状态</li><li>最后也是很重要的一点，认真读下厂商提供的PHY芯片手册，以及硬件设计的要点，避免踩到不必要的坑</li></ul><p>总的说来，梳理好MAC/PHY的流程，再进行驱动开发就会顺手不少。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次新平台采用了与之前不同的以太网方案， MAC是内置在SoC(System On Chip)上，而PHY采用了Marvell的一款100Mps的车规级的芯片，MAC/PHY的驱动都要重新开发适配，工作难度比之前预想的要大了很多，完成时间比预想的慢了近一个星期。
    
    </summary>
    
      <category term="汽车电子" scheme="http://sniffer.site/categories/%E6%B1%BD%E8%BD%A6%E7%94%B5%E5%AD%90/"/>
    
    
      <category term="MAC" scheme="http://sniffer.site/tags/MAC/"/>
    
      <category term="PHY" scheme="http://sniffer.site/tags/PHY/"/>
    
      <category term="车载以太网" scheme="http://sniffer.site/tags/%E8%BD%A6%E8%BD%BD%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>汽车网络演化-从CAN到以太网</title>
    <link href="http://sniffer.site/2020/11/06/%E6%B1%BD%E8%BD%A6%E7%BD%91%E7%BB%9C%E6%BC%94%E5%8C%96-%E4%BB%8ECAN%E5%88%B0%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
    <id>http://sniffer.site/2020/11/06/汽车网络演化-从CAN到以太网/</id>
    <published>2020-11-06T06:32:25.000Z</published>
    <updated>2020-12-31T03:03:04.585Z</updated>
    
    <content type="html"><![CDATA[<p>汽车电子的发展伴随着技术迭代而不断进化，汽车网络总线从最开的CAN，CAN-FD,到后来的Flexray, MOST再到LIN，到Ethernet，在市场需求与技术发展双重合力之下，经过了不断的发展积累，到如今已经有进40年的历史。近几年，随着各大汽车公司，尤其是新能源汽车公司如特斯拉/蔚来/小鹏等在自动驾驶领域的大力投入，汽车网络开始向高带宽/低延时的以太网方向发展。在这篇文章我们就来对比看看各种汽车网络总线的工作原理以及使用场景。</p><h2 id="CAN-Controller-Area-Network"><a href="#CAN-Controller-Area-Network" class="headerlink" title="CAN(Controller Area Network)"></a><strong>CAN(Controller Area Network)</strong></h2><p>CAN最初是由博世(Bosch)于1985年开发出来的车内总线。在这之前，汽车厂商需要通过一条条线将各种汽车控制器连接起来，形成一个个点对点的连接网络。这也导致了增加了汽车本身的重量，增加了系统的复杂度与成本。</p><p>CAN作为一个串行总线，具有低成本，轻量化的优势，最高支持1Mb/s的速率，因此迅速被各大厂商采用，并于1993年被定为ISO国际化标准(ISO 11898).</p><p>下图是CAN报文的结构：</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/CAN_frame_format.jpeg" alt="CAN frame format"></p><ul><li>SOF(Start of Frame): 帧开始标记位，一般为0</li><li>Arbitration ID: 11位的仲裁优先级，用于标识消息以及消息的优先级</li><li>IDE(Identifier Extension): 占1位，表示允许标准帧与扩展帧的差别</li><li>RTP(Remote Transmission Request): 1bit, 区分一个数据帧与远端帧(remote frame), 0表示数据帧，1表示远端帧</li><li>DLC(Data length code): 表示数据的长度</li><li>Data Field: 包含0～8字节的数据</li><li>CRC(Cyclic Redundancy Check):循环冗余检测码，用于检查数据错误</li><li>ACK: 接收端在收到数据后，发送一个ACK帧，发送端收到后确认发送成功，否则就要重发数据</li><li>EOF(End of Frame): 结束位 </li></ul><p>CAN是一个点对点的网络，对于CAN总线的访问没有一个仲裁节点用于控制各个节点的数据发送/接收。 所有节点在发送数据之前都要检查当前总线上是否有数据传输，如果多个节点尝试同时发送数据，拥有最高优先级的节点（仲裁ID值低）自动获取到总线的访问权限，而低优先级的节点则需要等到高优先级的节点发送完数据后再传输。由上述CAN报文的结构可以看到，CAN消息中并没有包含节点的地址，每个节点发送的消息都会广播到其他所有节点，接收端需要通过仲裁ID来判断是否接收某个数据报文。</p><p>由于每个CAN报文实际只有一个字节(8bit)的数据，因此传输速率实际收到了限制。为了应对日益出现的高速数据传输需求，比如诊断数据等，博世(Bosch)基于CAN扩展出了一个新的总线CAN-FD(Flexible Data-rate)协议, 于2012年发布并成为了国际标准（ISO 11898-1）。 CAN-FD将消息的长度扩展到最大支持64bit数据，从而提高了数据传输的速率。有关更多关于CAN-FD的信息可以参考:</p><ul><li><a href="https://en.wikipedia.org/wiki/CAN_FD" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/CAN_FD</a></li><li><a href="https://www.ni.com/zh-cn/innovations/white-papers/14/understanding-can-with-flexible-data-rate--can-fd-.html" target="_blank" rel="noopener">https://www.ni.com/zh-cn/innovations/white-papers/14/understanding-can-with-flexible-data-rate--can-fd-.html</a></li></ul><h2 id="FlexRay"><a href="#FlexRay" class="headerlink" title="FlexRay"></a><strong>FlexRay</strong></h2><p><a href="https://en.wikipedia.org/wiki/FlexRay" target="_blank" rel="noopener">FlexRay</a>设计之初的目的在于提供更快，更可靠，更低延迟的ECU数据传输方法。随着汽车电子工业的发展，在2000年，宝马(BMW), 戴姆勒(Daimler)以及博世(Bosch)等厂商组成了<code>FlexRay</code>委员会，为了解决现有CAN总线上的一些缺陷创造一个新的总线协议，这就是FlexRay.:</p><ul><li>为了确保多个节点之间实现安全，实时实时的通讯，FlexRay中的每个节点都个共享相同的时间基准</li><li>FlexRay基于时间触发的消息机制，确保了安全相关的消息传输具有更低的时延</li><li>FlexRay通过双通道物理结构提供了更高的可靠性</li><li>FlexRay每个通道的最大理论速率能达到10Mb/s，是CAN总线的10倍</li></ul><p>FlexRay支持多种网络拓扑结构（星形/树状/多种拓扑混合），网络中的每个节点不能同时发送消息，因此需要通过冲突避免(collision avoidance)的方法来避免传输冲突;与CAN通过优先级来仲裁传输的方法不同，FlexRay使用了TDMA(Time Division Multiple Access)的方法来控制各个节点传输数据的顺序，每个节点都遵照事先设定的时序来使用总线。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/flexray_frame_format.png" alt="Flexray frame format"></p><p>FlexRay的消息帧结构主要分为三部分：一个是帧头，一个是数据部分，最后一个是校验值。</p><ul><li>帧头的状态字(Status Bits): 占5位，每一位分别对应<ul><li>第一位保留用于后续使用</li><li>Payload Preamble Indicator（数据前导码标识): 区分static segment/dynamic segment</li><li>Null Frame Indicator: 表示消息未包含数据，数据位为空</li><li>Sync Frame Indicator: 时间同步帧标识</li><li>Startup Frame Indicator: 网络启动帧标识，只有被配置为启动(startup)的节点才能发送该消息</li></ul></li><li>Frame ID: 帧ID，表示消息所在的时间槽(slot ID),  与消息中的<code>Cycle</code>一起作为消息的唯一识别码，类似于CAN消息中的冲裁ID</li><li>Length: 数据长度</li><li>Header CRC: 帧循环冗余校验值</li><li>Cycle： 帧传输的周期（占用的时间）</li><li>Payload: 消息体</li><li>CRC: 消息体对应的校验码</li></ul><p>更多关于FlexRay的资料可以参考：</p><ul><li><a href="https://en.wikipedia.org/wiki/FlexRay" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/FlexRay</a></li><li><a href="https://www.ni.com/zh-cn/innovations/white-papers/06/flexray-automotive-communication-bus-overview.html" target="_blank" rel="noopener">https://www.ni.com/zh-cn/innovations/white-papers/06/flexray-automotive-communication-bus-overview.html</a></li></ul><h2 id="MOST"><a href="#MOST" class="headerlink" title="MOST"></a><strong>MOST</strong></h2><p><a href="https://en.wikipedia.org/wiki/MOST_Bus" target="_blank" rel="noopener">MOST(Media Oriented Serial Transport)</a>, 直译过来就是基于媒体的串行传输总线，从字面意思可以看到，MOST就是为了解决汽车上日益增加的诸如音频/视频等数据传输需求设计的。在上世纪90年代，高端车型逐渐出现了诸如导航，音频，显示等复杂的媒体功能，为了应对这种日益增长娱乐系统需求，Harman (哈曼), BMW, Daimler, and Oasis Silicon Systems (即现在的Microchip Technology)组成了一个专门的合作团队，开发下一代汽车总线。目前MOST已广泛被BMW，Daimler，Volkswagen（大众），Volvo等欧洲豪华品牌采用，日美等汽车厂商则采用了基于UTP（Unshielded Twisted Pair）的MOST总线(MOST50).</p><p>想比较CAN与FlexRay等汽车总线，MOST具有如下特点：</p><ul><li>内置专门的通道用于音频/视频数据传输，更适合影音娱乐应用</li><li>最高可达150Mb/s传输速率，远高于CAN/LIN/FlexRay</li><li>MOST150支持MEP(Ethernet Packet Channel)用于IP数据的传输</li><li>支持光纤传输，可以消除电磁干扰(EMC, Electromagnetic Compatiblitity) ,并天然具备电气隔离能力</li></ul><p>MOST一般采用环形拓扑网络结构， 有一个主节点(timing master)用于控制所有同步通讯（synchronous communication), 同步帧(synchronous frame)会周期性（频率为48kHz)的从主控节点发送到网络中的各个节点，其他从节点在收到属于同步帧后主动把数据放到该同步帧的后面，继续发送到下一个节点。</p><p>对MOST协议来说，每个数据帧都划分为不同的<em>通道</em>(Channels), 每个通道都严格按照时间顺序均匀的传输数据，比如在同步帧中就包含了相同大小的音频数据，这样接收端拿到数据后就可以重新合成一个实时的音频流。下图是MOST150总线的一个数据帧的结构:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/most150_frame_format.png" alt="MOST150 frame format"></p><ul><li>CC(Control Channel): 控制通道用于协调网络的数据传输以及交换各个节点的状态信息</li><li>SYN/ISOC CH: 同步数据通道，该通道会动态的划分为其他通道以便于同时传输音频/视频/立体声等数据</li><li>ASYNC: 异步通道用于传输，用于传输事件通知/数据报文，新的协议已经被MEP通道取代</li><li>MEP(MOST Ethernet Packets): 在MOST150协议中使用，专门用于传输IP数据包，数据长度类似于以太网数据帧</li></ul><p>更多关于MOST总线相关的信息可以参考官网文档: <a href="https://www.mostcooperation.com/technology/most-network/" target="_blank" rel="noopener">https://www.mostcooperation.com/technology/most-network/</a></p><h2 id="LIN"><a href="#LIN" class="headerlink" title="LIN"></a><strong>LIN</strong></h2><p>在1990年代，BMW，Volvo，Audio等一众厂商发现，虽然CAN极大的改善了整车的布线复杂度与成本，但是在某些场景下还是过度的使用了，比如控制车窗/座椅，并不需要1Mb/s这样的速率以及专门的控制器，因此需要一个适合于低速/低成本场景下的布线方法。这就是LIN(Local Interconnect Network)的由来：</p><ul><li>LIN采用Master/Slave的网络结构，一个Master节点最多可以控制15个（包括自身则是16个）Slave节点</li><li>使用单一连接线，提供最高20kb/s的传输速率</li><li>无需专门的控制器(MicroControllers), 实现更为简单</li></ul><p>LIN网络数据的传输都是有Master节点来控制，主节点内置了一个调度表，用于控制何时传输哪个ID的消息。消息头在主节点产生后，对应ID的从节点收到该消息头就把数据放到消息的对应位置，然后接收节点通过检查消息帧的ID值来选择发送还是接收数据。下图是LIN消息帧的构成，主要包括消息头与响应：</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/lin_frame_format.png" alt="LIN frame format"></p><ul><li>Break: 帧的开始位，至少为11个连续0,最新的标准使用13个连续位0</li><li>SYNC: 为固定值0x55, 交替的0/1信号用于从节点与主节点传输同步</li><li>ID: 包含6为ID和2位奇偶校验位，每个节点都通过该值来确定是发送数据还是接收数据</li><li>Payload: 8字节数据</li><li>CS(Checksum): 数据校验值</li></ul><p>有关LIN的更多信息可以参考：</p><ul><li><a href="https://www.ni.com/zh-cn/innovations/white-papers/09/introduction-to-the-local-interconnect-network--lin--bus.html" target="_blank" rel="noopener">https://www.ni.com/zh-cn/innovations/white-papers/09/introduction-to-the-local-interconnect-network--lin--bus.html</a></li><li><a href="https://en.wikipedia.org/wiki/Local_Interconnect_Network" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Local_Interconnect_Network</a></li></ul><h2 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a><strong>Ethernet</strong></h2><p>相比较于上述几种汽车网络总线，Ethernet（以太网）可谓后起之秀。实际上，早在1970年代，以太网就随着互联网的诞生一起出现了，其被广泛用于各种终端设备的网络互联，40多年的经验表明以太网具备了很高的可靠性。但为何，持到最近这几年才真正应用到汽车电子领域，并成为一个有望全面取代CAN/LIN/MOST这些总线的绝杀器了？ 主要还是前期以太网在汽车上使用还有几个技术难题没有得到解决，比如电磁干扰，布线成本。2011年博通(Broadcom)公布了一项针对汽车以太网的解决方案<a href="https://en.wikipedia.org/wiki/BroadR-Reach" target="_blank" rel="noopener">BroadR-Reach</a>，汽车以太网（Automative Ethernet)随之遍地开花。目前，NXP，Broadcast，Marvell等汽车电子厂商都有AE相关的产品。</p><p>与CAN，MOST等总线相比，AE主要有几大特性：</p><ul><li>多家厂商支持，产品类别更为丰富，技术体系更为开放完善</li><li>广泛应用于局域网，基于TCP/IP协议，能够传输各种音视频数据，是作为汽车中枢网络的节点连接的理想选择</li><li>基于UTP数据线，布线成本低;基于差分信号，可以较少外界电磁干扰(Electromagnetic interference, EMI)</li></ul><p>经典以太网都是通过共享介质的方式进行互联，因此需要使用诸如CSMA/CD（Carrier Sense Muliptile Access with Collission Detection)的冲突监测技术来避免传输出错，而汽车以太网则通过点对点的连接实现了全双工通讯(full-duplex），即数据可以同时接收/发送，传输速率可到100Mb/s，下图是一个网络连接拓扑图：</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ae_network_topogy.png" alt="AE network topology"></p><p>通过网关，节点之间都是点对点连接，从Port1发送的数据只会发送给Port2，同样从Port0发送的数据不会发送给Port3,因此实现了全双工的通讯。最后来看一看以太网的帧结构：</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ethernet_frame_format.png" alt="Ethernet Frame format"></p><ul><li>Preamble: 前导码，交替1/0信号，用于同步传输与发送</li><li>SOF(Start Of Frame Delimiter): 用于标识帧的开始，分开前导码与帧数据</li><li>目标/源地址: SOF之后分别是6个字节的目标MAC/源MAC地址</li><li>802.3Q(VLAN/Priority): VLAN标签，在汽车以太网中用于AVB(Audio/Video Bridge)时用于标识包的优先级</li><li>TYPE: 以太网协议类型，参考<a href="https://en.wikipedia.org/wiki/EtherType" target="_blank" rel="noopener">EthernetType</a></li><li>Data: 数据，最长可以到1500字节（有网络的MTU设置有关）</li><li>FCS(Frame Checksum Sequence): 32位的CRC码</li></ul><p>目前车载以太网多用于仪表显示/自动驾驶等需要高速数据传输的场景。</p><p>##<strong> 参考资料</strong> ##</p><ul><li><a href="https://www.can-cia.org/can-knowledge/can/can-history/" target="_blank" rel="noopener">https://www.can-cia.org/can-knowledge/can/can-history/</a></li><li><a href="https://en.wikipedia.org/wiki/CAN_bus" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/CAN_bus</a></li><li><a href="https://www.ni.com/zh-cn/innovations/white-papers/06/controller-area-network--can--overview.html" target="_blank" rel="noopener">https://www.ni.com/zh-cn/innovations/white-papers/06/controller-area-network--can--overview.html</a></li><li><a href="https://www.ni.com/zh-cn/innovations/white-papers/06/flexray-automotive-communication-bus-overview.html" target="_blank" rel="noopener">https://www.ni.com/zh-cn/innovations/white-papers/06/flexray-automotive-communication-bus-overview.html</a></li><li><a href="https://en.wikipedia.org/wiki/BroadR-Reach" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/BroadR-Reach</a></li><li>Automative Ethernet-Definitive Guide</li><li><a href="http://www.ieee802.org/3/1TPCESG/public/BroadR_Reach_Automotive_Spec_V3.0.pdf" target="_blank" rel="noopener">http://www.ieee802.org/3/1TPCESG/public/BroadR_Reach_Automotive_Spec_V3.0.pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;汽车电子的发展伴随着技术迭代而不断进化，汽车网络总线从最开的CAN，CAN-FD,到后来的Flexray, MOST再到LIN，到Ethernet，在市场需求与技术发展双重合力之下，经过了不断的发展积累，到如今已经有进40年的历史。近几年，随着各大汽车公司，尤其是新能源汽车
      
    
    </summary>
    
      <category term="汽车电子" scheme="http://sniffer.site/categories/%E6%B1%BD%E8%BD%A6%E7%94%B5%E5%AD%90/"/>
    
    
      <category term="CAN" scheme="http://sniffer.site/tags/CAN/"/>
    
      <category term="MOST" scheme="http://sniffer.site/tags/MOST/"/>
    
      <category term="LIN" scheme="http://sniffer.site/tags/LIN/"/>
    
      <category term="Ethernet" scheme="http://sniffer.site/tags/Ethernet/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核中的锁</title>
    <link href="http://sniffer.site/2020/10/23/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>http://sniffer.site/2020/10/23/Linux内核中的锁/</id>
    <published>2020-10-23T02:21:25.000Z</published>
    <updated>2020-10-26T03:46:22.627Z</updated>
    
    <content type="html"><![CDATA[<p>在看Linux内核代码时，经常会遇到各种锁(lock)的使用。对于像<code>spin_lock_irq</code>/<code>spin_lock_irqsave</code>的区别感到困惑，每次都要重新查一下资料。遂决定写一篇文章记录下内核中使用到的锁，以及使用的场景。</p><p>与应用中的锁类似，内核中的锁也只是为了保护某个内核数据结构或者内存区域在多个执行路径时不被破坏，确保数据的一致性。Linux内核作为应用层服务的提供者，一方面要为应用提供系统调用接口(<code>system call</code>)，代表用户进程执行任务,即<a href="https://tldp.org/LDP/LG/issue23/flower/intro.html" target="_blank" rel="noopener">process context</a>;同时与硬件直接交互，要响应硬件中断的请求，处理诸如网卡数据/串口数据等请求，即<a href="https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html" target="_blank" rel="noopener">Interrupt Context</a>. 内核就是在进程上下文/中断上下文直接来回切换，执行相应的任务请求。这就自然产生了数据的并发访问，产生了竞争条件(<code>race condition</code>)。另一方面，目前大多数的系统都是多核CPU的，多个CPU同时访问内核数据也同样会产生竞争条件。</p><p>简单来说，内核中锁要做的事情就是确保临界区&lt;<code>critical section</code>&gt;始终只有一个执行路径，就是说在有锁保护的情况下，临界区的执行不会被其他执行路径中断; 接下来，就分别看一看内核中常用的几个锁保护机制&lt;对应的代码实现在<code>/kernel/locking/</code>&gt;：</p><ul><li>semaphore(信号量）</li><li>Spin Lock(自旋锁）</li><li>Mutex(互斥锁）</li><li>Atomic(原子操作）</li></ul><h2 id="Semaphore-信号量）"><a href="#Semaphore-信号量）" class="headerlink" title="Semaphore(信号量）"></a><strong>Semaphore(信号量）</strong></h2><p><a href="https://en.wikipedia.org/wiki/Semaphore_(programming" target="_blank" rel="noopener"><code>semaphore</code></a>)是很常见的同步资源访问的方法，可以用于多个资源的访问控制;一般用于多个内核路径试图控制某个数据的并发访问，内核中对应的头文件在<code>linux/semaphore.h</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">  <span class="keyword">raw_spinlock_t</span>lock;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>count;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述中<code>count</code>就是需要同步访问的资源个数，一般在内核中都设置为<code>1</code>，即等同于互斥锁。<code>semaphore</code>有两个常用的操作方法：</p><ul><li><code>down</code>: 获取锁，读应可用的资源减少，通常获取锁会将阻塞所执行的路径，让任务进入等待状态; 内核实现了好几种方法供调用：<ul><li><code>down</code>:  如果锁已被持有，则执行任务会被阻塞，在内核中不推荐使用该方法</li><li><code>down_interruptible</code>： 允许获取锁时被中断，在接收到中断信号后，返回中断错误<code>-EINTR</code></li><li><code>down_killable</code>: 执行任务阻塞时如果发生错误，则被中断返回<code>-EINTR</code></li><li><code>down_trylock</code>: 尝试获取锁，如果已被占用，则直接返回，该方法支持在中断上下文中使用</li><li><code>down_timeout</code>： 设置一个超时时间，超过该等待时间未获取到锁则返回<code>-ETIME</code></li></ul></li><li><code>up</code>: 释放锁，可以在任何执行路径执行该方法，即使未执行过<code>down</code>也可以进行锁的释放</li></ul><p>互斥锁的使用与<code>semaphore</code>比较类似，具体的使用可以参考源码<code>kernel/mutex.c</code>.</p><h2 id="spin-lock-自旋锁"><a href="#spin-lock-自旋锁" class="headerlink" title="spin lock(自旋锁)"></a><strong>spin lock(自旋锁)</strong></h2><p><code>spin lock</code>是内核中最常用的同步方法，通常用于多个CPU执行路径尝试访问同一个内存数据时的同步并且执行任务不能休眠的场景。与其他如<code>semaphore</code>不同的是，<code>spin lock</code>不会让锁等待者进入休眠状态，而是执行一个简单的循环等待，如果此时锁被释放，则会尝试获取锁，这样就避免了上下文切换，从而提升效率。一般如果锁等待的时间如果超过系统上下文切换的时间，使用<code>spin lock</code>则会较少任务的等待时间，改善系统性能。</p><p>除此之外，在某些特殊的场景比如在中断上下文与内核执行路径上共享数据时，就不能使用如<code>semaphore</code>这类会时执行任务休眠的同步锁，因为内核一旦在处理中断时，发生进程调度，则可能发生中断无法被处理的情况。同样地，在处理中断时，也不能使用<code>spin lock</code>以防止类似的情况;因此，在中断处理上下文中，使用<code>spin lock</code>时要将本地中断禁止。另外，在可能发生内核抢占(<code>kernel preemption</code>)的时候，如果被抢占任务执有<code>spin lock</code>，就可能导致该锁一直未被释放。总结来说，使用<code>spin lock</code>要注意如下几个原则:</p><ul><li>内核抢占应该被禁止，以防出现竞争条件</li><li>本地中断需要被禁止，防止中断无法处理的情况</li><li>持有锁的时间越短越好，避免引起性能问题</li></ul><p>跟上述几个场景对应，Linux中的<code>spin lock</code>提供了好几个函数来实现不同场景下的同步&lt;<code>linux/spinlock.h</code>&gt;：</p><ul><li><code>spin_lock</code>: 获取锁，如果锁被持有了，则等待</li><li><code>spin_lock_bh</code>： 获取锁，禁止了软中断/本地中断，但可以响应物理中断</li><li><code>spin_lock_irq</code>： 获取锁时打开中断</li><li><code>spin_lock_irqsave</code>： 获取锁时禁止本地中断</li></ul><p>上述几个函数的实现都在<code>kernel/locking/spinlock.c</code>中，如果不希望获取锁失败时等待，则可以通过<code>spin_trylock*</code>来实现。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://static.lwn.net/images/pdf/LDD3/ch05.pdf" target="_blank" rel="noopener">https://static.lwn.net/images/pdf/LDD3/ch05.pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在看Linux内核代码时，经常会遇到各种锁(lock)的使用。对于像&lt;code&gt;spin_lock_irq&lt;/code&gt;/&lt;code&gt;spin_lock_irqsave&lt;/code&gt;的区别感到困惑，每次都要重新查一下资料。遂决定写一篇文章记录下内核中使用到的锁，以及使用的场
      
    
    </summary>
    
      <category term="Linux" scheme="http://sniffer.site/categories/Linux/"/>
    
    
      <category term="mutex" scheme="http://sniffer.site/tags/mutex/"/>
    
      <category term="Spin Lock" scheme="http://sniffer.site/tags/Spin-Lock/"/>
    
      <category term="Kernel" scheme="http://sniffer.site/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>IPV6地址的那些事儿</title>
    <link href="http://sniffer.site/2020/10/14/IPV6%E5%9C%B0%E5%9D%80%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://sniffer.site/2020/10/14/IPV6地址的那些事儿/</id>
    <published>2020-10-14T02:23:38.000Z</published>
    <updated>2021-02-25T03:05:53.199Z</updated>
    
    <content type="html"><![CDATA[<p>前阵子在Android下调试一个只有IPv6地址的网络设备时，发现通过<code>ping6</code>来测试网络连通时提示错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ping6 fe80::47af:e871:3c63:a272</span><br><span class="line">connect: Invalid argument</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/44670778/ipv6-ping-connect-invalid-argument-on-android" target="_blank" rel="noopener">stackoverflow上有人说</a>这是一个<code>link-local address</code>本地链路地址，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use the following syntax on Android:</span><br><span class="line"></span><br><span class="line">ping6 fe80::405a:e0a5:e054:cbde%wlan0</span><br><span class="line"></span><br><span class="line">You must add %wlan0 since it is a link-local address, and your android device has multiple interfaces (Wi-Fi and mobile at least), so you need to tell your device the interface/link you want to use with this link-local address.</span><br></pre></td></tr></table></figure><p>所以在<code>ping</code>时需要加上端口，或者像这样&lt;亲测，Android设备不支持如下指令&gt;：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ping6 -I wlan0  fe80::47af:e871:3c63:a272</span><br></pre></td></tr></table></figure><p>那么，什么是本地链路地址(<code>link-local address</code>)？ 其跟IPv4中的局域网地址有什么不同的地方了？ 这里就来看下IPv6地址的一些细节。</p><h2 id="什么是link-local-地址"><a href="#什么是link-local-地址" class="headerlink" title="什么是link-local 地址"></a>什么是link-local 地址</h2><p>按照<a href="https://en.wikipedia.org/wiki/Link-local_address" target="_blank" rel="noopener">维基百科的解释</a>, <code>link-local</code>地址是一个只有在主机当前网段或者广播域才有效的地址。由于本地链路地址一般都是系统自动配置的，因此也被称为自动私有IP寻址(<code>automatic private IP addressing</code>)或者自动IP(<code>auto IP</code>):</p><ul><li>对IPv4来说，本地链路地址范围为: <code>169.254.0.0/16</code></li><li>IPv6的本地链路地址一般为: `fe80::/10</li></ul><p>在弄清楚IPv6<code>link-local</code>地址是如何自动分配之前，先来看下IPv6地址的格式以及分类。</p><h2 id="IPv6地址格式"><a href="#IPv6地址格式" class="headerlink" title="IPv6地址格式"></a>IPv6地址格式</h2><p>相比IPv4地址的32位，IPv6地址扩到了128位，一般有两部分组成：</p><ul><li>Network Prefix(网络前缀): 占n位，跟IPV4的网络ID类似</li><li>Interface ID(网口ID): 占余下的(128 - n)位， 类似于IPV4的主机ID</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ipv6_address_format.png" alt="IPV6 address format"></p><p>IPv6的地址类型有单播(unicast), 组播(anycast), 多播(multicast)三种，而广播地址(broadcast)的功能则由多播地址替代：</p><ul><li>unicast address: 单播地址对应唯一的一个网口，发送给单播地址的数据包都只会发送到对应的网口上，根据不同的功能需要，单播地址又可以分为如下几个：</li></ul><table><thead><tr><th>单播地址类型</th><th>二进制前缀</th><th>IPV6缩写</th></tr></thead><tbody><tr><td>link-local unicast addresss</td><td>1111111010</td><td>FE80::/10</td></tr><tr><td>unique local unicast address</td><td>1111110</td><td>FC00::/7</td></tr><tr><td>loopback address</td><td>00…1(128bits)</td><td>::1/128</td></tr><tr><td>unspecified address</td><td>00..0(128bits)</td><td>::/128</td></tr><tr><td>Global unicast adress</td><td>其他</td></tr></tbody></table><ul><li><p>anycast address:  用于标识一组网口（通常属于不同的网络节点），发送给组播地址的数据会发送到该组网络节点中的一个</p></li><li><p>multicast address: 与anycast address类似，只是发送到该地址的数据会发送给该组所有的网络节点</p></li></ul><p>有关IPv6地址的具体描述，可以参考<a href="https://tools.ietf.org/html/rfc4291" target="_blank" rel="noopener">RFC4291</a></p><h2 id="link-local-address是如何生成的"><a href="#link-local-address是如何生成的" class="headerlink" title="link-local address是如何生成的"></a>link-local address是如何生成的</h2><p>对IPv6来说，<code>link-local</code>地址一般通过NDP(Neighbour Discovery Protocol)协议来实现自动配置：IPv6地址在设置之前，系统会先通过NDP协议发送消息确保要配置的IPv6地址在当前链路上具有唯一性，不与其他节点的IP地址发生冲突。</p><p>NDP协议类似与IPv4的ARP(Address Resolution Protocol)，不同的是NDP是基于ICMPv6, 更多关于NDP细节可以参考<a href="https://tools.ietf.org/html/rfc4862" target="_blank" rel="noopener">RFC4862</a>; Linux的实现可以参考源码：<code>/net/ipv6/ndisc.c</code></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://tools.ietf.org/html/rfc7404" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7404</a></li><li><a href="https://tools.ietf.org/html/rfc4862" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc4862</a></li><li><a href="https://en.wikipedia.org/wiki/Link-local_address" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Link-local_address</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前阵子在Android下调试一个只有IPv6地址的网络设备时，发现通过&lt;code&gt;ping6&lt;/code&gt;来测试网络连通时提示错误：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="网络协议" scheme="http://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="IPv6" scheme="http://sniffer.site/tags/IPv6/"/>
    
      <category term="ICMP" scheme="http://sniffer.site/tags/ICMP/"/>
    
  </entry>
  
  <entry>
    <title>由Policy Routing引发的一个奇怪问题</title>
    <link href="http://sniffer.site/2020/06/03/%E7%94%B1Policy-Routing%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://sniffer.site/2020/06/03/由Policy-Routing引发的一个奇怪问题/</id>
    <published>2020-06-03T06:05:32.000Z</published>
    <updated>2020-06-07T08:49:03.690Z</updated>
    
    <content type="html"><![CDATA[<p>最近新的项目又开始了, 开始还算顺利, 却不料碰到了一个奇怪的问题. 先来了解下问题的背景. 这个项目里, Android中有两个以太网网口, 一个用于内网通讯<eth0>, 不具备上外网的能力;一个用于外网通讯<eth1>, 使用该网口可以访问互联网. 在网络管理模块的工作完成后, 提交了代码我原本以为可以高枕无忧, 前两天组内的同学跑过来告诉我, 他有个系统服务一直没法通过<eth0>与内网的其他设备上的服务建立TCP链接, 但是网络却一直可以ping通; 而另外的一个开发板上却不存在这个问题. </eth0></eth1></eth0></p><p>开始我有点不相信竟然会有这样的问题, 但事实摆在面前, 我也不好抵赖, 于是自己找来一个板子, 看了下, 才逐渐找到答案. 问题的根源在于Android配置的策略路由<policy routing>规则隐含了一个针对系统默认网络的<code>fwmark</code>规则, 要解决问题, 只要我们将包含了<eth0>内网路由表的路由规则的优先级提升到高于Android隐含的这条规则即可. 虽然找到了解决方案, 但是还是决定花点时间把整个事情的来龙去脉都理清楚. </eth0></policy></p><p>大致分如下几个部分来讲一讲这个问题:</p><ul><li>介绍下什么是Policy Routing&lt;策略路由&gt;</li><li>分析具体的问题, 并给出方案</li><li>从源代码角度来分析下, 为何TCP无法建立, 但ping却可以</li></ul><h2 id="什么是Policy-Routing"><a href="#什么是Policy-Routing" class="headerlink" title="什么是Policy Routing"></a><strong>什么是Policy Routing</strong></h2><p>我们都知道, 传统的Linux路由都是基于目标IP地址来进行路由设置, 策略路由不同的是, 在原有路由表的基础上, 添加一系列具有优先级的规则, 这些规则可以根据数据包的入口&lt;本地或者lo&gt;, 出口, TOS&lt;<code>Type Of Service</code>&gt;, fwmark标签值, 协议以及端口号等来进行路由表的选择, 所有这些策略规则都放在一个称为<code>routing policy database</code><rpdb>的数据库中. 一般, 一条策略路由规则都由<code>selector</code>(选择器)以及<code>action predicate</code>(需要执行的动作)两部分组成; 通过<code>ip rule</code>指令, 我们可以修改/删除系统中的策略路由规则. 例如, 在Ubuntu系统中, 输入<code>ip rule list</code>, 大致是这样的:</rpdb></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">0</span>:from all lookup local </span><br><span class="line"><span class="number">32766</span>:from all lookup main </span><br><span class="line"><span class="number">32767</span>:from all lookup <span class="keyword">default</span></span><br></pre></td></tr></table></figure><p>这些策略路由规则都是内核初始化时默认生成的, 按照规则的优先级大小排列, 数字越小, 优先级越高:</p><ul><li>优先级<code>0</code>: 会匹配任何数据包, 执行的动作是在<code>local</code>路由表<id 255>查找路由</id></li><li>优先级<code>32766</code>: 匹配任何数据包, 执行的动作是在<code>main</code>路由表<id 254>中查找路由</id></li><li>优先级<code>32767</code>: 匹配任何数据包, 执行的动作是在<code>default</code>路由表<id 253>中查找路由</id></li></ul><p>通过<code>man ip rule</code>我们可以查看到更多关于RP规则的信息. 而对于Android来说, 由于需要同时管理多个网络, 并根据网络权限/用户UID等来设置防火墙, 策略路由的规则就复杂了很多, 例如在我的开发板上输入<code>adb shell ip rule list</code>可以看到这么一大串的规则列表:</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/android_ip_rules_list.png" alt="Android Ip Rule list examples"></p><p>这里, <code>eth0</code>就是用来作内网通讯用的网口, 而<code>usb0</code>是用来连接外网的网口, 当前系统默认的默认网络&lt;具有默认路由&gt;即<code>usb0</code>. Android的Netd(负责网络管理的native进程, 可以参考早前的文章了解更多信息<a href="http://sniffer.site/2018/12/18/Android-netd%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">Android Netd详解</a>)会把每个正常工作的网口都建立一个相应的路由表, 路由表的ID就是对应网络的<code>netID</code>&lt;每个网络在创建后都会分配一个唯一的ID&gt;, 例如通过输入<code>ip route show table usb0</code>查看路由表<code>usb0</code>实际是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">default</span> via <span class="number">192.168</span><span class="number">.225</span><span class="number">.1</span> dev usb0 proto <span class="keyword">static</span> </span><br><span class="line"><span class="number">192.168</span><span class="number">.225</span><span class="number">.0</span>/<span class="number">24</span> dev usb0 proto <span class="keyword">static</span> scope link</span><br></pre></td></tr></table></figure><p>这张路由表包含了两个路由规则: 前一个是默认路由, 用于匹配外网数据(非<code>192.168.225.*</code>IP段的都会匹配该路由)的路由；后一个是用于该网卡局域网内IP地址的路由.上图中我们看到的这个RPDB实际是能正常工作的, 就是说通过<code>eth0</code>可以建立TCP连接, ping网络也正常, 后面在分析问题时会再贴出有问题的RPDB.</p><h2 id="网络ping通但无法建立TCP的问题"><a href="#网络ping通但无法建立TCP的问题" class="headerlink" title="网络ping通但无法建立TCP的问题"></a><strong>网络ping通但无法建立TCP的问题</strong></h2><p>出问题时的路由表<code>eth0</code>只有一个路由规则:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">172.20</span><span class="number">.1</span><span class="number">.0</span>/<span class="number">24</span> dev eth0 proto <span class="keyword">static</span> scope link</span><br></pre></td></tr></table></figure><p>相应的RPDB大致如下, 这里要说明的是<code>21300:    from all lookup main</code>这个查找<code>main</code>路由表的规则是需要自己添加的, Android原生代码已经把<code>main</code>表的查找规则剔除了, 对于同时有对个网卡共存的情况, <code>main</code>表是必须的, 否则基于<code>eth0</code>网口的局域网就无法正常ping通.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">0</span>:from all lookup local </span><br><span class="line"><span class="number">10000</span>:from all fwmark <span class="number">0xc0000</span>/<span class="number">0xd0000</span> lookup legacy_system </span><br><span class="line"><span class="number">10500</span>:from all iif lo oif dummy0 uidrange <span class="number">0</span><span class="number">-0</span> lookup dummy0 </span><br><span class="line"><span class="number">10500</span>:from all iif lo oif eth0 uidrange <span class="number">0</span><span class="number">-0</span> lookup eth0 </span><br><span class="line"><span class="number">10500</span>:from all iif lo oif usb0 uidrange <span class="number">0</span><span class="number">-0</span> lookup usb0 </span><br><span class="line"><span class="number">13000</span>:from all fwmark <span class="number">0x10063</span>/<span class="number">0x1ffff</span> iif lo lookup local_network </span><br><span class="line"><span class="number">13000</span>:from all fwmark <span class="number">0x10064</span>/<span class="number">0x1ffff</span> iif lo lookup eth0 </span><br><span class="line"><span class="number">13000</span>:from all fwmark <span class="number">0x10065</span>/<span class="number">0x1ffff</span> iif lo lookup usb0 </span><br><span class="line"><span class="number">14000</span>:from all iif lo oif dummy0 lookup dummy0 </span><br><span class="line"><span class="number">14000</span>:from all iif lo oif eth0 lookup eth0 </span><br><span class="line"><span class="number">14000</span>:from all iif lo oif usb0 lookup usb0 </span><br><span class="line"><span class="number">15000</span>:from all fwmark <span class="number">0x0</span>/<span class="number">0x10000</span> lookup legacy_system </span><br><span class="line"><span class="number">16000</span>:from all fwmark <span class="number">0x0</span>/<span class="number">0x10000</span> lookup legacy_network </span><br><span class="line"><span class="number">17000</span>:from all fwmark <span class="number">0x0</span>/<span class="number">0x10000</span> lookup local_network </span><br><span class="line"><span class="number">19000</span>:from all fwmark <span class="number">0x64</span>/<span class="number">0x1ffff</span> iif lo lookup eth0 </span><br><span class="line"><span class="number">19000</span>:from all fwmark <span class="number">0x65</span>/<span class="number">0x1ffff</span> iif lo lookup usb0 </span><br><span class="line"><span class="number">21300</span>:from all lookup main </span><br><span class="line"><span class="number">22000</span>:from all fwmark <span class="number">0x0</span>/<span class="number">0xffff</span> iif lo lookup usb0 </span><br><span class="line"><span class="number">32000</span>:from all unreachable</span><br></pre></td></tr></table></figure><p>基于上述RPDB规则, 尝试测试内网某个设备的连通性: <code>ping 172.20.1.55</code>有看到回应, 但是如果通过ssh指令<code>ssh -vvv root@172.20.1.55</code>尝试登录到对端, 就会提示<code>No Route to Host</code>, 其他上层TCP连接也没法正常建立成功. 细心的同学可能已经发现, 在之前讲到的那个正常RPDB与这里的异常的RPDB唯一的区别就是在与<code>main</code>路由表查找规则的优先级, 一个是<code>21300</code>, 一个<code>18300</code>, 那么为什么优先级的差异会导致不一样的结果?</p><p>对于一般的TCP连接, 并不会指定连接的网口(通过<code>setsocktopt</code>的<code>SO_BINDTODEVICE</code>选项指定), 所以可以判定那些指定了<code>oif</code>(数据包出口)的<code>ip rule</code>规则应该不会导致问题的发生, 这里我们可以通过<code>ip rule add pref &lt;pref_no&gt; lookup main</code>调整这个规则的优先级, 通过二分查找测试几次就知道了. 在另外一方面, 测试的同学反馈, 如果没有接<code>usb0</code>这个网络设备, 问题就不会存在. 这样这个问题就更清晰了: 跟<code>usb0</code>路由表相关的几条规则是问题的关键. 排除掉指定了<code>oif</code>相关的规则, 只剩下两条:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">13000</span>:from all fwmark <span class="number">0x10065</span>/<span class="number">0x1ffff</span> iif lo lookup usb0 </span><br><span class="line"><span class="number">19000</span>:from all fwmark <span class="number">0x65</span>/<span class="number">0x1ffff</span> iif lo lookup usb0</span><br></pre></td></tr></table></figure><p>删除掉原有的规则<code>ip rule del pref 21300 lookup main</code>, 然后添加一个优先级高于第一条<code>13000</code>的规则<code>ip rule add pref 12800 lookup main</code>, 试验下发现TCP可以正常建立连接, 问题不存在;再次实验, 先删除<code>main</code>路由表对应的规则, 添加一条<code>ip rule add pref 18300 lookup main</code>的规则, 也可以正常建立TCP连接. 于是, 我们可以断定, 优先级为<code>19000</code>这条规则是罪魁祸首.解决问题的方案就是把原来的<code>main</code>查找的优先级高于<code>19000</code>即可.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ip rule add pref <span class="number">18300</span> lookup main</span><br></pre></td></tr></table></figure><p>问题是解决了, 可以为什么会这样了? 这条包含了<code>fwmark</code>的规则为何会让TCP连接没法正常建立而ping又可以了? 还是要<code>read the fucking source code</code>才能找到根本原因了.</p><h2 id="看看该死的源代码"><a href="#看看该死的源代码" class="headerlink" title="看看该死的源代码"></a><strong>看看该死的源代码</strong></h2><p>对于Android来说, 无论是Java的网络请求, 还是native的最终都会通过<code>libc</code>的封装的系统调用来完成. 因此, 第一步就来看看<code>libc</code>中对常用socket API的实现逻辑. 对应的源码位于<code>/bionic/libc</code>. 我们知道, 对于TCP客户端来说, 一般先调用<code>socket</code>创建套接字获取到文件描述符后, 会直接调用<code>connect</code>尝试连接到服务端, 由于创建socket不涉及到路由, 因此就来看看<code>connect</code>的具体调用逻辑. 找到<code>connect.cpp</code>, 代码很简单, 只有一行:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr* addr, <span class="keyword">socklen_t</span> addrlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __netdClientDispatch.connect(sockfd, addr, addrlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数直接是调用了<code>__netdClientDispatch</code>对应的实现, 从函数名字来看, 实际应该是把请求转发给<code>Netd</code>, 不妨接续看代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// private/NetdClientDispatch.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetdClientDispatch</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*accept4)(<span class="keyword">int</span>, struct sockaddr*, <span class="keyword">socklen_t</span>*, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*connect)(<span class="keyword">int</span>, <span class="keyword">const</span> struct sockaddr*, <span class="keyword">socklen_t</span>);</span><br><span class="line">    <span class="keyword">int</span> (*socket)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> (*netIdForResolv)(<span class="keyword">unsigned</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// NetdClientDispatch.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __i386__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __socketcall __attribute__((__cdecl__))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __socketcall</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __socketcall <span class="keyword">int</span> __accept4(<span class="keyword">int</span>, sockaddr*, <span class="keyword">socklen_t</span>*, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __socketcall <span class="keyword">int</span> __connect(<span class="keyword">int</span>, <span class="keyword">const</span> sockaddr*, <span class="keyword">socklen_t</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __socketcall <span class="keyword">int</span> __socket(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="title">fallBackNetIdForResolv</span><span class="params">(<span class="keyword">unsigned</span> netId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> netId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This structure is modified only at startup (when libc.so is loaded) and never</span></span><br><span class="line"><span class="comment">// afterwards, so it's okay that it's read later at runtime without a lock.</span></span><br><span class="line">__LIBC_HIDDEN__ NetdClientDispatch __netdClientDispatch __attribute__((aligned(<span class="number">32</span>))) = &#123;</span><br><span class="line">    __accept4,</span><br><span class="line">    __connect,</span><br><span class="line">    __socket,</span><br><span class="line">    fallBackNetIdForResolv,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__netdClientDispatch</code>实际是封装了几个外部函数而已, 那么<code>__socket/__connect</code>/<code>__accept4</code>这几个函数又在哪里实现的了? 搜索下<code>libc</code>下面的代码, 发现原来在<code>libc</code>初始化的时候, 会加载一个<code>libnetd_client.so</code>的库, 然后把相应的实现加载过来:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// NetdClient.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FunctionType&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">netdClientInitFunction</span><span class="params">(<span class="keyword">void</span>* handle, <span class="keyword">const</span> <span class="keyword">char</span>* symbol, FunctionType* function)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*InitFunctionType)</span><span class="params">(FunctionType*)</span></span>;</span><br><span class="line">    InitFunctionType initFunction = <span class="keyword">reinterpret_cast</span>&lt;InitFunctionType&gt;(dlsym(handle, symbol));</span><br><span class="line">    <span class="keyword">if</span> (initFunction != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        initFunction(function);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">netdClientInitImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* netdClientHandle = dlopen(<span class="string">"libnetd_client.so"</span>, RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (netdClientHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// If the library is not available, it's not an error. We'll just use</span></span><br><span class="line">        <span class="comment">// default implementations of functions that it would've overridden.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    netdClientInitFunction(netdClientHandle, <span class="string">"netdClientInitAccept4"</span>,</span><br><span class="line">                          &amp;__netdClientDispatch.accept4);</span><br><span class="line">    netdClientInitFunction(netdClientHandle, <span class="string">"netdClientInitConnect"</span>,</span><br><span class="line">                          &amp;__netdClientDispatch.connect);</span><br><span class="line">    netdClientInitFunction(netdClientHandle, <span class="string">"netdClientInitNetIdForResolv"</span>,</span><br><span class="line">                          &amp;__netdClientDispatch.netIdForResolv);</span><br><span class="line">    netdClientInitFunction(netdClientHandle, <span class="string">"netdClientInitSocket"</span>, &amp;__netdClientDispatch.socket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> netdClientInitOnce = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __<span class="function">LIBC_HIDDEN__ <span class="keyword">void</span> <span class="title">netdClientInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pthread_once(&amp;netdClientInitOnce, netdClientInitImpl)) &#123;</span><br><span class="line">        async_safe_format_log(ANDROID_LOG_ERROR, <span class="string">"netdClient"</span>, <span class="string">"Failed to initialize netd_client"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有兴趣的可以看看<code>libc</code>具体的初始化流程. 这里, 我们直接跳到<code>libnetd_client.so</code>这个库去看看<code>netdClientInitConnect</code>的实现. 共享库<code>libnetd_client.so</code>的代码位于<code>/system/netd/client</code>目录, 其中有个文件<code>NetdClient.cpp</code>即实现了该函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// NetdClient.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netdClientConnect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr* addr, <span class="keyword">socklen_t</span> addrlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> shouldSetFwmark = (sockfd &gt;= <span class="number">0</span>) &amp;&amp; addr</span><br><span class="line">            &amp;&amp; FwmarkClient::shouldSetFwmark(addr-&gt;sa_family);</span><br><span class="line">    <span class="keyword">if</span> (shouldSetFwmark) &#123;</span><br><span class="line">        FwmarkCommand command = &#123;FwmarkCommand::ON_CONNECT, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">int</span> error = FwmarkClient().send(&amp;command, sockfd, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">            errno = -error;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Latency measurement does not include time of sending commands to Fwmark</span></span><br><span class="line">    Stopwatch s;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ret = libcConnect(sockfd, addr, addrlen);</span><br><span class="line">    <span class="comment">// Save errno so it isn't clobbered by sending ON_CONNECT_COMPLETE</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> connectErrno = errno;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> latencyMs = lround(s.timeTaken());</span><br><span class="line">    <span class="comment">// Send an ON_CONNECT_COMPLETE command that includes sockaddr and connect latency for reporting</span></span><br><span class="line">    <span class="keyword">if</span> (shouldSetFwmark &amp;&amp; FwmarkClient::shouldReportConnectComplete(addr-&gt;sa_family)) &#123;</span><br><span class="line">        <span class="function">FwmarkConnectInfo <span class="title">connectInfo</span><span class="params">(ret == <span class="number">0</span> ? <span class="number">0</span> : connectErrno, latencyMs, addr)</span></span>;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> get the netId from the socket mark once we have continuous benchmark runs</span></span><br><span class="line">        FwmarkCommand command = &#123;FwmarkCommand::ON_CONNECT_COMPLETE, <span class="comment">/* netId (ignored) */</span> <span class="number">0</span>,</span><br><span class="line">                                <span class="comment">/* uid (filled in by the server) */</span> <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// Ignore return value since it's only used for logging</span></span><br><span class="line">        FwmarkClient().send(&amp;command, sockfd, &amp;connectInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = connectErrno;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里的<code>Fwmark</code>等字样, 似乎有点眼熟了, 这个函数的逻辑是, 首先要判断一个socket链接是否要打上防火墙标签(Firewall Mark)<code>shouldSetFwmark</code>, 实际上对于TCP的socket来说, 该函数都返回<code>True</code>, 接着会将对应的socketFd通过一个本地<code>fwmarkd</code>这个socket发送给<code>FwmarkServer</code>, 由其负责将socket打上防火墙标签:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> FwmarkServer::processClient(SocketClient* client, <span class="keyword">int</span>* socketFd) &#123;</span><br><span class="line">    FwmarkCommand command;</span><br><span class="line">    FwmarkConnectInfo connectInfo;</span><br><span class="line"></span><br><span class="line">    iovec iov[<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123; &amp;command, <span class="keyword">sizeof</span>(command) &#125;,</span><br><span class="line">        &#123; &amp;connectInfo, <span class="keyword">sizeof</span>(connectInfo) &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    msghdr message;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;message, <span class="number">0</span>, <span class="keyword">sizeof</span>(message));</span><br><span class="line">    message.msg_iov = iov;</span><br><span class="line">    message.msg_iovlen = ARRAY_SIZE(iov);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        cmsghdr cmh;</span><br><span class="line">        <span class="keyword">char</span> cmsg[CMSG_SPACE(<span class="keyword">sizeof</span>(*socketFd))];</span><br><span class="line">    &#125; cmsgu;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(cmsgu.cmsg, <span class="number">0</span>, <span class="keyword">sizeof</span>(cmsgu.cmsg));</span><br><span class="line">    message.msg_control = cmsgu.cmsg;</span><br><span class="line">    message.msg_controllen = <span class="keyword">sizeof</span>(cmsgu.cmsg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> messageLength = TEMP_FAILURE_RETRY(recvmsg(client-&gt;getSocket(), &amp;message, MSG_CMSG_CLOEXEC));</span><br><span class="line">    <span class="keyword">if</span> (messageLength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!((command.cmdId != FwmarkCommand::ON_CONNECT_COMPLETE &amp;&amp; messageLength == <span class="keyword">sizeof</span>(command))</span><br><span class="line">            || (command.cmdId == FwmarkCommand::ON_CONNECT_COMPLETE</span><br><span class="line">            &amp;&amp; messageLength == <span class="keyword">sizeof</span>(command) + <span class="keyword">sizeof</span>(connectInfo)))) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADMSG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前用户是否有网络访问权限</span></span><br><span class="line">    Permission permission = mNetworkController-&gt;getPermissionForUser(client-&gt;getUid());</span><br><span class="line">    ...</span><br><span class="line">    Fwmark fwmark;</span><br><span class="line">    <span class="keyword">socklen_t</span> fwmarkLen = <span class="keyword">sizeof</span>(fwmark.intValue);</span><br><span class="line">    <span class="comment">// 获取当前socket上的fwmark</span></span><br><span class="line">    <span class="keyword">if</span> (getsockopt(*socketFd, SOL_SOCKET, SO_MARK, &amp;fwmark.intValue, &amp;fwmarkLen) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (command.cmdId) &#123;</span><br><span class="line">        <span class="keyword">case</span> FwmarkCommand::ON_ACCEPT: &#123;</span><br><span class="line">            <span class="comment">// Called after a socket accept(). The kernel would've marked the NetId and necessary</span></span><br><span class="line">            <span class="comment">// permissions bits, so we just add the rest of the user's permissions here.</span></span><br><span class="line">            permission = <span class="keyword">static_cast</span>&lt;Permission&gt;(permission | fwmark.permission);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> FwmarkCommand::ON_CONNECT: &#123;</span><br><span class="line">            <span class="comment">// Called before a socket connect() happens. Set an appropriate NetId into the fwmark so</span></span><br><span class="line">            <span class="comment">// that the socket routes consistently over that network. Do this even if the socket</span></span><br><span class="line">            <span class="comment">// already has a NetId, so that calling connect() multiple times still works.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// But if the explicit bit was set, the existing NetId was explicitly preferred (and not</span></span><br><span class="line">            <span class="comment">// a case of connect() being called multiple times). Don't reset the NetId in that case.</span></span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// 这里explicitlySelected为false, 因此实际会选择默认网络的netId</span></span><br><span class="line">            <span class="keyword">if</span> (!fwmark.explicitlySelected) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fwmark.protectedFromVpn) &#123;</span><br><span class="line">                    fwmark.netId = mNetworkController-&gt;getNetworkForConnect(client-&gt;getUid());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mNetworkController-&gt;isVirtualNetwork(fwmark.netId)) &#123;</span><br><span class="line">                    fwmark.netId = mNetworkController-&gt;getDefaultNetwork();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">    fwmark.permission = permission;</span><br><span class="line">    <span class="comment">// 将该socket打上防火墙的标签, 这个实际就是用来给内核选择路由时用的</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(*socketFd, SOL_SOCKET, SO_MARK, &amp;fwmark.intValue,</span><br><span class="line">                  <span class="keyword">sizeof</span>(fwmark.intValue)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步, 我们大概知道, <code>fwmark</code>实际是一个32位的整型数值, 其中网络的<code>netId</code>占了低16位, 网络权限<code>permission</code>占了2位, 这样系统所有的TCP连接都会被打上<code>fwmark</code>. 那么, 内核的RPDB规则又何时被添加过去的了? 我们再来看看<code>Netd</code>的代码.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">union</span> Fwmark &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> intValue;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> netId          : <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">bool</span> explicitlySelected :  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> protectedFromVpn   :  <span class="number">1</span>;</span><br><span class="line">        Permission permission   :  <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">bool</span> uidBillingDone     :  <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    constexpr Fwmark() : intValue(0) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Android对网络路由相关的管理与控制逻辑都放在<code>/system/netd/server/RouteController.cpp</code>中, 找到对应开始引起问题的那个RP规则, 其优先级为<code>19000</code>, 这正好是<code>RULE_PRIORITY_IMPLICIT_NETWORK</code>这个值.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19000:from all fwmark 0x65/0x1ffff iif lo lookup usb0</span><br></pre></td></tr></table></figure><p>搜索这个关键字, 可以看到Netd会在创建无需任何权限的<code>PhysicalNetwork</code>对象时, 会根据网络的netId时生成一条隐性的策略路由规则<code>modifyImplicitNetworkRule</code>: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">WARN_UNUSED_RESULT <span class="keyword">int</span> RouteController::modifyPhysicalNetwork(<span class="keyword">unsigned</span> netId, <span class="keyword">const</span> <span class="keyword">char</span>* interface,</span><br><span class="line">                                                              Permission permission, <span class="keyword">bool</span> add) &#123;</span><br><span class="line">  <span class="comment">//if network id has register interface, other interface route add to the table with interface registered by netid</span></span><br><span class="line">  ....</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">int</span> ret = modifyIncomingPacketMark(netId, interface, permission, add)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">int</span> ret = modifyExplicitNetworkRule(netId, table, permission, INVALID_UID, INVALID_UID,</span><br><span class="line">                                            add)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">int</span> ret = modifyOutputInterfaceRules(interface, table, permission, INVALID_UID, INVALID_UID,</span><br><span class="line">                                            add)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only set implicit rules for networks that don't require permissions.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is so that if the default network ceases to be the default network and then switches</span></span><br><span class="line">    <span class="comment">// from requiring no permissions to requiring permissions, we ensure that apps only use the</span></span><br><span class="line">    <span class="comment">// network if they explicitly select it. This is consistent with destroySocketsLackingPermission</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (permission == PERMISSION_NONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> modifyImplicitNetworkRule(netId, table, add);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数会设置一个值为默认网络<code>netId</code>的<code>fwmark</code>, 也就是我们最开始看到的那条优先级为<code>19000</code>的规则, 并通过类型为<code>NETLINK_ROUTE</code>的netlink向内核配置该规则, 内核就会根据这条规则来匹配上对应的TCP包, 因而就会出现我们最开始的那个问题:使用TCP连接会提示<code>No Route to Host</code>, 那为何ping不存在这个问题了? </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">WARN_UNUSED_RESULT <span class="keyword">int</span> <span class="title">modifyImplicitNetworkRule</span><span class="params">(<span class="keyword">unsigned</span> netId, <span class="keyword">uint32_t</span> table, <span class="keyword">bool</span> add)</span> </span>&#123;</span><br><span class="line">    Fwmark fwmark;</span><br><span class="line">    Fwmark mask;</span><br><span class="line"></span><br><span class="line">    fwmark.netId = netId;</span><br><span class="line">    mask.netId = FWMARK_NET_ID_MASK;</span><br><span class="line"></span><br><span class="line">    fwmark.explicitlySelected = <span class="literal">false</span>;</span><br><span class="line">    mask.explicitlySelected = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    fwmark.permission = PERMISSION_NONE;</span><br><span class="line">    mask.permission = PERMISSION_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> modifyIpRule(add ? RTM_NEWRULE : RTM_DELRULE, RULE_PRIORITY_IMPLICIT_NETWORK, table,</span><br><span class="line">                        fwmark.intValue, mask.intValue, IIF_LOOPBACK, OIF_NONE, INVALID_UID,</span><br><span class="line">                        INVALID_UID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道ping一般是基于<code>IPPROTO_ICMP</code>协议, 实际发送ping的<code>ECHO_REQUEST</code>时, 只需要创建一个<code>socket</code>接口, 然后直接通过<code>sendto</code>发送对应的数据报文就好了;从刚开始的代码知道, libc会把socket相关的请求转发给Netd, 我们直接看Netd中<code>NetdClient.cpp</code>的建立socket相关的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="keyword">atomic_uint</span> <span class="title">netIdForProcess</span><span class="params">(NETID_UNSET)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netdClientSocket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> socketFd = libcSocket(domain, type, protocol);</span><br><span class="line">    <span class="keyword">if</span> (socketFd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> netId = netIdForProcess;</span><br><span class="line">    <span class="keyword">if</span> (netId != NETID_UNSET &amp;&amp; FwmarkClient::shouldSetFwmark(domain)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">int</span> error = setNetworkForSocket(netId, socketFd)) &#123;</span><br><span class="line">            <span class="keyword">return</span> closeFdAndSetErrno(socketFd, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> socketFd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数首先会调用libc创建socket, ping的时候并没有调用<code>setNetworkForProcess</code>指定网络netId, 因此实际路由时会跳过<code>19000</code>这条规则, 使用的是后面<code>21300</code>这个main路由规则来进行路由选择. 至此问题的谜团也算揭开了.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="http://linux-ip.net/html/routing-tables.html#list-routing-route-types" target="_blank" rel="noopener">http://linux-ip.net/html/routing-tables.html#list-routing-route-types</a></li><li><a href="https://www.man7.org/linux/man-pages/man8/ip-rule.8.html" target="_blank" rel="noopener">https://www.man7.org/linux/man-pages/man8/ip-rule.8.html</a></li><li><a href="https://www.drdobbs.com/policy-routing-in-linux/199100936" target="_blank" rel="noopener">https://www.drdobbs.com/policy-routing-in-linux/199100936</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近新的项目又开始了, 开始还算顺利, 却不料碰到了一个奇怪的问题. 先来了解下问题的背景. 这个项目里, Android中有两个以太网网口, 一个用于内网通讯&lt;eth0&gt;, 不具备上外网的能力;一个用于外网通讯&lt;eth1&gt;, 使用该网口可以访问互联网. 在网络管理模块的工
      
    
    </summary>
    
      <category term="Android" scheme="http://sniffer.site/categories/Android/"/>
    
    
      <category term="Policy Routing" scheme="http://sniffer.site/tags/Policy-Routing/"/>
    
      <category term="策略路由" scheme="http://sniffer.site/tags/%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1/"/>
    
      <category term="网络管理" scheme="http://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    
      <category term="Netd" scheme="http://sniffer.site/tags/Netd/"/>
    
  </entry>
  
  <entry>
    <title>软件开发与BUG的那些事儿</title>
    <link href="http://sniffer.site/2020/05/27/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%8EBUG%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://sniffer.site/2020/05/27/软件开发与BUG的那些事儿/</id>
    <published>2020-05-27T02:12:28.000Z</published>
    <updated>2020-08-24T08:00:01.959Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Excellence in any department can be attained only by the labor of a lifetime;it is not to be purchased at a lesser price</p><p>Paul Graham</p></blockquote><p>前段时间, 看新闻说<a href="https://www.ithome.com/0/484/241.htm" target="_blank" rel="noopener">“微软4万多的软件开发工程师, 每天产生进3万个BUG”</a>, 当时感觉有点震惊, 然后就哑然失笑. 震惊的是连微软这样厉害的公司, 工程师应该都很优秀, 人才济济, 为何却会每天产生这么多的BUG了? <a id="more"></a>于是,再想想自己的开发经历, 才恍然明白: 开发人员一旦走进办公室,打开电脑写代码, 就不可避免的要写出BUG来. 与BUG纠缠不清似乎是每个开发人员的宿命.恰逢最近遇到了一个BUG, 让我纠结不已, 痛定思痛, 觉得有必要把自己的开发”心得经验”写下来, 权当是给自己一点警醒, 给自己一点回顾的资料, 分享下自己在开发过程中遇到的困难与挫折, 苦恼与迷惑.</p><ul><li>对业务理解的越深, 你对可能发生的问题就越透彻；认真思考每个需求/每行代码背后蕴含的业务逻辑, 这对于实现更优秀的方案具有重要的作用. 要对你所负责的业务领域的知识有广泛的把握, 这样也能够帮助你快速深入的进入一个全新的领域.</li><li>对于要提交的每个PR(Pull Request), 在提交前自己先过一遍, 检查格式, 检查拼写, 检查PR的描述是否清晰简单明确, 检查功能实现是否与需求一致, 同时还要问问自己这个修改是否有可以优化改进的地方, 是否存在更好的解决策略? 是否有疏漏的地方? 只有完整的走了必须的checklist, 才真正加上代码reviewer.</li><li>在每次实现方案, 提交代码时, 首先要摒弃的是”这个实现很完美, 我敢打包票, 毫无疑问没有问题了”类似这种自信爆棚的观念, 首先要正视可能存在的缺陷, 正视自己当前对于问题的认知可能还有不完善的地方, 把可能存在漏洞的地方在代码实现处comment出来, 这样后面再来看代码时可能会有更好的思路.</li><li>现代软件项目开发的核心在于高质量且如期交付产品, 而要确保高质量与项目日程预期的达成, 核心在于管控软件开发中的风险点. 因此, 对于大部分公司开发软件来说, 都要有质量/测试/开发多个部门的通力合作才能达成这一目标.对与软件开发工程师而言, 在确保自己提交代码的质量, 减少BUG的数量的同时, 还要关注项目日程安排, 确保修改正常合入到正确的分支, 确保给到用户都是稳定可靠/BUG更少的版本.时刻铭记交付质量对于一个优秀工程师来说至关重要.</li><li>产生的任何BUG都要保持警惕, 而不是防御心态: 总觉得这个BUG不是我的责任, 不会是我代码实现产生的问题, 当别人指出来你的错误时, 不是保持开放的思考, 而是一味的浪费时间与人纠缠争吵, 不敢承认自己思维上存在的问题; 一旦确认了BUG, 就要坦然面对, 而不是藏着掩着;诚实的面对自己犯下的错误, 总结经验教训, 这不仅能让你赢得同事的认可与信任, 也能让领导对你放心.</li><li>不时的想一想你的客户是谁? 你的客户不仅是产品的使用者, 也是你的上司, 你的同事, 你要确保你的每个产出物都具备高质量, 能让使用者感到舒服, 感到可信赖.要对自己所做的每件事情都负责, 对上司交代的任务要反馈; 对同事的问题要多关心;对产品的质量要严格的把控.</li><li>不满足于已有的知识, 不停的学习新的技能, 反复总结打磨自己的知识系统, 长此以往, 你的能力与视野就会得到质的改变；学习的同时, 也要不断的总结, 将所学所思分享给身边的同事, 保持影响力</li><li>软件从业人员经常被工作进度压得传不过气来, 时间紧张, 以至于忽略了锻炼身体. 想要平时尽量产生BUG, 保持良好的生活习惯, 必不可少. 这么看起来, 写好代码, 少产生BUG, 不仅仅是一个逻辑问题, 更是一个程序员自我修养与提高的问题</li><li>养成良好的工作习惯: 不时的总结些提升工作效率的方法, 比如修改分支代码时, 先同步远端代码<code>git pull --rebase</code>; 修改好的代码要及时保存; 重要的数据要做好备份; 及时的梳理知识结构, 有时间最好将心得总结写下来</li><li>遵从项目流程，即便是日程紧急，也要遵守项目规范，确保发出的版本是可靠稳定的;定期发布版本，每个版本都要有对应的release分支(<em>_</em>笑，最近我们有个项目自始至终都只有一个dev分支，项目后期风险不断，时不时的掉坑里）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;Excellence in any department can be attained only by the labor of a lifetime;it is not to be purchased at a lesser price&lt;/p&gt;
&lt;p&gt;Paul Graham&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前段时间, 看新闻说&lt;a href=&quot;https://www.ithome.com/0/484/241.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“微软4万多的软件开发工程师, 每天产生进3万个BUG”&lt;/a&gt;, 当时感觉有点震惊, 然后就哑然失笑. 震惊的是连微软这样厉害的公司, 工程师应该都很优秀, 人才济济, 为何却会每天产生这么多的BUG了?
    
    </summary>
    
      <category term="软件工程" scheme="http://sniffer.site/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件开发" scheme="http://sniffer.site/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="BUG" scheme="http://sniffer.site/tags/BUG/"/>
    
      <category term="软件工程" scheme="http://sniffer.site/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="项目管理" scheme="http://sniffer.site/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>从NAPI说一说Linux内核数据的接收流程</title>
    <link href="http://sniffer.site/2020/05/12/%E4%BB%8ENAPI%E8%AF%B4%E4%B8%80%E8%AF%B4Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/"/>
    <id>http://sniffer.site/2020/05/12/从NAPI说一说Linux内核数据的接收流程/</id>
    <published>2020-05-12T10:01:22.000Z</published>
    <updated>2020-05-14T07:39:13.089Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/New_API" target="_blank" rel="noopener">NAPI(New API)</a>是Linux内核针对网络数据传输做出的一个优化措施，其目的是在大量数据传输时， 在收到硬件中断后，通过poll方式将传输过来的数据包统一处理， 通过禁止网络设备中断以减少硬件中断数量((Interrupt Mitigation)，从而实现更高的数据传输。</p><p>基于NAPI接口， 一般的网络传输都有如下几个步骤：</p><ul><li>网络设备驱动加载与初始化（配置IP等）</li><li>数据包从网络侧发送到网卡(Network Interface Controller, NIC)</li><li>通过<a href="https://en.wikipedia.org/wiki/Direct_memory_access" target="_blank" rel="noopener">DMA(Direct Memory Access)</a>，将数据从网卡拷贝到内存的环形缓冲区(ring buffer)</li><li>NIC产生硬件中断告知内核有新的数据包达到了</li><li>网卡驱动收到中断后调用NAPI接口开启poll线程（如果当前没有正在执行的线程）(常规数据传输直接处理NIC的中断时中间一般通过调用<code>netif_rx</code>来发起数据接收）</li><li><code>ksoftirqd</code>（内核启动时每个CPU上都会启动这样一个线程）线程负责调用NAPI的<code>poll</code>接口来获取内存环形缓冲区的数据包</li><li>通过DMA传输到内存中的数据包，最终通过<code>sk_buff</code>的形式传递给上层网络协议栈（TCP/IP层)</li><li>如果支持数据包转发(packet steering)或者NIC本身支持多个接收队列的话, 从网卡过来的数据会在不同的CPU之间进行分发</li><li>网络协议栈处理数据包，并将其发送到对应的<code>socket</code>接收缓冲区</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/network_recieving_process.png" alt="网络数据接收流程"></p><p>下面就结合具体的代码来看看数据是如何一步步接收的（以intel的千兆以太网卡为例<code>kernel/drivers/net/intel/e1000</code>）。</p><h2 id="驱动加载与设备初始化"><a href="#驱动加载与设备初始化" class="headerlink" title="驱动加载与设备初始化"></a><strong>驱动加载与设备初始化</strong></h2><p>看<code>e1000_main.c</code>代码，驱动的初始化首先要做的是注册一个<code>pci</code>设备驱动到内核，这样设备枚举的时候会匹配到该网卡</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">e1000_init_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">pr_info(<span class="string">"%s - version %s\n"</span>, e1000_driver_string, e1000_driver_version);</span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">"%s\n"</span>, e1000_copyright);</span><br><span class="line"></span><br><span class="line">ret = pci_register_driver(&amp;e1000_driver);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(e1000_init_module);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">e1000_driver</span> = &#123;</span></span><br><span class="line">.name     = e1000_driver_name,</span><br><span class="line">.id_table = e1000_pci_tbl,</span><br><span class="line">.probe    = e1000_probe,</span><br><span class="line">.remove   = e1000_remove,</span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line"><span class="comment">/* Power Management Hooks */</span></span><br><span class="line">.suspend  = e1000_suspend,</span><br><span class="line">.resume   = e1000_resume,</span><br><span class="line">#endif</span><br><span class="line">.shutdown = e1000_shutdown,</span><br><span class="line">.err_handler = &amp;e1000_err_handler</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>匹配到网卡后， pci总线会调用驱动的<code>probe</code>函数， 大致会做如下几个事情：</p><ul><li>调用<code>alloc_etherdev</code> 分配一个网络设备对象，并注册到系统中</li><li>通过<code>netif_napi_add</code>添加NAPI的poll接口</li><li>设置网卡寄存器IO映射内存区域</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">e1000_probe</span><span class="params">(struct pci_dev *pdev, <span class="keyword">const</span> struct pci_device_id *ent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ....</span><br><span class="line">err = pci_request_selected_regions(pdev, bars, e1000_driver_name);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> err_pci_reg;</span><br><span class="line"></span><br><span class="line">pci_set_master(pdev);</span><br><span class="line">err = pci_save_state(pdev);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> err_alloc_etherdev;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="comment">// 分配以太网网络对象</span></span><br><span class="line">netdev = alloc_etherdev(<span class="keyword">sizeof</span>(struct e1000_adapter));</span><br><span class="line"><span class="keyword">if</span> (!netdev)</span><br><span class="line"><span class="keyword">goto</span> err_alloc_etherdev;</span><br><span class="line"></span><br><span class="line">SET_NETDEV_DEV(netdev, &amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">pci_set_drvdata(pdev, netdev);</span><br><span class="line">adapter = netdev_priv(netdev);</span><br><span class="line">adapter-&gt;netdev = netdev;</span><br><span class="line">adapter-&gt;pdev = pdev;</span><br><span class="line">adapter-&gt;msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);</span><br><span class="line">adapter-&gt;bars = bars;</span><br><span class="line">adapter-&gt;need_ioport = need_ioport;</span><br><span class="line"></span><br><span class="line">hw = &amp;adapter-&gt;hw;</span><br><span class="line">hw-&gt;back = adapter;</span><br><span class="line"></span><br><span class="line">err = -EIO;</span><br><span class="line"><span class="comment">// 映射寄存器IO区域</span></span><br><span class="line">hw-&gt;hw_addr = pci_ioremap_bar(pdev, BAR_0);</span><br><span class="line"><span class="keyword">if</span> (!hw-&gt;hw_addr)</span><br><span class="line"><span class="keyword">goto</span> err_ioremap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (adapter-&gt;need_ioport) &#123;</span><br><span class="line"><span class="keyword">for</span> (i = BAR_1; i &lt;= BAR_5; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (pci_resource_len(pdev, i) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (pci_resource_flags(pdev, i) &amp; IORESOURCE_IO) &#123;</span><br><span class="line">hw-&gt;io_base = pci_resource_start(pdev, i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* make ready for any if (hw-&gt;...) below */</span></span><br><span class="line">err = e1000_init_hw_struct(adapter, hw);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> err_sw_init;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 设置网络设备对象的操作接口</span></span><br><span class="line">netdev-&gt;netdev_ops = &amp;e1000_netdev_ops;</span><br><span class="line">e1000_set_ethtool_ops(netdev);</span><br><span class="line">netdev-&gt;watchdog_timeo = <span class="number">5</span> * HZ;</span><br><span class="line"><span class="comment">// 添加napi的poll接口</span></span><br><span class="line">netif_napi_add(netdev, &amp;adapter-&gt;napi, e1000_clean, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(netdev-&gt;name, pci_name(pdev), <span class="keyword">sizeof</span>(netdev-&gt;name) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">adapter-&gt;bd_number = cards_found;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* setup the private structure */</span></span><br><span class="line"></span><br><span class="line">err = e1000_sw_init(adapter);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> err_sw_init;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!is_valid_ether_addr(netdev-&gt;dev_addr))</span><br><span class="line">e_err(probe, <span class="string">"Invalid MAC Address\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INIT_DELAYED_WORK(&amp;adapter-&gt;watchdog_task, e1000_watchdog);</span><br><span class="line">INIT_DELAYED_WORK(&amp;adapter-&gt;fifo_stall_task,</span><br><span class="line">  e1000_82547_tx_fifo_stall_task);</span><br><span class="line">INIT_DELAYED_WORK(&amp;adapter-&gt;phy_info_task, e1000_update_phy_info_task);</span><br><span class="line">INIT_WORK(&amp;adapter-&gt;reset_task, e1000_reset_task);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initialize the wol settings based on the eeprom settings */</span></span><br><span class="line">adapter-&gt;wol = adapter-&gt;eeprom_wol;</span><br><span class="line">device_set_wakeup_enable(&amp;adapter-&gt;pdev-&gt;dev, adapter-&gt;wol);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Auto detect PHY address */</span></span><br><span class="line"><span class="keyword">if</span> (hw-&gt;mac_type == e1000_ce4100) &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">hw-&gt;phy_addr = i;</span><br><span class="line">e1000_read_phy_reg(hw, PHY_ID2, &amp;tmp);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="number">0</span> || tmp == <span class="number">0xFF</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">31</span>)</span><br><span class="line"><span class="keyword">goto</span> err_eeprom;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* reset the hardware with the new settings */</span></span><br><span class="line">e1000_reset(adapter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置网卡名字，注册网络设备对象</span></span><br><span class="line"><span class="built_in">strcpy</span>(netdev-&gt;name, <span class="string">"eth%d"</span>);</span><br><span class="line">err = register_netdev(netdev);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> err_register;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* carrier off reporting is important to ethtool even BEFORE open */</span></span><br><span class="line">netif_carrier_off(netdev);</span><br><span class="line"></span><br><span class="line">e_info(probe, <span class="string">"Intel(R) PRO/1000 Network Connection\n"</span>);</span><br><span class="line"></span><br><span class="line">cards_found++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步网卡还不是可用状态，需要通过手动<code>ifconfig eth0 up/ifconfig eth0 &lt;ip&gt;</code>， 设置网卡为<code>UP</code>时，会调用驱动的<code>ndo_open</code>函数：</p><ul><li>请求硬件中断，并使能该中断</li><li><code>napi_enable</code>开启napi</li><li>启动网络的发送队列，允许发送数据</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">e1000_open</span><span class="params">(struct net_device *netdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_adapter</span> *<span class="title">adapter</span> = <span class="title">netdev_priv</span>(<span class="title">netdev</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_hw</span> *<span class="title">hw</span> = &amp;<span class="title">adapter</span>-&gt;<span class="title">hw</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">netif_carrier_off(netdev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocate transmit descriptors */</span></span><br><span class="line">err = e1000_setup_all_tx_resources(adapter);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocate receive descriptors */</span></span><br><span class="line">err = e1000_setup_all_rx_resources(adapter);</span><br><span class="line"></span><br><span class="line">e1000_power_up_phy(adapter);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">err = e1000_request_irq(adapter);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* From here on the code is the same as e1000_up() */</span></span><br><span class="line">clear_bit(__E1000_DOWN, &amp;adapter-&gt;flags);</span><br><span class="line"></span><br><span class="line">napi_enable(&amp;adapter-&gt;napi);</span><br><span class="line"></span><br><span class="line">e1000_irq_enable(adapter);</span><br><span class="line"></span><br><span class="line">netif_start_queue(netdev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fire a link status change interrupt to start the watchdog */</span></span><br><span class="line">ew32(ICS, E1000_ICS_LSC);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> E1000_SUCCESS;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此时网卡正常工作， 再来看看数据接收的具体流程。</p><h2 id="网卡数据接收"><a href="#网卡数据接收" class="headerlink" title="网卡数据接收"></a><strong>网卡数据接收</strong></h2><p>网卡数据的接收大概有三个步骤：</p><ul><li>网卡发送中断给驱动</li><li>驱动处理函数处理中断，并启动一个<code>napi</code>处理任务</li><li>发送接收数据的软中断<code>NET_RX_SOFTIRQ</code></li><li>内核线程处理网络软中断，将数据包发送给上层协议栈</li></ul><h3 id="处理网卡中断"><a href="#处理网卡中断" class="headerlink" title="处理网卡中断"></a><strong>处理网卡中断</strong></h3><p>在网卡驱动初始化的过程，我们看到驱动会向内核请求中断, 并注册一个中断处理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">e1000_request_irq</span><span class="params">(struct e1000_adapter *adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span> = <span class="title">adapter</span>-&gt;<span class="title">netdev</span>;</span></span><br><span class="line"><span class="keyword">irq_handler_t</span> handler = e1000_intr;</span><br><span class="line"><span class="keyword">int</span> irq_flags = IRQF_SHARED;</span><br><span class="line"></span><br><span class="line">err = request_irq(adapter-&gt;pdev-&gt;irq, handler, irq_flags, netdev-&gt;name,</span><br><span class="line">          netdev);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当网卡产生数据中断后，调用中断处理函数： 对于napi来说，首先要禁止当前网卡的中断，如果当前没有在运行的napi任务，则调度一个新的napi任务<code>__napi_schedule</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> irqreturn_t <span class="title">e1000_intr</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* disable interrupts, without the synchronize_irq bit */</span></span><br><span class="line">ew32(IMC, ~<span class="number">0</span>);</span><br><span class="line">E1000_WRITE_FLUSH();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(napi_schedule_prep(&amp;adapter-&gt;napi))) &#123;</span><br><span class="line">adapter-&gt;total_tx_bytes = <span class="number">0</span>;</span><br><span class="line">adapter-&gt;total_tx_packets = <span class="number">0</span>;</span><br><span class="line">adapter-&gt;total_rx_bytes = <span class="number">0</span>;</span><br><span class="line">adapter-&gt;total_rx_packets = <span class="number">0</span>;</span><br><span class="line">__napi_schedule(&amp;adapter-&gt;napi);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* this really should not happen! if it does it is basically a</span></span><br><span class="line"><span class="comment"> * bug, but not a hard error, so enable ints and continue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;flags))</span><br><span class="line">e1000_irq_enable(adapter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动napi任务，发送软中断"><a href="#启动napi任务，发送软中断" class="headerlink" title="启动napi任务，发送软中断"></a><strong>启动napi任务，发送软中断</strong></h3><p><code>__napi_schedule</code>在<code>/kernel/net/core/dev.c</code>中，其实际做了两件事：</p><ul><li>将<code>napi_struct</code>添加到中断处理CPU的<code>softnet_data</code>对应的poll列表中</li><li>发出一个<code>NET_RX_SOFTIRQ</code>的软中断，让内核线程<code>ksoftirqd</code>来处理对应的该<code>softirq</code>软中断</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> __napi_schedule(struct napi_struct *n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">local_irq_save(flags);</span><br><span class="line">____napi_schedule(this_cpu_ptr(&amp;softnet_data), n);</span><br><span class="line">local_irq_restore(flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> ____napi_schedule(struct softnet_data *sd,</span><br><span class="line">     struct napi_struct *napi)</span><br><span class="line">&#123;</span><br><span class="line">list_add_tail(&amp;napi-&gt;poll_list, &amp;sd-&gt;poll_list);</span><br><span class="line">__raise_softirq_irqoff(NET_RX_SOFTIRQ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__raise_softirq_irqoff</code>函数在<code>/kernel/softirq.c</code>中定义，其实际做的事情就是将当前CPU对应的<code>softirq</code>状态标记为待运行状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> __raise_softirq_irqoff(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span><br><span class="line">&#123;</span><br><span class="line">trace_softirq_raise(nr);</span><br><span class="line">or_softirq_pending(<span class="number">1U</span>L &lt;&lt; nr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理网络软中断"><a href="#处理网络软中断" class="headerlink" title="处理网络软中断"></a><strong>处理网络软中断</strong></h3><p>内核在初始化的时候，每个CPU上都会启动一个专门的<code>ksoftirqd%d</code>（<code>%d</code>对应CPU的ID）内核线程用于处理CPU上的软中断（代码同样在<code>softirq.c</code>)中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">smp_hotplug_thread</span> <span class="title">softirq_threads</span> = &#123;</span></span><br><span class="line">.store= &amp;ksoftirqd,</span><br><span class="line">.thread_should_run= ksoftirqd_should_run,</span><br><span class="line">.thread_fn= run_ksoftirqd,</span><br><span class="line">.thread_comm= <span class="string">"ksoftirqd/%u"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">init <span class="keyword">int</span> <span class="title">spawn_ksoftirqd</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">register_cpu_notifier(&amp;cpu_nfb);</span><br><span class="line"></span><br><span class="line">BUG_ON(smpboot_register_percpu_thread(&amp;softirq_threads));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">early_initcall(spawn_ksoftirqd);</span><br></pre></td></tr></table></figure><p>每个内核线程<code>ksoftirqd</code>实际一直执行的是<code>run_ksoftirqd</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run_ksoftirqd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">local_irq_disable();</span><br><span class="line"><span class="keyword">if</span> (local_softirq_pending()) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We can safely run softirq on inline stack, as we are not deep</span></span><br><span class="line"><span class="comment"> * in the task stack here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__do_softirq();</span><br><span class="line">local_irq_enable();</span><br><span class="line">cond_resched_rcu_qs();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">local_irq_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>__do_softirq</code>检查当前CPU所有待处理的软中断，并调用对应的处理函数<code>softirq_action</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">asmlinkage __visible <span class="keyword">void</span> __softirq_entry __do_softirq(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> ((softirq_bit = ffs(pending))) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vec_nr;</span><br><span class="line"><span class="keyword">int</span> prev_count;</span><br><span class="line"></span><br><span class="line">h += softirq_bit - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">vec_nr = h - softirq_vec;</span><br><span class="line">...</span><br><span class="line">h-&gt;action(h);</span><br><span class="line">...</span><br><span class="line">h++;</span><br><span class="line">pending &gt;&gt;= softirq_bit;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>softirq_action</code>实际是在网络模块初始化的时候注册的(查看<code>/kernel/net/dev.c</code>)中的函数<code>net_dev_init</code>，通过调用<code>open_softirq</code>告知内核启动网络数据传输的两个软中断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">net_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (register_pernet_subsys(&amp;netdev_net_ops))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Initialise the packet receive queues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">for_each_possible_cpu(i) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> = &amp;<span class="title">per_cpu</span>(<span class="title">softnet_data</span>, <span class="title">i</span>);</span></span><br><span class="line"></span><br><span class="line">skb_queue_head_init(&amp;sd-&gt;input_pkt_queue);</span><br><span class="line">skb_queue_head_init(&amp;sd-&gt;process_queue);</span><br><span class="line">INIT_LIST_HEAD(&amp;sd-&gt;poll_list);</span><br><span class="line">sd-&gt;output_queue_tailp = &amp;sd-&gt;output_queue;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RPS</span></span><br><span class="line">sd-&gt;csd.func = rps_trigger_softirq;</span><br><span class="line">sd-&gt;csd.info = sd;</span><br><span class="line">sd-&gt;cpu = i;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">sd-&gt;backlog.poll = process_backlog;</span><br><span class="line">sd-&gt;backlog.weight = weight_p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">open_softirq(NET_TX_SOFTIRQ, net_tx_action);</span><br><span class="line">open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span><br><span class="line"></span><br><span class="line">hotcpu_notifier(dev_cpu_callback, <span class="number">0</span>);</span><br><span class="line">dst_subsys_init();</span><br><span class="line">rc = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就说<code>h-&gt;action</code> 调用的实际是<code>net_rx_action</code>函数： 不断的调用<code>napi_poll</code>获取CPU上的数据包，直到到达单个CPU处理的上限或者所有需要poll的列表完成处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">net_rx_action</span><span class="params">(struct softirq_action *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span> *<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;<span class="built_in">list</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!sd_has_rps_ipi_waiting(sd) &amp;&amp; list_empty(&amp;repoll))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n = list_first_entry(&amp;<span class="built_in">list</span>, struct napi_struct, poll_list);</span><br><span class="line">budget -= napi_poll(n, &amp;repoll);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If softirq window is exhausted then punt.</span></span><br><span class="line"><span class="comment"> * Allow this to run for 2 jiffies since which will allow</span></span><br><span class="line"><span class="comment"> * an average latency of 1.5/HZ.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(budget &lt;= <span class="number">0</span> ||</span><br><span class="line">     time_after_eq(jiffies, time_limit))) &#123;</span><br><span class="line">sd-&gt;time_squeeze++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">local_irq_disable();</span><br><span class="line"></span><br><span class="line">list_splice_tail_init(&amp;sd-&gt;poll_list, &amp;<span class="built_in">list</span>);</span><br><span class="line">list_splice_tail(&amp;repoll, &amp;<span class="built_in">list</span>);</span><br><span class="line">list_splice(&amp;<span class="built_in">list</span>, &amp;sd-&gt;poll_list);</span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;sd-&gt;poll_list))</span><br><span class="line">__raise_softirq_irqoff(NET_RX_SOFTIRQ);</span><br><span class="line"></span><br><span class="line">net_rps_action_and_irq_enable(sd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>napi_poll</code>则调用最初网卡驱动注册的poll函数<code>e1000_clean</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">napi_poll</span><span class="params">(struct napi_struct *n, struct list_head *repoll)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *have;</span><br><span class="line"><span class="keyword">int</span> work, weight;</span><br><span class="line"></span><br><span class="line">list_del_init(&amp;n-&gt;poll_list);</span><br><span class="line"></span><br><span class="line">have = netpoll_poll_lock(n);</span><br><span class="line"></span><br><span class="line">weight = n-&gt;weight;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This NAPI_STATE_SCHED test is for avoiding a race</span></span><br><span class="line"><span class="comment"> * with netpoll's poll_napi().  Only the entity which</span></span><br><span class="line"><span class="comment"> * obtains the lock and sees NAPI_STATE_SCHED set will</span></span><br><span class="line"><span class="comment"> * actually make the -&gt;poll() call.  Therefore we avoid</span></span><br><span class="line"><span class="comment"> * accidentally calling -&gt;poll() when NAPI is not scheduled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">work = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (test_bit(NAPI_STATE_SCHED, &amp;n-&gt;state)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> = <span class="title">this_cpu_ptr</span>(&amp;<span class="title">softnet_data</span>);</span></span><br><span class="line"></span><br><span class="line">sd-&gt;current_napi = n;</span><br><span class="line">work = n-&gt;poll(n, weight);</span><br><span class="line">trace_napi_poll(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> work;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>e1000_clean</code>会将当前CPU中接收到的数据包放到<code>skb_buff</code>列表当中，并将数据发送给上层协议栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">e1000_clean</span><span class="params">(struct napi_struct *napi, <span class="keyword">int</span> budget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_adapter</span> *<span class="title">adapter</span> = <span class="title">container_of</span>(<span class="title">napi</span>, <span class="title">struct</span> <span class="title">e1000_adapter</span>,</span></span><br><span class="line"><span class="class">     <span class="title">napi</span>);</span></span><br><span class="line"><span class="keyword">int</span> tx_clean_complete = <span class="number">0</span>, work_done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">tx_clean_complete = e1000_clean_tx_irq(adapter, &amp;adapter-&gt;tx_ring[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">adapter-&gt;clean_rx(adapter, &amp;adapter-&gt;rx_ring[<span class="number">0</span>], &amp;work_done, budget);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!tx_clean_complete)</span><br><span class="line">work_done = budget;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If budget not fully consumed, exit the polling mode */</span></span><br><span class="line"><span class="keyword">if</span> (work_done &lt; budget) &#123;</span><br><span class="line"><span class="keyword">if</span> (likely(adapter-&gt;itr_setting &amp; <span class="number">3</span>))</span><br><span class="line">e1000_set_itr(adapter);</span><br><span class="line">napi_complete_done(napi, work_done);</span><br><span class="line"><span class="keyword">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;flags))</span><br><span class="line">e1000_irq_enable(adapter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> work_done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将skb-buff-发送给协议栈"><a href="#将skb-buff-发送给协议栈" class="headerlink" title="将skb_buff 发送给协议栈"></a><strong>将<code>skb_buff</code> 发送给协议栈</strong></h3><p><code>e1000_clean_rx_irq</code>不断的从网卡对应的内存环形缓冲区中获取网络数据包，并将数据包以<code>sk_buff</code>的形式传给协议栈进行处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">e1000_clean_rx_irq</span><span class="params">(struct e1000_adapter *adapter,</span></span></span><br><span class="line"><span class="function"><span class="params">       struct e1000_rx_ring *rx_ring,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">int</span> *work_done, <span class="keyword">int</span> work_to_do)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span> = <span class="title">adapter</span>-&gt;<span class="title">netdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_dev</span> *<span class="title">pdev</span> = <span class="title">adapter</span>-&gt;<span class="title">pdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_rx_desc</span> *<span class="title">rx_desc</span>, *<span class="title">next_rxd</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_rx_buffer</span> *<span class="title">buffer_info</span>, *<span class="title">next_buffer</span>;</span></span><br><span class="line">u32 length;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> cleaned_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> cleaned = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> total_rx_bytes=<span class="number">0</span>, total_rx_packets=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">i = rx_ring-&gt;next_to_clean;</span><br><span class="line">rx_desc = E1000_RX_DESC(*rx_ring, i);</span><br><span class="line">buffer_info = &amp;rx_ring-&gt;buffer_info[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (rx_desc-&gt;status &amp; E1000_RXD_STAT_DD) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">u8 *data;</span><br><span class="line">u8 status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*work_done &gt;= work_to_do)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">(*work_done)++;</span><br><span class="line">dma_rmb(); <span class="comment">/* read descriptor and rx_buffer_info after status DD */</span></span><br><span class="line"></span><br><span class="line">status = rx_desc-&gt;status;</span><br><span class="line">length = le16_to_cpu(rx_desc-&gt;length);</span><br><span class="line"></span><br><span class="line">data = buffer_info-&gt;rxbuf.data;</span><br><span class="line">prefetch(data);</span><br><span class="line">skb = e1000_copybreak(adapter, buffer_info, length, data);</span><br><span class="line"><span class="keyword">if</span> (!skb) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> frag_len = e1000_frag_len(adapter);</span><br><span class="line"></span><br><span class="line">skb = build_skb(data - E1000_HEADROOM, frag_len);</span><br><span class="line"><span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">adapter-&gt;alloc_rx_buff_failed++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skb_reserve(skb, E1000_HEADROOM);</span><br><span class="line">dma_unmap_single(&amp;pdev-&gt;dev, buffer_info-&gt;dma,</span><br><span class="line"> adapter-&gt;rx_buffer_len,</span><br><span class="line"> DMA_FROM_DEVICE);</span><br><span class="line">buffer_info-&gt;dma = <span class="number">0</span>;</span><br><span class="line">buffer_info-&gt;rxbuf.data = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (++i == rx_ring-&gt;count) i = <span class="number">0</span>;</span><br><span class="line">next_rxd = E1000_RX_DESC(*rx_ring, i);</span><br><span class="line">prefetch(next_rxd);</span><br><span class="line"></span><br><span class="line">next_buffer = &amp;rx_ring-&gt;buffer_info[i];</span><br><span class="line"></span><br><span class="line">cleaned = <span class="literal">true</span>;</span><br><span class="line">cleaned_count++;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* !EOP means multiple descriptors were used to store a single</span></span><br><span class="line"><span class="comment"> * packet, if thats the case we need to toss it.  In fact, we</span></span><br><span class="line"><span class="comment"> * to toss every packet with the EOP bit clear and the next</span></span><br><span class="line"><span class="comment"> * frame that _does_ have the EOP bit set, as it is by</span></span><br><span class="line"><span class="comment"> * definition only a frame fragment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!(status &amp; E1000_RXD_STAT_EOP)))</span><br><span class="line">adapter-&gt;discarding = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (adapter-&gt;discarding) &#123;</span><br><span class="line"><span class="comment">/* All receives must fit into a single buffer */</span></span><br><span class="line">netdev_dbg(netdev, <span class="string">"Receive packet consumed multiple buffers\n"</span>);</span><br><span class="line">dev_kfree_skb(skb);</span><br><span class="line"><span class="keyword">if</span> (status &amp; E1000_RXD_STAT_EOP)</span><br><span class="line">adapter-&gt;discarding = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">goto</span> next_desc;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">process_skb:</span><br><span class="line">total_rx_bytes += (length - <span class="number">4</span>); <span class="comment">/* don't count FCS */</span></span><br><span class="line">total_rx_packets++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(!(netdev-&gt;features &amp; NETIF_F_RXFCS)))</span><br><span class="line"><span class="comment">/* adjust length to remove Ethernet CRC, this must be</span></span><br><span class="line"><span class="comment"> * done after the TBI_ACCEPT workaround above</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">length -= <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buffer_info-&gt;rxbuf.data == <span class="literal">NULL</span>)</span><br><span class="line">skb_put(skb, length);</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* copybreak skb */</span></span><br><span class="line">skb_trim(skb, length);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Receive Checksum Offload */</span></span><br><span class="line">e1000_rx_checksum(adapter,</span><br><span class="line">  (u32)(status) |</span><br><span class="line">  ((u32)(rx_desc-&gt;errors) &lt;&lt; <span class="number">24</span>),</span><br><span class="line">  le16_to_cpu(rx_desc-&gt;csum), skb);</span><br><span class="line"></span><br><span class="line">e1000_receive_skb(adapter, status, rx_desc-&gt;special, skb);</span><br><span class="line"></span><br><span class="line">next_desc:</span><br><span class="line">rx_desc-&gt;status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* return some buffers to hardware, one at a time is too slow */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(cleaned_count &gt;= E1000_RX_BUFFER_WRITE)) &#123;</span><br><span class="line">adapter-&gt;alloc_rx_buf(adapter, rx_ring, cleaned_count);</span><br><span class="line">cleaned_count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* use prefetched values */</span></span><br><span class="line">rx_desc = next_rxd;</span><br><span class="line">buffer_info = next_buffer;</span><br><span class="line">&#125;</span><br><span class="line">rx_ring-&gt;next_to_clean = i;</span><br><span class="line"></span><br><span class="line">cleaned_count = E1000_DESC_UNUSED(rx_ring);</span><br><span class="line"><span class="keyword">if</span> (cleaned_count)</span><br><span class="line">adapter-&gt;alloc_rx_buf(adapter, rx_ring, cleaned_count);</span><br><span class="line"></span><br><span class="line">adapter-&gt;total_rx_packets += total_rx_packets;</span><br><span class="line">adapter-&gt;total_rx_bytes += total_rx_bytes;</span><br><span class="line">netdev-&gt;stats.rx_bytes += total_rx_bytes;</span><br><span class="line">netdev-&gt;stats.rx_packets += total_rx_packets;</span><br><span class="line"><span class="keyword">return</span> cleaned;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>e1000_receive_skb</code>实际调用<code>napi_gro_receive</code>将数据发送出去：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">e1000_receive_skb</span><span class="params">(struct e1000_adapter *adapter, u8 status,</span></span></span><br><span class="line"><span class="function"><span class="params">      __le16 vlan, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">skb-&gt;protocol = eth_type_trans(skb, adapter-&gt;netdev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status &amp; E1000_RXD_STAT_VP) &#123;</span><br><span class="line">u16 vid = le16_to_cpu(vlan) &amp; E1000_RXD_SPC_VLAN_MASK;</span><br><span class="line"></span><br><span class="line">__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);</span><br><span class="line">&#125;</span><br><span class="line">napi_gro_receive(&amp;adapter-&gt;napi, skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>napi_gro_receive</code>首先会尝试通过<code>GRO</code>（<code>Generic Receive Offload</code>)的方式将数据发送出去，如果网卡本身不支持<code>GRO</code>则会直接将数据报传送给上层协议栈（简单来说GRO就是将数据包累积到一定数量后再传给上层，这样一次性的处理多个数据包从而提升效率，可以参考<a href="https://lwn.net/Articles/358910/)：" target="_blank" rel="noopener">https://lwn.net/Articles/358910/)：</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// kernel/net/dev.c</span></span><br><span class="line"><span class="keyword">gro_result_t</span> napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">trace_napi_gro_receive_entry(skb);</span><br><span class="line"></span><br><span class="line">skb_gro_reset_offset(skb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> napi_skb_finish(dev_gro_receive(napi, skb), skb);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(napi_gro_receive);</span><br></pre></td></tr></table></figure><p>Intel这个网卡没有开启<code>GRO</code>，所以实际<code>dev_gro_receive</code>直接返回了<code>GRO_NORMAL</code>，这样就通过<code>netif_receive_skb_internal</code>处理数据包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> gro_result_t <span class="title">napi_skb_finish</span><span class="params">(<span class="keyword">gro_result_t</span> ret, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> GRO_NORMAL:</span><br><span class="line"><span class="keyword">if</span> (netif_receive_skb_internal(skb))</span><br><span class="line">ret = GRO_DROP;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> GRO_DROP:</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> GRO_MERGED_FREE:</span><br><span class="line"><span class="keyword">if</span> (NAPI_GRO_CB(skb)-&gt;<span class="built_in">free</span> == NAPI_GRO_FREE_STOLEN_HEAD)</span><br><span class="line">napi_skb_free_stolen_head(skb);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__kfree_skb(skb);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> GRO_HELD:</span><br><span class="line"><span class="keyword">case</span> GRO_MERGED:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于多核系统来说，一般数据传输处理的CPU跟中断处理的CPU是一致的，后来随着网卡速度的提升，如果把网卡的数据都放到一个CPU处理的话，会导致CPU负载过大进而导致数据传输的延迟，因此有人提出了RPS(<a href="https://lwn.net/Articles/362339/" target="_blank" rel="noopener">Receive packet steering</a>, 就是将数据包的处理任务均衡的分配到各个CPU；要支持该特性，需要打开配置<code>CONFIG_RPS</code>， 同时在内核的配置中<code>/sys/class/net/ethx/queues/rx-0/rps_cpus</code>中将需要处理数据包的CPU设置为<code>1</code>， 这样在处理数据的时候就会将数据包先放到各个CPU的数据队列中进行处理。</p><p>这里假定该网卡没有配置RPS，接着会调用<code>__netif_receive_skb</code>处理网络数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">netif_receive_skb_internal</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">net_timestamp_check(netdev_tstamp_prequeue, skb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skb_defer_rx_timestamp(skb))</span><br><span class="line"><span class="keyword">return</span> NET_RX_SUCCESS;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RPS</span></span><br><span class="line"><span class="keyword">if</span> (static_key_false(&amp;rps_needed)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rps_dev_flow</span> <span class="title">voidflow</span>, *<span class="title">rflow</span> = &amp;<span class="title">voidflow</span>;</span></span><br><span class="line"><span class="keyword">int</span> cpu = get_rps_cpu(skb-&gt;dev, skb, &amp;rflow);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cpu &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">ret = enqueue_to_backlog(skb, cpu, &amp;rflow-&gt;last_qtail);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">ret = __netif_receive_skb(skb);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__netif_receive_skb</code>实际调用<code>__netif_receive_skb_core</code>处理数据：<code>__netif_receive_skb_core</code>调用内核初始化时注册的协议类型，并调用其回调函数，由相应的协议来处理该数据包</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __netif_receive_skb(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sk_memalloc_socks() &amp;&amp; skb_pfmemalloc(skb)) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pflags = current-&gt;flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PFMEMALLOC skbs are special, they should</span></span><br><span class="line"><span class="comment"> * - be delivered to SOCK_MEMALLOC sockets only</span></span><br><span class="line"><span class="comment"> * - stay away from userspace</span></span><br><span class="line"><span class="comment"> * - have bounded memory usage</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use PF_MEMALLOC as this saves us from propagating the allocation</span></span><br><span class="line"><span class="comment"> * context down to all allocation sites.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">current-&gt;flags |= PF_MEMALLOC;</span><br><span class="line">ret = __netif_receive_skb_core(skb, <span class="literal">true</span>);</span><br><span class="line">tsk_restore_flags(current, pflags, PF_MEMALLOC);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">ret = __netif_receive_skb_core(skb, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __netif_receive_skb_core(struct sk_buff *skb, <span class="keyword">bool</span> pfmemalloc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> *<span class="title">ptype</span>, *<span class="title">pt_prev</span>;</span></span><br><span class="line"><span class="keyword">rx_handler_func_t</span> *rx_handler;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">orig_dev</span>;</span></span><br><span class="line"><span class="keyword">bool</span> deliver_exact = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> ret = NET_RX_DROP;</span><br><span class="line">__be16 type;</span><br><span class="line"></span><br><span class="line">net_timestamp_check(!netdev_tstamp_prequeue, skb);</span><br><span class="line"></span><br><span class="line">trace_netif_receive_skb(skb);</span><br><span class="line"></span><br><span class="line">orig_dev = skb-&gt;dev;</span><br><span class="line"></span><br><span class="line">skb_reset_network_header(skb);</span><br><span class="line"><span class="keyword">if</span> (!skb_transport_header_was_set(skb))</span><br><span class="line">skb_reset_transport_header(skb);</span><br><span class="line">skb_reset_mac_len(skb);</span><br><span class="line"></span><br><span class="line">pt_prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">another_round:</span><br><span class="line">skb-&gt;skb_iif = skb-&gt;dev-&gt;ifindex;</span><br><span class="line"></span><br><span class="line">__this_cpu_inc(softnet_data.processed);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;protocol == cpu_to_be16(ETH_P_8021Q) ||</span><br><span class="line">    skb-&gt;protocol == cpu_to_be16(ETH_P_8021AD)) &#123;</span><br><span class="line">skb = skb_vlan_untag(skb);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 遍历已注册的协议，并调用其回调函数(一般是libpcap通过`AF_PACKET`传入的)</span></span><br><span class="line">list_for_each_entry_rcu(ptype, &amp;ptype_all, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (pt_prev)</span><br><span class="line">ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">pt_prev = ptype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协议栈</span></span><br><span class="line">list_for_each_entry_rcu(ptype, &amp;skb-&gt;dev-&gt;ptype_all, <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (pt_prev)</span><br><span class="line">ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">pt_prev = ptype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skip_taps:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_INGRESS</span></span><br><span class="line"><span class="keyword">if</span> (static_key_false(&amp;ingress_needed)) &#123;</span><br><span class="line">skb = handle_ing(skb, &amp;pt_prev, &amp;ret, orig_dev);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nf_ingress(skb, &amp;pt_prev, &amp;ret, orig_dev) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调协议包<code>struct packet_type</code>注册的回调函数，把<code>sk_buff</code>传给该协议层处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">deliver_skb</span><span class="params">(struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct packet_type *pt_prev,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct net_device *orig_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(skb_orphan_frags(skb, GFP_ATOMIC)))</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">atomic_inc(&amp;skb-&gt;users);</span><br><span class="line"><span class="keyword">return</span> pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev, orig_dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有这些<code>struct packet_type</code>实际都是在内核初始化的时候通过<code>dev_add_pack</code>注册的，有兴趣的可以跟踪下对应的代码逻辑。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://lwn.net/Articles/30107/" target="_blank" rel="noopener">Driver porting: Network drivers</a></li><li><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#overview" target="_blank" rel="noopener">https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#overview</a></li><li><a href="https://lwn.net/Articles/358910/" target="_blank" rel="noopener">Generic Receive Offload</a></li><li><a href="https://lwn.net/Articles/362339/" target="_blank" rel="noopener">RPS</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rps" target="_blank" rel="noopener">Redhat RPS</a></li><li><a href="https://blog.csdn.net/lucien_cc/article/details/11731463" target="_blank" rel="noopener">https://blog.csdn.net/lucien_cc/article/details/11731463</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/New_API&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NAPI(New API)&lt;/a&gt;是Linux内核针对网络数据传输做出的一个优化措施，其目的是在大量数据传输时， 在
      
    
    </summary>
    
      <category term="网络协议" scheme="http://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="Linux" scheme="http://sniffer.site/tags/Linux/"/>
    
      <category term="TCP/IP" scheme="http://sniffer.site/tags/TCP-IP/"/>
    
      <category term="NAPI" scheme="http://sniffer.site/tags/NAPI/"/>
    
  </entry>
  
  <entry>
    <title>由新冠病毒想到的一些事情</title>
    <link href="http://sniffer.site/2020/04/04/%E8%AF%B4%E8%AF%B4%E8%BF%99%E6%AC%A1%E6%96%B0%E5%86%A0%E4%BC%A0%E6%9F%93%E7%97%85%E6%83%B3%E5%88%B0%E7%9A%84%E4%BA%8B%E6%83%85/"/>
    <id>http://sniffer.site/2020/04/04/说说这次新冠传染病想到的事情/</id>
    <published>2020-04-04T11:48:27.000Z</published>
    <updated>2020-04-06T03:31:34.658Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Live as everything is a miracle or nothing is miracle</p><p>爱因斯坦</p></blockquote><p>这次新型冠状病毒发展到现在估计已经超出了绝大多数人的预料, 现在国内的疫情基本稳定了, 但国外包括北美, 欧洲大部分国家都处于病毒爆发的高峰期, 截至4月3日全球已经有超过80多万的病毒感染者<a id="more"></a>:</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/convid-19_trend.png" alt="新冠病毒确诊人数趋势图"></p><p>看这个图, 增长速率丝毫没有减缓的迹象, 新冠病毒的传染能力也可见一斑.那何时又是个头?我们不妨通过简单的数学模型来估算下最终可能感染的人数以及疫情控制的大致时间节点.按照生物学的规律, <a href="https://www.khanacademy.org/science/biology/ecology/population-growth-and-regulation/a/exponential-logistic-growth" target="_blank" rel="noopener">一个生物种群数量的增长都遵循S型曲线的增长</a>:</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/s_shaped_curve.png" alt="logistic growth curve"></p><p>图中的横轴表示时间, 纵轴表示生物种群的个数, 将上述增长曲线写成对应的公式大致如下:</p><p>$$ y(t) = \frac{k}{1 + Ae^{-rt}} $$</p><p>这里<code>t</code>是时间, <code>k</code>/<code>A</code>是常数(<code>k</code>的值实际表示了最后可能感染的人数), <code>y(t)</code>即当前感染的人数, <code>r</code>是最大的增长率.参考<a href="https://voice.baidu.com/act/newpneumonia/newpneumonia" target="_blank" rel="noopener">百度疫情</a>给出的数据, 为了简化计算, 从历史数据中大概计算了感染人数的增长率为<code>15%</code>(实际最大的增长率已经超过<code>20%</code>, 这里取了一个中间值);分别取了<code>2020/02/20</code>/<code>2020/04/03</code>两天的的数据, 得到<code>k</code>的值大约为<code>2332345.16</code>, 也就是说最后大概总共有200万左右的感染人数, 据此可以得到一个如下的简单感染人数模型:</p><p>$$ y(t) = \frac{2332345.16}{1 + 2172.67e^{-0.15t}} $$</p><p>画成图形可能看得比较直观, 下图中时间<code>0</code>对应<code>2020/02/20</code>, 从图上来看要等90天之后, 也就是<code>2020/5/20</code>左右疫情才能真正稳定下来, 当然后续控制力度加强可能这个时间会提前.</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/prediction_of_infected_persons.png" alt="病毒感染人数预测"></p><p>在全球化的今天, 这次疫情对每个人来说都有着重大的影响, 对那些因为病毒感染失去亲人朋友的人来说, 更是如此. 还记得当时跟同事讨论这个病毒, 病人的症状跟非典(SARS)很相似, 但官方却迟迟没有给出明确的结论是否存在比较强的感染, 还是含糊其词的说”有限人传人”, 直到后来包不住火了, 才实施封城, 最后还是比病毒的传播慢了半拍.</p><p>从湖北考察回来的管轶教授, 上来就说这次很失望, 很麻烦, 比SARS那会要严重很多, 感染人数至少10倍起, 当时很多人不以为然, 还质疑管教授的立场, 以为他是危言耸听, 出于报复心理才这么说的.但凡真的看过管教授履历的人都知道, 他本人是国际知名的传染病科学家,在这样影响大的传染病面前, 作为一个科学家, 他断不会因为一己之心而放弃对真相与道义的坚守.事情事实上比他预想的还要糟糕.面对这么一个局面, 不得不让人感慨深思.</p><p>自工业革命以来, 人类开始了轰轰烈烈的自然改造, 地上跑的有火车/汽车, 天上有飞机/火箭, 同时还把触角伸向了宇宙, 人类的成功恐怕让人自己都难以不陶醉. 人的权能感也达到了新的高度, 以至于都忘记了自己只是生活在一个小小的星球上的生物而已. 人类虽说成了地球生物的主宰, 活在生物链的最顶端, 享尽了自然的馈赠, 但却少了一份对自然的敬畏之心. 病毒其实早在人类诞生之前就存在了, 时间退回到第一个细胞出现的那一刻, 人和病毒其实都来自于同一个祖先, 只是病毒走了另外一条道路, 而进化成生物体的细胞走了另外一条叉路而已, 恐怕从生物学的角度, 病毒要比人类更了解人类自己, 也更聪明.病毒可以欺骗人类的免疫细胞, 然后自我繁殖变异, 通过人与人的传播, 这种独特的生存方式, 人类估计要花很长的时间精力才能真正研究清楚.</p><p>而再看看这次我们对待新冠病毒的方式, 就知道人类赖以生存的复杂社会体系其实有多么的脆弱.官僚体系的迟钝, 组织机构把个人生命安危置若罔闻, 发生重大危机时, 开始时没有百姓的声音, 最后收场时, 却是那些官员们领取功劳, 宣扬成就的表演, 也无法听到普通人的真实声音. 百姓仿佛一只猴子一般被玩弄于手掌. 如今这样的社会体系中, 政府与组织的权力触角实际已经够大够深了, 个人的空间被压缩挤占, 再这样下去, 实际上每个人都会被裹挟者往前走.难道,我们真的要把所有的隐私与权力都要让度于政府或组织吗? 在集体控制与个人权利之间如何才能达成平衡? 个人又要如何在这样的体系结构下生存?</p><p>从大的方面来讲, 在全球化的今天, 面对这样的危机, 个人是否还能明哲保身? 恐怕很难. 我们都没有机会从这种灾难中挣脱出来, 每个人的生活都与这种全球性的危难紧密相关;人与人之间, 国与国之间只有共同合作与互相帮助才能从危机中走过来, 人类能从进化中胜出, 依靠的也是这种团结与协作.最近, 浏览新闻, 时不时有人在兴高采烈的想着: 这次疫情, 美国估计抗不住了, 我们恐怕要赢了；有人也一直在宣扬, 新冠病毒乃美国的阴谋, 实际疫情在美国老早就发生了, 我们压根就不应该帮助美国.这些怪异的言论, 说的头头是道, 却是毫无道义与来由的说辞.不论新冠病毒来自何方, 但目前从发生的时间来看, 就是从武汉传染出去的, 这个毋庸置疑, 如今病毒扩散的其他国家, 我们作为负责任的大国, 理应尽力去帮助其他国家共同抵抗疫情的进一步恶化. 这首先是出于道义, 然则是出于经济发展与社会稳定的考虑.如果此时不去积极帮助美国在内的国家抗击病毒, 我们的国家形象只会变得更加矮小;而其他国家一日不稳定下来, 依靠出口的企业就难以维系, 社会经济压力就会越大.这样的时刻, 只有合作与协作才有利于彼此, 而不是只考虑到眼前的一己之利.</p><p>再具体到个人, 想要在这样的全球性危机中安稳的过渡, 首先还是要积蓄能量, 不论是学习, 提升个人能力还是锻炼身体都不能落下, 同时还要多做些资金的储备, 不要乱花钱. 这样等疫情缓过来后, 方能找到机会去改变与突破. </p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.khanacademy.org/science/biology/ecology/population-growth-and-regulation/a/exponential-logistic-growth" target="_blank" rel="noopener">https://www.khanacademy.org/science/biology/ecology/population-growth-and-regulation/a/exponential-logistic-growth</a></li><li><a href="https://voice.baidu.com/act/newpneumonia/newpneumonia" target="_blank" rel="noopener">https://voice.baidu.com/act/newpneumonia/newpneumonia</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;Live as everything is a miracle or nothing is miracle&lt;/p&gt;
&lt;p&gt;爱因斯坦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这次新型冠状病毒发展到现在估计已经超出了绝大多数人的预料, 现在国内的疫情基本稳定了, 但国外包括北美, 欧洲大部分国家都处于病毒爆发的高峰期, 截至4月3日全球已经有超过80多万的病毒感染者
    
    </summary>
    
      <category term="社会万象" scheme="http://sniffer.site/categories/%E7%A4%BE%E4%BC%9A%E4%B8%87%E8%B1%A1/"/>
    
    
      <category term="哲学" scheme="http://sniffer.site/tags/%E5%93%B2%E5%AD%A6/"/>
    
      <category term="社会" scheme="http://sniffer.site/tags/%E7%A4%BE%E4%BC%9A/"/>
    
      <category term="思考" scheme="http://sniffer.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Android是如何实现流量统计的?</title>
    <link href="http://sniffer.site/2020/04/01/%E8%AF%B4%E8%AF%B4Android%E4%B8%AD%E7%9A%84%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1/"/>
    <id>http://sniffer.site/2020/04/01/说说Android中的流量统计/</id>
    <published>2020-04-01T07:56:35.000Z</published>
    <updated>2020-06-15T08:17:32.258Z</updated>
    
    <content type="html"><![CDATA[<p>使用Android手机时, 我们不仅可以看到当前系统的流量使用情况, 还可以查看每个应用消耗了多少流量, 借此我们可以发现有那些流氓APP在偷偷在背后消耗流量.那么, Android是具体如何实现流量统计的? 又是如何对每个应用的流量使用进行监控? 这篇文章我们就来看看Android流量统计的具体实现原理.</p><p>大致说来, Android从如何几个方面进行流量统计:</p><ul><li>统计每个网口当前发送/接收的流量数据</li><li>监控每个应用(对应唯一的UID)所消耗的流量</li><li>支持对总的流量配额进行限制, 如达到一定的流量阈值后, 会对网络进行限制</li></ul><p>而具体到每个应用(比如system应用, UID=1000), Android还支持对应用内的每个socket进行标记(tag), 用于区分每个应用(UID)内部具体使用了那些流量.后面, 我们会讲到如何通过标签来区分UID内部的流量.</p><p>下图是Android流量统计的原理框图: 为了实现流量统计, Android在Linux内核增加了一个netfilter模块: <code>xt_qtaguid</code>(源码可以在<code>kernel/net/netfilter</code>中找到), 用于统计当前系统所有流量, 该模块初始化时, 会初始化一个<code>/proc/net/xt_qtaguid</code>目录供用户空间的进程使用;<code>NetworkStatsService</code>系统服务就是周期性的读取该目录的数据来获取当前系统消耗的实时流量的;而如果要对某个特定的<code>socket</code>打上标签, 则需要通过JNI接口调用,然后发请求给<code>netd</code>将该<code>socket</code>标签信息通过接口<code>/proc/net/xt_qtaguid/ctrl</code>写入内核.</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/Android%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="Android流量统计原理图"></p><p>接下来就一起看下Android具体是如何进行流量统计的.</p><h2 id="Android流量统计实现"><a href="#Android流量统计实现" class="headerlink" title="Android流量统计实现"></a><strong>Android流量统计实现</strong></h2><p>Android有一个系统服务<code>NetworkStatsService</code>来负责流量统计管理. 在系统启动的时候会创建该服务, 对其进行初始化: 创建一个<code>NetworkStatsService</code>, 并返回给<code>SystemServer</code>, 服务内有一个线程用于数据统计业务的处理.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NetworkStatsService <span class="title">create</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">            INetworkManagementService networkManager)</span> </span>&#123;</span><br><span class="line">    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</span><br><span class="line">    PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);</span><br><span class="line">    PowerManager.WakeLock wakeLock =</span><br><span class="line">            powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);</span><br><span class="line"></span><br><span class="line">    NetworkStatsService service = <span class="keyword">new</span> NetworkStatsService(context, networkManager, alarmManager,</span><br><span class="line">            wakeLock, getDefaultClock(), TelephonyManager.getDefault(),</span><br><span class="line">            <span class="keyword">new</span> DefaultNetworkStatsSettings(context), <span class="keyword">new</span> NetworkStatsObservers(),</span><br><span class="line">            getDefaultSystemDir(), getDefaultBaseDir());</span><br><span class="line"></span><br><span class="line">    HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(TAG);</span><br><span class="line">    Handler.Callback callback = <span class="keyword">new</span> HandlerCallback(service);</span><br><span class="line">    handlerThread.start();</span><br><span class="line">    Handler handler = <span class="keyword">new</span> Handler(handlerThread.getLooper(), callback);</span><br><span class="line">    service.setHandler(handler, callback);</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等到<code>SystemServer</code>完成对系统服务的初始化后, 会调用<code>NetworkStatsService.systemReady()</code>, 告诉服务可以正常启动了, 启动时<code>NetworkStatsService</code>需要做如下几件事情:</p><ul><li>创建四个流量统计的类型, 实际对应放在<code>/data/system/netstats</code>目录的四个类型的文件而已, 分别用于统计每个网口的消耗的流量(<code>PREFIX_DEV</code>), 视频通话以及热点分享所消耗的流量(<code>PREFIX_XT</code>), 每个用户所消耗的流量(<code>PREFXI_UID</code>)以及每个用户对应的每个标签所消耗的流量(<code>PREFIX_UID_TAG</code>)</li><li>更新每个流量统计数据写入的阈值: 即流量消耗达到某个阈值后, 需要将当前统计数据写入磁盘, 目前默认统一使用的是<code>2MB</code>；接着还要看下是否需要从早前版本中把老的流量统计数据迁移过来</li><li>注册并监听系统广播, 比如定时从系统拉取流量统计数据(<code>ACTION_NETWORK_STATS_POLL</code>), Android默认30分钟拉取一次; 系统用户增加与删除的广播;关机的广播等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mSystemReady = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mStatsLock) &#123;</span><br><span class="line">        <span class="comment">// create data recorders along with historical rotators</span></span><br><span class="line">        mDevRecorder = buildRecorder(PREFIX_DEV, mSettings.getDevConfig(), <span class="keyword">false</span>);</span><br><span class="line">        mXtRecorder = buildRecorder(PREFIX_XT, mSettings.getXtConfig(), <span class="keyword">false</span>);</span><br><span class="line">        mUidRecorder = buildRecorder(PREFIX_UID, mSettings.getUidConfig(), <span class="keyword">false</span>);</span><br><span class="line">        mUidTagRecorder = buildRecorder(PREFIX_UID_TAG, mSettings.getUidTagConfig(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        updatePersistThresholdsLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// upgrade any legacy stats, migrating them to rotated files</span></span><br><span class="line">        maybeUpgradeLegacyStatsLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read historical network stats from disk, since policy service</span></span><br><span class="line">        <span class="comment">// might need them right away.</span></span><br><span class="line">        mXtStatsCached = mXtRecorder.getOrLoadCompleteLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bootstrap initial stats to prevent double-counting later</span></span><br><span class="line">        bootstrapStatsLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// watch for tethering changes</span></span><br><span class="line">    <span class="keyword">final</span> IntentFilter tetherFilter = <span class="keyword">new</span> IntentFilter(ACTION_TETHER_STATE_CHANGED);</span><br><span class="line">    mContext.registerReceiver(mTetherReceiver, tetherFilter, <span class="keyword">null</span>, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen for periodic polling events</span></span><br><span class="line">    <span class="keyword">final</span> IntentFilter pollFilter = <span class="keyword">new</span> IntentFilter(ACTION_NETWORK_STATS_POLL);</span><br><span class="line">    mContext.registerReceiver(mPollReceiver, pollFilter, READ_NETWORK_USAGE_HISTORY, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen for uid removal to clean stats</span></span><br><span class="line">    <span class="keyword">final</span> IntentFilter removedFilter = <span class="keyword">new</span> IntentFilter(ACTION_UID_REMOVED);</span><br><span class="line">    mContext.registerReceiver(mRemovedReceiver, removedFilter, <span class="keyword">null</span>, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen for user changes to clean stats</span></span><br><span class="line">    <span class="keyword">final</span> IntentFilter userFilter = <span class="keyword">new</span> IntentFilter(ACTION_USER_REMOVED);</span><br><span class="line">    mContext.registerReceiver(mUserReceiver, userFilter, <span class="keyword">null</span>, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// persist stats during clean shutdown</span></span><br><span class="line">    <span class="keyword">final</span> IntentFilter shutdownFilter = <span class="keyword">new</span> IntentFilter(ACTION_SHUTDOWN);</span><br><span class="line">    mContext.registerReceiver(mShutdownReceiver, shutdownFilter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mNetworkManager.registerObserver(mAlertObserver);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// ignored; service lives in system_server</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    registerPollAlarmLocked();</span><br><span class="line">    registerGlobalAlert();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NetworkStatsService</code>启动后, 注册了一个定时广播<code>com.android.server.action.NETWORK_STATS_POLL</code>, 每隔一段时间就会定时拉取当前系统消耗的流量统计数据, 收到该广播后, 系统会尝试将统计数据写入到磁盘永久保存下来:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> BroadcastReceiver mPollReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// on background handler thread, and verified UPDATE_DEVICE_STATS</span></span><br><span class="line">        <span class="comment">// permission above.</span></span><br><span class="line">        performPoll(FLAG_PERSIST_ALL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// verify that we're watching global alert</span></span><br><span class="line">        registerGlobalAlert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拉取当前流量数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPoll</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mStatsLock) &#123;</span><br><span class="line">        mWakeLock.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            performPollLocked(flags);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mWakeLock.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法<code>performPollLocked</code>首先会获取当前的统计数据快照, 然后将其自动写入到磁盘<code>/data/system/netstats</code>目录:</p><ul><li><code>recordSnapShotLocked()</code>实际通过<code>NetworkManagementService</code>提供的接口从<code>/proc/net/xt_qtaguid</code>这个目录读取当前的历史统计数据并将其保存到<code>mDevRecorder</code>/<code>mXtRecorder</code>/<code>mUidRecorder</code>中</li><li>根据传入的标志位, 来确定各个<code>NetworkStatsRecorder</code>是否将数据写入磁盘: 可以强制写入(<code>forcePersistLocked</code>), 也可以等到消耗流量达到阈值(就是之前说的<code>2MB</code>)之后再写入(<code>maybePersistLocked</code>)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPollLocked</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSystemReady) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> persistNetwork = (flags &amp; FLAG_PERSIST_NETWORK) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> persistUid = (flags &amp; FLAG_PERSIST_UID) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> persistForce = (flags &amp; FLAG_PERSIST_FORCE) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> consider marking "untrusted" times in historical stats</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTime = mClock.millis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        recordSnapshotLocked(currentTime);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">"problem reading network stats"</span>, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// ignored; service lives in system_server</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// persist any pending data depending on requested flags</span></span><br><span class="line">    <span class="keyword">if</span> (persistForce) &#123;</span><br><span class="line">        mDevRecorder.forcePersistLocked(currentTime);</span><br><span class="line">        mXtRecorder.forcePersistLocked(currentTime);</span><br><span class="line">        mUidRecorder.forcePersistLocked(currentTime);</span><br><span class="line">        mUidTagRecorder.forcePersistLocked(currentTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (persistNetwork) &#123;</span><br><span class="line">            mDevRecorder.maybePersistLocked(currentTime);</span><br><span class="line">            mXtRecorder.maybePersistLocked(currentTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (persistUid) &#123;</span><br><span class="line">            mUidRecorder.maybePersistLocked(currentTime);</span><br><span class="line">            mUidTagRecorder.maybePersistLocked(currentTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后, 我们来看看流量统计的数据是如何写入磁盘, 又如何从磁盘读取的. Android将系统消耗的流量按照时间切割成一段段固定时间长度的统计值(<code>NetworkStatsHistory</code>), 并将其与<code>NetworkIdentitySet</code>(表示一个网口集合)组成一个统计的哈希列表(<code>NetworkStatsCollection</code>), 然后每次更新当前消耗的流量时, <code>NetworkStatsRecorder</code>都会不断的将数据写入到磁盘:</p><ul><li><code>NetworkStatsRecorder</code>中包含了两个流量统计数据: 当前未写入磁盘的数据(<code>pending</code>)以及开机以来的统计数据(<code>mSinceBoot</code>)</li><li><code>FileRotator</code>负责将<code>NetworkStatsRecorder</code>中的数据定时写入到磁盘, 并按照一定的老化时间来创建新的统计文件, 而且每个统计文件在达到一定的生命周期后, 会自动被删除</li></ul><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/%E6%B5%81%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%BB%E5%86%99.png" alt="流量统计数据的读写"></p><h2 id="利用标签来统计特定Socket流量"><a href="#利用标签来统计特定Socket流量" class="headerlink" title="利用标签来统计特定Socket流量"></a><strong>利用标签来统计特定Socket流量</strong></h2><p><code>TrafficStats</code>中提供了接口, 可以在特定的socket(也可以使用socket对应的文件描述符)上打上标签,从而实现对每个应用你内部的流量消耗进行细分.Android系统已经定义了部分的TAG值, 比如用户DHCP协议的数据(<code>TAG_SYSTEM_DHCP</code>), 用于获取NTP网络时间的流量(<code>TAG_SYSTEM_NTP</code>), 用于探测网络的流量(<code>TAG_SYSTEM_PROBE</code>).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrafficStats</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default tag value for &#123;<span class="doctag">@link</span> DownloadManager&#125; traffic.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_DOWNLOAD = <span class="number">0xFFFFFF01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default tag value for &#123;<span class="doctag">@link</span> MediaPlayer&#125; traffic.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_MEDIA = <span class="number">0xFFFFFF02</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default tag value for &#123;<span class="doctag">@link</span> BackupManager&#125; backup traffic; that is,</span></span><br><span class="line"><span class="comment">    * traffic from the device to the storage backend.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_BACKUP = <span class="number">0xFFFFFF03</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default tag value for &#123;<span class="doctag">@link</span> BackupManager&#125; restore traffic; that is,</span></span><br><span class="line"><span class="comment">    * app data retrieved from the storage backend at install time.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_RESTORE = <span class="number">0xFFFFFF04</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default tag value for code (typically APKs) downloaded by an app store on</span></span><br><span class="line"><span class="comment">    * behalf of the app, such as updates.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_APP = <span class="number">0xFFFFFF05</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_DHCP = <span class="number">0xFFFFFF40</span>;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_NTP = <span class="number">0xFFFFFF41</span>;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_PROBE = <span class="number">0xFFFFFF42</span>;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_NEIGHBOR = <span class="number">0xFFFFFF43</span>;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_GPS = <span class="number">0xFFFFFF44</span>;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_PAC = <span class="number">0xFFFFFF45</span>;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set active tag to use when accounting &#123;<span class="doctag">@link</span> Socket&#125; traffic originating</span></span><br><span class="line"><span class="comment">    * from the current thread. Only one active tag per thread is supported.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Changes only take effect during subsequent calls to</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #tagSocket(Socket)&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Tags between &#123;<span class="doctag">@code</span> 0xFFFFFF00&#125; and &#123;<span class="doctag">@code</span> 0xFFFFFFFF&#125; are reserved and</span></span><br><span class="line"><span class="comment">    * used internally by system services like &#123;<span class="doctag">@link</span> DownloadManager&#125; when</span></span><br><span class="line"><span class="comment">    * performing traffic on behalf of an application.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #clearThreadStatsTag()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setThreadStatsTag</span><span class="params">(<span class="keyword">int</span> tag)</span> </span>&#123;</span><br><span class="line">        NetworkManagementSocketTagger.setThreadSocketStatsTag(tag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set active tag to use when accounting &#123;<span class="doctag">@link</span> Socket&#125; traffic originating</span></span><br><span class="line"><span class="comment">    * from the current thread. Only one active tag per thread is supported.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Changes only take effect during subsequent calls to</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #tagSocket(Socket)&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Tags between &#123;<span class="doctag">@code</span> 0xFFFFFF00&#125; and &#123;<span class="doctag">@code</span> 0xFFFFFFFF&#125; are reserved and</span></span><br><span class="line"><span class="comment">    * used internally by system services like &#123;<span class="doctag">@link</span> DownloadManager&#125; when</span></span><br><span class="line"><span class="comment">    * performing traffic on behalf of an application.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the current tag for the calling thread, which can be used to</span></span><br><span class="line"><span class="comment">    *         restore any existing values after a nested operation is finished</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAndSetThreadStatsTag</span><span class="params">(<span class="keyword">int</span> tag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NetworkManagementSocketTagger.setThreadSocketStatsTag(tag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Tag the given &#123;<span class="doctag">@link</span> Socket&#125; with any statistics parameters active for</span></span><br><span class="line"><span class="comment">   * the current thread. Subsequent calls always replace any existing</span></span><br><span class="line"><span class="comment">   * parameters. When finished, call &#123;<span class="doctag">@link</span> #untagSocket(Socket)&#125; to remove</span></span><br><span class="line"><span class="comment">   * statistics parameters.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> #setThreadStatsTag(int)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tagSocket</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">      SocketTagger.get().tag(socket);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove any statistics parameters from the given &#123;<span class="doctag">@link</span> Socket&#125;.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * In Android 8.1 (API level 27) and lower, a socket is automatically</span></span><br><span class="line"><span class="comment">   * untagged when it's sent to another process using binder IPC with a</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> ParcelFileDescriptor&#125; container. In Android 9.0 (API level 28)</span></span><br><span class="line"><span class="comment">   * and higher, the socket tag is kept when the socket is sent to another</span></span><br><span class="line"><span class="comment">   * process using binder IPC. You can mimic the previous behavior by</span></span><br><span class="line"><span class="comment">   * calling &#123;<span class="doctag">@code</span> untagSocket()&#125; before sending the socket to another</span></span><br><span class="line"><span class="comment">   * process.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">untagSocket</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">      SocketTagger.get().untag(socket);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>要使用一个socket的标签其实很简单, 只要在创建通讯的socket的连接后, 主动调用<code>setThreadStatsTag</code>就可以了, 来看一个示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupSocket</span><span class="params">(<span class="keyword">int</span> sockType, <span class="keyword">int</span> prot, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> writeTimeout, <span class="keyword">long</span> readTimeout, <span class="keyword">int</span> destPort)</span> <span class="keyword">throws</span> ErrnoException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前socket打上PROBE标签</span></span><br><span class="line">    <span class="keyword">int</span> oldTag = TrafficStats.getAndSetThreadStatsTag(TrafficStats.TAG_SYSTEM_PROBE);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mFd = Os.socket(mAddrFamily, sockType, prot);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        TrafficStats.setThreadStatsTag(oldTag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Os.setsockoptTimeval(mFd, SOL_SOCKET, SO_SNDTIMEO, StructTimeval.fromMillis(writeTimeout));</span><br><span class="line">    Os.setsockoptTimeval(mFd, SOL_SOCKET, SO_RCVTIMEO, StructTimeval.fromMillis(readTimeout));</span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(mIface)) &#123;</span><br><span class="line">        Os.setsockoptIfreq(mFd, SOL_SOCKET, SO_BINDTODEVICE, mIface);</span><br><span class="line">    &#125;</span><br><span class="line">    Os.connect(mFd, mTarget, destPort);</span><br><span class="line"></span><br><span class="line">    mSockAddr = Os.getsockname(mFd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要获取某个UID对应的标签数据, 只要调用<code>NetworkStatsManager.java</code>的<code>queryDetailsForUid</code>接口, 传入对应的开始/结束时间就可以了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Query network usage statistics details for a given uid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * #see queryDetailsForUidTagState(int, String, long, long, int, int, int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkStats <span class="title">queryDetailsForUid</span><span class="params">(<span class="keyword">int</span> networkType, String subscriberId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> startTime, <span class="keyword">long</span> endTime, <span class="keyword">int</span> uid)</span> <span class="keyword">throws</span> SecurityException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queryDetailsForUidTagState(networkType, subscriberId, startTime, endTime, uid,</span><br><span class="line">        NetworkStats.Bucket.TAG_NONE, NetworkStats.Bucket.STATE_ALL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Query network usage statistics details for a given uid and tag.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * #see queryDetailsForUidTagState(int, String, long, long, int, int, int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkStats <span class="title">queryDetailsForUidTag</span><span class="params">(<span class="keyword">int</span> networkType, String subscriberId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> startTime, <span class="keyword">long</span> endTime, <span class="keyword">int</span> uid, <span class="keyword">int</span> tag)</span> <span class="keyword">throws</span> SecurityException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queryDetailsForUidTagState(networkType, subscriberId, startTime, endTime, uid,</span><br><span class="line">        tag, NetworkStats.Bucket.STATE_ALL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Android流量统计在9.0还是基于<code>xt_qtaguid</code>来实现的, 后面实际会通过<code>BPF</code>来做(参考文章<a href="http://sniffer.site/2019/11/07/BPF%E4%B8%8EeBPF/">BPF与eBPF</a>).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Android手机时, 我们不仅可以看到当前系统的流量使用情况, 还可以查看每个应用消耗了多少流量, 借此我们可以发现有那些流氓APP在偷偷在背后消耗流量.那么, Android是具体如何实现流量统计的? 又是如何对每个应用的流量使用进行监控? 这篇文章我们就来看看An
      
    
    </summary>
    
      <category term="Android" scheme="http://sniffer.site/categories/Android/"/>
    
    
      <category term="网络管理" scheme="http://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    
      <category term="流量统计" scheme="http://sniffer.site/tags/%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>利用SSH隧道访问局域网</title>
    <link href="http://sniffer.site/2020/02/24/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8SSH%E9%9A%A7%E9%81%93%E8%AE%BF%E9%97%AE%E5%B1%80%E5%9F%9F%E7%BD%91/"/>
    <id>http://sniffer.site/2020/02/24/如何利用SSH隧道访问局域网/</id>
    <published>2020-02-24T07:46:09.000Z</published>
    <updated>2020-03-24T03:41:34.364Z</updated>
    
    <content type="html"><![CDATA[<p>SSH(<a href="https://en.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">Secure SHell</a>)是一种基于加密算法的网络安全协议, 其在TCP/IP协议的基础上通过<a href="https://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="noopener">非对称公钥算法</a>对用户身份进行验证. SSH在网络中有广泛的应用, 比如平常在远程登录时就会用到SSH, Github的代码仓库提交也会基于SSH协议来验证提交者的合法性, 而对常年生活在局域网内的人来说, SSH更多的用途则是搭建穿越防火墙的VPN实现网络自由.</p><p>一台服务器如果有公共域名或者IP地址, 只需要事先将客户端的公钥放到服务器上就可以正常登录, 但如果服务器本身位于防火墙之外(比如某个端口被禁)或者位于NAT(<a href="https://en.wikipedia.org/wiki/Network_address_translation" target="_blank" rel="noopener">Network Address Translation</a>)网关之后, 这个方法就不起作用了. 用过VPN的同志应该比较清楚, 穿透防火墙或者某个局域网的NAT网关, 一般要用到SSH隧道技术(<a href="https://www.ssh.com/ssh/tunneling" target="_blank" rel="noopener">SSH tunneling</a>);SSH隧道技术也被称为端口转发(port forwarding).简单来说, 建立SSH隧道大致有两个流程:</p><ul><li>由位于局域网的设备A向服务器PC发起SSH连接, 建立一个安全加密的通信通道, 并基于该通道监听某个特定的端口</li><li>接着, 服务器基于已有的加密通道再建立一个SSH通信链路,基于这个通道服务器就可以登录到大屏, 执行交互指令</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ssh_login.png" alt="SSH login"></p><blockquote><p>SSH隧道技术的端口转发具体说有两种, 一种叫本地端口转发(local port forwarding), 就是在客户端做端口转发;一种叫远端端口转发(remote port forwarding), 就是在服务端做端口的数据转发, 这篇文章用到的技术是后一种.</p></blockquote><p>这里就来看看如何通过SSH隧道技术来实现对局域网内某个服务器的登录: 局域网内有一台设备A(服务端), 只有私有IP地址, 通过NAT网关访问外部网络, 设备B(客户端)是外部网络的一个PC, 现在要通过该PC(设备B)正常登录到设备A. </p><h2 id="实现SSH隧道功能"><a href="#实现SSH隧道功能" class="headerlink" title="实现SSH隧道功能"></a><strong>实现SSH隧道功能</strong></h2><p>在开启SSH隧道功能之前, 确保客户端/服务器都正常配置了ssh(SSH的客户端程序)/sshd(SSH守护进程):</p><ul><li>ssh: ssh登录的客户端, 负责发起ssh登录请求, 其配置一般放在<code>/etc/ssh/ssh_config</code></li><li><p>sshd: sshd是服务端的守护进程, 负责监听来自客户端的请求, 其配置放在<code>/etc/ssh/sshd_config</code></p><p>为了确保ssh可以正常进行端口转发, 需要打开<code>AllowTcpForwarding</code>:</p></li><li><p>设置<code>AllowTcpForwarding</code>为<code>yes</code>, 确保能够使用端口转发功能</p></li></ul><p>另外SSH密钥交换时要用到主机的密钥(host key), 可以通过<code>ssh-keygen</code>产生, 对于Ubuntu系统来说, 主机密钥一般放在<code>/etc/ssh</code>目录下. </p><p>为了避免每次ssh登录都要输入密码, 可以事先分别在客户端/服务器产生一个rsa密钥对, 并将公钥放到服务器/客户端的<code>/.ssh/authorized_keys</code>中保存下来, 并在执行ssh指令时指定对应的私钥文件, 这样身份验证就会在密钥验证阶段完成无需再输入用户密码了.</p><h3 id="启动sshd"><a href="#启动sshd" class="headerlink" title="启动sshd"></a><strong>启动sshd</strong></h3><p>配置完成后, 如果没有<code>sshd</code>进程, 需要在设备A(服务端)/设备B(用户端)都启动sshd:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sshd -ddd -h /etc/ssh/ssh_host_rsa_key -f /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>其中参数<code>-ddd</code>用于输出调试信息, <code>-h</code>指定host密钥文件, <code>-f</code>指定<code>sshd</code>的配置;启动完成后, 设备就可以正常收到来其他ssh客户端的请求了.</p><h3 id="启动ssh远程登录"><a href="#启动ssh远程登录" class="headerlink" title="启动ssh远程登录"></a><strong>启动ssh远程登录</strong></h3><p>在大屏输入如下指令, 尝试与设备A(客户端)建立SSH链接:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -vvv -TN -i &lt;identity_file&gt; -R 8989:localhost:22 user_name@remote_host</span><br></pre></td></tr></table></figure><p><code>-vvv</code>参数用于输出debug信息, <code></code>-TN<code>告诉ssh在登录后不要开启终端执行指令而是监听某个指定的端口, -i</code>制定身份验证的密钥文件目录, 参数<code>-R</code>指定了远端转发端口的规则: 将来自远端<code>8989</code>的数据都转发到本地的<code>22</code>端口; 执行该命令后, 身份验证通过, 可能会输入服务器密码, 然后我们就可以看到ssh会一直在监听<code>8989</code>这个端口, 接着在设备A(服务器)输入指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -vvv -i &lt;identity_file&gt;  -p 8989 root@localhost</span><br></pre></td></tr></table></figure><p>身份认证完成后, 就可以看到一个输入shell指令的命令窗口, 就算登录完成了.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://www.ssh.com/ssh/tunneling" target="_blank" rel="noopener">https://www.ssh.com/ssh/tunneling</a></li><li><a href="https://www.booleanworld.com/guide-ssh-port-forwarding-tunnelling/" target="_blank" rel="noopener">https://www.booleanworld.com/guide-ssh-port-forwarding-tunnelling/</a></li><li><a href="http://arondight.me/2016/02/17/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" target="_blank" rel="noopener">http://arondight.me/2016/02/17/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</a></li><li><a href="https://en.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Secure_Shell</a></li><li><a href="https://tools.ietf.org/html/rfc4251" target="_blank" rel="noopener">The Secure Shell (SSH) Protocol Architecture</a></li><li><code>man ssh/sshd/sshd_config</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SSH(&lt;a href=&quot;https://en.wikipedia.org/wiki/Secure_Shell&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Secure SHell&lt;/a&gt;)是一种基于加密算法的网络安全协议, 其在TCP/IP协议的基础上
      
    
    </summary>
    
      <category term="网络协议" scheme="http://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="SSH" scheme="http://sniffer.site/tags/SSH/"/>
    
      <category term="远程登录" scheme="http://sniffer.site/tags/%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"/>
    
      <category term="反向隧道" scheme="http://sniffer.site/tags/%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>Recovery模式如何支持ADB</title>
    <link href="http://sniffer.site/2019/12/31/Recovery%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81ADB/"/>
    <id>http://sniffer.site/2019/12/31/Recovery模式如何支持ADB/</id>
    <published>2019-12-31T08:15:41.000Z</published>
    <updated>2020-01-08T05:41:13.588Z</updated>
    
    <content type="html"><![CDATA[<p>这两天顺着recovery模式下一个网络需求, 为了便于调试又在recovery下做了ADB功能. 在Android早期的如4.4版本, recovery模式下支持ADB配置起来比较简单(支持<code>adb devices</code>/<code>adb reboot</code>/<code>adb pull/push</code>等常用指令), 但在Android 9.0下USB辅助设备一般都通过<code>configfs</code>的方式来配置了, 因此相对来说要适配的东西就多一些, 如果额外要适配<code>adb shell</code>命令, 则要修改<code>adbd</code>的源代码了.这篇文章就来看看如何在Recovery模式下解决这几个问题.</p><p>在进入正题之前, 先了解下USB相关的基础知识.</p><p>USB全称是<a href="https://en.wikipedia.org/wiki/USB" target="_blank" rel="noopener"><code>Universal Serial Bus</code></a>, 是一种广泛用于主机与外设之间的连接的串行总线.USB设备使用的是一种层级的结构, 最多可支持多达127个设备, 每个USB设备对应一个功能(<code>function</code>), 比如USB打印机提供了打印服务; 存储设备则提供了存储数据的功能.</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/usb_system_architecture.png" alt="USB system architecture"></p><p>Android中的USB支持<a href="https://en.wikipedia.org/wiki/USB_On-The-Go" target="_blank" rel="noopener">OTG(On The Go)</a>, 因此有两种模式, 一种是Android自身作为host,可以接入其他USB设备;一种是Android作为peripheral设备, Android可以连接到PC端, 比如要查看Android设备的存储内容时, 使用ADB时都必须将Android设置为<code>peripheral</code>模式.ADB是Android中用于开发调试的一个工具, 更详细的说明可以参考官网的说明<a href="https://developer.android.com/studio/command-line/adb" target="_blank" rel="noopener">Android Debuge Bridge</a>.</p><h2 id="Recovery下的ADB"><a href="#Recovery下的ADB" class="headerlink" title="Recovery下的ADB"></a>Recovery下的ADB</h2><p>适配的第一步是首先看看源码. 进入Recovery的代码<code>/bootable/recovery</code>下面有一个<code>README.md</code>的文档, 里边有大致说明了如何在recovery下使用ADB. 对<code>USESRDEBUG/ENG</code>版本, 默认是启动了<code>adbd</code>, 并且对于<code>recovery</code>模式通过<code>adb devices</code>看到的是一个如下设备:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">1234567890abcdef    recovery</span><br></pre></td></tr></table></figure><p>还需要明确的一点是, 在recovery模式下, 只有部分adb指令可用, 比如<code>adb root</code>/<code>adb push/pull</code>, 如果要使用<code>adb shell</code>需要把<code>/system</code>分区挂载上来.看起来一切都比较简单了, 可通过<code>adb reboot recovery</code>之后却无法找到设备, 在PC端查看<code>dmesg</code>也没有任何USB设备枚举上来. </p><p>继续看文档, 上面说到, 如果设备使用了<code>configfs</code>这个配置文件系统的话, 需要设置相关的配置.那问题可能就出在这里: 使用了<code>configfs</code>来配置USB设备, 但是在recovery模式没有正常配置.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">If device is using [configfs](https://www.kernel.org/doc/Documentation/usb/gadget_configfs.txt),</span><br><span class="line">check if configfs has been properly set up in init rc scripts. See the [example</span><br><span class="line">configuration](https://android.googlesource.com/device/google/wahoo/+/master/init.recovery.hardware.rc)</span><br><span class="line">for Pixel 2 devices. Note that the flag set via sysfs (i.e. the one above) is no-op when using</span><br><span class="line">configfs.</span><br></pre></td></tr></table></figure><p>简单来说, 在Linux中, <code>USB Gadget</code>是一个具有UDC(<code>USB Device Controller</code>)的可以连接到一个USB Host的设备, 其通常具有串口通讯/数据存储的功能.而对于Host来说, 一个<code>USB Gadget</code>就是一个配置的集合而已, 每个配置包含很多接口, 也被称为功能(functions). 目前Linux已经包含了很多功能供<code>USB Gadgets</code>使用, 具体可以参看Linux的源码<code>/kernel/drivers/usb/gadget</code>. </p><p>那么具体来说ADB适配要经历哪几个步骤了? 接下来就来看一看recovery下适配ADB需要做的事情.</p><h2 id="Recovery下的ADB适配"><a href="#Recovery下的ADB适配" class="headerlink" title="Recovery下的ADB适配"></a>Recovery下的ADB适配</h2><ul><li><strong>挂载FunctionFs将USB用于ADB通信</strong></li></ul><p>在recovery代码目录<code>/bootable/recovery/etc/init.rc</code>中对ADB对应的<code>FunctionFs</code>做了配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">on fs</span><br><span class="line">    write /sys/class/android_usb/android0/f_ffs/aliases adb</span><br><span class="line">    mkdir /dev/usb-ffs 0770 shell shell</span><br><span class="line">    mkdir /dev/usb-ffs/adb 0770 shell shell</span><br><span class="line">    mount functionfs adb /dev/usb-ffs/adb uid=2000,gid=2000</span><br></pre></td></tr></table></figure><p>这个有什么用了?看ADB的源码(<code>/system/core/daemon</code>), 大致可以看到, 只有挂载了<code>functionfs</code>, ADB才能基于USB的<code>ep0</code>端口进行通讯:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// /dev/usb-ffs/adb/ep0 (main.cpp)</span></span><br><span class="line"><span class="keyword">if</span> (access(USB_FFS_ADB_EP0, F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Listen on USB.</span></span><br><span class="line">    usb_init();</span><br><span class="line">    is_usb = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usb.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usb_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dummy_fd = adb_open(<span class="string">"/dev/null"</span>, O_WRONLY);</span><br><span class="line">  CHECK_NE(dummy_fd, <span class="number">-1</span>);</span><br><span class="line">  usb_ffs_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usb.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usb_ffs_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D(<span class="string">"[ usb_init - using FunctionFS ]"</span>);</span><br><span class="line"></span><br><span class="line">    usb_handle* h = <span class="keyword">new</span> usb_handle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (android::base::GetBoolProperty(<span class="string">"sys.usb.ffs.aio_compat"</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// Devices on older kernels (&lt; 3.18) will not have aio support for ffs</span></span><br><span class="line">        <span class="comment">// unless backported. Fall back on the non-aio functions instead.</span></span><br><span class="line">        h-&gt;write = usb_ffs_write;</span><br><span class="line">        h-&gt;read = usb_ffs_read;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        h-&gt;write = usb_ffs_aio_write;</span><br><span class="line">        h-&gt;read = usb_ffs_aio_read;</span><br><span class="line">        aio_block_init(&amp;h-&gt;read_aiob);</span><br><span class="line">        aio_block_init(&amp;h-&gt;write_aiob);</span><br><span class="line">    &#125;</span><br><span class="line">    h-&gt;kick = usb_ffs_kick;</span><br><span class="line">    h-&gt;close = usb_ffs_close;</span><br><span class="line"></span><br><span class="line">    D(<span class="string">"[ usb_init - starting thread ]"</span>);</span><br><span class="line">    <span class="built_in">std</span>::thread(usb_ffs_open_thread, h).detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要了解USB<code>FunctionFs</code>的同学可以参考Linux的文档<code>https://www.kernel.org/doc/Documentation/usb/functionfs.txt</code>.</p><ul><li><strong>创建ADB相关的功能配置</strong></li></ul><p>挂载<code>configfs</code>到某个目录, 并生成ADB相关的配置, 主要是USB的ProductID/VendorID以及设备序列号等信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">on init</span><br><span class="line">    mount configfs none /config</span><br><span class="line">    mkdir /config/usb_gadget/g1 0770 shell shell</span><br><span class="line">    write /config/usb_gadget/g1/idVendor &lt;youre_usb_vendor_id&gt;</span><br><span class="line">    write /config/usb_gadget/g1/idProduct &lt;youre_usb_product_id&gt;</span><br><span class="line">    mkdir /config/usb_gadget/g1/strings/0x409 0770</span><br><span class="line">    write /config/usb_gadget/g1/strings/0x409/serialnumber $&#123;ro.serialno&#125;</span><br><span class="line">    write /config/usb_gadget/g1/strings/0x409/manufacturer $&#123;ro.product.manufacturer&#125;</span><br><span class="line">    write /config/usb_gadget/g1/strings/0x409/product $&#123;ro.product.model&#125;</span><br><span class="line">    mkdir /config/usb_gadget/g1/functions/ffs.adb</span><br><span class="line">    write /config/usb_gadget/g1/os_desc/use 1</span><br><span class="line">    setprop sys.usb.configfs 1</span><br></pre></td></tr></table></figure><p>配置完成后, <code>/config/usb_gadget/g1</code>目录下大致如下:</p><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/usb_gadgets_configfs.png" alt="usb gadget configfs"></p><ul><li><strong>使能对应的USB Gadgets</strong></li></ul><p>在Android设备文件目录<code>/sys/class/udc</code>找到对应USB设备控制器的名称, 将其写入到对应的配置, 从而使得USB主机端可以正常枚举到该USB设备:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">on property:sys.usb.ffs.ready=1</span><br><span class="line">    mkdir /config/usb_gadget/g1/configs/b.1 0777 shell shell</span><br><span class="line">    symlink /config/usb_gadget/g1/configs/b.1 /config/usb_gadget/g1/os_desc/b.1</span><br><span class="line">    mkdir /config/usb_gadget/g1/configs/b.1/strings/0x409 0770 shell shell</span><br><span class="line">    write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration &quot;adb&quot;</span><br><span class="line">    symlink /config/usb_gadget/g1/functions/ffs.adb /config/usb_gadget/g1/configs/b.1/f1</span><br><span class="line">    write /config/usb_gadget/g1/UDC &quot;a800000.dwc3&quot;  # 这里写入对应的UDC名字</span><br></pre></td></tr></table></figure><p>配置完成后, 重新打包下BOOT分区, 刷写后, 输入<code>adb devices</code>可以看到:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List of devices attached </span><br><span class="line">1297270arecovery</span><br></pre></td></tr></table></figure><p>说明修改起作用了, 但目前输入<code>adb shell</code>还是会提示<code>/system/bin/sh</code>目前找不到的错误, 原因是recovery并没有正常挂载<code>system</code>分区, 那么有没有可能不挂载<code>system</code>分区同时又能使用<code>adb shell</code>了? 看<code>/bootable/recovery/etc/init.rc</code>, recovery下实际有集成了一个命令工具集合<code>busybox</code>, 通过<code>busybox</code>我们应该也可以实现类似与正常模式下<code>/system/bin/sh</code>的功能, 这就需要修改Android中ADBD的源码了, 具体可以看下<code>/system/core/adb/shell_serivce.cpp</code>中的代码逻辑.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://www.linux-usb.org/" target="_blank" rel="noopener">Linux USB相关的资料文档</a></li><li><a href="https://www.beyondlogic.org/usbnutshell/usb3.shtml#USBFunctions" target="_blank" rel="noopener">USB Nutshell</a></li><li><a href="https://www.kernel.org/doc/Documentation/usb/gadget_configfs.txt" target="_blank" rel="noopener">USB Gadget Configfs</a></li><li><a href="https://www.kernel.org/doc/Documentation/usb/functionfs.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/usb/functionfs.txt</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天顺着recovery模式下一个网络需求, 为了便于调试又在recovery下做了ADB功能. 在Android早期的如4.4版本, recovery模式下支持ADB配置起来比较简单(支持&lt;code&gt;adb devices&lt;/code&gt;/&lt;code&gt;adb reboot
      
    
    </summary>
    
      <category term="Android" scheme="http://sniffer.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://sniffer.site/tags/Android/"/>
    
      <category term="ADB" scheme="http://sniffer.site/tags/ADB/"/>
    
      <category term="Recovery" scheme="http://sniffer.site/tags/Recovery/"/>
    
  </entry>
  
  <entry>
    <title>SELinux在Android中的应用</title>
    <link href="http://sniffer.site/2019/12/07/Selinux%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://sniffer.site/2019/12/07/Selinux在Android中的应用/</id>
    <published>2019-12-07T10:00:37.000Z</published>
    <updated>2019-12-07T10:03:00.481Z</updated>
    
    <content type="html"><![CDATA[<p>SELinux(<a href="https://en.wikipedia.org/wiki/Security-Enhanced_Linux" target="_blank" rel="noopener">Security Enhanced Linux</a>)是Linux下的安全控制机制, 为进程访问系统资源提供了访问控制(access control)策略. 早期, Linux基于用户身份/用户组的DAC(<a href="https://en.wikipedia.org/wiki/Discretionary_access_control" target="_blank" rel="noopener">Discretionary Access Control</a>作为访问控制策略: 每个进程都有所属的UID, 每个文件都有所属的UID/GID以及文件模式(读写执行等), 一个进程是否可以访问某个文件就是基于UID/GID/文件模式来管理的.换句话说,只要某个资源序属于该用于或该用户组, 则该用户对该资源具有绝对控制权力, 这样一旦用户获得了root权限, 那么整个系统就成了肉鸡. 可见, DAC的安全控制策略比较粗放.</p><p>SELinux最初是由美国Utah大学与NSA(National Security Agency)的安全小组研究出来的<a href="http://freecomputerbooks.com/books/The_SELinux_Notebook-4th_Edition.pdf" target="_blank" rel="noopener">安全框架FLASK</a>演变而来, 后被合入到Linux 2.6版本.相较于DAC, SELinux采用的是更细粒度的MAC(<a href="https://en.wikipedia.org/wiki/Mandatory_access_control" target="_blank" rel="noopener">Mandatory Access Control</a>).对于DAC而言, 资源的权限是由每个用户自己控制的, 而MAC则将所有的权限收拢, 由一个统一的管理者(SELinux)统一来分配所有的资源权限, 如果访问者没有事先分配到某个资源的权限, 则不会允许访问.这样即使是root用户也要收到安全策略的约束. Android在4.3开始引入SELinux, 到了5.0版本之后, 则开始全面支持了.</p><p>在SELinux机制下, Android中所有的对象(进程/文件/socket/property)都打上了标签(label), 进程访问对象时, SELinux根据事先配置好的安全策略(security policy)判断访问者是否有权限. </p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/selinux_policy_concepts.png" alt="selinux policy concepts"></p><p>另外, Android系统是同时支持DAC与SELinux的, 就是说, 在一个进程访问某个资源时,会按照如下规则进行权限控制:</p><ul><li>首先根据DAC规则, 检查进程权限, 是否具有对应资源的读写/执行权限, 如果没有则拒绝执行;</li><li>如果DAC规则检查通过, 则执行SELinux安全规则的检查, 如果不通过,则拒绝访问.</li></ul><h2 id="初识SELinux"><a href="#初识SELinux" class="headerlink" title="初识SELinux"></a><strong>初识SELinux</strong></h2><p>SELinux的首要原则是: 任何未被声明允许执行的都会被拒绝, 其有两种运行模式:</p><ul><li><code>Permissive</code>模式: 访问控制的策略不会强制执行, 但是会被日志记录下来</li><li><code>Enforcing</code>模式: 访问控制策略会被强制执行并被记录下来</li></ul><p>在Android下可以通过 <code>adb getenforce</code>来查看当前SELinux处于何种模式, 也可以通过<code>adb setenforce</code>来设置SELinux的模式(USER版本默认是<code>enforcing</code>, USERDEBUG/ENG可以设置模式):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">adb setenforce 0 // permissive模式</span><br><span class="line">adb setenforce 1 // enforcing模式</span><br></pre></td></tr></table></figure><p>在SELinux中, 主要有Subject/Object/Object Manager/Security Server等几个核心的组成部分(见下图):</p><ul><li><code>Subject</code>: 在SELinux中, <code>Subject</code>是一个进程, 每个<code>Subject</code>都有与之关联的一个安全上下文(<code>security context</code>); <code>Subject</code>负责发起访问某个对象的请求,比如读文件/建立socket链接</li><li><code>Object</code>: 一个对象就是一个资源, 比如文件, socket, pipes以及网络接口；每个对象都由一个类型标识其用途(file, socket), 并且与一个权限(permissions)集合关联, 该权限集合描述了对象能提供什么样的服务(比如read/write/send等)</li><li><code>Object Manager</code>: 对象管理者负责管理所有对象以及这些对象上能够执行的动作</li><li><code>Access Vecctor Cache</code>: 用于缓存Security Server的访问决策,以改善系统性能</li><li><code>Security Server</code>: 安全服务器根据安全策略来决定某个对象上的动作是否被执行</li><li><code>Security Policy</code>: 用于描述SELinux的访问规则</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/selinux_core_components.png" alt="SELinux components"></p><p>接下来我们看看SELinux具体是如何给每个对象打标签以及实现安全策略规则的.</p><h3 id="标签-label-与策略规则"><a href="#标签-label-与策略规则" class="headerlink" title="标签(label)与策略规则"></a><strong>标签(label)与策略规则</strong></h3><p>SELinux是通过标签(label)来匹配执行动作以及策略的.标签决定了何种动作是允许被执行的, socket/文件/进程都有自己的标签. SELinux的访问控制就是根据各个对象上的的标签来决定的, 而策略文件则定义了这些对象是如何相互交互的.</p><p>一个标签通常有如下的形式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">user:role:type:mls_level</span><br></pre></td></tr></table></figure><p>这样一个标签也通常被成为<code>Security Context</code>. 在Android中, 通常不用关心<code>user</code>/<code>role</code>/<code>msl_level</code>, <code>user</code>一般只有<code>u</code>, <code>role</code>对于进程来说是<code>r</code>, 对其他对象是<code>object_r</code>, <code>msl_level</code>是<code>s0</code>, 而<code>type</code>则用来标识对象的类型, 其决定了该对象的所具备的能力, 因此Android中的SELinux又称为基于TE(<code>Type Enforcement</code>)的安全机制, 在Android中, 所有的SELinux策略文件都以<code>te</code>结尾.</p><p>通过<code>ls/ps</code>指令中加入<code>-Z</code>参数, 可以查看文件/进程的SELinux状态, 如输入<code>ls -aZ /init*</code>查看<code>init</code>文件夹的标签:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ls_z_file_context.png" alt="ls -z示例"></p><p>上图中的<code>init</code>可执行程序以及文件夹都是在<code>/system/sepolicy/private/file_contexts</code>中定义的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Data files</span><br><span class="line">/adb_keys           u:object_r:adb_keys_file:s0</span><br><span class="line">/build\.prop        u:object_r:rootfs:s0</span><br><span class="line">/default\.prop      u:object_r:rootfs:s0</span><br><span class="line">/fstab\..*          u:object_r:rootfs:s0</span><br><span class="line">/init\..*           u:object_r:rootfs:s0</span><br><span class="line">/res(/.*)?          u:object_r:rootfs:s0</span><br><span class="line">/selinux_version    u:object_r:rootfs:s0</span><br><span class="line">/ueventd\..*        u:object_r:rootfs:s0</span><br><span class="line">/verity_key         u:object_r:rootfs:s0</span><br><span class="line"></span><br><span class="line"># Executables</span><br><span class="line">/charger            u:object_r:rootfs:s0</span><br><span class="line">/init               u:object_r:init_exec:s0</span><br><span class="line">/sbin(/.*)?         u:object_r:rootfs:s0</span><br></pre></td></tr></table></figure><p>同样输入<code>ps -Z</code>可以查看进程的标签:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ps_z_security_context.png" alt="ps -Z"></p><p>策略规则(policy rules)决定了进程是如何访问对象的, 其通常是如下格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">allow domains types:classes permissions</span><br></pre></td></tr></table></figure><p>这里, </p><ul><li><code>Domain</code>: 域是一个进程或一组进程的标签,也被成为域类型</li><li><code>Type</code>: 对象的标签(如file/socket等)或者一个对象集合</li><li><code>Class</code>: 访问对象的类型</li><li><code>Permission</code>: 请求的权限(read/write)</li></ul><p>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">allow appdomain app_data_file:file rw_file_perms;</span><br></pre></td></tr></table></figure><p>这个规则的意思是允许所有应用域的进程访问标签为<code>app_data_file</code>的文件. 所有这些规则需要依赖于<code>global_macros</code>/<code>te_macros</code>的宏定义(位于<code>/system/sepolicy</code>目录下). 除了像上面的规则指定某个特定的域或类型, 也可以通过指定一个属性(<code>attribute</code>)来表示一组域或类型;当通过一个规则有属性时, 会被自动扩展成为了相应的域或类型. 按照上述方式写成的规则如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RULE_VARIANT SOURCE_TYPES TARGET_TYPES: CLASSES PERMISSIONS</span><br></pre></td></tr></table></figure><p>在这个规则下, 只要一个<code>Subject</code>标识了<code>SOURCE_TYPES</code>就可以有权在类型为<code>CLASSES</code>/标签为<code>TAEGET_TYPES</code>的对象上执行任何在<code>PERMISSONS</code>中声明的操作.例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">allow domain null_device:chr_file &#123; getattr open read ioctl write&#125;;</span><br></pre></td></tr></table></figure><p>这个条规则意思是允许任何有<code>domain</code>域的进程访问<code>null_device</code>类型(对应<code>/dev/null</code>)的字符设备.最后我们来看下Android是如何应用SELinux的.</p><h2 id="SELiunx在Android中的应用"><a href="#SELiunx在Android中的应用" class="headerlink" title="SELiunx在Android中的应用"></a><strong>SELiunx在Android中的应用</strong></h2><p>Android的SELinux配置(以下均以Android P 9.0的代码为例)在Android源码中有两个目录: </p><ul><li><code>/system/sepolicy</code></li><li><code>/device/&lt;manufactory&gt;/&lt;device-name&gt;/sepolicy</code></li></ul><p>而<code>/system/sepolicy</code>主要是Android原生已有的SELinux文件, 包括所有SELinux标签以及策略文件<code>.te</code>的定义, 一般不做修改;<code>/device</code>目录下的SELinux配置通过编译宏<code>BOARD_SEPOLICY_DIRS</code>引入, 所有SELinux相关的编译都要依靠<code>/system/sepolicy/Android.mk</code>这个makefile. 具体来说, SELinux的配置大致有如下几个部分:</p><table><thead><tr><th>配置目录</th><th>说明</th></tr></thead><tbody><tr><td>/system/sepolicy/public</td><td>包含了系统sepolicy相关的API</td></tr><tr><td>/system/sepolicy/private</td><td>包含了系统sepolicy的具体实现(与vendor无关)</td></tr><tr><td>/system/sepolicy/vendor</td><td>提供给厂商(vendor)自由实现的配置</td></tr><tr><td>BOARD_SEPOLICY_DIRS</td><td>包含厂商sepolicy的定制化配置</td></tr></tbody></table><p>所有以<code>.te</code>结尾的都是安全策略文件, 其定义了对象的域(domain)和类型(types); 而SELinux标签文件(也称为SELinux context文件), 大致有<a href="https://source.android.com/security/selinux/implement.html#key_files" target="_blank" rel="noopener">如下几种</a>:</p><ul><li><code>file_contexts</code>: 为用户空间的文件分配标签</li><li><code>genfs_contexts</code>: 为不支持扩展属性的文件分配标签(如<code>proc</code>/<code>vfat</code>)</li><li><code>property_contexts</code>: 为Android所有属性分配标签,<code>init</code>进程在初始化时会读取该配置 </li><li><code>service_contexts</code>: 为Android所有binder服务分配标签, 用于控制哪些进程可以注册/查找这些服务</li><li><code>seapp_contexts</code>: 为<code>/data/data</code>目录下的应用分配标签, 应用启动时<code>zygote</code>进程以及在应用安装时<code>installd</code>都会读取该配置</li><li><code>mac_permissions.xml</code>: 根据应用的签名(也可能包括包名)分配<code>seinfo tag</code>;<code>seinfo tag</code>在<code>seapp_contexts</code>文件中可以当作一个密钥用于分配特定的标签给所有的应用. 该配置在<code>system_sever</code>启动时会被读取</li></ul><p>那么, 这些SELinux的标签配置以及策略文件是如何编译的? 大致有两个编译路径,所有的<code>file_contexts</code>标签文件都会编译生成一个<code>file_contexts.bin</code>;而其他的如<code>security_classes</code>/<code>*.te</code>/<code>genfs_contexts</code>/<code>port_contexts</code>等文件都会编译生成一个<code>sepolicy</code>的二进制文件, 整体的编译逻辑如下图所示:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/selinux_android_build.png" alt="SELinux build logic"></p><p>有关SELinux在Android的编译可以参考<a href="https://source.android.com/security/selinux/build" target="_blank" rel="noopener">https://source.android.com/security/selinux/build</a>. </p><p>有了SELinux的基础知识, 要如何修改或者添加SELinux规则? 一般, 通过<code>dmesg | grep avc</code>或则<code>logcat | grep avc</code>查看系统当前的SELinux访问的记录, 如果出现<code>avc: denied</code>等字样, 说明有进程违反了安全策略, 举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[   42.357295] selinux: avc:  denied  &#123; set &#125; for property=net.usb0.dns1 pid=473 uid=0 gid=0 scontext=u:r:network_manager:s0 tcontext=u:object_r:system_prop:s0 tclass=proper1</span><br></pre></td></tr></table></figure><p>这个访问拒绝的提示说明, 进程<code>473</code>(network_manager)的标签<code>u:r:network_manager:s0</code>不具备访问标签为<code>u:object_r:system_prop:s0</code>, 类型为<code>system_prop</code>的属性值, 需要添加安全规则:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">set_prop(network_manager, system_prop)</span><br></pre></td></tr></table></figure><p>再次编译验证后就不会出现访问拒绝的日志了.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://source.android.com/security/selinux/images/SELinux_Treble.pdf" target="_blank" rel="noopener">SELinux for Android</a></li><li><a href="https://source.android.com/security/selinux/build" target="_blank" rel="noopener">SEAndroid的介绍</a></li><li><a href="http://freecomputerbooks.com/books/The_SELinux_Notebook-4th_Edition.pdf" target="_blank" rel="noopener">SELinux NoteBook</a></li><li><a href="http://www.cs.columbia.edu/~lierranli/coms6998-7Spring2014/papers/SEAndroid-NDSS2013.pdf" target="_blank" rel="noopener">SELinux在Android应用的挑战与问题</a></li><li><a href="https://wiki.gentoo.org/wiki/SELinux/Quick_introduction#SELinux_policy" target="_blank" rel="noopener">Introduction to SELinux</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SELinux(&lt;a href=&quot;https://en.wikipedia.org/wiki/Security-Enhanced_Linux&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Security Enhanced Linux&lt;/a&gt;)是Linux
      
    
    </summary>
    
      <category term="Android" scheme="http://sniffer.site/categories/Android/"/>
    
      <category term="Security" scheme="http://sniffer.site/categories/Android/Security/"/>
    
    
      <category term="Android" scheme="http://sniffer.site/tags/Android/"/>
    
      <category term="SELinux" scheme="http://sniffer.site/tags/SELinux/"/>
    
      <category term="Security" scheme="http://sniffer.site/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>BPF与eBPF</title>
    <link href="http://sniffer.site/2019/11/07/BPF%E4%B8%8EeBPF/"/>
    <id>http://sniffer.site/2019/11/07/BPF与eBPF/</id>
    <published>2019-11-07T11:35:03.000Z</published>
    <updated>2021-01-25T10:02:35.764Z</updated>
    
    <content type="html"><![CDATA[<p>最近了解Linux的性能优化时, 偶然接触到了BPF(<a href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter" target="_blank" rel="noopener">Berkeley Packet Filter</a>)。很有意思也很强大的功能;想把学到的一些基本原理与知识记录下来, 算是一个初步的总结. 这篇文章主要从如下几个方面介绍下BPF <a id="more"></a>:</p><ul><li>BPF的原理</li><li>什么是eBPF</li><li>如何在Linux中使用BPF</li></ul><p>用过<code>tcpdump</code>的同学应该都了解<code>pcap</code>, 实际上<code>pcap</code>就是基于BPF来实现网络数据包的过滤的. <code>tcpdump</code>的原理如下图所示: <code>tcpdump</code>将包过滤的表达式, 如查看某个网口所有udp包, 输入<code>tcpdump -n -i eth0 udp</code>, 这个表达式通过PCAP库编译成伪机器字节码后, 通过系统调用发送给内核(内核中有对应的机器码解释器)解释执行, 这样只要系统有udp包, 内核都会过滤出来转发给用户进程<code>tcpdump</code>:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcpdump%E5%8E%9F%E7%90%86.png" alt="how tcpdump works"></p><p>BPF全称Berkeley Packet Filters, 最初是Steven MaCanne, Van Jacobson在文章<a href="http://www.tcpdump.org/papers/bpf-usenix93.pdf" target="_blank" rel="noopener">‘The BSD Packet Filter: A New Architecture for User-level Packet Capture’</a>中提出的一种基于BSD Unix操作系统的包过滤器, 其原理是将包过滤的表达式编译成特定伪机器码后, 由Kernel中的虚拟机执行; 每当网卡中有数据包过来时, 将其拷贝发送给BPF模块, 由BPF根据对应的过滤条件将过滤后的包发送给用户进程:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/how_bpf_works.png" alt="how BPF works"></p><blockquote><p>针对tcpdump, linux有专门用于包过滤的表达式, 参考<code>pcap-filter</code></p></blockquote><p>BPF在Linux中的发展大致经历三个阶段: </p><ul><li>Linux 2.1.75最初的实现基于原有的socket接口, 被称为<a href="https://www.kernel.org/doc/Documentation/networking/filter.txt" target="_blank" rel="noopener"><code>Linux Socket Filter</code></a>(LSF)</li><li>Linux 3.0版本中,在BPF中加入JIT(<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="noopener"><code>Just-In-Time Compiler</code></a>), 提升BPF的性能与速度 </li><li>Linux 3.15开始将BPF扩展成为通用的模块, BPF不仅可用于数据包过滤, 也可以用来进行内核事件跟踪/应用性能调优/流量控制(Traffic Control)等, 代码也统一整合到了<code>/kernel/bpf</code>, 这也是目前被称为eBPF(extended BPF)的原因, 而早前的BPF实现则被称为cBPF(classic BPF).</li></ul><p>首先来看下传统的cBPF是如何实现的.</p><h2 id="cBPF"><a href="#cBPF" class="headerlink" title="cBPF"></a><strong>cBPF</strong></h2><p>BPF最初的BSD实现方案是通过打开一个字符设备<code>/dev/bpf*</code>(<code>/dev/bpf0</code>, <code>/dev/bpf1</code> etc), 再通过<code>ioctl</code>来控制该设备, 而Linux内核则基于现有的<code>socket</code>接口加入新的选项<code>SO_ATTACH_FILTER/SO_DETACH_FILTER</code>来执行系统调用, 具体的代码实现在<a href="https://elixir.bootlin.com/linux/v3.10.107/source/net/core/filter.c" target="_blank" rel="noopener"><code>/net/core/filter.c</code></a>. 通过一个简单的示例来看下cBPF是如何工作的.</p><ul><li>首先通过<code>tcpdump</code>指令来产生数据包的过滤代码: <code>tcpdump dst port 53 -dd</code>(这里过滤所有目标端口为53的数据包)</li><li>然后创建一个<code>AF_PACKET</code>(用于接收所有的数据包)的<code>socket</code>用于向kernel传递过滤代码, 并接收过滤后的数据包</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// tcpdump dst port 53 -dd</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter_code</span>[] = &#123;</span></span><br><span class="line">    &#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000c</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0x000086dd</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x30</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000014</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0x00000084</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x00000006</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">17</span>, <span class="number">0x00000011</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000036</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">0x00000035</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000038</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">0x00000035</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">0x00000800</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x30</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000017</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0x00000084</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x00000006</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0x00000011</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000014</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x45</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0x00001fff</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0xb1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000e</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x48</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000e</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0x00000035</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x48</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000010</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x00000035</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00040000</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000000</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">bpf</span> = &#123;</span></span><br><span class="line">    .len = <span class="keyword">sizeof</span>(filter_code)/(<span class="keyword">sizeof</span>(struct sock_filter)),</span><br><span class="line">    .filter = filter_code,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock_fd, bytes;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip_header</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> src_addr[INET_ADDRSTRLEN], dst_addr[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">char</span> *iface_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s iface_name\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. create socket</span></span><br><span class="line">    sock_fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line">    <span class="keyword">if</span> (sock_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket created failure"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    iface_name = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sll_ifindex = if_nametoindex(iface_name);</span><br><span class="line">    addr.sll_family = AF_PACKET;</span><br><span class="line">    addr.sll_protocol = htons(ETH_P_ALL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. attach filter (no need to call bind)</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sock_fd, SOL_SOCKET, SO_ATTACH_FILTER, &amp;bpf, <span class="keyword">sizeof</span>(bpf)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"attaching filter failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bytes = recv(sock_fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytes &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"received data failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ip_header = (struct iphdr *) (buf + <span class="keyword">sizeof</span>(struct ether_header));</span><br><span class="line">        inet_ntop(AF_INET, &amp;ip_header-&gt;saddr, src_addr, <span class="keyword">sizeof</span>(src_addr));</span><br><span class="line">        inet_ntop(AF_INET, &amp;ip_header-&gt;daddr, dst_addr, <span class="keyword">sizeof</span>(dst_addr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"IPv%d proto=%d src=%s dest=%s\n"</span>, </span><br><span class="line">                ip_header-&gt;version, ip_header-&gt;protocol, src_addr, dst_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚才说到在Linux 3.0版本中BPF加入了JIT; JIT能够提升伪机器码的执行效率. 从执行流程来说, 主要区别在于传入内核的<code>socket_filter</code>伪机器代码都会通过<code>bpf_jit_compile</code>进行优化处理, 然后再通过字节码解释器执行. 具体来说, 不同的平台<a href="https://elixir.bootlin.com/linux/v3.10.107/ident/bpf_jit_compile" target="_blank" rel="noopener"><code>bpf_jit_compile</code></a>的实现不一样, 内核中的代码路径位于<code>arch/&lt;platform&gt;/net/</code>, 感兴趣的可以跳转到<a href="https://elixir.bootlin.com/linux/v3.10.107/ident/bpf_jit_compile" target="_blank" rel="noopener">这里</a>看下.</p><h2 id="eBPF"><a href="#eBPF" class="headerlink" title="eBPF"></a><strong>eBPF</strong></h2><p><code>eBPF</code>即<a href="https://lwn.net/Articles/603983/" target="_blank" rel="noopener"><code>extended BPF</code></a>, 顾名思义是对原有BPF进行了扩展, 这样不仅BPF可以用来过滤网络数据包(tcpdump/XDP), 也可以用于性能分析, 将BPF代码插入到内核的跟踪点(<code>tracepoints</code>), <code>kprobes</code>, <code>perf</code>事件, 收集相应的数据.除了扩展了cBPF的功能外, eBPF另一个不同于cBPF的地方在于调用的方式: eBPF提供了一个统一的<code>bpf()</code>系统调用来执行相应的操作,同时应用与内核的数据传递也统一通过<code>map</code>这种数据结构来进行. 比如用<code>BPF_MAP_CREATE</code>命令来创建一个eBPF的map对象(不同的内核事件对应的map类型不同):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure><p>我们可以通过<a href="http://man7.org/linux/man-pages/man2/bpf.2.html" target="_blank" rel="noopener"><code>man bpf</code></a>来查看<code>bpf</code>系统调用的具体用法. eBPF对于内核的开发, 以及性能分析无疑是一大利器, 先通过具体的实例来看一看如何使用eBPF(Linux源码中有很多示例<a href="https://elixir.bootlin.com/linux/latest/source/samples/bpf" target="_blank" rel="noopener"><code>samples/bpf</code></a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_sock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sock = <span class="number">-1</span>, map_fd, prog_fd, i, key;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">0</span>, tcp_cnt, udp_cnt, icmp_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个bpf的array map用于保存结果</span></span><br><span class="line">  map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(key), <span class="keyword">sizeof</span>(value), <span class="number">256</span>);</span><br><span class="line">  <span class="keyword">if</span> (map_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"failed to create map '%s'\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// eBPF对应的伪机器码</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] = &#123;</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),</span><br><span class="line">    BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr, protocol) <span class="comment">/* R0 = ip-&gt;proto */</span>),</span><br><span class="line">    BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, <span class="number">-4</span>), <span class="comment">/* *(u32 *)(fp - 4) = r0 */</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>), <span class="comment">/* r2 = fp - 4 */</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_1, map_fd),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem),</span><br><span class="line">    BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, <span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_1, <span class="number">1</span>), <span class="comment">/* r1 = 1 */</span></span><br><span class="line">    BPF_RAW_INSN(BPF_STX | BPF_XADD | BPF_DW, BPF_REG_0, BPF_REG_1, <span class="number">0</span>, <span class="number">0</span>), <span class="comment">/* xadd r0 += r1 */</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>), <span class="comment">/* r0 = 0 */</span></span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载eBPF伪机器码到内核</span></span><br><span class="line">  prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, <span class="keyword">sizeof</span>(prog),</span><br><span class="line">        <span class="string">"GPL"</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (prog_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"failed to load prog '%s'\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sock = open_raw_sock(<span class="string">"lo"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将该eBPF的伪代码绑定到某个socket上</span></span><br><span class="line">  <span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd,</span><br><span class="line">          <span class="keyword">sizeof</span>(prog_fd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查询过滤得到的结果</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    key = IPPROTO_TCP;</span><br><span class="line">    assert(bpf_lookup_elem(map_fd, &amp;key, &amp;tcp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_UDP;</span><br><span class="line">    assert(bpf_lookup_elem(map_fd, &amp;key, &amp;udp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_ICMP;</span><br><span class="line">    assert(bpf_lookup_elem(map_fd, &amp;key, &amp;icmp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"TCP %lld UDP %lld ICMP %lld packets\n"</span>,</span><br><span class="line">          tcp_cnt, udp_cnt, icmp_cnt);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">  <span class="comment">/* maps, programs, raw sockets will auto cleanup on process exit */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到,对于eBPF而言, 大概有如下几个执行步骤:</p><ul><li>编写ePBF伪机器代码</li><li>调用<code>bpf</code>创建对应的map对象, 并将伪机器码加载到内核</li><li>内核对加载得到伪机器码进行优化/校验, 验证其是否合法(是否有非法指令等)</li><li>用户程序通过<code>bpf</code>的接口读取内核事件的结果</li></ul><p>这个例子用的是类似汇编语言的方式来实现eBPF伪机器代码, 这个对于非专业的开发者来说实在有点痛苦. 那么, 能否通过其他高级语言来编写eBPF的代码了? 这就要用到专门的编译器<a href="https://en.wikipedia.org/wiki/LLVM" target="_blank" rel="noopener"><code>LLVM</code>(Lower Level Virtual Machine)</a>了.通过<code>LLVM</code>, 我们只需要将需要执行的eBPF代码用C语言编写好后, 将其编译成<code>elf</code>格式的镜像(image)文件, 然后通过<code>libelf</code>库加载解析后, 装载到内核中执行. 如果去看<a href="https://elixir.bootlin.com/linux/latest/source/samples/bpf" target="_blank" rel="noopener"><code>samples/bpf</code></a>中的其他示例, 都是通过类似的方式实现的.</p><p>了解了eBPF大致的执行流程, 我们一起来看下eBPF原理的框架简图(eBPF涉及的内核知识比较多, 刚开始建立一个整体的框架有助于理解):</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ebpf_architecture.png" alt="eBPF architecture"></p><h2 id="BCC"><a href="#BCC" class="headerlink" title="BCC"></a><strong>BCC</strong></h2><p>即使有现成的编译工具LLVM, 有加载解析elf的库, 但对大部分开发者来说, 日常并没有太多时间精力一步步来开发这些eBPF工具与代码. 于是, 一些大牛们便搞出了一套<a href="https://github.com/iovisor/bcc" target="_blank" rel="noopener">BCC(BPF Compilation Collection)</a>的eBPF工具集合, 这个工具集合把所有eBPF内核代码编写/编译以及错误处理的流程都封装好了, 使用时只需通过python/Lua等脚本语言进行调用,这里从BCC的示例中选出一个简单的例子, 可以看到BCC极大的简化了eBPF的开发与使用流程:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Copyright (c) PLUMgrid, Inc.</span></span><br><span class="line"><span class="comment"># Licensed under the Apache License, Version 2.0 (the "License")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run in project examples directory with:</span></span><br><span class="line"><span class="comment"># sudo ./hello_world.py"</span></span><br><span class="line"><span class="comment"># see trace_fields.py for a longer example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每当发生`clone`系统调用时, 该脚本都会打印`hello world`</span></span><br><span class="line"><span class="comment"># This may not work for 4.17 on x64, you need replace kprobe__sys_clone with kprobe____x64_sys_clone</span></span><br><span class="line">BPF(text=<span class="string">'int kprobe__sys_clone(void *ctx) &#123; bpf_trace_printk("Hello, World!\\n"); return 0; &#125;'</span>).trace_print()</span><br></pre></td></tr></table></figure><p>如果Linux内核版本在4.4以上(如Ubuntu 16.04等), 可以通过如下指令安装BCC使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># echo "deb [trusted=yes] https://repo.iovisor.org/apt/xenial xenial-nightly main" | \</span></span><br><span class="line">    sudo tee /etc/apt/sources.list.d/iovisor.list</span><br><span class="line"><span class="comment"># sudo apt-get update</span></span><br><span class="line"><span class="comment"># sudo apt-get install bpfcc-tools# or the old package name: bcc-tools</span></span><br></pre></td></tr></table></figure><p>相应的, BCC的工具会安装到<code>/usr/share/bcc/tools</code>下面.更多BCC功能的解锁说明可以参考<a href="http://www.brendangregg.com/ebpf.html" target="_blank" rel="noopener">Brendan D.Gregg性能优化大牛的eBPF介绍</a>以及BCC的[官网]<a href="https://github.com/iovisor/bcc)" target="_blank" rel="noopener">https://github.com/iovisor/bcc)</a>. 安装完成后, 无论是对CPU, 内存, 磁盘I/O还是网络数据的传输都可以利用这一套工具进行监控了.</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html" target="_blank" rel="noopener">Breadan Gregg大牛的博客, 性能优化的大牛</a></li><li><a href="http://man7.org/linux/man-pages/man2/bpf.2.html" target="_blank" rel="noopener">BPF系统调用的说明</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html" target="_blank" rel="noopener">BPF的很详尽的介绍资料</a></li><li><a href="https://www.kernel.org/doc/Documentation/networking/filter.txt" target="_blank" rel="noopener">Linux BPF实现的说明</a></li><li><a href="https://llvm.org/" target="_blank" rel="noopener">LLVM开源项目的官网</a></li><li><a href="https://github.com/iovisor/bcc" target="_blank" rel="noopener">BCC Github主页, 如何使用/安装/开发资料很全面</a></li><li><a href="https://lwn.net/Articles/742082/" target="_blank" rel="noopener">BCC入门级介绍</a></li><li><a href="https://github.com/zoidbergwill/awesome-ebpf" target="_blank" rel="noopener">收集了很多eBPF相关的资料</a></li><li><a href="https://qmonnet.github.io/whirl-offload/2016/09/01/dive-into-bpf/" target="_blank" rel="noopener">BPF资料合集</a></li><li><a href="https://blogs.oracle.com/linux/notes-on-bpf-1" target="_blank" rel="noopener">Oracle技术博客上有关BPF的系列文章</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近了解Linux的性能优化时, 偶然接触到了BPF(&lt;a href=&quot;https://en.wikipedia.org/wiki/Berkeley_Packet_Filter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Berkeley Packet Filter&lt;/a&gt;)。很有意思也很强大的功能;想把学到的一些基本原理与知识记录下来, 算是一个初步的总结. 这篇文章主要从如下几个方面介绍下BPF
    
    </summary>
    
      <category term="网络协议" scheme="http://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="Linux" scheme="http://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/Linux/"/>
    
    
      <category term="Berkeley Packet Filters" scheme="http://sniffer.site/tags/Berkeley-Packet-Filters/"/>
    
      <category term="extended Berkeley Packet Filters" scheme="http://sniffer.site/tags/extended-Berkeley-Packet-Filters/"/>
    
      <category term="性能优化" scheme="http://sniffer.site/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>说说Process.waitfor()引起的进程阻塞问题</title>
    <link href="http://sniffer.site/2019/09/04/%E8%AF%B4%E8%AF%B4Process-waitfor-%E5%BC%95%E8%B5%B7%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98/"/>
    <id>http://sniffer.site/2019/09/04/说说Process-waitfor-引起的进程阻塞问题/</id>
    <published>2019-09-04T08:35:16.000Z</published>
    <updated>2019-09-05T01:58:12.601Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到一个看似很怪异的问题, 在两个APP上调用同样的本地指令得到的结果却大相径庭; 看源代码, 这个本地进程做的事情其实并不复杂:</p><ul><li>从一个串口<code>/dev/ttyUSBX</code>读取数据</li><li>将数据写入到本地目录(读缓存大小为1KB)</li></ul><p>本地进程的代码逻辑其实相当简单: 主线程起来后主动创建一个负责读/写的子线程, 然后通过<code>pthread_join</code>主动等待子线程完成后退出.</p><p>问题是, 应用A调用的时保存的日志大小雷打不动的停留在不到4M就停止了, 而应用B可以一直写数据. 看应用A调用时, 通过<code>debuggerd -b &lt;tid&gt;</code>查看本地进程的堆栈, 大概是这样的:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/process_stack.jpg" alt="process stack"></p><p>说明此时本地进程一直在”卡”在写数据上了, 那到底卡在哪里了? 查看<code>cat /proc/&lt;pid&gt;/wchan</code>(也可以通过<code>strace -p &lt;pid&gt;</code>来查看目前进程所调用的系统调用), 就是本地进程的正在执行的系统调用, 发现是<code>pipe_wait</code>, 这个是怎么回事? 本地进程本身并不会用到pipe来进行数据的传输, 那很可能是Java父进程与本地进程之间的数据通信管道了. </p><p>回到最开始的问题, 为何两个APP调用同样的指令会有如此大的差异了? 我们再来看看应用A与应用B之间执行的代码到底有多少的差异?</p><ul><li>应用A的调用逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">Process process = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    process = Runtime.getRuntime().exec(COMMAND);</span><br><span class="line">    process.waitFor();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(process != <span class="keyword">null</span>) &#123;</span><br><span class="line">        process.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>应用B的调用逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Process process = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    process = Runtime.getRuntime().exec(COMMAND);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(process != <span class="keyword">null</span>) &#123;</span><br><span class="line">        process.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么一对比, 看起来问题是出在<code>Process.waitfor()</code>上了, 看了网上一个类似的案例<code>https://www.cnblogs.com/embedded-linux/p/6986525.html</code>, 顿时觉得豁然开朗, 这个不就是我碰到问题末!  看 <code>java.lang.Process</code>的文档说明(这里只拿了最关键的一段话): </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">By default, the created process does not have its own terminal</span><br><span class="line">or console.  All its standard I/O (i.e. stdin, stdout, stderr)</span><br><span class="line">operations will be redirected to the parent process, where they can</span><br><span class="line">be accessed via the streams obtained using the methods</span><br><span class="line">&#123;@link #getOutputStream()&#125;,</span><br><span class="line">&#123;@link #getInputStream()&#125;, and</span><br><span class="line"> &#123;@link #getErrorStream()&#125;.</span><br><span class="line">The parent process uses these streams to feed input to and get output</span><br><span class="line">from the process.  Because some native platforms only provide</span><br><span class="line">limited buffer size for standard input and output streams, failure</span><br><span class="line">to promptly write the input stream or read the output stream of</span><br><span class="line">the process may cause the process to block, or even deadlock.</span><br></pre></td></tr></table></figure><p>这段话的大概意思是, 通过Java创建的本地子进程本身是没有标准输入/输出以及错误流的, 这三个流都会被重定向到父进程; 父进程则通过<code>Process.getInputStream()/getOutputStream</code>等来获取子进程的流, 而如果父进程如果一直不读取子进程的输出流, 由于平台本身的输入输出流的缓冲大小是有限的, 此时子进程就可能阻塞, 甚至死锁(如果父进程也在等待子进程的话). 这样看起来, 问题的原因就很明显了:  应用A没有处理子进程的输出流, 且调用了<code>Process.waitfor()</code>, 由于本地进程一直在打印输出日志, 导致输出缓冲区满了之后发生阻塞, 而父进程并不知道子进程发生了阻塞, 一直傻傻的等.现在看来, 调用任何接口之前看<strong>看文档</strong>总是有益的, 至少在定位分析问题的时候可以少走弯路.</p><p>我们先来看下Java调用本地进程的整个处理流程, 再来看具体如何解决这个问题.  调用<code>Runtime.exec(cmd)</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String prog)</span> <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> exec(prog, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String prog, String[] envp, File directory)</span> <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line"><span class="comment">// Sanity checks</span></span><br><span class="line"><span class="keyword">if</span> (prog == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"prog == null"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (prog.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"prog is empty"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Break down into tokens, as described in Java docs</span></span><br><span class="line">StringTokenizer tokenizer = <span class="keyword">new</span> StringTokenizer(prog);</span><br><span class="line"><span class="keyword">int</span> length = tokenizer.countTokens();</span><br><span class="line">String[] progArray = <span class="keyword">new</span> String[length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    progArray[i] = tokenizer.nextToken();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delegate</span></span><br><span class="line"><span class="keyword">return</span> exec(progArray, envp, directory);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String[] progArray, String[] envp, File directory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// ProcessManager is responsible for all argument checking.</span></span><br><span class="line">      <span class="keyword">return</span> ProcessManager.getInstance().exec(progArray, envp, directory, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接着调用<code>ProcessManager.getInstance().exec()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes a process and returns an object representing it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String[] taintedCommand, String[] taintedEnvironment, File workingDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> redirectErrorStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure we throw the same exceptions as the RI.</span></span><br><span class="line">    <span class="keyword">if</span> (taintedCommand == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"taintedCommand == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (taintedCommand.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"taintedCommand.length == 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle security and safety by copying mutable inputs and checking them.</span></span><br><span class="line">    String[] command = taintedCommand.clone();</span><br><span class="line">    String[] environment = taintedEnvironment != <span class="keyword">null</span> ? taintedEnvironment.clone() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check we're not passing null Strings to the native exec.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; command.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (command[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"taintedCommand["</span> + i + <span class="string">"] == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The environment is allowed to be null or empty, but no element may be null.</span></span><br><span class="line">    <span class="keyword">if</span> (environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; environment.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (environment[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"taintedEnvironment["</span> + i + <span class="string">"] == null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FileDescriptor in = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    FileDescriptor out = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    FileDescriptor err = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line"></span><br><span class="line">    String workingPath = (workingDirectory == <span class="keyword">null</span>)</span><br><span class="line">            ? <span class="keyword">null</span></span><br><span class="line">            : workingDirectory.getPath();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure onExit() doesn't access the process map before we add our</span></span><br><span class="line">    <span class="comment">// entry.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (processReferences) &#123;</span><br><span class="line">        <span class="keyword">int</span> pid;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用JNI方法, 创建一个子进程, 并返回对应的PID</span></span><br><span class="line">            pid = exec(command, environment, workingPath, in, out, err, redirectErrorStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            IOException wrapper = <span class="keyword">new</span> IOException(<span class="string">"Error running exec()."</span></span><br><span class="line">                    + <span class="string">" Command: "</span> + Arrays.toString(command)</span><br><span class="line">                    + <span class="string">" Working Directory: "</span> + workingDirectory</span><br><span class="line">                    + <span class="string">" Environment: "</span> + Arrays.toString(environment));</span><br><span class="line">            wrapper.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> wrapper;</span><br><span class="line">        &#125;</span><br><span class="line">        ProcessImpl process = <span class="keyword">new</span> ProcessImpl(pid, in, out, err);</span><br><span class="line">        ProcessReference processReference = <span class="keyword">new</span> ProcessReference(process, referenceQueue);</span><br><span class="line">        processReferences.put(pid, processReference);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This will wake up the child monitor thread in case there</span></span><br><span class="line"><span class="comment">         * weren't previously any children to wait on.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        processReferences.notifyAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> process;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看下对应的JNI方法<code>java_lang_ProcessManager.cpp</code>,  看到<code>ExecuteProcess</code>中将子进程的输入输出以及错误流均重定向到pipe的一端, 而pipe的另一端则对应着父进程的输出输入以及错误流, 这样一看子进程所阻塞的函数<code>pipe_wait</code>正是因为输出流缓冲满了, 无法再继续写了(那么, 可能还有疑问? 为何本地进程一直要写pipe了, 手动输入命令调用下就知道, 这个本地进程一直变态的在打印自己写入数据的文件名到标准输出).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ProcessManager_exec</span><span class="params">(JNIEnv* env, jclass, jobjectArray javaCommands,</span></span></span><br><span class="line"><span class="function"><span class="params">                         jobjectArray javaEnvironment, jstring javaWorkingDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">                         jobject inDescriptor, jobject outDescriptor, jobject errDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">                         jboolean redirectErrorStream)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">ExecStrings <span class="title">commands</span><span class="params">(env, javaCommands)</span></span>;</span><br><span class="line">  <span class="function">ExecStrings <span class="title">environment</span><span class="params">(env, javaEnvironment)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Extract working directory string.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* workingDirectory = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (javaWorkingDirectory != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    workingDirectory = env-&gt;GetStringUTFChars(javaWorkingDirectory, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pid_t</span> result = ExecuteProcess(env, commands.get(), environment.get(), workingDirectory,</span><br><span class="line">                        inDescriptor, outDescriptor, errDescriptor, redirectErrorStream);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clean up working directory string.</span></span><br><span class="line">  <span class="keyword">if</span> (javaWorkingDirectory != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(javaWorkingDirectory, workingDirectory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Executes a command in a child process. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ExecuteProcess</span><span class="params">(JNIEnv* env, <span class="keyword">char</span>** commands, <span class="keyword">char</span>** environment,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">char</span>* workingDirectory, jobject inDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">                    jobject outDescriptor, jobject errDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">                    jboolean redirectErrorStream)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create 4 pipes: stdin, stdout, stderr, and an exec() status pipe.</span></span><br><span class="line">  <span class="keyword">int</span> pipes[PIPE_COUNT * <span class="number">2</span>] = &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_COUNT; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipes + i * <span class="number">2</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      jniThrowIOException(env, errno);</span><br><span class="line">      ClosePipes(pipes, <span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> stdinIn = pipes[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> stdinOut = pipes[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> stdoutIn = pipes[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> stdoutOut = pipes[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">int</span> stderrIn = pipes[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span> stderrOut = pipes[<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">int</span> statusIn = pipes[<span class="number">6</span>];</span><br><span class="line">  <span class="keyword">int</span> statusOut = pipes[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pid_t</span> childPid = fork();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If fork() failed...</span></span><br><span class="line">  <span class="keyword">if</span> (childPid == <span class="number">-1</span>) &#123;</span><br><span class="line">    jniThrowIOException(env, errno);</span><br><span class="line">    ClosePipes(pipes, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is the child process...</span></span><br><span class="line">  <span class="keyword">if</span> (childPid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Note: We cannot malloc(3) or free(3) after this point!</span></span><br><span class="line">    <span class="comment">// A thread in the parent that no longer exists in the child may have held the heap lock</span></span><br><span class="line">    <span class="comment">// when we forked, so an attempt to malloc(3) or free(3) would result in deadlock.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace stdin, out, and err with pipes.</span></span><br><span class="line">    dup2(stdinIn, <span class="number">0</span>);</span><br><span class="line">    dup2(stdoutOut, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (redirectErrorStream) &#123;</span><br><span class="line">      dup2(stdoutOut, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dup2(stderrOut, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close all but statusOut. This saves some work in the next step.</span></span><br><span class="line">    ClosePipes(pipes, statusOut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make statusOut automatically close if execvp() succeeds.</span></span><br><span class="line">    fcntl(statusOut, F_SETFD, FD_CLOEXEC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close remaining unwanted open fds.</span></span><br><span class="line">    CloseNonStandardFds(statusOut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch to working directory.</span></span><br><span class="line">    <span class="keyword">if</span> (workingDirectory != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (chdir(workingDirectory) == <span class="number">-1</span>) &#123;</span><br><span class="line">AbortChild(statusOut);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up environment.</span></span><br><span class="line">    <span class="keyword">if</span> (environment != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">extern</span> <span class="keyword">char</span>** environ; <span class="comment">// Standard, but not in any header file.</span></span><br><span class="line">      environ = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute process. By convention, the first argument in the arg array</span></span><br><span class="line">    <span class="comment">// should be the command itself.</span></span><br><span class="line">    execvp(commands[<span class="number">0</span>], commands);</span><br><span class="line">    AbortChild(statusOut);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is the parent process.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Close child's pipe ends.</span></span><br><span class="line">  close(stdinIn);</span><br><span class="line">  close(stdoutOut);</span><br><span class="line">  close(stderrOut);</span><br><span class="line">  close(statusOut);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check status pipe for an error code. If execvp(2) succeeds, the other</span></span><br><span class="line">  <span class="comment">// end of the pipe should automatically close, in which case, we'll read</span></span><br><span class="line">  <span class="comment">// nothing.</span></span><br><span class="line">  <span class="keyword">int</span> child_errno;</span><br><span class="line">  <span class="keyword">ssize_t</span> count = TEMP_FAILURE_RETRY(read(statusIn, &amp;child_errno, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">  close(statusIn);</span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// chdir(2) or execvp(2) in the child failed.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> track which so we can be more specific in the detail message.</span></span><br><span class="line">    jniThrowIOException(env, child_errno);</span><br><span class="line"></span><br><span class="line">    close(stdoutIn);</span><br><span class="line">    close(stdinOut);</span><br><span class="line">    close(stderrIn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reap our zombie child right away.</span></span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> rc = TEMP_FAILURE_RETRY(waitpid(childPid, &amp;status, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">-1</span>) &#123;</span><br><span class="line">      ALOGW(<span class="string">"waitpid on failed exec failed: %s"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill in file descriptor wrappers.</span></span><br><span class="line">  jniSetFileDescriptorOfFD(env, inDescriptor, stdoutIn);</span><br><span class="line">  jniSetFileDescriptorOfFD(env, outDescriptor, stdinOut);</span><br><span class="line">  jniSetFileDescriptorOfFD(env, errDescriptor, stderrIn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> childPid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有兴趣还可以继续看下kernel的代码<code>fs/pipe.c</code>是如何实现<code>pipe_write/pipe_read</code>以及<code>pipe_wait</code>是如何发生的.</p><p>这么一看代码流程, 如何解决这个问题的思路也有了, 大致有这么几种:</p><ul><li>直接在Java代码中去掉<code>Process.waitfor()</code>, 这个方法可能还是会有导致子进程阻塞的风险, 虽然不会死锁</li><li>在新的线程中读取子线程的输出流:<code>Process.getInputStream()</code>, 这样确保子进程不会被阻塞</li><li>直接将子进程的流全部丢弃(如果本身不感兴趣的话)</li><li>要写本地进程的人把所有这些不必要的打印全部去掉(这个最好不要当作终极解决方案)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近碰到一个看似很怪异的问题, 在两个APP上调用同样的本地指令得到的结果却大相径庭; 看源代码, 这个本地进程做的事情其实并不复杂:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从一个串口&lt;code&gt;/dev/ttyUSBX&lt;/code&gt;读取数据&lt;/li&gt;
&lt;li&gt;将数据写入到本地目录(读
      
    
    </summary>
    
      <category term="Java" scheme="http://sniffer.site/categories/Java/"/>
    
    
      <category term="Java" scheme="http://sniffer.site/tags/Java/"/>
    
      <category term="Process" scheme="http://sniffer.site/tags/Process/"/>
    
      <category term="waitfor" scheme="http://sniffer.site/tags/waitfor/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊TCP协议</title>
    <link href="http://sniffer.site/2019/07/30/%E8%81%8A%E4%B8%80%E8%81%8ATCP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://sniffer.site/2019/07/30/聊一聊TCP协议/</id>
    <published>2019-07-30T06:01:35.000Z</published>
    <updated>2020-10-21T03:47:00.032Z</updated>
    
    <content type="html"><![CDATA[<p>TCP(<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener">Transmission Control Protocol</a>)即传输控制协议, 位于TCP/IP协议栈的第三层传输层, 与UDP不同的是, TCP号称提供有链接的(connection-oriented), 可靠的(reliable)字节流服务, 很多其他应用层协议如HTTP/SMTP/MQTT都是基于TCP协议实现.</p><p>这篇文章我们就从定义的角度来看一看TCP协议的具体工作原理. 首先看下有链接的(<code>connection-oriented</code>)具体含义.</p><p>TCP在发送数据之前, 第一件事情就是要在通信的双方建立一个通信的链路, 这个有点像日常生活中的打电话: A向B发起通话请求, B确认后双方建立通信链接才能正式通话. TCP也一样, 在发送任何数据之前必须要建立链接(connection), 这个建立通信链接的过程就是我们常说的”三次握手”；同样, 如果要想结束通信, 也需要有一个挥手的过程(四次挥手).有关TCP链接的建立与关闭可以参考之前的一篇文章(<a href="http://sniffer.site/2019/07/15/TCP%E9%93%BE%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB/">TCP的链接建立与状态迁移</a>). 那么, TCP建立链接主要完成哪几件事情了?</p><ul><li>交换双方的ISN(Initial Sequence Number): ISN的作用(后面在讲重传时会再讲到)是用来确保每个TCP数据包都是唯一的, 接收端如果收到了重复包可以根据每个包的序列号来实现去重</li><li>确认发送数据的MSS(Maximum Segment Size): MSS是TCP能发送的数据的最大值, 通过TCP头中的<code>options</code>交换, 默认值是536, 一般是当前系统MTU(Maximum Transmission Unit)的值减去TCP/IP协议头的大小之和(40byte), 其与MTU关系如下图所示</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcp-mss.png" alt="MSS vs MTU"></p><ul><li>接收窗口的大小: 在TCP头中有一个<code>window</code>项, 用来告诉对端自己接收缓冲区的大小, 这个窗口在拥塞与流量控制中扮演着十分重要的角色, 用于告诉发送方最大可以发送的数据大小</li></ul><p>通信双方在三次握手完成之后, 都知道了对方的初始序列号(<code>ISN</code>), 接收窗口大小以及MSS, 这样发送方就可以开始愉快的发送数据了. 接着讲第二个方面: TCP是如何做到要数据的可靠(<code>reliable</code>)传输的? 为了实现这一目标,TCP需要解决很多问题: </p><ol><li><p>数据在网络上丢包了如何办? TCP对于每个数据包都有个定时器, 如果接收方长时间没有回应, 在定时器超是后就会发起重传, 那么如何选择这个定时器的时长? 重传时间(Retransmission Timeout, RTO)太长, 导致数据传输效率太低; RTO太短, 则可能导致重传的数据包太多, 引发更大的网络拥堵.</p></li><li><p>发送方如何来控制自己数据的发送速率, 确保接收方能够处理的过来. 发送方不能不顾一切的发送数据, 而不管接收方是否有足够的空间来接受数据. 因此, TCP在接收方忙/没有足够空间接收数据时都会主动降低发送速度, 让接收方可以有机会及时恢复.这个是TCP流量控制(<code>flow control</code>)需要做的事情.</p></li><li><p>如果网络发生拥塞, TCP应该如何处理?发送端不能不顾及网络带宽以及拥堵状态而只管发送数据包, 进而影响其他用户正常使用网络.为了体现网络使用的公平性, 确保不同用户能够都能均衡的使用网络, 减少用户之间的相互干扰, TCP通过多种拥塞控制(<code>Congestion Control</code>)手段来减少网络拥堵, 并且在发生拥堵时尝试尽快恢复.</p></li></ol><p>具体说来TCP主要通过如下几个方式来解决上述几个问题:</p><ul><li>重传时间的计算: 如何实时调整RTO(<code>retransmission timeout</code>)的大小, 确保重传的频率在合适的范围</li><li>流量控制(<code>flow control</code>): 通过滑动窗口(<code>sliding window</code>)机制来实现数据发送的流量控制</li><li>拥塞控制(<code>Congestion Control</code>): 拥塞控制主要有 (1) 慢启动 ; (2) 拥塞避免； (3) 拥塞发生； (4) 快速恢复. 在后面会一一介绍这几个算法的原理.</li></ul><h2 id="何时重传"><a href="#何时重传" class="headerlink" title="何时重传"></a>何时重传</h2><p>为了确保数据的可靠传达, TCP每发送一个数据包, 接收方都要回应一个ACK包, 发送方在发送完一个数据包后就会启动一个重传定时器(<code>retransmission timer</code>), 如果在定时器超时后都未能收到对方的ACK包, 就会重传. 那么如何发送方如何知道重传的超时时间(<code>Retransmission Timeout</code>, RTO)? (在TCP的标准协议文档<a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC793</a>中给出了一个低通滤波的计算方式, 式中<code>alpha</code>一般为0.9, <code>RTT</code>(Round Trip Time)表示测量得到的返程时间, <code>R</code>表示平滑后的RTT:  $$ R = \alpha R + (1 - \alpha) RTT$$</p><p>而RTO是在平滑后的RTT乘以一个系数<code>beta</code>(一般取值为2)得到:</p><p>$$ RTO = \beta R $$</p><p>按照上述的计算得到RTO, 由于采用低通滤波,因而没有考虑到在网络发生波动(比如网络拥堵, 路由故障等)等情况下RTT变大的情况, 导致不必要的重传, 反而带来更大的网络负载, 导致网络陷入持久的拥堵.针对该问题, Jacobson在1988年提出了一个改进的RTO计算方法(<a href="https://ee.lbl.gov/papers/congavoid.pdf" target="_blank" rel="noopener">链接</a>, 该算法考虑到了由于网络波动导致的延迟, 因此可以更准确的反映网络拥塞状态:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/how_rto_calculated.png" alt="rto"></p><p>上述公式, <code>MRTT</code>代表实际测量得到的RTT, <code>SRTT</code>表示平滑后的RTT值, D实际表示的是RTT的平均方差(不是平方差), <code>g</code>一般设为1/8(0.125), 而<code>h</code>设为0.25.对于发生了重传的情况, RTO一般会通过<a href="https://en.wikipedia.org/wiki/Exponential_backoff" target="_blank" rel="noopener">指数回退</a>的方式进行倍乘(Karn and Partridge 1987).</p><h2 id="流量控制-如何控制发送速率"><a href="#流量控制-如何控制发送速率" class="headerlink" title="流量控制: 如何控制发送速率"></a><strong>流量控制: 如何控制发送速率</strong></h2><p>收发数据的两端常常在网络带宽以及性能上都存在差异, (快的)发送方如果不控制发送的速度, 可能会让处在慢速网络中的接收方不知所措.因此, 为了实现数据的可靠传输, TCP需要根据接收方的信息及时调整发送速率, 这个控制发送流量的技术就是著名的滑动窗口(<code>sliding window</code>)协议.简单地讲, 滑动窗口是要根据接收方的可用<code>window</code>(TCP缓存)的大小来达到调整接收方流量大小的目的, 下图是一个滑动窗口示意图(图片来自<a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-7.htm" target="_blank" rel="noopener">TCP/IP Guide</a>):</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcpswwindows.png" alt="TCP sliding window"></p><p>图中的数据主要分为4个部分:</p><ul><li>‘#1’: 表示已经发送的数据, 并且收到了ACK</li><li>‘#2’: 表示发送了的数据, 但是没有收到ACK确认</li><li>‘#3’: 尚未发送的数据(接收方还有空间)</li><li>‘#4’: 不可发送的数据(接收方没有足够空间, 无能为力)</li></ul><p>当发送了部分<code>#3</code>的数据更新后的滑动窗口如下图所示(图片来自<a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-7.htm" target="_blank" rel="noopener">TCPIP Guide</a>):</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcpswaftersendnow.png" alt="TCP after sliding window"></p><p>可以看到此时<code>可用的部分窗口</code>大小变成了0, 后续要等到接收方确认了<code>#2</code>部分的数据后, 窗口才会继续往前滑动.那么TCP协议是如何在数据传输过程中调整窗口大小(<code>window size</code>)的了? 了解TCP协议的人应该记得, 在TCP协议头有一个专门的字段<code>window</code>用于通信的两端来告知对方当前窗口的大小(能接收多少数据), 而通过<code>socket</code>的<code>SO_RCVBUF</code>参数可以来设置通信时接收缓冲区的大小(<a href="http://man7.org/linux/man-pages/man7/socket.7.html" target="_blank" rel="noopener">socket(7)</a>). 下图是一个接发数据过程通信两端TCP窗口大小的更新过程:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcpswflow.png" alt="TCP window size update"></p><ul><li>在发送数据的开始, 接收端会在三次握手时告知发送端自己的<code>window size</code>(图中为360)</li><li>随着发送端不断发送数据, 接收端的<code>window</code>会逐渐减少, 直到为0, 此时发送端会暂停发送数据</li></ul><p>问题来了, 如果接收方的<code>window</code>为0, 要如何处理?对于接收端, 在接收缓冲区可用后(如应用从读取了部分数据), 会发送一个<code>window update</code>的ACK包, 那万一这个ACK在传输过程中丢失了怎么办? 这样就会导致发送端的TCP无法正常关闭, 因此需要通过在发送端每隔一段时间就发送一个<code>Zero Window Probe</code>的探测包, 来获取接收端窗口的状态, 关于ZWP的说明可以参考(<a href="https://tools.ietf.org/html/rfc1122#page-92" target="_blank" rel="noopener">RFC1122</a>)的讨论.</p><h3 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a><strong>Silly Window Syndrome</strong></h3><p>Silly Window Syndrome(中译为<code>糊涂窗口综合症</code>)的意思是, 接收端的应用可能每次都只拿走很少的一部分(比如几个字节)的数据, 因此每次<code>window update</code>后发送端也只会发送几个字节的数据, 而我们知道, 光TCP+IP两个协议头都需要40个字节的空间,这样的传输效率看起来太低了.针对该问题, 有两种策略:</p><ul><li><p>如果问题发生在接收端(接收端处理太慢等), 则可以在<code>window</code>小于某个值时, 直接向发送端ACK一个<code>window=0</code>的包, 告诉发送端暂停发送, 等<code>window</code>大于某个值(比如<code>MSS/2</code>)时再发送<code>window update</code>包让发送方继续发送数据;</p></li><li><p>而如果问题发生在发送方,则可以考虑Nagle在1984年提出的<code>Nagle Algorithm</code><a href="https://tools.ietf.org/html/rfc896" target="_blank" rel="noopener">RFC896</a>: 对于一个TCP连接, 只要还有一个数据包的没有被确认, 就将应用发送的数据缓存下来, 直到接收到该数据包的ACK之后才允许发送新的数据.这样TCP就尽可能的发送”大”的数据包, 而不是发送多个小包, 导致效率降低. 但对于某些交互式应用如<code>Telenet/SSH/Rlogin</code>, 为了避免延时带来的交互延时, 通常需要关闭<code>Nagle</code>算法, 可以通过socket的选项参数<code>TCP_NODELAY</code>来关闭该算法, 从而提升交互体验.</p></li></ul><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><strong>拥塞控制</strong></h2><p>TCP的滑动窗口很好的控制了接收端与发送端的包速率,  但并没有考虑到中间网络如路由器/交换机拥塞/故障引发的网络拥堵, 为了避免网络拥塞引起网络瘫痪(<code>congestion collapse</code>), TCP需要对网络的拥塞信号做出反应(发生丢包/包乱序等). 总的说来, TCP的拥塞控制(<code>congestion control</code>)是为了: </p><ul><li>(1) 尽可能减少拥塞导致的网络瘫痪(如某个路由节点由于不堪重负崩溃或者卡死)；</li><li>(2) 网络使用的公平性(<code>faireness</code>): TCP的目标是尽可能使每个网络的使用者都达到比较好的体验, 避免某一个发送端或者接收端过度的占用网络带宽. </li></ul><p>在RFC5681(<a href="https://tools.ietf.org/html/rfc5681" target="_blank" rel="noopener"><code>TCP Congestion Control</code></a>)中总结了四个拥塞控制算法:</p><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a><strong>慢启动</strong></h3><p>TCP慢启动(<code>slow start</code>)的意思是开始发送数据时, 尽量逐步增加发送的数据量, 而不是最开始就发送一个大的数据包, 这样试探性的发送数据可以减少网络拥塞.为了实现慢启动以及拥塞避免(与慢启动配套的算法, 接下来会讲到), 需要引入两个状态变量: (1) 拥塞窗口(<code>congestion window</code>) <code>cwnd</code>; (2) 慢启动阈值(<code>slow start threshold</code>) <code>ssthresh</code>, 这个阈值用于慢启动与拥塞避免两个算法之间的切换.</p><p>慢启动算法的大致步骤如下:</p><ol><li>将<code>cwnd</code>设为1, 表示一个MSS大小(<a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf" target="_blank" rel="noopener">目前一般Linux系统都按照Google的建议</a>将该值设为10)</li><li>每次接收到一个ACK后, <code>cwnd += 1</code></li></ol><p>这样收到一个ACK后,<code>cwnd</code>变为2,接着会发出两个MSS的数据包, ACK会变成4, 最终发送的包数量呈指数上升.等到<code>cwnd &gt; ssthresh</code>, 则进入拥塞避免阶段, TCP会根据收发包的丢包重传的情况, 适当调整<code>cwnd</code>的值, 确保不要让网络变得过度拥堵.</p><h2 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a><strong>拥塞避免</strong></h2><p>当<code>cwnd &gt; ssthresh</code>时, TCP进入拥塞避免(<code>congestion avoidance</code>), 此时<code>cwnd</code>会进入线性调整阶段:</p><ol><li><code>sshthresh</code>的值大小一般初始化为65535(<code>0x7ffffff</code>)</li><li>cwnd += 1/cwnd(参考[<a href="https://tools.ietf.org/html/rfc5681]" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc5681]</a></li><li>每过一个RTT, 则<code>cwnd = cwnd + 1</code></li></ol><p>当发生RTO重传时, 需要减少<code>sshthresh</code>的值, 同时减少<code>cwnd</code>的值: </p><ul><li><code>sshthresh = max(FlightSize/2, 2*MSS)</code></li><li><code>cwnd = 1</code></li></ul><p>这样在重传之后TCP又进入了慢启动模式, 逐步增加发送数据包的速率.</p><h2 id="快速重传与快速恢复"><a href="#快速重传与快速恢复" class="headerlink" title="快速重传与快速恢复"></a><strong>快速重传与快速恢复</strong></h2><p>先来了解下快速重传(<code>fast restransmition</code>)与快速恢复(<code>fast recovery</code>)的具体含义:</p><ul><li>快速重传: 在TCP接收到连续3次DACK(<code>duplicate ACK</code>)后, 主动重传丢失的数据包, 而不是等到RTO超时</li><li>快速恢复: 当TCP完成快速重传后, 会进入拥塞避免而不是慢启动, 这样确保发送的流量在适当的拥塞之后保持稳定</li></ul><p>一般来说, 快速重传与快速恢复是同一起实现的, 具体的流程如下:</p><ul><li>如果连续收到三个DACk包, 则重传丢失的数据包</li><li>更新拥塞窗口以及慢启动阈值: <code>sshthresh = max(FlightSize/2, 2*MSS)</code> 以及<code>cwnd = ssthresh + 3 * MSS</code></li><li>后续每收到一个DACK, 增加将拥塞窗口加一: <code>cwnd = cwnd + 1</code></li><li>如果收到ACK, 则<code>cwnd = sshthresh</code>, 这样TCP会再次进入拥塞控制</li></ul><p>实际TCP针对丢包与重传的情况还有很多改善型算法, 详细可以参考<a href="https://tools.ietf.org/html/rfc5681" target="_blank" rel="noopener">RFC5681</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://www.tcpipguide.com/free/t_TCPWindowSizeAdjustmentandFlowControl-2.htm" target="_blank" rel="noopener">TCP流量控制</a></li><li><a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo.htm" target="_blank" rel="noopener">TCP滑动窗口</a></li><li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">TCP的那些事情, 耗子叔的力作</a></li><li><a href="https://tools.ietf.org/html/rfc2914" target="_blank" rel="noopener">Congestion Control Principles</a></li><li><a href="https://tools.ietf.org/html/rfc7414" target="_blank" rel="noopener">TCP roadmap</a></li><li><a href="https://tools.ietf.org/html/rfc5681" target="_blank" rel="noopener">TCP congestion control</a></li><li><a href="https://tools.ietf.org/html/rfc1122" target="_blank" rel="noopener">TCP/IP协议的各种问题的总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCP(&lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Transmission Control Protocol&lt;/a
      
    
    </summary>
    
      <category term="网络协议" scheme="http://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="TCP" scheme="http://sniffer.site/tags/TCP/"/>
    
      <category term="拥塞控制" scheme="http://sniffer.site/tags/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>TCP链接建立与状态迁移</title>
    <link href="http://sniffer.site/2019/07/15/TCP%E9%93%BE%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB/"/>
    <id>http://sniffer.site/2019/07/15/TCP链接建立与状态迁移/</id>
    <published>2019-07-15T07:17:03.000Z</published>
    <updated>2020-10-21T03:09:03.040Z</updated>
    
    <content type="html"><![CDATA[<p>学习TCP协议的第一步是要了解熟悉TCP的三次握手/四次挥手以及状态迁移图. 这篇文章用三个图展示TCP链接的建立与关闭以及状态的迁移.</p><h2 id="TCP状态迁移"><a href="#TCP状态迁移" class="headerlink" title="TCP状态迁移"></a><strong>TCP状态迁移</strong></h2><p>根据TCP协议的文档<a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC793</a>, 一个TCP链接有下图中的几个状态(图中实粗线为Client端的正常情况下状态迁移图, 虚线为Server端正常情况下的状态迁移图):</p><ul><li><code>CLOSED</code>: TCP链接的初始状态, 表示没有任何链接</li><li><code>LISTEN</code>: (服务端)等待来自远程客户端的请求</li><li><code>SYN_SENT</code>: 发送了一个建立TCP链接的SYN请求, 等待对端返回结果</li><li><code>SYN_RCVD</code>: 收到了TCP建立链接的SYN包, 等待对方的回应(ACK)</li><li><code>ESTABLISHED</code>: TCP链接建立成功, 从这里开始可以交换数据包了</li><li><code>FIN_WAIT1</code>: 应用进程关闭了TCP链接(发送FIN包), 并等待对端的响应</li><li><code>FIN_WAIT2</code>: 接收到关闭回应后, 等待对端结束TCP链接(等待FIN包)</li><li><code>CLOSING</code>: 如果两端同时接收到了FIN包, 则进入该状态</li><li><code>CLOSE_WAIT</code>:处于被动关闭一端接受到FIN请求后, 等待本地进程的关闭TCP链接</li><li><code>LAST_ACK</code>: 服务端本地进程关闭TCP链接后, 发送FIN包, 等待回应</li><li><code>TIME_WAIT</code>: 等待2*MSL(Maximum Segment Lifetime, TCP包的最大存活时间)后关闭该TCP链接, 等待足够长的时间是为了确保最后关闭链接的ACK包有足够长的时间达到对端, 如果对端未能收到该包, 则会重传FIN包, 这样对端也可以重传ACK包, 一般MSL为60s</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/TCP_state_transition.png" alt="TCP state transition"></p><h2 id="TCP三次握手与四次挥手"><a href="#TCP三次握手与四次挥手" class="headerlink" title="TCP三次握手与四次挥手"></a><strong>TCP三次握手与四次挥手</strong></h2><p>正常情况下, TCP的三次握手与四次挥手如下图所示:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcp_three_way_handeshake.png" alt="TCP connection establish/close"></p><h2 id="同时关闭时的TCP状态变化"><a href="#同时关闭时的TCP状态变化" class="headerlink" title="同时关闭时的TCP状态变化"></a><strong>同时关闭时的TCP状态变化</strong></h2><p>如果TCP通信的两端同时请求关闭链接, 流程如下图所示:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcp_simutaneous_close.png" alt="TCP simutaneous close"></p><p>关于TCP协议的参考资料:</p><ul><li>RFC793: 这是有关TCP协议的标准文本, 信息的源头</li><li>&lt;TCP/IP详解 卷1&gt;: W. Richard Stevens的经典, 必看</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习TCP协议的第一步是要了解熟悉TCP的三次握手/四次挥手以及状态迁移图. 这篇文章用三个图展示TCP链接的建立与关闭以及状态的迁移.&lt;/p&gt;
&lt;h2 id=&quot;TCP状态迁移&quot;&gt;&lt;a href=&quot;#TCP状态迁移&quot; class=&quot;headerlink&quot; title=&quot;TC
      
    
    </summary>
    
      <category term="网络协议" scheme="http://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="TCP" scheme="http://sniffer.site/tags/TCP/"/>
    
      <category term="三次握手" scheme="http://sniffer.site/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    
      <category term="四次挥手" scheme="http://sniffer.site/tags/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>PPP拨号时拿到错误DNS的问题解析</title>
    <link href="http://sniffer.site/2019/07/05/PPP%E6%8B%A8%E5%8F%B7%E6%97%B6%E6%8B%BF%E5%88%B0%E9%94%99%E8%AF%AFDNS%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://sniffer.site/2019/07/05/PPP拨号时拿到错误DNS的问题/</id>
    <published>2019-07-05T09:56:32.000Z</published>
    <updated>2021-02-25T03:07:15.867Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到一个PPP拨号拿到了假的DNS地址<code>10.11.12.13/14</code>, 之前也发生过一次, 但是一直没有有效的日志, 所以就简单粗暴的做了一个方案: 在PPP拨号进行网络参数协商时, 如果发现拿到了<code>10.11.12.13/14</code>这样的DNS地址就修改为指定的运营商DNS地址. 本来以为万事大吉了, 没想到运营商DNS一改, 问题又暴露了, 好在重现抓到了现场日志, 终于找到了原因. 网上看有原来也有不少人碰到了类似现象(<a href="https://bugzilla.redhat.com/show_bug.cgi?id=467004#c31)" target="_blank" rel="noopener">https://bugzilla.redhat.com/show_bug.cgi?id=467004#c31)</a>, 在这里简要的描述下整个问题的来龙去脉并给出几种可能的解决方案.</p><p>在介绍这个问题的根因之前, 先来了解下PPP协议的一些基本概念.</p><h2 id="PPP协议介绍"><a href="#PPP协议介绍" class="headerlink" title="PPP协议介绍"></a><strong>PPP协议介绍</strong></h2><p>PPP(Point-to-Point Protocol)是在SLIP(Serial Line Internet Protocol)的基础上发展而来, 其通过在终端与远端(remote peer)之间建立一个IPPP数据链路, 将终端设备接入网络. 早些年上网的时候, 把一个<a href="https://en.wikipedia.org/wiki/Asymmetric_digital_subscriber_line" target="_blank" rel="noopener">ADSL</a> modem跟电脑连接后, 拿着运营商给的用户名与密码, 然后拨号接入互联网,这里边用到的协议就是<a href="https://en.wikipedia.org/wiki/Point-to-Point_Protocol_over_Ethernet" target="_blank" rel="noopener">PPP</a>.</p><p>PPP协议位于TCP/IP协议栈的第二层-数据链路层(见下图), 其主要有三个部分组成:</p><ul><li>包封装: 如何将网络报文如IP报文封装成类似与HDLC的格式</li><li>LCP协议: Link Control Protocol, 负责建立数据链路, 验证用户身份以及测试链路的连通状态</li><li>NCP协议: Network Control Protocol, 负责适配其他协议, 如针对IP协议有IPCP协议, 该协议的功能是从网络侧拿到IP地址以及DNS地址 </li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/PPP_stack.png" alt="PPP in TCP/IP stack"></p><p>一般来说, PPP拨号上网有如下几个阶段:</p><ul><li>链路建立阶段(Establish): LCP协议负责建立数据链路, 建立链路过程主要是协商数据的压缩格式以及最大传输单元MRU(Maximum Receive Unit, 类似于MTU)</li><li>身份验证阶段(Authenticate): 主要是通过PAP/CHAP等协议验证用户的身份(用户名与密码)</li><li>网络阶段(Network): 协商网络参数, 如IP地址, DNS地址等. 网络阶段完成后, 就可以真正进行数据报文的接发了.</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/PPP_phase_diagram.jpg" alt="PPP phone diagram"></p><p>在NCP阶段, PPP拨号进行参数协商过程中一般都有如下几个指令: <code>Configure-Request</code>(发起参数协商), <code>Configure-Ack</code>(如果同意该参数则发送ACK给对端), <code>Configure-Nak</code>(如果参数合法, 但是有不同意对方的某些参数, 则发送NAK给对端), <code>Configure-Reject</code>(如果不同意对方发送过来的参数, 则直接发送Reject), 具体可以参考RFC1661的文档(<a href="https://tools.ietf.org/html/rfc1661" target="_blank" rel="noopener">rfc1661</a>).下图是一个完整基于IPCP协议的消息交换过程:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ipcp_process.png" alt="IPCP process"></p><p>有了这些知识背景, 就来看下具体的问题是怎么样的.</p><h2 id="假DNS问题的来由"><a href="#假DNS问题的来由" class="headerlink" title="假DNS问题的来由"></a><strong>假DNS问题的来由</strong></h2><p>问题发生终端大致的网络架构如下图所示:终端通过modem与运营商的LNS节点建立一个PPP的链路, 然后通过该链路接入私有网络:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ppp_mobile_network_architecture.png" alt="ppp network architecture"></p><blockquote><p>图中的<code>LAC</code>/<code>LNS</code>分别指<code>L2TP Access Concentrator</code>/<code>L2TP Network Server</code>， 参考<a href="https://en.wikipedia.org/wiki/Layer_2_Tunneling_Protocol" target="_blank" rel="noopener">Wikipedia</a></p></blockquote><p>这里系统使用的是高通的modem, 在LTE网络下使用PPP拨号从运营商网关拿IP/DNS地址. PPP拨号时, 实际已经通过了身份验证, 但在IPCP协议进行参数协商时, 前面一直拿到了<code>10.11.12.13/14</code>这样的DNS地址, 后面运营商下发了正确的DNS地址, modem也未能把正确的DNS地址发送过来, PPPD拨号的过程日志如下, </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.024</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : <span class="keyword">using</span> channel <span class="number">3</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.024</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [LCP ConfReq id=<span class="number">0x1</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;magic <span class="number">0x6c3c9df8</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.024</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [LCP ConfReq id=<span class="number">0x3</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;auth pap&gt; &lt;magic <span class="number">0xf2cb3c8d</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.024</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [LCP ConfAck id=<span class="number">0x3</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;auth pap&gt; &lt;magic <span class="number">0xf2cb3c8d</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.024</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [LCP ConfAck id=<span class="number">0x1</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;magic <span class="number">0x6c3c9df8</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [LCP DiscReq id=<span class="number">0x4</span> magic=<span class="number">0xf2cb3c8d</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [PAP AuthAck id=<span class="number">0x1</span> <span class="string">""</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> I pppd    : PAP authentication succeeded</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [CCP ConfReq id=<span class="number">0x1</span> &lt;deflate <span class="number">15</span>&gt; &lt;deflate(old#) <span class="number">15</span>&gt; &lt;bsd v1 <span class="number">15</span>&gt;]</span><br><span class="line"><span class="comment">// IPCP开始协商IP地址, DNS地址等参数</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x1</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns3 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [LCP ProtRej id=<span class="number">0x5</span> <span class="number">80</span> fd <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0f</span> <span class="number">1</span>a <span class="number">04</span> <span class="number">78</span> <span class="number">00</span> <span class="number">18</span> <span class="number">04</span> <span class="number">78</span> <span class="number">00</span> <span class="number">15</span> <span class="number">03</span> <span class="number">2f</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">38.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x1</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">38.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x2</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">39.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x2</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">39.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x3</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">40.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x3</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">40.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x4</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">41.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x4</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">41.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x5</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">42.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x5</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">42.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x6</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">43.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x6</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">43.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x7</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">44.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x7</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">44.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x8</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x8</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x9</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="comment">// 到现在才收到远端(remote peer)的IP协商请求</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfReq id=<span class="number">0x2</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfNak id=<span class="number">0x2</span> &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfRej id=<span class="number">0x9</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0xa</span> &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfReq id=<span class="number">0x3</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfAck id=<span class="number">0x3</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0xa</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0xb</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfAck id=<span class="number">0xb</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> W pppd    : Could <span class="keyword">not</span> determine remote IP address: defaulting to <span class="number">10.64</span><span class="number">.64</span><span class="number">.64</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.654</span>  <span class="number">3183</span>  <span class="number">3183</span> I pppd    : local  IP address <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.654</span>  <span class="number">3183</span>  <span class="number">3183</span> I pppd    : remote IP address <span class="number">10.64</span><span class="number">.64</span><span class="number">.64</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.654</span>  <span class="number">3183</span>  <span class="number">3183</span> I pppd    : primary   DNS address <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.654</span>  <span class="number">3183</span>  <span class="number">3183</span> I pppd    : secondary DNS address <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.654</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : Script /etc/ppp/ip-up started (pid <span class="number">3229</span>)</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.714</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : Script /etc/ppp/ip-up finished (pid <span class="number">3229</span>), status = <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>可以看到在第一次PPP参数协商时, PPPD就收到了这样的配置, 这里<code>ms-wins</code>参数是针对微软的客户端产生的配置(在Linux系统下并没有什么作用):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">38.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x1</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br></pre></td></tr></table></figure><p>再来对比下正常的PPPD拨号的情况, PPPD拨号时首先很快就收到了<code>IPCP ConfReq id=0x0</code>的请求, 这个请求是告诉客户端可以发起IP地址的协商了, 于是客户端就发了<code>NAK</code>包告诉服务端自己的IP地址是空的<code>sent [IPCP ConfNak id=0x0 &lt;addr 0.0.0.0&gt;]</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : <span class="keyword">using</span> channel <span class="number">1</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [LCP ConfReq id=<span class="number">0x1</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;magic <span class="number">0x2d6bff1</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [LCP ConfReq id=<span class="number">0x0</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;auth pap&gt; &lt;magic <span class="number">0xf2cab769</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [LCP ConfAck id=<span class="number">0x0</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;auth pap&gt; &lt;magic <span class="number">0xf2cab769</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [LCP ConfAck id=<span class="number">0x1</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;magic <span class="number">0x2d6bff1</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [LCP DiscReq id=<span class="number">0x1</span> magic=<span class="number">0xf2cab769</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [PAP AuthAck id=<span class="number">0x1</span> <span class="string">""</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> I pppd    : PAP authentication succeeded</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [CCP ConfReq id=<span class="number">0x1</span> &lt;deflate <span class="number">15</span>&gt; &lt;deflate(old#) <span class="number">15</span>&gt; &lt;bsd v1 <span class="number">15</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x1</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns3 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [LCP ProtRej id=<span class="number">0x2</span> <span class="number">80</span> fd <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0f</span> <span class="number">1</span>a <span class="number">04</span> <span class="number">78</span> <span class="number">00</span> <span class="number">18</span> <span class="number">04</span> <span class="number">78</span> <span class="number">00</span> <span class="number">15</span> <span class="number">03</span> <span class="number">2f</span>]</span><br><span class="line"><span class="comment">// 很快收到IP地址协商请求</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [IPCP ConfReq id=<span class="number">0x0</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [IPCP ConfNak id=<span class="number">0x0</span> &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [IPCP ConfRej id=<span class="number">0x1</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x2</span> &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns3 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [IPCP ConfReq id=<span class="number">0x1</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [IPCP ConfAck id=<span class="number">0x1</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x2</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x3</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [IPCP ConfAck id=<span class="number">0x3</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> W pppd    : Could <span class="keyword">not</span> determine remote IP address: defaulting to <span class="number">10.64</span><span class="number">.64</span><span class="number">.64</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.980</span>  <span class="number">1643</span>  <span class="number">1643</span> I pppd    : local  IP address <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.980</span>  <span class="number">1643</span>  <span class="number">1643</span> I pppd    : remote IP address <span class="number">10.64</span><span class="number">.64</span><span class="number">.64</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.980</span>  <span class="number">1643</span>  <span class="number">1643</span> I pppd    : primary   DNS address <span class="number">211.</span>xxx.xxx.xxx</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.980</span>  <span class="number">1643</span>  <span class="number">1643</span> I pppd    : secondary DNS address <span class="number">211.</span>xxx.xxx.xxx</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.980</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : Script /etc/ppp/ip-up started (pid <span class="number">1682</span>)</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">02.060</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : Script /etc/ppp/ip-up finished (pid <span class="number">1682</span>), status = <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>接着又发了一个地址配置的请求, 在收到服务端的配置后,并相互确认后最终拿到了正确的IP地址/DNS地址:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sent [IPCP ConfReq id=<span class="number">0x2</span> &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns3 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line">rcvd [IPCP ConfNak id=<span class="number">0x2</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br><span class="line">sent [IPCP ConfReq id=<span class="number">0x3</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br><span class="line">rcvd [IPCP ConfAck id=<span class="number">0x3</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br></pre></td></tr></table></figure><p>单纯从PPPD拨号的LOG来看, 流程上就有不小的差异: 异常情况迟迟收不到远端(这里就是运营商的服务器)的IP地址协商的请求<code>ConfReq</code>, 而发出去的<code>IPCP ConfReq</code>参数协商请求一直拿到了假的DNS地址<code>10.11.12.13/14</code>(这个地址实际是modem产生的不是来自网络), 对端回过来的地址一直都是全零<code>0.0.0.0</code>, 导致客户端一直发送<code>ConfReq</code>,直到远端(remote peer)的<code>NAK</code>超过最大的次数(PPPD代码默认是5)后,才停止DNS的协商过程(看pppd的代码是默认关闭了对DNS的协商请求).</p><p>那么问题的根源在哪里了? 抓了modem的日志给供应商分析才发现, 本端(local peer)在PDN(Packet Data Network)数据链接尚未建立的情况下(相当于终端与运营商还没有建立物理上的通路)就去发起IPCP参数协商了, 此时modem还没有拿到IP地址和DNS地址, 因此就给了一个假的DNS地址了. 等到几秒钟后PDN建立成功, 运营商网络正常下发分配的IP地址与DNS地址后, modem却没有主动下发正确的DNS地址, 而本端的pppd也没有再次请求DNS地址, 这样到了PPP拨号完成本地拿到的始终是一个假的DNS地址.</p><p>找到了问题的原因之后, 解决问题就好办了. 大概有这么几个解决方案:</p><ol><li>在modem侧修改: 如果PDN链接建立成功后, 主动下发正确的DNS地址(运营商给的DNS地址)</li><li>在本端的PPPD中修改: 如果发现拿到的DNS地址为<code>10.11.12.13/14</code>, 则在接收到远端的<code>NAK</code>时将该地址拒绝, 并且在下次参数协商时主动告诉远端自己没有拿到DNS地址, 这样远端会在下一个<code>NAK</code>中主动将正确的DNS发送过来(如果已经有了的话)</li><li>在PPPD拨号时将参数<code>connect-delay</code>设置为<code>5000</code>(5s, 默认是<code>1000</code>), 这个相当于尽量等待PDN的链接, 等成功后再进行参数协商. 这个方案只能在一定程度上缓解问题发生的概率, 并不能从根本上解决问题.</li><li>如果收到假的DNS地址<code>10.11.12.13/14</code>, 则强制修改为正确的运营商DNS地址(如果运营商DNS地址发生变化, 又会出问题, 不是终极解决方案)</li></ol><p>目前采用了方案二, 初步验证可以拿到正确的DNS地址.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近碰到一个PPP拨号拿到了假的DNS地址&lt;code&gt;10.11.12.13/14&lt;/code&gt;, 之前也发生过一次, 但是一直没有有效的日志, 所以就简单粗暴的做了一个方案: 在PPP拨号进行网络参数协商时, 如果发现拿到了&lt;code&gt;10.11.12.13/14&lt;/co
      
    
    </summary>
    
      <category term="网络协议" scheme="http://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="PPP" scheme="http://sniffer.site/tags/PPP/"/>
    
      <category term="DNS" scheme="http://sniffer.site/tags/DNS/"/>
    
  </entry>
  
</feed>
