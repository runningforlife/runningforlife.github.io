<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasonWang&#39;s Blog</title>
  
  <subtitle>本色做人，角色做事</subtitle>
  <link href="https://sniffer.site/atom.xml" rel="self"/>
  
  <link href="https://sniffer.site/"/>
  <updated>2024-01-31T12:52:12.564Z</updated>
  <id>https://sniffer.site/</id>
  
  <author>
    <name>Jason Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你好,2024</title>
    <link href="https://sniffer.site/2024/01/30/%E4%BD%A0%E5%A5%BD,2024/"/>
    <id>https://sniffer.site/2024/01/30/%E4%BD%A0%E5%A5%BD,2024/</id>
    <published>2024-01-29T23:08:50.000Z</published>
    <updated>2024-01-31T12:52:12.564Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Nothing is easier than self-deceit. For what each man wishes, that he also believes to be true(人们善于自欺，人们想得到什么，就会相信什么)</p><p>  德摩斯梯尼（Demosthenes，古希腊）</p></blockquote><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/new-year-fireworks.jpg" alt="new year fireworks"></p><span id="more"></span><p>一晃眼，2024年已经过去一个月了，一直想写下2023年的总结，却因为各种事情迟迟没有动笔。2023发生了太多事情，想说点什么，却又无从说起。回想起来，各种事情却又历历在目:</p><ul><li>母亲今年开始一直开始头痛，国庆期间抽空回老家陪老妈去了一趟医院，所幸的是检查结果是良性的血管瘤，并没有大碍，修理调养下应该问题不大。这件事让我真正感到所谓上有老，下有小的压力与责任。</li><li>小宝贝开始进入幼儿园学习了，开始了全新的阶段，总体上说，她适应的不错，事实证明很多之前的担忧都是多余的；在陪伴小宝贝成长的过程中，我逐渐意识到，很多发生在儿女身上的问题，往往不是她自身有什么问题，问题的本质来源于家庭，来源于父母自己，来源于错误的观念。如果我多尝试站在女儿的角度思考某些问题，重新审视很多的事情，许多所谓的问题都会烟消云散。父母与儿女的冲突根源在于权力的不对等，为人父母总想用自己所谓的权威与身体上的强大来压制儿女的某些行为，结果只会让彼此更痛苦、难受。真正的爱首先是接纳，然后是理解与包容。我爱小宝贝，那么，我首先需要做的是接纳她的个性，接纳她身上所谓的<code>毛病</code>，然后理解她，用真情真心去陪伴她一起成长。我需要融入她的生活与思维，忘掉烙印在自己身上的各种身份，做一个引路人而不是主导者。</li><li>去年下旬，业内的一个技术大佬左耳朵耗子叔因为突发心肌梗塞去世了，真的非常难以置信，；他去世前几天我还在看他的博文，字里行间可以感受到他对于技术的热爱，没料到翌日人就没了，真是伤心又难过。不得不感慨，人的生命其实非常的脆弱，步入中年，身体在长年累月的工作与压力之下，是疾病的高发期。这也给我们做技术的人一个警醒，工作挣钱固然重要，更重要的是有一个健康的身体。</li><li>想了很久，还是离开了工作多年的公司，见证了公司曲折的创业历程，经历了从第一个产品推出到公司上市，非常难得的经历，有许多的不舍，但是考虑到自己职业生涯的发展，还是决定跳出当前的技术舒适圈，去寻求更大的突破。祝愿公司在未来的发展中百舸争流，再创辉煌。</li><li>阅读量较之前多了不少，可回想来看，阅读质量却没有太多的提升。印象比较深的是&lt;稻盛和夫的哲学&gt;、&lt;哲学之树-通往自我认知的哲学课&gt;、&lt;思考快与慢&gt;、&lt;史蒂夫-乔布斯传&gt;、&lt;认识大脑-关于大脑的7 1&#x2F;2课&gt;，其他的则只有一些很模糊的印象。阅读，在很大程度上是作者与读者之间的心灵交流，如果两方的思维方式差异较大，有时确实很难真正理解书中的思想与观点；总结下来，想要提升阅读的质量，一方面是要提升阅读技巧，要学会做阅读笔记，把阅读时的所思所想都记录下来；更多的还是要改善自己的思维方式，变换自己的观念，才能真正有所收获。</li></ul><p>生活曲曲折折，2023思考更多的是活着的意义与人生而为人的价值。前段时间看辽宁的一个名叫柏剑老师，十年如一日坚持不懈通过体育锻炼来培养一群问题少年的故事，十分感慨；与此同时，又看到某地的贪官私藏大量现金的新闻。联系起来看，不禁要问，人与人之间何以有如此大的差异了？从本质上来说，这些抉择的背后体现的就是一个人的价值观与世界观。这眼花缭乱的世界，一个人生命的意义与价值究竟在哪里？</p><p>如果从整个宇宙范围来说，人生其实是没有意义的，所有的意义都会指向一个空-即死亡；死亡之后，就是空，就是虚无。但人活着，有荷尔蒙，便会有欲望，有好奇心，有探索的渴求，正是身体里的这些化学的荷尔蒙驱动了我们的行为，塑造着我们独特的个性。回到生活本身，如果我们只是为身体的荷尔蒙驱使，被自己的意识与观念驱动，那本质上来说，我们只是自己的思维与欲望的囚徒，一个困在自然进化牢笼中的囚徒而已。欲望是一种枷锁，所有通过努力来获取到的财富、金钱、地位、名利以及身体的满足都是一种无形的枷锁，如果我们不去反思，不假思索的接受现实，无疑我们是在自我欺骗罢了。譬如，那些拼了命捞钱的贪官污吏，财迷心窍，最终也不过是让金钱、名利困住，成为一个监守自盗的人；那些努力通过流量与各种宣传话术来挣钱的主播，一旦丧失自己的内心的道德底线，最终不过是给自己戴上一个牢笼而已。</p><p>生命也好，生活也罢，真正难的是平衡，是平衡的智慧；是内心里对于现实的认知的平衡，不自欺，不自弃。做到不自欺，不自弃，我们才有可能真正迈向智慧的台阶，让自己生活快乐、轻松、淡定，平和。面向2024，也希望自己能做到不自欺，不自弃，踏踏实实过好每一天，成为一个更好的父亲，一个更好的老公，一个更好的人。以下几点自勉，与大家共勉。</p><ul><li>学会爱:不仅仅是要爱身边的人，也要学会爱自己；学会感受别人的爱，学会感受自然的一切馈赠。培养的爱的能力，保持自省与自律，做一个有智慧的人。</li><li>发现价值，创造价值: 工作不仅仅是赚取一份收入，也是体现自我价值的地方。做一件事，不能只关注短期的收益，也要努力思考背后的价值，看到背后更长远的收益；保持开放的视野，点滴积累，厚积薄发。</li><li>读书与思考：阅读让人平静，在如今被各种短视频充斥的媒体时代，时间被割裂成碎片，我们已很难专注的进行深度思考。多去阅读，保持思考，保持定力。</li><li>发现身体的价值: 在思维与认知上倾注了太多的精力、时间，身体太容易被忽略；只有当身体出现各种疾病症状时，我们才可能意识到身体的价值。人到中年，见多了生老病死，才慢慢发现，身体的价值可能远比想象的要大。我们要关注身体的信号，减少对身体的消耗-熬夜、通宵、不运动、饮食规律。要学着做身体的朋友，关心她，呵护她。</li></ul><p>2023，再见；你好，2024！</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;Nothing is easier than self-deceit. For what each man wishes, that he also believes to be true(人们善于自欺，人们想得到什么，就会相信什么)&lt;/p&gt;
&lt;p&gt;  德摩斯梯尼（Demosthenes，古希腊）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://md-files.oss-cn-shenzhen.aliyuncs.com/new-year-fireworks.jpg&quot; alt=&quot;new year fireworks&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="https://sniffer.site/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="成长" scheme="https://sniffer.site/tags/%E6%88%90%E9%95%BF/"/>
    
    <category term="价值" scheme="https://sniffer.site/tags/%E4%BB%B7%E5%80%BC/"/>
    
    <category term="探索" scheme="https://sniffer.site/tags/%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>认识你的大脑</title>
    <link href="https://sniffer.site/2023/11/26/%E8%AE%A4%E8%AF%86%E4%BD%A0%E7%9A%84%E5%A4%A7%E8%84%91/"/>
    <id>https://sniffer.site/2023/11/26/%E8%AE%A4%E8%AF%86%E4%BD%A0%E7%9A%84%E5%A4%A7%E8%84%91/</id>
    <published>2023-11-26T04:37:04.000Z</published>
    <updated>2023-11-28T01:17:22.658Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>If we spoke a different language, we would perceive a somewhat differenet world.</p><pre><code>Ludwig Wittgenstein</code></pre></blockquote><p> <img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/high-tech-brain.jpg" alt="Your high tech brain"></p> <span id="more"></span><p> 一直对大脑的构造与运作机制比较感兴趣，想花点时间了解人类思维与意识的奥秘。前段时间，从图书馆借了<code>Eisa Feldman Barrett</code>写的一本比较薄的有关大脑的书<code>认识大脑-关于大脑的7 1/2堂课</code>，通俗易懂，也澄清了认知上的一些误解与疑惑。基于这本书的内容，结合自己这几年的思考与经历，有一些想法与心得，在这里一并写下来。有很多地方比较粗浅，有错误的地方，还请大家指正。</p><blockquote><p>我们的每一个想法，每一种快乐、愤怒或者敬畏的感觉，我们给予或者接受的每一个拥抱，释放的每一个善意，承受的每一次侮辱，都类似从身体预算中存款或者取款，我们往往意识不到，而实际一切都在发生。认清这一点，对理解大脑如何工作，以及如何保持健康，活的更长，更有意义至关重要。</p></blockquote><p>大脑的诞生并不是用于思考的，大脑是为生存而演化出来的复杂计算系统。在几亿年前，地球上并不存在有大脑的生物；当时的海洋中，有文昌鱼这种无脊椎动物，它们的神经系统非常单一，仅有一小团细胞（并不能称为大脑）；没有味觉与嗅觉器官，文昌鱼就是靠着简单的感知能力在海底生存了近5.5亿年。那么，地球上为什么会出现有大脑的生物了？进化论认为，这是源自生物的生存竞争与自然选择。在激烈的生存竞争中，那些拥有更快反应速度、更强大感知能力、更高的能效比的生物具备更好的生存能力，有更大的几率生存下来；而大脑正是用于调节生物内部能量效率的计算中心。对人类来说同样如此，大脑首先是一个为生存而演化出来的器官。人类的大脑会准确预算每个行为需要消耗的能量，为每个行为储备水、盐和葡萄糖等资源：你所采取的每一步行动都是一种带有经济考虑的选择-大脑会预测什么时候消耗资源，什么时候节省资源。所有动物，包括人类都学会了从过去的行为中学习如何预测下一次行动，如果过去的行为带来了好处，比如一次成功的逃脱或享受一顿美餐，那么它们就会重复过去的行为；大脑会通过某种方式唤起过去的经历，让身体为行动做好准备。</p><blockquote><p>柏拉图认为，人类的思维是一场三股不同力量之间持续不断地战争: 第一股力量是生存，代表饥饿与身体的欲望；第二股力量是情绪，如喜悦、愤怒和恐惧；第三种力量是理性思维。后来，有科学家根据这一类观点发展出三重脑理论，认为人的大脑有三层，一层负责生存（对应脑干），一层用来感受（对应边缘系统），一层用来思考（对应新皮质）。</p></blockquote><p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/three-brain-theory.png" alt="三重大脑结构"></p><p>单纯就大脑的大小，人类的大脑确实比一般的动物，如老鼠，鱼类，蜥蜴，猕猴都要大得多，结构上也似乎不太相同。但最近的科学研究发现，所有哺乳动物的大脑发育都遵从同一个计划（爬行动物与其他脊椎动物的大脑也可能遵从类似的构造模式）：哺乳动物的大脑神经元的形成顺序是可预测的。区分在于，不同动物在构造的不同阶段所花费的时间不同而已，不同部分的大脑大小不一样罢了。因此，我们会看到人类有一个很大的新皮质，而老鼠的相对比较小。从这个角度来说，人类的大脑没有新增的部分-我们大脑中的神经元不仅可以在其他哺乳动物的大脑中发现，也可以在其他脊椎动物中被找到。人类的大脑并没有特别的地方；人类只是一种有趣的动物，具有特殊的适应性，帮助我们在特定的环境中生存与竞争。但自然界的其他动物表现的并不比人类差，如鸟可以飞，细菌则可以在恶劣的环境中存活。</p><p>那么，我们常说的理性又究竟是怎么回事？传统上，理性的行为是指不受情绪干扰-思维被认为是理性的，而情绪则被认为是非理性的。但事实并非如此。思维有时并非总是理性的。比如连续刷了几个小时抖音，你安慰自己发现了很多有趣的东西。因此，书中作者将理性定义为：身体预算-对我们每天所需的水、盐、葡萄糖和其他身体资源的管理；它意味着在特定情况下进行良好的身体预算投资。</p><blockquote><p>大脑是一个复杂的网络，由多达1280亿个神经元组成；神经元之间通过树突相互连接，通过突触来传递信号。这种复杂的神经元网络让大脑具备高度的复杂性，让大脑具备更高的容错能力与抗损伤能力，这也是人类创造性的源泉。与其他很多动物不同的是，人在刚出生时，虽然神经元的数量两倍于成年人的大脑，但神经元的连接只是完成了一部分，人类需要在后面长达25年的时间内不断完善、构造神经元的连接-新的连接被创建、不断调整，多余的连接则会被<code>修剪</code>掉。</p></blockquote><p>大脑神经元网络的复杂性所涌现出的能力，不禁让我联想起最近人工智能领域的<code>chatGPT</code>： 一个类神经元网络在数据与参数大到一定程度后所展现出的潜能让人惊讶不已。原本，人类可能需要通过正向分析大脑的整个构造过程才能解开智能的真正奥秘，如今通过<code>chatGPT</code>这种大模型技术，我们可能从另外一个角度破解智能的本质。但在此真正的通用人工智能出现之前，人还是要努力思考下，是什么让一个人具备了不一样的独特性？或者说，我们应该怎么做才能让一个婴儿能够变得更聪明，更有创造力，更有责任感与道德心？一个婴儿，刚出生时大脑连接尚未完成，理论上具备无限的可能。我们每一个人都应该重视对儿童的关心与爱护；整个社会要努力去营造一个让儿童健康成长的环境，这种付出成本较小，但是收益却是大的多：一个健康、智慧而有责任心的公民会为未来的社会带来可靠的价值，而一个在不幸与贫穷中长大的儿童则可能成长为一个愤世嫉俗、无所事事、毫无责任与道德感的人，这只会增加社会的成本。</p><blockquote><p>大脑是一个预测器官，它会根据过去的经验来对当前感知到的现实进行判断，从而做出预测；在我们做出某个行为之前，大脑实际上已经做了预测。什么在塑造我们的大脑神经元的构造？除了先天基因之外，家庭、教育、社会文化都在潜移默化中塑造一个人的大脑连接的回路。正是大脑神经元连接的多样性，塑造了丰富多彩的人类文明，让每个个体都具有独特的个性，使我们具备了与其他动物不一样的能力-创造社会现实。大脑通过创造力、沟通、模仿、合作以及压缩（总结信息，删除冗余）来构造人类独有的社会文化，让人类成为一个社会性的物种。</p></blockquote><p>是什么在塑造我们的大脑（心灵）？又是什么力量让人形成了对自我、他人以及社会的观念与看法？同样的一件事，每个人都会有自己的一套想法与思维方式；我们每一天的行为的驱动力又来自哪里？如果大脑的连接已经被过去的经验所塑造，我们改变不了过去，那么是否意味着我们也没法改变现状，没有拥有改变自我的意志与力量？但实际情况并非如此-我们可以改变自我。我们无法改变我们的家庭，无法改变身边的人，无法改变社会现实，但可以通过努力来改变大脑的连接方式，改变大脑对于外界的行为预测。比如，你可能在公众面前演讲比较紧张，通过足够的练习与反馈，你可以获得这一技能，从而让自己适应这种状态-在众人面前讲话做到放松自如。这就是大脑的潜能，作为大脑的主人，只要学会利用这种控制的权利，承担起改变的责任，那么，通过足够的努力与学习，我们就可以达成自己想要实现的目标。改变的前提是，我们要放下当前大脑固有连接所带来的认知与思维模式，换一种不一样的角度来看待当前的现实，从而调整大脑对于固有行为的预测，进而改变自我，完成新大脑神经元连接的塑造。</p><p>但在一个由各种类型连接的大脑塑造的社会现实中，我们不仅仅要面对自我，也要面对他人，以及形态各异的社会壁垒。我们渴望改变自我，但与此同时也受限于社会关系；我们要改变自我，那么不得不去与他人合作，与他人达成协作的关系。所谓<code>他人即天堂，他人即地狱</code>，与他人（家庭、同事、朋友）建立良好健康的关系，可以帮助我们重塑自我，让我们获得成长的动力，过得幸福、快乐与满足；反之，他人可能会成为吞噬自我的地狱，让我们陷入挣扎与纠缠的泥潭。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;If we spoke a different language, we would perceive a somewhat differenet world.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ludwig Wittgenstein
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt; &lt;img src=&quot;https://md-files.oss-cn-shenzhen.aliyuncs.com/high-tech-brain.jpg&quot; alt=&quot;Your high tech brain&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="社会万象" scheme="https://sniffer.site/categories/%E7%A4%BE%E4%BC%9A%E4%B8%87%E8%B1%A1/"/>
    
    
    <category term="哲学" scheme="https://sniffer.site/tags/%E5%93%B2%E5%AD%A6/"/>
    
    <category term="大脑" scheme="https://sniffer.site/tags/%E5%A4%A7%E8%84%91/"/>
    
    <category term="人生" scheme="https://sniffer.site/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Android常用的性能分析工具</title>
    <link href="https://sniffer.site/2023/10/20/Android%E5%B8%B8%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
    <id>https://sniffer.site/2023/10/20/Android%E5%B8%B8%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</id>
    <published>2023-10-20T03:45:04.000Z</published>
    <updated>2023-10-20T03:57:31.038Z</updated>
    
    <content type="html"><![CDATA[<p>在Android系统开发过程中，经常碰到CPU占用率高、内存泄露、内存占用高等性能相关的问题，这时通常需要抓取系统的<code>trace</code>日志，用以查看进程的CPU占用，内存分配等情况。怎么抓取系统trace， 这时一般需要用到系统性能相关的分析工具。这篇文章就以<code>Android S</code>为例，说明Android开发中常用的一些性能优化工具的使用方法，主要包括如下几个工具:</p><span id="more"></span><ul><li>atrace</li><li>systrace</li><li>dumpsys</li><li>simpleperf</li><li>perfetto</li><li>Android Profiler</li></ul><h2 id="atrace"><a href="#atrace" class="headerlink" title="atrace"></a><strong>atrace</strong></h2><p><code>atrace</code>是<code>Android</code>系统的自带的一个抓取<code>systrace</code>的工具，不仅可用于抓取系统服务的状态，如<code>input</code>、<code>SurfaceFlinger</code>、<code>Window Manager</code>等，也可以用于抓取内核的<code>trace</code>日志，如<code>CPU</code>调度、<code>irq</code>中断、内存等信息, 具体支持那些类型的<code>trace</code>日志，可以通过<code>adb shell atrace --list_categories</code>查看。</p><blockquote><p>对<code>atrace</code>实现感兴趣的同学，可以查看<code>frameworks/native/cmds/atrace</code>的代码</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">usage: atrace [options] [categories...]</span><br><span class="line">options include:</span><br><span class="line">-a appname      <span class="built_in">enable</span> app-level tracing <span class="keyword">for</span> a comma separated list of cmdlines; * is a wildcard matching any process</span><br><span class="line">-b N            use a trace buffer size of N KB</span><br><span class="line">-c              trace into a circular buffer</span><br><span class="line">-f filename     use the categories written <span class="keyword">in</span> a file as space-separated</span><br><span class="line">                    values <span class="keyword">in</span> a line</span><br><span class="line">-k fname,...    trace the listed kernel <span class="built_in">functions</span></span><br><span class="line">-n              ignore signals</span><br><span class="line">-s N            <span class="built_in">sleep</span> <span class="keyword">for</span> N seconds before tracing [default 0]</span><br><span class="line">-t N            trace <span class="keyword">for</span> N seconds [default 5]</span><br><span class="line">-z              compress the trace dump</span><br><span class="line">--async_start   start circular trace and <span class="built_in">return</span> immediately</span><br><span class="line">--async_dump    dump the current contents of circular trace buffer</span><br><span class="line">--async_stop    stop tracing and dump the current contents of circular</span><br><span class="line">                    trace buffer</span><br><span class="line">--stream        stream trace to stdout as it enters the trace buffer</span><br><span class="line">                    Note: this can take significant CPU time, and is best</span><br><span class="line">                    used <span class="keyword">for</span> measuring things that are not affected by</span><br><span class="line">                    CPU performance, like pagecache usage.</span><br><span class="line">--list_categories</span><br><span class="line">                list the available tracing categories</span><br><span class="line">-o filename      write the trace to the specified file instead</span><br><span class="line">                    of stdout.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如，如果我们想查看<code>SurfaceFlinger</code>（对应的类型未<code>gfx</code>）,可以再设备上执行如下命令抓取(默认只抓取5s的记录):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">atrace gfx irq <span class="built_in">sched</span> &gt; /data/gfx.trace</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把抓取到的<code>gfx.trace</code>文件拉到本地，然后使用<a href="https://ui.perfetto.dev/"><code>perfetto</code></a>工具打开即可查看。</p><h2 id="systrace"><a href="#systrace" class="headerlink" title="systrace"></a>systrace</h2><p>与<code>atrace</code>类似，<code>systrace</code>也是一个用于抓取系统<code>trace</code>日志的工具（适用于Android4.3以后的所有版本），不过<code>systrace</code>通过一个<code>python</code>脚本将抓取到的日志转换成<code>html</code>的可视化格式，这样就可以通过在<code>chrome</code>浏览器中输入<code>chrome://tracing/</code>，然后将对应的<code>html</code>加载即可浏览。</p><blockquote><p><code>systrace.py</code>工具可以通过<code>google</code>的网站下载或者再<code>SDK</code>中下载；如果是<code>SDK</code>，可以在<code>platform-tools/systrace</code>中找到对应的脚本</p></blockquote><p>通过<code>python2.7 systrace.py -h</code>查看具体的命令说明:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Usage: systrace.py [options] [category1 [category2 ...]]</span><br><span class="line"></span><br><span class="line">Example: systrace.py -b 32768 -t 15 gfx input view <span class="built_in">sched</span> freq</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -h, --<span class="built_in">help</span>            show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  -o FILE               write HTML to FILE</span><br><span class="line">  -t N, --time=N        trace <span class="keyword">for</span> N seconds</span><br><span class="line">  -b N, --buf-size=N    use a trace buffer size of N KB</span><br><span class="line">  -k KFUNCS, --ktrace=KFUNCS</span><br><span class="line">                        specify a comma-separated list of kernel <span class="built_in">functions</span> to</span><br><span class="line">                        trace</span><br><span class="line">  -l, --list-categories</span><br><span class="line">                        list the available categories and <span class="built_in">exit</span></span><br><span class="line">  -a APP_NAME, --app=APP_NAME</span><br><span class="line">                        <span class="built_in">enable</span> application-level tracing <span class="keyword">for</span> comma-separated</span><br><span class="line">                        list of app cmdlines</span><br><span class="line">  --link-assets         <span class="built_in">link</span> to original CSS or JS resources instead of</span><br><span class="line">                        embedding them</span><br><span class="line">  --from-file=FROM_FILE</span><br><span class="line">                        <span class="built_in">read</span> the trace from a file (compressed) rather than</span><br><span class="line">                        running a live trace</span><br><span class="line">  --asset-dir=ASSET_DIR</span><br><span class="line">  -e DEVICE_SERIAL, --serial=DEVICE_SERIAL</span><br><span class="line">                        adb device serial number</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如可以通过如下命令抓取图形、输入以及调度相关的<code>systrace</code>日志:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">python2<span class="number">.7</span> systrace.py systrace.py -b <span class="number">32768</span> -t <span class="number">15</span> gfx input view sched freq</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认会抓取15s的日志，然后自动保存到一个<code>trace.html</code>的HTLM文件中；这个问题我们可以通过在<code>Chrome</code>浏览器中输入<code>chrome://tracing/</code>查看，也可以使用<a href="https://ui.perfetto.dev/"><code>perfetto</code></a>进行日志的浏览分析。</p><p>更多的使用规则可以参考<a href="https://stuff.mit.edu/afs/sipb/project/android/docs/tools/help/systrace.html">systrace usage</a></p><h2 id="dumpsys"><a href="#dumpsys" class="headerlink" title="dumpsys"></a>dumpsys</h2><p><code>dumpsys</code>是<code>Android</code>自带的一个工具，除了用于<code>dump</code>系统中注册的服务状态外，还可以用于各个进出的CPU占用、内存分配等情况，在分析一些系统的问题可能会有帮助:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">usage: dumpsys</span><br><span class="line">         To dump all services.</span><br><span class="line">or:</span><br><span class="line">       dumpsys [-t TIMEOUT] [--priority LEVEL] [--pid] [--thread] [--<span class="built_in">help</span> | -l | --skip SERVICES | SERVICE [ARGS]]</span><br><span class="line">         --<span class="built_in">help</span>: shows this <span class="built_in">help</span></span><br><span class="line">         -l: only list services, <span class="keyword">do</span> not dump them</span><br><span class="line">         -t TIMEOUT_SEC: TIMEOUT to use <span class="keyword">in</span> seconds instead of default 10 seconds</span><br><span class="line">         -T TIMEOUT_MS: TIMEOUT to use <span class="keyword">in</span> milliseconds instead of default 10 seconds</span><br><span class="line">         --pid: dump PID instead of usual dump</span><br><span class="line">         --thread: dump thread usage instead of usual dump</span><br><span class="line">         --proto: filter services that support dumping data <span class="keyword">in</span> proto format. Dumps</span><br><span class="line">               will be <span class="keyword">in</span> proto format.</span><br><span class="line">         --priority LEVEL: filter services based on specified priority</span><br><span class="line">               LEVEL must be one of CRITICAL | HIGH | NORMAL</span><br><span class="line">         --skip SERVICES: dumps all services but SERVICES (comma-separated list)</span><br><span class="line">         SERVICE [ARGS]: dumps only service SERVICE, optionally passing ARGS to it</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果我们只需要<code>dump</code>部分服务，可以先<code>dumpsys -l</code>获取到当前的服务列表, 然后保存对应的服务的<code>dump</code>日志:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dumpsys SurfaceFlinger</span><br><span class="line"></span><br><span class="line">dumpsys cpuinfo</span><br><span class="line"></span><br><span class="line">dumpsys meminfo</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="simpleperf"><a href="#simpleperf" class="headerlink" title="simpleperf"></a>simpleperf</h2><p><code>simpleperf</code>是Android原生自带的一个用于采集APP或者系统日志的分析工具，其实际上包含了一系列工具库，包括可以在Android Native的直接运行的工具<code>simpleperf</code>；可以在PC上执行的脚本集合，包括生成火焰图的<code>inferno.py</code>, 用于分析APP（包括Native进程）的<code>app_profile.py</code>，所有的这些包括源代码都可以在AOSP的源代码仓库路径<code>system/extras/simpleperf</code>中找到。</p><p>先来看下如何使用<code>simpleperf</code>在Android本地上抓取分析的日志(如果没有<code>simpleperf</code>，可以到<code>simpleperf</code>目录下载或者自行编译一个push到系统中)；输入<code>simpleperf -h</code>查看使用说明:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Usage: simpleperf [common options] subcommand [args_for_subcommand]</span><br><span class="line">common options:</span><br><span class="line">    -h/--help     Print this <span class="built_in">help</span> information.</span><br><span class="line">    --<span class="built_in">log</span> &lt;severity&gt; Set the minimum severity of logging. Possible severities</span><br><span class="line">                     include verbose, debug, warning, info, error, fatal.</span><br><span class="line">                     Default is info.</span><br><span class="line">    --log-to-android-buffer  Write <span class="built_in">log</span> to android <span class="built_in">log</span> buffer instead of stderr.</span><br><span class="line">    --version     Print version of simpleperf.</span><br><span class="line">subcommands:</span><br><span class="line">    api-collect         Collect recording data generated by app api</span><br><span class="line">    api-prepare         Prepare recording via app api</span><br><span class="line">    debug-unwind        Debug/test offline unwinding.</span><br><span class="line">    dump                dump perf record file</span><br><span class="line">    <span class="built_in">help</span>                <span class="built_in">print</span> <span class="built_in">help</span> information <span class="keyword">for</span> simpleperf</span><br><span class="line">    inject              parse etm instruction tracing data</span><br><span class="line">    kmem                collect kernel memory allocation information</span><br><span class="line">    list                list available event types</span><br><span class="line">    merge               merge multiple perf.data into one</span><br><span class="line">    monitor             monitor events and <span class="built_in">print</span> their textual representations to stdout</span><br><span class="line">    record              record sampling info <span class="keyword">in</span> perf.data</span><br><span class="line">    report              report sampling information <span class="keyword">in</span> perf.data</span><br><span class="line">    report-sample       report raw sample information <span class="keyword">in</span> perf.data</span><br><span class="line">    <span class="built_in">stat</span>                gather performance counter information</span><br><span class="line">    trace-sched         Trace system-wide process runtime events.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里比较关键的两个命令是<code>simpleperf record/report</code>, <code>record</code>命令用于抓取进程的<code>perf</code>数据，而<code>report</code>指令则用于展示抓取到的<code>perf.data</code>，比如我们用如下命令抓取某个进程的分析日志:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># perf.data会保存在该目录</span></span><br><span class="line"><span class="built_in">cd</span> /data</span><br><span class="line"></span><br><span class="line">simpleperf record -p 1047 --duration 10</span><br><span class="line"></span><br><span class="line">simpleperf report</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了在Android查看<code>perf.data</code>之外，也可以将<code>perf.data</code>的数据保存到PC上，用<code>scripts</code>下面的<code>report_html.py</code>脚本以网页的形式查看结果, 只需要执行<code>./report_html.py -i perf.data</code>，脚本就会自动解析日志并在浏览器中展示一个HTML形式的报告。</p><p><code>simpleperf</code>里边还有一个很有趣的工具<code>inferno.sh</code>，可以一个指令快速生成火焰图：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">./inferno.sh --pid 2481 --title system</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行后会自动生成一个对应进程调用链的<a href="https://www.brendangregg.com/flamegraphs.html">火焰图</a>，然后在浏览器中查看各个线程执行的调用堆栈。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/simpleperf-flamegraph.png" alt="flamegraph"></p><p>另外我们还可以通过<code>simpleperf</code>来获取某个进程内核的<code>CPU</code>占用以及指令执行的统计信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Stat using default events (cpu-cycles,instructions,...), and monitor process 7394 for 10 seconds.</span></span><br><span class="line">$ simpleperf <span class="built_in">stat</span> -p 7394 --duration 10</span><br><span class="line">Performance counter statistics:</span><br><span class="line"></span><br><span class="line"><span class="comment">#         count  event_name                # count / runtime</span></span><br><span class="line">     16,513,564  cpu-cycles                <span class="comment"># 1.612904 GHz</span></span><br><span class="line">      4,564,133  stalled-cycles-frontend   <span class="comment"># 341.490 M/sec</span></span><br><span class="line">      6,520,383  stalled-cycles-backend    <span class="comment"># 591.666 M/sec</span></span><br><span class="line">      4,900,403  instructions              <span class="comment"># 612.859 M/sec</span></span><br><span class="line">         47,821  branch-misses             <span class="comment"># 6.085 M/sec</span></span><br><span class="line">  25.274251(ms)  task-clock                <span class="comment"># 0.002520 cpus used</span></span><br><span class="line">              4  context-switches          <span class="comment"># 158.264 /sec</span></span><br><span class="line">            466  page-faults               <span class="comment"># 18.438 K/sec</span></span><br><span class="line"></span><br><span class="line">Total <span class="built_in">test</span> time: 10.027923 seconds.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多详情可以参考<a href="https://android.googlesource.com/platform/system/extras/+/master/simpleperf/doc/executable_commands_reference.md">simpleperf usage</a>或者AOSP中的代码目录<code>system/extras/simpleperf</code>。</p><h2 id="perfetto"><a href="#perfetto" class="headerlink" title="perfetto"></a>perfetto</h2><p><a href="https://perfetto.dev/"><code>perfetto</code></a>是Google开源的用于系统性能分析、Trace日志抓取的工具，是一个综合了Trace日志抓取、分析以及UI展示的工具链。<code>perfetto</code>采集的数据主要来自<code>ftrace</code>(收集内核信息)，<code>atrace</code>(收集服务与应用的Trace日志)以及<code>heapprofd</code>(用于收集APP的内存使用情况)；Android 10以后的版本都默认集成了一个<code>perfetto</code>的可执行程序用于Trace的抓取:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Usage: perfetto</span><br><span class="line">  --background     -d      : Exits immediately and continues tracing <span class="keyword">in</span></span><br><span class="line">                            background</span><br><span class="line">  --config         -c      : /path/to/trace/config/file or - <span class="keyword">for</span> stdin</span><br><span class="line">  --out            -o      : /path/to/out/trace/file or - <span class="keyword">for</span> stdout</span><br><span class="line">  --upload                 : Upload field trace (Android only)</span><br><span class="line">  --dropbox        TAG     : DEPRECATED: Use --upload instead</span><br><span class="line">                            TAG should always be <span class="built_in">set</span> to <span class="string">&#x27;perfetto&#x27;</span></span><br><span class="line">  --no-guardrails          : Ignore guardrails triggered when using --upload</span><br><span class="line">                            (<span class="keyword">for</span> testing).</span><br><span class="line">  --txt                    : Parse config as pbtxt. Not <span class="keyword">for</span> production use.</span><br><span class="line">                            Not a stable API.</span><br><span class="line">  --reset-guardrails       : Resets the state of the guardails and exits</span><br><span class="line">                            (<span class="keyword">for</span> testing).</span><br><span class="line">  --query                  : Queries the service state and prints it as</span><br><span class="line">                            human-readable text.</span><br><span class="line">  --query-raw              : Like --query, but prints raw proto-encoded bytes</span><br><span class="line">                            of tracing_service_state.proto.</span><br><span class="line">  --save-for-bugreport     : If a trace with bugreport_score &gt; 0 is running, it</span><br><span class="line">                            saves it into a file. Outputs the path when <span class="keyword">done</span>.</span><br><span class="line">  --<span class="built_in">help</span>           -h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">light configuration flags: (only when NOT using -c/--config)</span><br><span class="line">  --time           -t      : Trace duration N[s,m,h] (default: 10s)</span><br><span class="line">  --buffer         -b      : Ring buffer size N[mb,gb] (default: 32mb)</span><br><span class="line">  --size           -s      : Max file size N[mb,gb] (default: in-memory ring-buffer only)</span><br><span class="line">  --app            -a      : Android (atrace) app name</span><br><span class="line">  ATRACE_CAT               : Record ATRACE_CAT (e.g. wm)</span><br><span class="line">  FTRACE_GROUP/FTRACE_NAME : Record ftrace event (e.g. <span class="built_in">sched</span>/sched_switch)</span><br><span class="line"></span><br><span class="line">statsd-specific flags:</span><br><span class="line">  --alert-id           : ID of the alert that triggered this trace.</span><br><span class="line">  --config-id          : ID of the triggering config.</span><br><span class="line">  --config-uid         : UID of app <span class="built_in">which</span> registered the config.</span><br><span class="line">  --subscription-id    : ID of the subscription that triggered this trace.</span><br><span class="line"></span><br><span class="line">Detach mode. DISCOURAGED, <span class="built_in">read</span> https://perfetto.dev/docs/concepts/detached-mode :</span><br><span class="line">  --detach=key          : Detach from the tracing session with the given key.</span><br><span class="line">  --attach=key [--stop] : Re-attach to the session (optionally stop tracing once reattached).</span><br><span class="line">  --is_detached=key     : Check <span class="keyword">if</span> the session can be re-attached (0:Yes, 2:No, 1:Error).</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>perfetto</code>包含以下两种模式，可确定用于记录跟踪数据的数据源：</p><ul><li>轻量模式：只能选择一部分数据源，具体来说就是<code>atrace</code>和<code>ftrace</code>。但此模式可提供类似于<code>systrace</code>的接口。</li><li>普通模式：从协议缓冲区获取其配置，并允许您更充分地利用<code>perfetto</code>功能，方法是使用<code>atrace</code>和<code>ftrace</code>之外的数据源。</li></ul><p>使用轻量模式来抓取<code>Trace</code>日志，这个跟<code>systrace</code>的用法类似，只需要制定<code>APP</code>的名字即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">perfetto --app &lt;app_name&gt; --time 15s -o /data/ss.trace</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果使用普通模式，首先需要参考标准的<a href="https://perfetto.dev/docs/reference/trace-config-proto"><code>TraceConfig</code></a>写一个配置文件；生成配置文件后，可以选择以<code>PBTX(ProtoBuf TeXtual representation)</code>的传递（生产环境不推荐）或者通过<a href="https://github.com/protocolbuffers/protobuf/releases"><code>protoc</code></a>工具转换成<code>Binary</code>形式的<code>protobuf</code>文件传给给<code>perfetto</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#把本地的sys_stats.cfg推到/data/misc/perfetto-configs</span></span><br><span class="line">perfetto -c /data/misc/perfetto-configs/sys_stats.cfg --txt -o /data/sys-stats.trace</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在AOSP源码目录<code>external/perfetto/test/configs</code>下面提供了很多<code>perfetto</code>的配置文件可以参考。除了使用<code>Android</code>系统自带的<code>perfetto</code>工具抓取Trace之外，还可以用<a href="https://ui.perfetto.dev/">网页版的<code>perfetto</code>工具抓取</a>: 点击<code>Record new trace</code>，会弹出一个页面，可以选择抓取<code>CPU</code>、<code>GPU</code>、<code>Memory</code>以及APP与服务的Trace日志:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/perfetto-ui-record-new-traces.png" alt="perfetto-ui usage"></p><h2 id="Android-Profiler"><a href="#Android-Profiler" class="headerlink" title="Android Profiler"></a>Android Profiler</h2><p>除了使用上述几个工具之外，<code>Android Studio(AS)</code>中也提供了一个可视化的<a href="https://developer.android.com/studio/profile?hl=zh-cn">图形界面工具<code>Profiler</code></a>来分析APP或者设备中进程的性能，包括CPU占用、内存分配以及网络使用等常见的性能指标。</p><p>打开<code>AS</code>后，点击界面的下方中的仪表指针的图标<code>Profiler</code>，然后点击弹出的界面左侧<code>SESSIONS</code>一栏中点击<code>+</code>按钮，选择需要分析跟踪的进程后，会弹出一个显示进程CPU、内存以及网络占用情况的界面:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/android-profiler-ui.png" alt="android profiler ui"></p><p>点击图中的<code>CPU</code>可以看到进程中各个线程的CPU占用情况，如果想要查看某个线程的调用堆栈，可以通过界面上的<code>Record</code>的功能来抓取<code>Java</code>或者<code>C/C++</code>代码<code>Trace</code>日志，抓取完成后会生产对应<code>Trace</code>的火焰图，可以用来进一步分析各个线程执行耗时; 类似的，<code>MEMORY</code>工具可以用来分析热点代码的内存分配情况，用来分析内存泄露、内存占用不合理的情况。</p><p>有关更多Profiler工具的使用说明，可以参考<a href="https://developer.android.com/studio/profile?hl=zh-cn">Android Profiler官网链接</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.android.com/topic/performance/tracing?hl=zh-cn">https://developer.android.com/topic/performance/tracing?hl=zh-cn</a></li><li><a href="https://developer.android.com/studio/profile?hl=zh-cn">https://developer.android.com/studio/profile?hl=zh-cn</a></li><li><a href="https://cs.android.com/">https://cs.android.com/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Android系统开发过程中，经常碰到CPU占用率高、内存泄露、内存占用高等性能相关的问题，这时通常需要抓取系统的&lt;code&gt;trace&lt;/code&gt;日志，用以查看进程的CPU占用，内存分配等情况。怎么抓取系统trace， 这时一般需要用到系统性能相关的分析工具。这篇文章就以&lt;code&gt;Android S&lt;/code&gt;为例，说明Android开发中常用的一些性能优化工具的使用方法，主要包括如下几个工具:&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://sniffer.site/categories/Android/"/>
    
    
    <category term="Android" scheme="https://sniffer.site/tags/Android/"/>
    
    <category term="性能分析" scheme="https://sniffer.site/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
    <category term="systrace" scheme="https://sniffer.site/tags/systrace/"/>
    
    <category term="perfetto" scheme="https://sniffer.site/tags/perfetto/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化之三virtio的实现原理</title>
    <link href="https://sniffer.site/2023/09/15/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E4%B8%89virtio%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sniffer.site/2023/09/15/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E4%B8%89virtio%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2023-09-15T10:42:33.000Z</published>
    <updated>2023-09-18T05:30:36.792Z</updated>
    
    <content type="html"><![CDATA[<p>在讲<a href="https://sniffer.site/2023/08/09/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E4%BA%8Cqnx%E8%99%9A%E6%8B%9F%E5%8C%96%E5%B9%B3%E5%8F%B0%E7%AE%80%E4%BB%8B/">虚拟化的第二篇QNX系统</a>时，提到在<code>QNX</code>中设备的虚拟化有直通(<code>pass-through</code>)、半虚拟化(<code>para-virtulization</code>)、全虚拟化(<code>full-virtualization</code>)等几种形式，而像串口、网络设备、块设备等通常都是基于半虚拟化的形式实现的。在半虚拟化的实现方案中，<code>virtio</code>是最常见的一种。简单来说，<code>virtio</code>是虚拟化设备的中间抽象层，为设备的虚拟化提供了一个统一的框架与接口，增加了跨平台时代码的复用性。<span id="more"></span></p><p>下图是两种虚拟化方案:全虚拟化与半虚拟化的框架简图。对全虚拟化方案而已，虚拟机完全不知道自己运行在一个虚拟化平台之上，<code>hypervisor</code>为虚拟机提供了一个完全模拟的环境，虚拟机对资源与设备的访问都需要通过异常的陷入(<code>trap</code>)指令来完成,这在一定程度上降低了资源访问的效率；而对半虚拟化方案而言，虚拟机与宿主机共同来完成虚拟化，虚拟机是完全知道自己运行在一个虚拟化的环境中，相对而言，半虚拟化的效率更高。</p><p><img src="https://developer.ibm.com/developer/default/articles/l-virtio/images/figure1.gif" alt="full-para virtualization"></p><p>而<code>virtio</code>正是半虚拟化技术中实现设备虚拟化的一种被广泛使用的方案，并被非营利性标准化组织<a href="https://www.oasis-open.org/org/"><code>OASIS</code></a>进行了标准化，详细的标准文档可以参考<a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html">Virtio V1.2</a>；<code>virtio</code>将设备驱动的实现分离为前端(<code>front-end</code>)与后端(<code>back-end</code>)两个部分:</p><ul><li>前端驱动(<code>front-end driver</code>): 虚拟机系统中的一个设备驱动模块，负责接收来自虚拟机用户的请求，将其发送给宿主机上的后端驱动</li><li>后端驱动(<code>back-end driver</code>): 运行在宿主机上的驱动模块，接收到来自虚拟机上的请求后，将其转换成物理设备上的操作</li></ul><p><img src="https://developer.ibm.com/developer/default/articles/l-virtio/images/figure2.gif" alt="driver abstractions with virtio"></p><p>对<code>QNX</code>系统，提供了常见的如网络设备、串口设备以及块设备等多种后端虚拟化实现, 可以很好的与<code>Linux</code>下的<code>virtio</code>框架进行衔接，例如要在<code>QNX</code>上给<code>Linux</code>的虚拟机提供一张虚拟网卡，只需要在<code>linux-lv.config</code>中如下配置即可:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vdev vdev-virtio-net.so loc <span class="number">0x1b018000</span> intr gic:<span class="number">45</span> peer /dev/vdevpeer/vp_lv mac aa:aa:aa:aa:aa:b1 bind-mode <span class="number">0660</span> name agl_to_host</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>Linux</code>虚拟机上打开内核配置<code>CONFIG_VIRTIO_NET</code>就可以枚举到对应的虚拟网卡， 其<code>mac</code>地址为<code>aa:aa:aa:aa:aa:b1</code>，中断号为<code>45</code>。接下来我们就以虚拟网卡<code>virtio-net</code>为例说明<code>virtio</code>具体的实现原理。</p><h2 id="virtio的原理"><a href="#virtio的原理" class="headerlink" title="virtio的原理"></a>virtio的原理</h2><p><code>QNX</code>中的<code>virtio</code>驱动分为两个部分: 前端设备驱动(<code>front-end driver</code>)与后端驱动(<code>back-end driver</code>)，前端驱动负责将虚拟机中的请求发送给后端驱动，后端驱动负责与前端驱动交互并将其请求发送给物理设备，像磁盘、网络、I2C、串口、fastRPC(用于与DSP交互)等设备都是通过<code>virtio</code>的方式来实现的，而其他的如音视频、显示、图形(Graphics)、Camera等传输数据比较大的模块也是采用了类似的前端与后端框架(高通称之为<code>HAB(Hypervisor ABstraction)</code>)。<code>virtio</code>为虚拟化驱动的实现提供了一个标准接口，从而解耦了宿主机与虚拟机之间的驱动开发, 提高了系统的开发效率。以<code>QNX</code>中的网络驱动为例:</p><ul><li>虚拟机有虚拟网卡驱动，与后端驱动通过一个内存映射的区域进行数据交互</li><li>后端驱动接收到虚拟机的数据后通过一个桥接口与<code>QNX</code>宿主机上的物理网卡驱动进行交互</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/virtio-net-qnx.png" alt="QNX虚拟网卡驱动框架"></p><p>接下来，我们从设备的识别与发现的过程来看下虚拟网卡中的具体实现。</p><h2 id="设备的识别与初始化"><a href="#设备的识别与初始化" class="headerlink" title="设备的识别与初始化"></a>设备的识别与初始化</h2><p><code>virtio</code>设备的发现一般有两种方式，一种是基于<code>PCI</code>虚拟总线进行设备枚举，一种是基于内存映射的方式。在QNX上，很多设备如虚拟网卡，虚拟磁盘设备等都是基于内存映射(<code>MMIO</code>)的方式来实现的。具体可以参考: </p><ul><li><a href="https://www.qnx.com/developers/docs/7.0.0/#com.qnx.doc.hypervisor.user/topic/use/virtio_guest.html">虚拟机上的设备发现</a></li><li><a href="https://docs.kernel.org/next/driver-api/virtio/virtio.html">Virtio on Linux</a></li><li><a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.pdf">virtio标准中设备发现部分</a></li><li><a href="https://www.qnx.com/developers/docs/7.0.0/index.html#com.qnx.doc.hypervisor.vdev/topic/intro/intro.html">如何在QNX中实现一个vdev</a></li></ul><blockquote><p>QNX上的虚拟设备<code>vdev</code>采用的是内存映射的方式，就是说虚拟设备实际是一个虚拟机的物理地址。<code>QNX</code>在启动<code>vdev</code>后端驱动进程时，会通过<code>gfdt_add_vdev</code>&#x2F;<code>gfdt_update_node</code>添加设备树到虚拟机上，这样虚拟机会在启动的时候枚举到对应的虚拟设备<br>可以在<code>/sys/firmware/devicetree/base/vdevs</code>目录中查找虚拟机上对应的设备树节点</p></blockquote><p><code>virtio</code>采用标准的<a href="https://linux-kernel-labs.github.io/refs/heads/master/labs/device_model.html">Linux设备模型</a>，设备与设备驱动之间通过一个名为<code>virtio</code>的虚拟总线进行连接。在虚拟机启动时，会枚举到<code>QNX</code>配置的虚拟设备，并调用<code>virtio_mmio_probe</code>:</p><ul><li>首先会通过<code>devm_request_mem_region</code>请求虚拟设备对应的内存区域，用于设备的控制与事件传递</li><li>接着会读取设备<code>I/O</code>地址来确认设备的类型(魔数)、<code>virtio</code>的版本号以及设备ID</li><li>最后<code>register_virtio_device</code>将该虚拟设cat备添加到系统中，这样设备驱动加载时可以匹配到对应的设备</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">virtio_mmio_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">virtio_mmio_device</span> *vm_dev;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">resource</span> *mem;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> magic;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">    mem = <span class="built_in">platform_get_resource</span>(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mem)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">devm_request_mem_region</span>(&amp;pdev-&gt;dev, mem-&gt;start,</span><br><span class="line">            <span class="built_in">resource_size</span>(mem), pdev-&gt;name))</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">    vm_dev = <span class="built_in">devm_kzalloc</span>(&amp;pdev-&gt;dev, <span class="built_in">sizeof</span>(*vm_dev), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!vm_dev)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    vm_dev-&gt;vdev.dev.parent = &amp;pdev-&gt;dev;</span><br><span class="line">    vm_dev-&gt;vdev.dev.release = virtio_mmio_release_dev;</span><br><span class="line">    vm_dev-&gt;vdev.config = &amp;virtio_mmio_config_ops;</span><br><span class="line">    vm_dev-&gt;pdev = pdev;</span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;vm_dev-&gt;virtqueues);</span><br><span class="line">    <span class="built_in">spin_lock_init</span>(&amp;vm_dev-&gt;lock);</span><br><span class="line"></span><br><span class="line">    vm_dev-&gt;base = <span class="built_in">devm_ioremap</span>(&amp;pdev-&gt;dev, mem-&gt;start, <span class="built_in">resource_size</span>(mem));</span><br><span class="line">    <span class="keyword">if</span> (vm_dev-&gt;base == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check magic value */</span></span><br><span class="line">    magic = <span class="built_in">readl</span>(vm_dev-&gt;base + VIRTIO_MMIO_MAGIC_VALUE);</span><br><span class="line">    <span class="keyword">if</span> (magic != (<span class="string">&#x27;v&#x27;</span> | <span class="string">&#x27;i&#x27;</span> &lt;&lt; <span class="number">8</span> | <span class="string">&#x27;r&#x27;</span> &lt;&lt; <span class="number">16</span> | <span class="string">&#x27;t&#x27;</span> &lt;&lt; <span class="number">24</span>)) &#123;</span><br><span class="line">        <span class="built_in">dev_warn</span>(&amp;pdev-&gt;dev, <span class="string">&quot;Wrong magic value 0x%08lx!\n&quot;</span>, magic);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check device version */</span></span><br><span class="line">    vm_dev-&gt;version = <span class="built_in">readl</span>(vm_dev-&gt;base + VIRTIO_MMIO_VERSION);</span><br><span class="line">    <span class="keyword">if</span> (vm_dev-&gt;version &lt; <span class="number">1</span> || vm_dev-&gt;version &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">dev_err</span>(&amp;pdev-&gt;dev, <span class="string">&quot;Version %ld not supported!\n&quot;</span>,</span><br><span class="line">                vm_dev-&gt;version);</span><br><span class="line">        <span class="keyword">return</span> -ENXIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vm_dev-&gt;vdev.id.device = <span class="built_in">readl</span>(vm_dev-&gt;base + VIRTIO_MMIO_DEVICE_ID);</span><br><span class="line">    ...</span><br><span class="line">    vm_dev-&gt;vdev.id.vendor = <span class="built_in">readl</span>(vm_dev-&gt;base + VIRTIO_MMIO_VENDOR_ID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm_dev-&gt;version == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">writel</span>(PAGE_SIZE, vm_dev-&gt;base + VIRTIO_MMIO_GUEST_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        rc = <span class="built_in">dma_set_mask</span>(&amp;pdev-&gt;dev, <span class="built_in">DMA_BIT_MASK</span>(<span class="number">64</span>));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * In the legacy case, ensure our coherently-allocated virtio</span></span><br><span class="line"><span class="comment">        * ring will be at an address expressable as a 32-bit PFN.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (!rc)</span><br><span class="line">            <span class="built_in">dma_set_coherent_mask</span>(&amp;pdev-&gt;dev,</span><br><span class="line">                        <span class="built_in">DMA_BIT_MASK</span>(<span class="number">32</span> + PAGE_SHIFT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rc = <span class="built_in">dma_set_mask_and_coherent</span>(&amp;pdev-&gt;dev, <span class="built_in">DMA_BIT_MASK</span>(<span class="number">64</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rc)</span><br><span class="line">        rc = <span class="built_in">dma_set_mask_and_coherent</span>(&amp;pdev-&gt;dev, <span class="built_in">DMA_BIT_MASK</span>(<span class="number">32</span>));</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">platform_set_drvdata</span>(pdev, vm_dev);</span><br><span class="line"></span><br><span class="line">    rc = <span class="built_in">register_virtio_device</span>(&amp;vm_dev-&gt;vdev);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>register_virtio_device</code>将虚拟设备注册到系统中，对应的总线类型为<code>virtio_bus</code>, 用于设备驱动的匹配与查找；对应的设备名称格式为<code>virtio%u</code>, 比如<code>virtio33</code>&#x2F;<code>virtio21</code>; 在Linux系统中，我们可以到路径<code>/sys/devices/platform/vdevs</code>中查看当前系统有哪些<code>virtio</code>设备:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">register_virtio_device</span><span class="params">(<span class="keyword">struct</span> virtio_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    dev-&gt;dev.bus = &amp;virtio_bus;</span><br><span class="line">    <span class="built_in">device_initialize</span>(&amp;dev-&gt;dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assign a unique device index and hence name. */</span></span><br><span class="line">    err = <span class="built_in">ida_simple_get</span>(&amp;virtio_index_ida, <span class="number">0</span>, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    dev-&gt;index = err;</span><br><span class="line">    <span class="built_in">dev_set_name</span>(&amp;dev-&gt;dev, <span class="string">&quot;virtio%u&quot;</span>, dev-&gt;index);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spin_lock_init</span>(&amp;dev-&gt;config_lock);</span><br><span class="line">    dev-&gt;config_enabled = <span class="literal">false</span>;</span><br><span class="line">    dev-&gt;config_change_pending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We always start by resetting the device, in case a previous</span></span><br><span class="line"><span class="comment">    * driver messed it up.  This also tests that code path a little. */</span></span><br><span class="line">    dev-&gt;config-&gt;<span class="built_in">reset</span>(dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Acknowledge that we&#x27;ve seen the device. */</span></span><br><span class="line">    <span class="built_in">virtio_add_status</span>(dev, VIRTIO_CONFIG_S_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;dev-&gt;vqs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * device_add() causes the bus infrastructure to look for a matching</span></span><br><span class="line"><span class="comment">    * driver.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    err = <span class="built_in">device_add</span>(&amp;dev-&gt;dev);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设备注册完后，虚拟网卡设备驱动程序<code>virtio-net</code>在注册时，会主动匹配与之对应的设备, 如果匹配到则会调用对应驱动的<code>probe</code>函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">virtio_driver</span> virtio_net_driver = &#123;</span><br><span class="line">    .feature_table = features,</span><br><span class="line">    .feature_table_size = <span class="built_in">ARRAY_SIZE</span>(features),</span><br><span class="line">    .feature_table_legacy = features_legacy,</span><br><span class="line">    .feature_table_size_legacy = <span class="built_in">ARRAY_SIZE</span>(features_legacy),</span><br><span class="line">    .driver.name =KBUILD_MODNAME,</span><br><span class="line">    .driver.owner =THIS_MODULE,</span><br><span class="line">    .id_table =id_table,</span><br><span class="line">    .validate =virtnet_validate,</span><br><span class="line">    .probe =virtnet_probe,</span><br><span class="line">    .remove =virtnet_remove,</span><br><span class="line">    .config_changed = virtnet_config_changed,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">    .freeze =virtnet_freeze,</span><br><span class="line">    .restore =virtnet_restore,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> __init <span class="type">int</span> <span class="title">virtio_net_driver_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">cpuhp_setup_state_multi</span>(CPUHP_AP_ONLINE_DYN, <span class="string">&quot;virtio/net:online&quot;</span>,</span><br><span class="line">                    virtnet_cpu_online,</span><br><span class="line">                    virtnet_cpu_down_prep);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    virtionet_online = ret;</span><br><span class="line">    ret = <span class="built_in">cpuhp_setup_state_multi</span>(CPUHP_VIRT_NET_DEAD, <span class="string">&quot;virtio/net:dead&quot;</span>,</span><br><span class="line">                    <span class="literal">NULL</span>, virtnet_cpu_dead);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> err_dead;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">register_virtio_driver</span>(&amp;virtio_net_driver);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module_init</span>(virtio_net_driver_init);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虚拟网卡的驱动加载函数<code>virtnet_probe</code>主要做几个事情:</p><ul><li>根据宿主机的驱动配置，设置对应的网卡特性，比如是否支持硬件校验计算、TSO、GSO等</li><li><code>alloc_etherdev_mq</code>分配协议栈的网络设备对象<code>net_device</code>, 将其注册到内核中<code>register_netdev</code></li><li>通过检查虚拟设备的特性(feature)确认是否打开网络设备某些配置，比如是否支持<code>GSO/TSO</code>等</li><li><code>init_vqs</code>初始化虚拟网卡的接收与发送队列， 创建对应的<code>virtqueue</code>循环队列</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">virtnet_probe</span><span class="params">(<span class="keyword">struct</span> virtio_device *vdev)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, err = -ENOMEM;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">net_device</span> *dev;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">virtnet_info</span> *vi;</span><br><span class="line">        u16 max_queue_pairs;</span><br><span class="line">        <span class="type">int</span> mtu;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Find if host supports multiqueue virtio_net device */</span></span><br><span class="line">        err = <span class="built_in">virtio_cread_feature</span>(vdev, VIRTIO_NET_F_MQ,</span><br><span class="line">                    <span class="keyword">struct</span> virtio_net_config,</span><br><span class="line">                    max_virtqueue_pairs, &amp;max_queue_pairs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We need at least 2 queue&#x27;s */</span></span><br><span class="line">        <span class="keyword">if</span> (err || max_queue_pairs &lt; VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN ||</span><br><span class="line">            max_queue_pairs &gt; VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX ||</span><br><span class="line">            !<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_CTRL_VQ))</span><br><span class="line">            max_queue_pairs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Allocate ourselves a network device with room for our info */</span></span><br><span class="line">        dev = <span class="built_in">alloc_etherdev_mq</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> virtnet_info), max_queue_pairs);</span><br><span class="line">        <span class="keyword">if</span> (!dev)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set up network device as normal. */</span></span><br><span class="line">        dev-&gt;priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE;</span><br><span class="line">        dev-&gt;netdev_ops = &amp;virtnet_netdev;</span><br><span class="line">        dev-&gt;features = NETIF_F_HIGHDMA;</span><br><span class="line"></span><br><span class="line">        dev-&gt;ethtool_ops = &amp;virtnet_ethtool_ops;</span><br><span class="line">        <span class="built_in">SET_NETDEV_DEV</span>(dev, &amp;vdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Do we support &quot;hardware&quot; checksums? */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_CSUM)) &#123;</span><br><span class="line">            <span class="comment">/* This opens up the world of extra features. */</span></span><br><span class="line">            dev-&gt;hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;</span><br><span class="line">            <span class="keyword">if</span> (csum)</span><br><span class="line">                dev-&gt;features |= NETIF_F_HW_CSUM | NETIF_F_SG;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_GSO)) &#123;</span><br><span class="line">                dev-&gt;hw_features |= NETIF_F_TSO</span><br><span class="line">                    | NETIF_F_TSO_ECN | NETIF_F_TSO6;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Individual feature bits: what can host handle? */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_HOST_TSO4))</span><br><span class="line">                dev-&gt;hw_features |= NETIF_F_TSO;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_HOST_TSO6))</span><br><span class="line">                dev-&gt;hw_features |= NETIF_F_TSO6;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_HOST_ECN))</span><br><span class="line">                dev-&gt;hw_features |= NETIF_F_TSO_ECN;</span><br><span class="line"></span><br><span class="line">            dev-&gt;features |= NETIF_F_GSO_ROBUST;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (gso)</span><br><span class="line">                dev-&gt;features |= dev-&gt;hw_features &amp; NETIF_F_ALL_TSO;</span><br><span class="line">            <span class="comment">/* (!csum &amp;&amp; gso) case will be fixed by register_netdev() */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_GUEST_CSUM))</span><br><span class="line">            dev-&gt;features |= NETIF_F_RXCSUM;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_GUEST_TSO4) ||</span><br><span class="line">            <span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_GUEST_TSO6))</span><br><span class="line">            dev-&gt;features |= NETIF_F_GRO_HW;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_CTRL_GUEST_OFFLOADS))</span><br><span class="line">            dev-&gt;hw_features |= NETIF_F_GRO_HW;</span><br><span class="line"></span><br><span class="line">        dev-&gt;vlan_features = dev-&gt;features;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* MTU range: 68 - 65535 */</span></span><br><span class="line">        dev-&gt;min_mtu = MIN_MTU;</span><br><span class="line">        dev-&gt;max_mtu = MAX_MTU;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Configuration may specify what MAC to use.  Otherwise random. */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_MAC))</span><br><span class="line">            <span class="built_in">virtio_cread_bytes</span>(vdev,</span><br><span class="line">                    <span class="built_in">offsetof</span>(<span class="keyword">struct</span> virtio_net_config, mac),</span><br><span class="line">                    dev-&gt;dev_addr, dev-&gt;addr_len);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">eth_hw_addr_random</span>(dev);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set up our device-specific information */</span></span><br><span class="line">        vi = <span class="built_in">netdev_priv</span>(dev);</span><br><span class="line">        vi-&gt;dev = dev;</span><br><span class="line">        vi-&gt;vdev = vdev;</span><br><span class="line">        vdev-&gt;priv = vi;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">INIT_WORK</span>(&amp;vi-&gt;config_work, virtnet_config_changed_work);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we can receive ANY GSO packets, we must allocate large ones. */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_GUEST_TSO4) ||</span><br><span class="line">            <span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_GUEST_TSO6) ||</span><br><span class="line">            <span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_GUEST_ECN) ||</span><br><span class="line">            <span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_GUEST_UFO))</span><br><span class="line">            vi-&gt;big_packets = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_MRG_RXBUF))</span><br><span class="line">            vi-&gt;mergeable_rx_bufs = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_MRG_RXBUF) ||</span><br><span class="line">            <span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_F_VERSION_1))</span><br><span class="line">            vi-&gt;hdr_len = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> virtio_net_hdr_mrg_rxbuf);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            vi-&gt;hdr_len = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> virtio_net_hdr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_F_ANY_LAYOUT) ||</span><br><span class="line">            <span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_F_VERSION_1))</span><br><span class="line">            vi-&gt;any_header_sg = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_CTRL_VQ))</span><br><span class="line">            vi-&gt;has_cvq = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_MTU)) &#123;</span><br><span class="line">            mtu = <span class="built_in">virtio_cread16</span>(vdev,</span><br><span class="line">                        <span class="built_in">offsetof</span>(<span class="keyword">struct</span> virtio_net_config,</span><br><span class="line">                            mtu));</span><br><span class="line">            <span class="keyword">if</span> (mtu &lt; dev-&gt;min_mtu) &#123;</span><br><span class="line">                <span class="comment">/* Should never trigger: MTU was previously validated</span></span><br><span class="line"><span class="comment">                * in virtnet_validate.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="built_in">dev_err</span>(&amp;vdev-&gt;dev,</span><br><span class="line">                    <span class="string">&quot;device MTU appears to have changed it is now %d &lt; %d&quot;</span>,</span><br><span class="line">                    mtu, dev-&gt;min_mtu);</span><br><span class="line">                err = -EINVAL;</span><br><span class="line">                <span class="keyword">goto</span> free;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dev-&gt;mtu = mtu;</span><br><span class="line">            dev-&gt;max_mtu = mtu;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* <span class="doctag">TODO:</span> size buffers correctly in this case. */</span></span><br><span class="line">            <span class="keyword">if</span> (dev-&gt;mtu &gt; ETH_DATA_LEN)</span><br><span class="line">                vi-&gt;big_packets = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vi-&gt;any_header_sg)</span><br><span class="line">            dev-&gt;needed_headroom = vi-&gt;hdr_len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Enable multiqueue by default */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">num_online_cpus</span>() &gt;= max_queue_pairs)</span><br><span class="line">            vi-&gt;curr_queue_pairs = max_queue_pairs;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            vi-&gt;curr_queue_pairs = <span class="built_in">num_online_cpus</span>();</span><br><span class="line">        vi-&gt;max_queue_pairs = max_queue_pairs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Allocate/initialize the rx/tx queues, and invoke find_vqs */</span></span><br><span class="line">        err = <span class="built_in">init_vqs</span>(vi);</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">netif_set_real_num_tx_queues</span>(dev, vi-&gt;curr_queue_pairs);</span><br><span class="line">        <span class="built_in">netif_set_real_num_rx_queues</span>(dev, vi-&gt;curr_queue_pairs);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">virtnet_init_settings</span>(dev);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vdev, VIRTIO_NET_F_STANDBY)) &#123;</span><br><span class="line">            vi-&gt;failover = <span class="built_in">net_failover_create</span>(vi-&gt;dev);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(vi-&gt;failover)) &#123;</span><br><span class="line">                err = <span class="built_in">PTR_ERR</span>(vi-&gt;failover);</span><br><span class="line">                <span class="keyword">goto</span> free_vqs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">register_netdev</span>(dev);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="built_in">virtio_device_ready</span>(vdev);</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">virtnet_cpu_notif_add</span>(vi);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="built_in">virtnet_set_queues</span>(vi, vi-&gt;curr_queue_pairs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Assume link up if device can&#x27;t report link status,</span></span><br><span class="line"><span class="comment">        otherwise get link status from config. */</span></span><br><span class="line">        <span class="built_in">netif_carrier_off</span>(dev);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vi-&gt;vdev, VIRTIO_NET_F_STATUS)) &#123;</span><br><span class="line">            <span class="built_in">schedule_work</span>(&amp;vi-&gt;config_work);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vi-&gt;status = VIRTIO_NET_S_LINK_UP;</span><br><span class="line">            <span class="built_in">virtnet_update_settings</span>(vi);</span><br><span class="line">            <span class="built_in">netif_carrier_on</span>(dev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">ARRAY_SIZE</span>(guest_offloads); i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">virtio_has_feature</span>(vi-&gt;vdev, guest_offloads[i]))</span><br><span class="line">                <span class="built_in">set_bit</span>(guest_offloads[i], &amp;vi-&gt;guest_offloads);</span><br><span class="line">        vi-&gt;guest_offloads_capable = vi-&gt;guest_offloads;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pr_debug</span>(<span class="string">&quot;virtnet: registered device %s with %d RX and TX vq&#x27;s\n&quot;</span>,</span><br><span class="line">            dev-&gt;name, max_queue_pairs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重点来看看<code>init_vqs</code>，这个函数首先分配用于接发数据的队列，然后调用<code>virtnet_find_vqs</code>来设置每个接发队列的回调，以及通过<code>virtio_mmio</code>的接口配置中断、配置接发缓冲区的内存等:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">init_vqs</span><span class="params">(<span class="keyword">struct</span> virtnet_info *vi)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate send &amp; receive queues */</span></span><br><span class="line">    ret = virtnet_alloc_queues(vi);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    ret = virtnet_find_vqs(vi);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> err_free;</span><br><span class="line"></span><br><span class="line">    get_online_cpus();</span><br><span class="line">    virtnet_set_affinity(vi);</span><br><span class="line">    put_online_cpus();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>virtnet_find_vqs</code>最终会通过<code>vdev-&gt;config-&gt;find_vqs</code>调用<code>virtio_mmio.c</code>设备的配置操作函数列表<code>virtio_mmio_config_ops-&gt;find_vqs</code>, 即<code>vm_find_vqs</code>, 这个函数主要做了如下几个事情:</p><ul><li>配置中断<code>request_irq</code>, 这个中断号就是从宿主机QNX端配置的，比如数据发送，数据接收等信号都是通过这个中断发送过来的</li><li>为每个接发队列分配足够的环形缓冲区，这个缓冲区的内存位于虚拟机上，分配成功后会通过通过<code>virtio</code>的协议，将对应的缓冲区队列的虚拟地址传递给宿主机QNX端，这样前端驱动就可以与后端进行数据的交互</li></ul><p>有关具体的配置细节可以参考<code>vring_create_virtqueue</code>&#x2F;<code>vring_create_virtqueue</code>这两个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vm_find_vqs</span><span class="params">(<span class="keyword">struct</span> virtio_device *vdev, <span class="type">unsigned</span> nvqs,</span></span><br><span class="line"><span class="params">          <span class="keyword">struct</span> virtqueue *vqs[],</span></span><br><span class="line"><span class="params">          <span class="type">vq_callback_t</span> *callbacks[],</span></span><br><span class="line"><span class="params">          <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> names[],</span></span><br><span class="line"><span class="params">          <span class="type">const</span> <span class="type">bool</span> *ctx,</span></span><br><span class="line"><span class="params">          <span class="keyword">struct</span> irq_affinity *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">virtio_mmio_device</span> *<span class="title">vm_dev</span> =</span> to_virtio_mmio_device(vdev);</span><br><span class="line">  <span class="type">int</span> irq = platform_get_irq(vm_dev-&gt;pdev, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> i, err, queue_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (irq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    dev_err(&amp;vdev-&gt;dev, <span class="string">&quot;Cannot get IRQ resource\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> irq;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err = request_irq(irq, vm_interrupt, IRQF_SHARED,</span><br><span class="line">      dev_name(&amp;vdev-&gt;dev), vm_dev);</span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (of_property_read_bool(vm_dev-&gt;pdev-&gt;dev.of_node, <span class="string">&quot;virtio,wakeup&quot;</span>))</span><br><span class="line">    enable_irq_wake(irq);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nvqs; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!names[i]) &#123;</span><br><span class="line">      vqs[i] = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vqs[i] = vm_setup_vq(vdev, queue_idx++, callbacks[i], names[i],</span><br><span class="line">            ctx ? ctx[i] : <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(vqs[i])) &#123;</span><br><span class="line">      vm_del_vqs(vdev);</span><br><span class="line">      <span class="keyword">return</span> PTR_ERR(vqs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p><code>virtio</code>是虚拟化技术中很常见的一种设备虚拟化方案，相比全模拟的设备虚拟化，<code>virtio</code>效率更高，性能更优；正是因为其在性能上的优势，<code>virtio</code>在QNX, KVM， QEMU等虚拟化方案中都得到了广泛的应用，QNX中的网络, 磁盘等虚拟化设备都是基于该技术方案实现的。目前，<code>virtio</code>的接口已经被<code>OASIS</code>标准化，这样前端的设备驱动开发与后端宿主机的驱动实现了完全的解耦，彼此只需要遵循标准的接口与协议即可相互匹配工作。</p><p>这篇文章我们主要以<code>virtio-net</code>虚拟网卡为例来说明<code>virtio</code>的大致原理，感兴趣的同学也可以下载<code>Linux</code>内核代码学习下其他如输入设备、块设备等虚拟设备驱动是如何实现的, 主要代码路径如下:</p><ul><li><code>drivers/virtio</code>: <code>virtio</code>的数据传输层代码，包括<code>PCI/MMIO</code>两种设备枚举方式以及<code>vring</code>的实现</li><li><code>drivers/net/virtio_net.c</code>: 虚拟网卡设备驱动</li><li><code>drivers/block/virtio_blk.c</code>: 块设备驱动</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blogs.oracle.com/linux/post/introduction-to-virtio">https://blogs.oracle.com/linux/post/introduction-to-virtio</a></li><li><a href="https://developer.ibm.com/articles/l-virtio/">https://developer.ibm.com/articles/l-virtio/</a></li><li><a href="https://www.cs.cmu.edu/~412/lectures/Virtio_2015-10-14.pdf">https://www.cs.cmu.edu/~412/lectures/Virtio_2015-10-14.pdf</a></li><li><a href="https://en.wikipedia.org/wiki/Kernel-based_Virtual_Machine">https://en.wikipedia.org/wiki/Kernel-based_Virtual_Machine</a></li><li><a href="https://lwn.net/Articles/239238/">An API for virtual I&#x2F;O: virtio</a></li><li><a href="https://docs.oasis-open.org/virtio/virtio/v1.2/cs01/virtio-v1.2-cs01.html">Virtual I&#x2F;O Device (VIRTIO) Version 1.2</a></li><li><a href="https://genode.org/documentation/articles/arm_virtualization">ARM virtualization</a></li><li><a href="https://developer.arm.com/documentation/100942/0100/Hypervisor-software">AArch64 virtualization</a></li><li><a href="https://tinylab.org/virtio-intro/#virtio-net">https://tinylab.org/virtio-intro/#virtio-net</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在讲&lt;a href=&quot;https://sniffer.site/2023/08/09/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E4%BA%8Cqnx%E8%99%9A%E6%8B%9F%E5%8C%96%E5%B9%B3%E5%8F%B0%E7%AE%80%E4%BB%8B/&quot;&gt;虚拟化的第二篇QNX系统&lt;/a&gt;时，提到在&lt;code&gt;QNX&lt;/code&gt;中设备的虚拟化有直通(&lt;code&gt;pass-through&lt;/code&gt;)、半虚拟化(&lt;code&gt;para-virtulization&lt;/code&gt;)、全虚拟化(&lt;code&gt;full-virtualization&lt;/code&gt;)等几种形式，而像串口、网络设备、块设备等通常都是基于半虚拟化的形式实现的。在半虚拟化的实现方案中，&lt;code&gt;virtio&lt;/code&gt;是最常见的一种。简单来说，&lt;code&gt;virtio&lt;/code&gt;是虚拟化设备的中间抽象层，为设备的虚拟化提供了一个统一的框架与接口，增加了跨平台时代码的复用性。</summary>
    
    
    
    <category term="虚拟化" scheme="https://sniffer.site/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="https://sniffer.site/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="QNX" scheme="https://sniffer.site/tags/QNX/"/>
    
    <category term="virtio" scheme="https://sniffer.site/tags/virtio/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化之二QNX虚拟化平台简介</title>
    <link href="https://sniffer.site/2023/08/09/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E4%BA%8CQNX%E8%99%9A%E6%8B%9F%E5%8C%96%E5%B9%B3%E5%8F%B0%E7%AE%80%E4%BB%8B/"/>
    <id>https://sniffer.site/2023/08/09/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E4%BA%8CQNX%E8%99%9A%E6%8B%9F%E5%8C%96%E5%B9%B3%E5%8F%B0%E7%AE%80%E4%BB%8B/</id>
    <published>2023-08-09T07:33:40.000Z</published>
    <updated>2023-08-10T04:34:45.997Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/QNX"><code>QNX</code></a>最初是<code>Gordon Bell</code>与<code>Dan Dodge</code>两人在1980年代初期创建的一个实时微内核操作系统(<code>RTOS(Real-Time Operating System</code>), 后来被黑莓(<code>BlackBerry</code>)公司收购，因此也叫做<code>Blackberry QNX</code>系统。<code>QNX</code>被世人熟知还是因为其高安全性、<code>QNX hypervisor</code>等特性在汽车领域的广泛应用。</p><span id="more"></span><p>这篇文章，我们就来看看<code>QNX</code>虚拟化平台的基本架构与实现原理，着重会介绍虚拟化方案:</p><ul><li>介绍<code>QNX</code>以及虚拟化平台的基本概念与架构</li><li>介绍QNX虚拟化的实现方法，包括<code>CPU</code>虚拟化，内存虚拟化，设备虚拟化等</li></ul><h2 id="QNX虚拟化平台的架构组成"><a href="#QNX虚拟化平台的架构组成" class="headerlink" title="QNX虚拟化平台的架构组成"></a><strong>QNX虚拟化平台的架构组成</strong></h2><p><code>QNX</code>系统是一个微内核(<code>microkernel</code>)的类<code>UNIX</code>的实时操作系统，支持<code>x86/ARM/PowerPC/MIPS</code>等多个芯片架构，可以应用到从小型的嵌入式硬件到大型的分布式系统中。总结来说，主要有如下几个特点:</p><ul><li>微内核的实时操作系统: 与Linux这样的宏内核(<code>Monolithic</code>)操作系统不同的是，QNX采用的微内核的实现。内核只实现了很少一部分功能，比如进程管理与进程通讯，进程同步与调度等，其他的如文件系统，设备驱动以及网络协议栈都在用户空间中实现。这么做一个明显的好处是，内核不会设备驱动或者网络协议栈等异常崩溃而卡死，从而提升了系统的稳定性与可用性；进程的上下文切换效率更高，因而实时性更好。</li><li>支持<code>POSIX</code>接口: 与大部分<code>UNIX</code>的操作系统类似，<code>QNX</code>支持<code>POSIX</code>标准接口，这样其他很多比如在<code>Linux</code>上写的程序就可以直接移植到<code>QNX</code>上，减少了开发成本。</li><li>系统级别的HA(<code>High Availability</code>)框架： <code>QNX</code>专门提供了一套高可用的开发框架，可以用于进程的快速恢复，确保系统业务功能的高可用性。</li><li>多个行业安全认证: <code>QNX</code>代码经过多个行业安全标准，如通信行业的<code>FIPS 140-2</code>, 工控行业的<code>IEC 61508</code>, 汽车电子领域的<code>ISO 26262</code>等等，从代码级别上提升了系统的安全性。</li><li>支持多个硬件平台：支持市面上大部分<code>SoC</code>供应商如<code>AMD</code>、<code>Intel</code>、<code>Nvidia</code>、<code>NXP</code>、<code>Qualcomm</code>的芯片</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qnx-sys-architecture.jpg" alt="QNX RTOS"></p><p>如上图所示，是<code>QNX</code>系统的一个架构简图，可以看到，内核为所有进程通讯提供了一个软总线(<code>software bus</code>),进程之间的通讯都是通过这条软总线传递消息。内核只是实现了诸如线程管理、消息传递、发送信号、中断处理、并发同步等功能，其他的如显示驱动，文件系统，网络协议栈、字符设备等统一在用户空间实现。</p><p><code>QNX</code>在原有系统上进行了虚拟化扩展，支持了<code>hypervisor</code>功能；在<code>hypervisor</code>的基础上，<code>QVM</code>(<code>QNX Virtual Machine</code>)支持运行如<code>Linux</code>、<code>Android</code>、<code>QNX</code>等<code>Guest</code>操作系统。目前常见的汽车座舱芯片如<code>Renesas R-Car H3</code>, 高通<code>820A</code>、<code>8155</code>以及<code>NXP i.MX 8</code>等都支持<code>QNX</code>虚拟化方案。</p><p>下图是<code>QNX</code>虚拟化平台的一个框架简图，每个运行的客户操作系统(<code>Guest OS</code>)都对应个<code>QVM</code>进程；客户操作系统可以通过虚拟设备或者<code>pass-through</code>的方式访问控制硬件。实际上，对<code>QNX</code>来说，客户操作系统并不一定运行在虚拟的环境，而是大部分时候都直接在物理<code>CPU</code>上执行指令，只有当需要访问一些特权指令或者无法访问的内存时，<code>hypervisor</code>才会介入，执行虚拟化相关的指令，让虚拟机退出。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qnx_qvm_arch.png" alt="QNX hypervisor architecture"></p><p>以单个<code>CPU</code>的执行流程为例，当<code>hypervisor</code>陷入到虚拟化相关的指令后，首先会尝试保存当前虚拟机的上下文信息，此时虚拟机退出，由<code>hypervisor</code>完成必要的工作后再恢复虚拟机的上下文，重新执行虚拟机被打断的流程(具体路程参考下图):</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qvm_lahavline.png" alt="The lahav line"></p><p>接下来我们就具体来看看<code>QNX</code>是如何实现<code>CPU</code>、内存、<code>I/O</code>设备以及中断是如何处理的。</p><h2 id="QNX虚拟化实现"><a href="#QNX虚拟化实现" class="headerlink" title="QNX虚拟化实现"></a><strong>QNX虚拟化实现</strong></h2><h3 id="CPU的虚拟化"><a href="#CPU的虚拟化" class="headerlink" title="CPU的虚拟化"></a><strong>CPU的虚拟化</strong></h3><p>虚拟机上的进程的调度实际是以虚拟<code>CPU</code>(vCPU)为基础进行的，每个虚拟机在启动时，可以配置<code>vCPU</code>的数量;<code>vCPU</code>的调度是由在<code>hypervisor</code>中的调度线程负责执行的。一个物理<code>CPU</code>可能对应着多个<code>vCPU</code>；类似的，一个<code>vCPU</code>也可以选择在多个物理<code>CPU</code>上电调度执行。需要注意的是，虚拟机中的线程优先级与宿主机中<code>QNX</code>的线程优先级没有关系，具体何时执行哪个<code>vCPU</code>完全是由<code>hypervisor</code>中的调度线程的优先级决定的: 两个<code>vCPU</code>竞争物理<code>CPU</code>时，对应的<code>hypervisor</code>调度线程的优先级更高的任务获得对应的物理<code>CPU</code>执行权。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qnx-process-schedule.png" alt="QNX虚拟化中进程的调度"></p><p>虚拟机的线程调度到物理<code>CPU</code>的过程类似与普通操作系统中进程上下文切换的过程: 在虚拟机上需要保存当前线程的上下文信息，接着通过一个虚拟指令陷入(<code>trap</code>, 这个跟<code>Linux</code>下的系统调用从用户空间切换到内核空间的过程很类似)到<code>hypervisor</code>中，然后由<code>hypervisor</code>最终完成整个调度上下文的状态保存与切换。当一个客户虚拟机中发生如<code>QNX</code>的中断，虚拟设备访问(不一定放弃<code>CPU</code>的控制权)，虚拟时钟到期等事件时，虚拟机就会让出当前<code>CPU</code>的控制权。</p><h3 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a><strong>内存虚拟化</strong></h3><p><code>QNX</code>中使用<a href="https://developer.arm.com/documentation/102142/0100/Stage-2-translation"><code>stage 2 translation</code>(二阶转换)</a>来完成内存的虚拟化，虚拟机看到的<code>物理内存</code>实际上是<code>QNX</code>宿主系统管理的非连续虚拟内存而已：二阶内存转换就是在正常的<code>VA-&gt;PA</code>之间增加一个地址转换过程<code>IPA(Intermediate Physical Address)</code>，于是虚拟机的内存访问就变成了<code>VA-&gt;IPA-&gt;PA</code>这样一个二阶段的过程。</p><ul><li>阶段1的内存地址转换<code>VA-&gt;IPA</code>由虚拟机来控制完成</li><li>阶段2的内存地址转换<code>IPA-&gt;PA</code>由<code>QNX</code>宿主机系统来完成</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qnx-hyp-ipa-pa.png" alt="QNX内存虚拟化"></p><p>由于增加了中间地址的转换层<code>IPA</code>，这样虚拟机与<code>QNX</code>宿主机之间的内存空间就完全隔离了，虚拟机只能看到<code>QNX</code>宿主机分配好的内存，无法访问其他虚拟机或者宿主机的内存空间。除此之外，<code>QNX</code>还提供了额外的内存访问方式:</p><ul><li><code>Pass-through memory</code>:直通内存允许虚拟机将某些设备直接映射到某个内存区域，然后直接访问这个物理设备；直通模式下的设备只有该虚拟机才能访问，在性能上比虚拟的设备会更高。有关直通设备的详细信息可以参考<a href="https://www.qnx.com/developers/docs/7.0.0/index.html#com.qnx.doc.hypervisor.user/topic/virt/pdevs.html">直通设备</a></li><li><code>Shared Memory</code>: 共享内存允许不同虚拟机共享同一块物理内存，通过该内存区域进行数据交互</li></ul><h3 id="I-x2F-O设备虚拟化"><a href="#I-x2F-O设备虚拟化" class="headerlink" title="I&#x2F;O设备虚拟化"></a><strong>I&#x2F;O设备虚拟化</strong></h3><p>在<code>QNX</code>中，物理设备可以由宿主机或者虚拟机独占，也可以由虚拟机与宿主机之间共享。虚拟机要访问物理设备，可以通过直通或者虚拟化的方式实现:</p><ul><li><code>Pass-through device</code>: 直通设备的访问完全由虚拟机控制，驱动也在虚拟机中实现， 而<code>hypervisor</code>只是负责识别、传递来自设备的中断，传递来自虚拟机发送过来的信号。</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qvm_pdev_passthru.png" alt="pass-through device"></p><ul><li><code>Virtual Devices</code>: 虚拟设备<code>vdev</code>可以是一个物理设备的模拟，也可以只是提供了一个类似物理设备功能的模拟设备。与直通设备类似，虚拟机要使用虚拟设备也需要提供驱动。目前<code>QNX hypervisor</code>提供了两种形式的虚拟设备-一个是模拟(<code>Emulation</code>)设备，一个是半虚拟化设备(<code>para-virtualized</code>， 见下图)。<code>QNX</code>中很多设备都是通过半虚拟化提供给虚拟机的，如输入设备、虚拟网卡都是通过半虚拟化方式<code>virtio</code>实现的，后面我们会专门用一篇文章来分析下<code>virtio</code>的虚拟化设备怎样的工作原理。</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qvm_vdev_paravirt.png" alt="Para-virtualized devices"></p><p>更多有关<code>QNX</code>支持的虚拟设备的可以参考<a href="https://www.qnx.com/developers/docs/7.0.0/index.html#com.qnx.doc.hypervisor.user/topic/vdev_ref/vdev_ref.html">vdev references</a>。</p><h3 id="虚拟机的中断处理流程"><a href="#虚拟机的中断处理流程" class="headerlink" title="虚拟机的中断处理流程"></a><strong>虚拟机的中断处理流程</strong></h3><p>每个中断都有一个中断号，如果设备需要处理中断，需要通过<code>vdev</code>或者<code>pass</code>直通的方式传递给虚拟机:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//vdev </span></span><br><span class="line">vdev vdev-virtio-i2c.so loc <span class="number">0x1cd00000</span> intr gic:<span class="number">104</span> verbose <span class="number">3</span> device i2c5</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass through</span></span><br><span class="line">pass intr gic:<span class="number">183</span>=<span class="number">183</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当一个中断发生时，如下图所示一般分为两种情况:</p><ul><li>如果当前中断发生的<code>CPU</code>执行是虚拟机线程，则首先虚拟机的线程退出，将中断丢给<code>hypervisor</code>处理，并切换到宿主机，由<code>QNX</code>判断该中断属于虚拟机还是宿主机:如果中断属于宿主机<code>QNX</code>，则由其处理中断即可；如果是属于虚拟机的中断，则需要通过<code>hypervisor</code>发送一个中断信号给虚拟机，然后交由虚拟机处理</li><li>如果当前中断发生的<code>CPU</code>执行的是宿主机<code>QNX</code>线程，<code>QNX</code>判断是虚拟机的线程则按照前述的步骤交由虚拟机处理。</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/gic_handling_process.png" alt="GIC handling process"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="http://www.qnx.com/developers/docs/">QNX 系统资料</a></li><li><a href="https://www.qnx.com/developers/docs/7.0.0/index.html#com.qnx.doc.hypervisor.nav/topic/bookset.html">QNX hypervisor</a></li><li><a href="https://developer.arm.com/documentation/102142/0100/Overview">ARM virtualization文档</a></li><li>hardware and software support for virtualization(Edouard Bugnion, Jason Nieh, and Dan Tsafrir)</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/QNX&quot;&gt;&lt;code&gt;QNX&lt;/code&gt;&lt;/a&gt;最初是&lt;code&gt;Gordon Bell&lt;/code&gt;与&lt;code&gt;Dan Dodge&lt;/code&gt;两人在1980年代初期创建的一个实时微内核操作系统(&lt;code&gt;RTOS(Real-Time Operating System&lt;/code&gt;), 后来被黑莓(&lt;code&gt;BlackBerry&lt;/code&gt;)公司收购，因此也叫做&lt;code&gt;Blackberry QNX&lt;/code&gt;系统。&lt;code&gt;QNX&lt;/code&gt;被世人熟知还是因为其高安全性、&lt;code&gt;QNX hypervisor&lt;/code&gt;等特性在汽车领域的广泛应用。&lt;/p&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://sniffer.site/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="virtualization" scheme="https://sniffer.site/tags/virtualization/"/>
    
    <category term="虚拟化" scheme="https://sniffer.site/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="QNX" scheme="https://sniffer.site/tags/QNX/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化之一虚拟机的基本概念</title>
    <link href="https://sniffer.site/2023/06/30/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E4%B8%80%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://sniffer.site/2023/06/30/%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B9%8B%E4%B8%80%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2023-06-30T05:58:13.000Z</published>
    <updated>2023-06-30T06:06:42.944Z</updated>
    
    <content type="html"><![CDATA[<p>这两年汽车领域在智能与域融合的推动下，开始兴起了各种虚拟化(<code>Virtualization</code>)的座舱解决方案，尤其以<a href="https://blackberry.qnx.com/en">黑莓公司的<code>QNX</code>虚拟化</a>方案应用最为广泛。说起来，虚拟化并不是什么新的概念，操作系统诞生之初就有了类似的原型: 对于一个分时的操作系统，通过在不同进程之间切换状态，给每个用户都制造一种完全使用整个机器的感觉，实则是操作系统通过进程之间的资源分时复用实现的结果。简单来说，虚拟化就是一种资源隔离与抽象的方案，通过对<code>CPU</code>、<code>Memory</code>、<code>I/O</code>设备增加中间层的访问控制，以达到与访问物理资源同等的效果。</p><span id="more"></span><p>在接下来的三篇文章里，我们就来一起来梳理虚拟化方案的整体脉络，先从大的基本概念入手，再将具体的实现细节，力求能够理解虚拟化的基本概念与实现原理:</p><ul><li>虚拟机的基本概念，主要讲虚拟化方案的优势，类型以及常见的虚拟化方案</li><li>汽车软件中常用的<code>QNX</code>虚拟化平台介绍，以及<code>CPU</code>、<code>I/O</code>、<code>Memory</code>以及中断虚拟化的具体原理</li><li><code>Linux</code>下的<code>I/O</code>设备虚拟化方案<code>virtio</code>的原理介绍</li></ul><p>这篇文章，我们就来看看虚拟化的一些基本概念，以及实现的类型与方式。</p><h2 id="虚拟化的基本概念"><a href="#虚拟化的基本概念" class="headerlink" title="虚拟化的基本概念"></a><strong>虚拟化的基本概念</strong></h2><p>从本质来说，虚拟化是一种资源隔离与权限访问控制的方法，比如常见的操作系统中的虚拟内存(<code>Virtual Memory</code>)以及<code>Java</code>中的<code>JVM(Java Virtual Machine</code>)都是基于类似的思路实现的。<code>JVM</code>是一种语言级别的虚拟化解决方案，其更多的是为了提供一个跨平台的执行环境，以解决编程语言的移植性;对于系统级别的虚拟化方案，如<code>VMWare/Xen/QNX</code>等，则是为了虚拟化整个操作系统所需要的环境，从而实现不同操作系统在同一个平台运行的目的。</p><p>常见的虚拟化方案有两种，分别称为<code>type-1</code>和<code>type-2</code>:</p><ul><li><code>type-1</code>的虚拟化方案的<code>hypervisor</code>直接运行在硬件上，此类虚拟机常见的有<code>VMWare ESX server</code>、<code>Xen</code>以及<code>QNX</code>等</li><li><code>type-2</code>的虚拟化方案的<code>hypervisor</code>则跑在一个宿主操作系统上,常见的虚拟机有<code>QEMU</code>、<code>VMWare Workstations</code>、<code>KVM</code>、<code>Oracle VirtualBox</code>等</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/vm-type.png" alt="虚拟化平台类型"></p><blockquote><p><code>hypervisor</code>是为虚拟机提供运行环境的系统软件，其目的是为了尽可能减少虚拟化带来的性能损失，也被称为<code>Virtual Machine Monitor(VMM)</code></p></blockquote><p>1974年， <code>Popek</code>与<code>Goldberg</code>提出了一个虚拟化管理程序<code>hypervisor</code>所需要遵循的三个基本的原则:</p><ul><li><code>Equivalence</code>(等价性): 虚拟机所执行的环境跟实际的物理硬件是等价的，一个<code>Guest</code>操作系统并不需要知道其本身是运行在虚拟机上还是实际的物理机上。这个规定相对而言比较严格，有时为了实现某些功能或者性能需要，<code>Guest</code>操作系统可能需要知道自己当前执行的是虚拟环境。</li><li><code>Safty</code>(安全): 虚拟化的隔离要求不同的虚拟机之间以及与<code>hypervisor</code>是完全隔离的，确保每个系统都是模块化的，互不影响。</li><li><code>Performance</code>(性能)： 虚拟化<code>hypervisor</code>需要尽可能的减少因为隔离与控制切换带来的性能损失，以接近于真实的物理执行环境的速度。</li></ul><h2 id="虚拟化的方法"><a href="#虚拟化的方法" class="headerlink" title="虚拟化的方法"></a><strong>虚拟化的方法</strong></h2><p>早期的很多虚拟化方案，由于没有芯片指令级的支持，通常都需要通过<a href="https://www.vmware.com/pdf/asplos235_adams.pdf">二进制翻译(<code>binary translation</code>)的方式</a>来达到<code>trap-and-emulate</code>(陷入与模拟)的虚拟化隔离，但这种方式效率较低，因此随着后续<code>x86</code>、<code>ARM</code>等平台增加了专门用于虚拟化的指令集，从而提升了虚拟机程序执行的效率。</p><p>实现虚拟化的方法一般有如下三种(下图中包含了软虚拟化与半虚拟化方案的示意图):</p><ul><li>软件虚拟化(<code>Full(software) Virtualization</code>): 虚拟机完全运行在<code>hypervisor</code>之上，并不知道当前运行在虚拟的环境中。常见的虚拟化提供商<code>VirtualBox/VMWare</code>都有类似的解决方案</li><li>硬件辅助虚拟化(<code>Hardware Virtualization, HVM</code>): 通过在芯片指令集中增加特殊的指令来辅助进行虚拟化，以提升虚拟化的性能</li><li>半虚拟化(<code>Paravirtualization</code>): 半虚拟化方案则通过虚拟机与<code>hypervisor</code>相互协作以完成虚拟化操作，此时虚拟机需要做额外的配置以实现虚拟化</li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/virtualization-methods.gif" alt="虚拟化的实现方法"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>虚拟化的概念伴随着计算机操作系统的概念一起诞生的，至今已有几十年历史。不管是在个人消费领域，还是分布式系统上，都可以看到虚拟化的身影。而在汽车领域，由于软件定义汽车(<code>SDV(Software Define Vehicle</code>)&#x2F;<code>SOA(Service Oriented Achitecture)</code>等概念与方案的逐步落地，用户对车辆不再满足于单一行车的功能，而是会有更多如个性化、智能化以及网联的需求。这些功能要求汽车厂商以及供应商具备更快速开发迭代的能力。目前虚拟化方案已经开始成为主机厂与方案供应商T1的首选方案了。未来，相信随着智能座舱域与自动驾驶域逐步走向融合，虚拟化方案由于其安全、高可用性、资源隔离等优点会得到更多的应用。</p><p>在下一篇文章，我们就一起来看看汽车领域的虚拟化方案领先者-<code>QNX</code>系统的架构与虚拟化实现原理。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.ibm.com/articles/l-virtio/">Virtio: An I&#x2F;O virtualization framework for Linux</a></li><li><a href="https://www.vmware.com/pdf/asplos235_adams.pdf">A Comparison of Software and Hardware Techniques for x86 Virtualization</a></li><li><a href="https://blackberry.qnx.com/en">Blackberry QNX</a></li><li>hardware and software support for virtualization(Edouard Bugnion, Jason Nieh, and Dan Tsafrir)</li><li><a href="https://github.com/Wenzel/awesome-virtualization">awesome-virtualization</a></li><li><a href="https://developer.ibm.com/tutorials/l-hypervisor/">Anatomy of a Linux hypervisor</a></li><li><a href="https://genode.org/documentation/articles/arm_virtualization">An in-depth look into the ARM virtualization extensions</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两年汽车领域在智能与域融合的推动下，开始兴起了各种虚拟化(&lt;code&gt;Virtualization&lt;/code&gt;)的座舱解决方案，尤其以&lt;a href=&quot;https://blackberry.qnx.com/en&quot;&gt;黑莓公司的&lt;code&gt;QNX&lt;/code&gt;虚拟化&lt;/a&gt;方案应用最为广泛。说起来，虚拟化并不是什么新的概念，操作系统诞生之初就有了类似的原型: 对于一个分时的操作系统，通过在不同进程之间切换状态，给每个用户都制造一种完全使用整个机器的感觉，实则是操作系统通过进程之间的资源分时复用实现的结果。简单来说，虚拟化就是一种资源隔离与抽象的方案，通过对&lt;code&gt;CPU&lt;/code&gt;、&lt;code&gt;Memory&lt;/code&gt;、&lt;code&gt;I/O&lt;/code&gt;设备增加中间层的访问控制，以达到与访问物理资源同等的效果。&lt;/p&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://sniffer.site/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="virtualization" scheme="https://sniffer.site/tags/virtualization/"/>
    
    <category term="虚拟化" scheme="https://sniffer.site/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="QNX" scheme="https://sniffer.site/tags/QNX/"/>
    
  </entry>
  
  <entry>
    <title>投屏中的服务发现协议</title>
    <link href="https://sniffer.site/2023/05/27/%E6%8A%95%E5%B1%8F%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8D%8F%E8%AE%AE/"/>
    <id>https://sniffer.site/2023/05/27/%E6%8A%95%E5%B1%8F%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8D%8F%E8%AE%AE/</id>
    <published>2023-05-27T06:29:32.000Z</published>
    <updated>2023-07-07T01:40:37.150Z</updated>
    
    <content type="html"><![CDATA[<p>投屏是指将某个终端的音视频或者其他内容通过有线或者无线的形式投射到其他终端上的一种协议。目前常见的投屏协议有<code>DLNA</code>&#x2F;<code>Airplay</code>&#x2F;<code>Mirracast</code>&#x2F;<code>Chromecast</code>:</p><ul><li><code>DLNA</code>(<code>Digital Living Network Alliance</code>): <a href="https://en.wikipedia.org/wiki/Digital_Living_Network_Alliance">DNLA</a>是由英特尔、索尼、微软等消费电子巨头在2003年建立的一个文件共享协议，目前很多的电视都会支持<code>DLNA</code>协议，用于手机与电视之间共享视频与图片等资源。</li><li><code>Airplay</code>: <a href="https://en.wikipedia.org/wiki/AirPlay">Airplay</a>是苹果公司开发的一个私有的投屏协议，实际包含了视频投屏与屏幕镜像等几个功能(音视频数据流包括交互控制协议都有是加密的)，可以用于播放音频、视频，也可以把本地的图片投屏到电视上进行浏览。目前国内很多支持<code>Airplay</code>的投屏协议都是基于秘钥破解进行开发的。<span id="more"></span></li><li><code>Mirracast</code>: <a href="https://www.wi-fi.org/discover-wi-fi/miracast">Mirracast</a>是<code>WIFI</code>联盟在2012年推出的一种基于<code>WIFI</code>将某个终端设备的音视频投屏到其他终端(比如电视、平板)上的协议，通常也被称为<code>HDMI over WIFI</code>。<code>Android</code>最开始在<code>AOSP 4.1</code>上实现了一个类似的<code>Mirracast</code>协议，后来的版本则全部删除了，后来<code>Google</code>就推出了闭源的一个投屏协议<code>Chromecast</code>。</li><li><code>Chromecast</code>: <code>Google</code>在2013年基于<code>Google Cast</code>协议开发的一个闭源的投屏协议，可以用于播放在线的音视频内容,用户可以通过支持<code>Google Cast</code>协议的手机或PC上的浏览器来控制音视频内容的播放。同时，<code>Google</code>提供了一个SDK给第三方应用开发投屏功能。</li></ul><p>对一个投屏协议来说，要在两个终端之间建立一个投屏的连接，通常需要经历如下几个步骤:</p><ul><li>被投屏的设备端以广播的形式向局域网的设备发布服务(该服务的信息通常会包含设备的名车，IP地址，以及通讯所用的端口地址等)</li><li>需要投屏的终端发现该服务后，会基于广播中的端口地址与另一端建立网络链接(控制与数据传输可能需要分开两个连接)</li><li>网络连接建立完成后，服务端需要告知对端设备的一些配置信息(比如设备的显示器的大小以及刷新率等)</li><li>投屏完成初始化配置后，最后一步就是投屏的终端向服务端发送需要投屏的内容(内容可能是音视频数据流，也可能是一个在线播放的<code>URL</code>)</li></ul><p>从上面的流程，我们可以看到，不同的投屏协议在其他方面可能有很大差别，但都离不开服务发现协议(<code>Service Discovery</code>)。在这篇文章，我们就来看看<code>DLNA</code>&#x2F;<code>Airplay</code>&#x2F;<code>Mirracast</code>三种投屏协议中所使用到的服务发现协议具体是怎么个原理。</p><h2 id="DLNA的服务发现"><a href="#DLNA的服务发现" class="headerlink" title="DLNA的服务发现"></a><strong>DLNA的服务发现</strong></h2><p>在<code>DLNA</code>中，播放音视频的一方通常被称为<code>Digital Media Renderer(DMR)</code>，而发送音视频数据的一方则称为<code>Digital Media Server(DMS)</code>, 负责中转数据的设备节点则称为<code>Control Point</code>(一般情况下，我们通常只有<code>DMS/DMR</code>两个设备，因此下文都是基于这种两个设备通讯的情况下进行讨论的)。<code>DLNA</code>使用<code>UPnP(Universal Plug and Play)</code>协议来进行服务发现以及数据的传输；<code>UPnP</code>可以在网络连接后通过<code>UDP</code>端口<code>1900</code>自动发布服务，<code>DMS</code>在收到该服务的广播消息后，会发送一个消息确认<code>DMR</code>的存在，这样整个服务发现过程就完成了。<code>UPnP</code>使用的服务发现协议叫做<code>SSDP(Simple Service Discovery Protocol)</code>。</p><p><code>DMR</code>服务启动后，会不断的通过组播地址<code>239.255.255.250:1900</code>发送<code>Advertisement</code>消息，广播系统当前的设备与服务状态(如果<code>DMR</code>中有多个设备或者服务，则会同时发送多个组播消息)，告知<code>DMS</code>有相应的设备与服务可用; 需要投屏的设备(<code>DMS</code>)收到该广播消息后，主动发送一个<code>M-SEARCH(ssdp:discover)</code>的消息, <code>DMR</code>收到该消息后需要发送一个<code>UDP</code>消息给<code>DMS</code>设备，该消息需要包含一个与广播<code>Advertisement</code>中一样的<code>UUID</code>。<code>Advertisement</code>消息一般有三种类型:</p><ul><li><code>NOTIFY ssdp:alive</code>: 当一个设备加入到网络中时需要发送<code>alive</code>消息广播根设备(<code>root device</code>)以及其他设备与服务的为可用状态，这样其他设备收到该消息后就可以发起连接</li><li><code>NOTIFY ssdp:byebye</code>: 设备从网络中移除时需要发送一个<code>byebyte</code>的消息告知其他节点设备即将变为不可用状态</li><li><code>NOTIFY ssdp:update</code>: 这个消息主要用于多IP设备广播设备与服务状态</li></ul><p>以<code>alive</code>组播消息为例，可以看到对于<code>SSDP</code>报文来说，最主要的字段主要有如下几个:</p><ul><li><code>CACHE-CONTROL:max-age=1800</code>: <code>Advertisement</code>消息最长生命周期</li><li><code>LOCATION</code>: 根设备的<code>URL</code>地址，一般是由IP地址与连接协议的监听端口号组成</li><li><code>NT</code>: 通知类型，如果是根设备通常是<code>upnp:rootdevice</code>, 其他设备对应的类型值是<code>NT:uuid:&lt;uuid&gt;</code>；如果是服务，则一般以<code>urn</code>开头,如:<ul><li><code>NT: urn:schemas-upnp-org:device:MediaRenderer</code></li><li><code>NT: urn:schemas-upnp-org:service:ConnectionManager</code></li></ul></li></ul><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ssdp-advertisement.png" alt="SSDP服务广播报文结构"></p><p>一旦完成服务发现，<code>DMR</code>通过<code>SOAP/XML</code>以及<code>HTTP</code>协议发布服务能力以及支持的协议，比如是否可以播放视频，是否能浏览图片等，最后通过连接服务来发送控制指令，可以完成诸如播放、暂停、跳转等功能。更多有关<code>UPnP/SSDP</code>协议相关的可以参考如下两个链接:</p><ul><li><a href="https://openconnectivity.org/upnp-specs/UPnP-arch-DeviceArchitecture-v2.0-20200417.pdf">UPnP Device Architecture 2.0</a></li><li><a href="https://github.com/4thline/cling">开源的协议实现:UPnP for Java&#x2F;Android</a></li></ul><h2 id="Airplay中的服务发现"><a href="#Airplay中的服务发现" class="headerlink" title="Airplay中的服务发现"></a><strong>Airplay中的服务发现</strong></h2><p>苹果的<code>Airplay</code>协议算是投屏协议里比较完全全面的，可以支持在线的音视频投屏、屏幕镜像以及图片浏览等功能，而且投屏过程中加入了私有秘钥验证机制，可以说是这几个投屏协议里安全性最好的。另外，<code>Airplay</code>可以支持有线与无线两种投屏方式。</p><p>实际上<code>Airplay</code>包含了两个服务，一个用于传输音频数据流的<a href="https://en.wikipedia.org/wiki/Remote_Audio_Output_Protocol"><code>RAOP(Remote Audio Output Protocol)</code></a>; 一个是用于传输视频与图片数据流的<code>Airplay</code>服务。<code>Airplay</code>中的服务发现是基于<code>DNS</code>的多播协议<code>muticast DNS(mDNS)</code>(最开始由<code>Apple</code>开源出来，也叫做<code>Bonjour</code>)来实现的，服务的发布与发现类似与域名的<code>DNS</code>解析过程:</p><ul><li>服务端通过<code>mDNS</code>服务进程发布<code>RAOP/Airplay</code>服务, 并监听<code>UDP</code>端口<code>5353</code></li><li>客户端连接上同一网络后，会发送<code>QUERY</code>到多播地址<code>224.0.0.251</code>对应的<code>5353</code>端口</li><li>服务端的<code>mDNS</code>收到请求后，把登记好的服务发送给对应的客户端</li></ul><blockquote><p>通过单播(<code>Unicast</code>)方式发送的<code>QUERY</code>响应(<code>RESPONSE</code>)的消息，称为<code>QU</code>消息; 通过多播方式发送<code>RESPONSE</code>的消息，称为<code>QM</code>消息。这个标志位会在<code>mDNS</code>消息中设置</p></blockquote><p>下面两个图分别是<code>mDNS</code>的<code>QUERY/RESPONSE</code>的消息，可以看到<code>mDNS</code>的消息结构与<code>DNS</code>的完全一致: <code>QUERY</code>中包含了需要查询的服务以及权威名称服务(<code>Authoritative nameservers</code>， 实际是客户端网口的<code>MAC</code>组成的一个名字而已); <code>RESPONSE</code>消息(根据记录类型不同，一般有<code>PTR</code>&#x2F;<code>TXT</code>两种)包含了服务的名称、协议类型，端口号以及协议所需要的其他字段(如设备的属性，设备的能力以及<code>MAC</code>地址等)。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/mdns-query.png" alt="mDNS query message"></p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/mdns-query-response.png" alt="mDNS query response"></p><p>完成服务发现后，客户端就会根据查询到的服务的端口与服务端建立连接，一般数据传输都使用<code>TCP</code>传输，其他的如时间同步协议则使用<code>UDP</code>。</p><p><code>Android</code>中已经集成了<code>mDNS</code>协议，代码可以参考<a href="https://cs.android.com/android/platform/superproject/+/master:external/mdnsresponder/">mdnsresponder</a>, 有关<code>mDNS</code>的详细细节可以参考<a href="https://www.rfc-editor.org/rfc/rfc6762.html">RFC6762</a>。</p><p><code>Airplay</code>是苹果公司的私有投屏协议，网上有一些相关的协议逆向分析的文档，但是都不算很全面，这里是之前搜索到的资料可以参考:</p><ul><li><a href="https://openairplay.github.io/airplay-spec/">Airplay非官方协议-总结的比较详细</a></li><li><a href="https://nto.github.io/AirPlay.html">Airplay协议分析</a></li><li><a href="https://emanuelecozzi.net/docs/airplay2">Airplay2协议细节</a></li></ul><p>已有实现的参考代码<a href="https://github.com/FD-/RPiPlay">Github RPiPlay</a>。</p><h2 id="Mirrorcast中的服务发现"><a href="#Mirrorcast中的服务发现" class="headerlink" title="Mirrorcast中的服务发现"></a><strong>Mirrorcast中的服务发现</strong></h2><p><code>Mirrorcast</code>在Android也被称作<code>Wifi Display(WFD)</code>，简单来说是一个通过<code>WIFI</code>来传输音视频数据的协议， 可以用于设备的屏幕镜像，这个跟<code>Airplay</code>的屏幕镜像功能是类似的。早在<code>Android 4.1</code>的时候<code>Google</code>开源过<a href="https://github.com/ivygroup/miracast-sink">相关代码</a>; 从实现来看， <code>Mirrorcast</code>并不算复杂，其主要分为两个大的步骤:</p><ul><li>通过<code>P2P</code>协议(也叫做<code>WIFI</code>直连(<code>Wifi Direct</code>))发现可用的<code>WFD</code>设备</li><li>与对应的<code>P2P</code>设备建立<code>RTP</code>连接，镜像的数据会通过<code>RTP</code>发送到接收端</li></ul><p><code>P2P</code>协议的发现分为两个流程，首先是设备的发现(<code>Device Disconvery</code>): 设备发现大致需要经过扫描与发现两个阶段。一个<code>P2P</code>设备要被发现需要处于<code>LISTEN</code>状态，并在2.4GHZ中的几个固定的<code>Socical</code>频段(1&#x2F;6&#x2F;11三个频段)选择一个频段进行监听，<code>P2P</code>设备在监听状态时只会对<code>Prope Request Frames</code>做出响应；设备在监听状态会等待固定的时间长度(0~100TU的随机时间)后，进入设备扫描阶段，扫描阶段，<code>P2P</code>会扫描周围设备与网络的所支持的所有频段。发现阶段的作用是确保两个设备处于同一个通讯频段。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/wifi-p2p-device-discovery-process.png" alt="P2P device discovery process"></p><p>设备发现完成后，就会进行服务发现。<code>P2P</code>的服务协议可以基于<code>Airplay/DLNA</code>中的协议如<code>mDNS/UPnP</code>进行扩展。搜索的一端主动发送<code>Service Discovery</code>数据帧，服务端收到搜索请求后发送<code>Response</code>给对端。<code>Android S</code>中可以看到两种服务发现协议的封装<a href="https://cs.android.com/android/platform/superproject/+/master:packages/modules/Wifi/framework/java/android/net/wifi/p2p/">WIFI P2P NSD</a>。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/p2p-service-discovery-process.png" alt="P2P service discovery process"></p><p>有关<code>WIFI P2P</code>的更多细节可以参考标准文档<a href="https://cse.iitkgp.ac.in/~bivasm/sp_notes/wifi_direct_2.pdf">WIFI Direct Spec</a>; 相关的代码实现可以参考<code>AOSP</code>的源码:</p><ul><li><a href="https://cs.android.com/android/platform/superproject/+/master:packages/modules/Wifi/">WIFI框架层代码</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://openconnectivity.org/upnp-specs/UPnP-arch-DeviceArchitecture-v2.0-20200417.pdf">UPnP协议文档</a></li><li><a href="https://openairplay.github.io/airplay-spec">Airplay非官方协议文档</a></li><li><a href="https://cse.iitkgp.ac.in/~bivasm/sp_notes/wifi_direct_2.pdf">P2P协议标准文档</a></li><li><a href="https://datatracker.ietf.org/doc/html/rfc3550">RTP协议标准文档</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;投屏是指将某个终端的音视频或者其他内容通过有线或者无线的形式投射到其他终端上的一种协议。目前常见的投屏协议有&lt;code&gt;DLNA&lt;/code&gt;&amp;#x2F;&lt;code&gt;Airplay&lt;/code&gt;&amp;#x2F;&lt;code&gt;Mirracast&lt;/code&gt;&amp;#x2F;&lt;code&gt;Chromecast&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DLNA&lt;/code&gt;(&lt;code&gt;Digital Living Network Alliance&lt;/code&gt;): &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_Living_Network_Alliance&quot;&gt;DNLA&lt;/a&gt;是由英特尔、索尼、微软等消费电子巨头在2003年建立的一个文件共享协议，目前很多的电视都会支持&lt;code&gt;DLNA&lt;/code&gt;协议，用于手机与电视之间共享视频与图片等资源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Airplay&lt;/code&gt;: &lt;a href=&quot;https://en.wikipedia.org/wiki/AirPlay&quot;&gt;Airplay&lt;/a&gt;是苹果公司开发的一个私有的投屏协议，实际包含了视频投屏与屏幕镜像等几个功能(音视频数据流包括交互控制协议都有是加密的)，可以用于播放音频、视频，也可以把本地的图片投屏到电视上进行浏览。目前国内很多支持&lt;code&gt;Airplay&lt;/code&gt;的投屏协议都是基于秘钥破解进行开发的。</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="投屏" scheme="https://sniffer.site/tags/%E6%8A%95%E5%B1%8F/"/>
    
    <category term="DLNA" scheme="https://sniffer.site/tags/DLNA/"/>
    
    <category term="Airplay" scheme="https://sniffer.site/tags/Airplay/"/>
    
  </entry>
  
  <entry>
    <title>Android如何进行DNS解析</title>
    <link href="https://sniffer.site/2023/04/17/Android%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8CDNS%E8%A7%A3%E6%9E%90/"/>
    <id>https://sniffer.site/2023/04/17/Android%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8CDNS%E8%A7%A3%E6%9E%90/</id>
    <published>2023-04-17T08:54:27.000Z</published>
    <updated>2023-04-18T06:07:52.377Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Domain_Name_System"><code>DNS(Domain Name System)</code></a>即域名解析系统，是网络访问时用于将域名解析成对应IP地址的一种分布式网络服务。比如，要访问<code>www.google.com</code>这个域名，<code>Android</code>系统会首先发送一个<code>UDP</code>请求到标准的<code>53</code>端口系统的域名解析服务器，拿到对应的IP地址后才会与服务端建立连接。除了标准的<code>DNS</code>服务外，目前还有<code>HttpDNS</code>(<a href="https://en.wikipedia.org/wiki/DNS_over_HTTPS"><code>DNS over Https, DoH</code></a>)以及基于<code>TSL</code>的<code>DNS</code>服务(<a href="https://datatracker.ietf.org/doc/html/rfc7858"><code>DNS over TLS， DoT</code></a>)。</p><p>那么，<code>Android</code>中<code>DNS</code>解析的大致框架是怎么的？整个<code>DNS</code>解析的流程又是怎么样的？ 在看具体实现细节之前，我们不妨思考一下几个问题，想一想，如果我们自己从零开始为<code>Android</code>设计一个<code>DNS</code>系统，应该怎么做？</p><span id="more"></span><ul><li><code>DNS</code>服务应该何时启动初始化，以何种形式为应用提供服务？</li><li><code>Android</code>中每个应用访问网络都会进行域名解析，如何对解析结果进行缓存，确保同样的域名不会被重复解析？</li><li>不同网络切换时，比如从<code>WIFI</code>切换到<code>4G</code>网络时，<code>DNS</code>解析的缓存应该如何清除？</li></ul><p>带着这几个问题，本文将从三个方面详细阐述下<code>Android</code>中<code>DNS</code>解析的具体原理与实现细节:</p><ul><li><code>DNS</code>服务的初始化</li><li>应用是如何执行域名解析的</li><li>网络变化时，<code>DNS</code>域名解析缓存是如何变化的</li></ul><blockquote><p>本文参考的源码是<code>Android S(12)</code></p></blockquote><h2 id="DNS系统服务的初始化"><a href="#DNS系统服务的初始化" class="headerlink" title="DNS系统服务的初始化"></a><strong>DNS系统服务的初始化</strong></h2><p><code>Android</code>中网络管理的核心服务都是在<a href="https://sniffer.site/2018/12/18/android-netd%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"><code>NETD</code></a>进程中实现的，<code>DNS</code>也不例外。在<code>netd</code>进程初始化时，系统会对<code>DNS</code>服务进行初始化<code>initDnsResolver</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stopwatch s;</span><br><span class="line">    gLog.<span class="built_in">info</span>(<span class="string">&quot;netd 1.0 starting&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Make sure BPF programs are loaded before doing anything</span></span><br><span class="line">    android::bpf::<span class="built_in">waitForProgsLoaded</span>();</span><br><span class="line">    gLog.<span class="built_in">info</span>(<span class="string">&quot;BPF programs are loaded&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Set local DNS mode, to prevent bionic from proxying</span></span><br><span class="line">    <span class="comment">// back to this service, recursively.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Check if we could remove it since resolver cache no loger</span></span><br><span class="line">    <span class="comment">// checks this environment variable after aosp/838050.</span></span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;ANDROID_DNS_MODE&quot;</span>, <span class="string">&quot;local&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Note that only call initDnsResolver after gCtls initializing.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">initDnsResolver</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to init resolver&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MDnsSdListener mdnsl;</span><br><span class="line">    <span class="keyword">if</span> (mdnsl.<span class="built_in">startListener</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to start MDnsSdListener (%s)&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">FwmarkServer <span class="title">fwmarkServer</span><span class="params">(&amp;gCtls-&gt;netCtrl, &amp;gCtls-&gt;eventReporter, &amp;gCtls-&gt;trafficCtrl)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (fwmarkServer.<span class="built_in">startListener</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to start FwmarkServer (%s)&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stopwatch subTime;</span><br><span class="line">    <span class="type">status_t</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = NetdNativeService::<span class="built_in">start</span>()) != android::OK) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to start NetdNativeService: %d&quot;</span>, ret);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    gLog.<span class="built_in">info</span>(<span class="string">&quot;Registering NetdNativeService: %&quot;</span> PRId64 <span class="string">&quot;us&quot;</span>, subTime.<span class="built_in">getTimeAndResetUs</span>());</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    gLog.<span class="built_in">info</span>(<span class="string">&quot;netd exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>initDnsResolver</code>调用<code>resolv_init</code>执行<code>DNS</code>服务的初始化，并注册一个回调函数，用于<code>DNS</code>服务调用时权限检查、获取当前网络ID以及打印日志等:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">initDnsResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResolverNetdCallbacks callbacks = &#123;</span><br><span class="line">            .check_calling_permission = &amp;checkCallingPermissionCallback,</span><br><span class="line">            .get_network_context = &amp;getNetworkContextCallback,</span><br><span class="line">            .log = &amp;logCallback,</span><br><span class="line">            .tagSocket = &amp;tagSocketCallback,</span><br><span class="line">            .evaluate_domain_name = &amp;evaluateDomainNameCallback,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">resolv_init</span>(&amp;callbacks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Android S</code>中<code>DNS</code>服务的代码放在了一个单独的模块<code>packages/modules/DnsResolver</code>中，函数<code>resolv_init</code>就是在模块的<code>DnsResolver.cpp</code>中实现的, 主要是设置日志标记以及打印等级，核心逻辑是创建一个<code>DnsResolver</code>对象，并启动<code>DNS</code>服务:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">resolv_init</span><span class="params">(<span class="type">const</span> ResolverNetdCallbacks* callbacks)</span> </span>&#123;</span><br><span class="line">    android::base::<span class="built_in">InitLogging</span>(<span class="comment">/*argv=*/</span><span class="literal">nullptr</span>);</span><br><span class="line">    android::base::<span class="built_in">SetDefaultTag</span>(<span class="string">&quot;libnetd_resolv&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: Initializing resolver&quot;</span>;</span><br><span class="line">    <span class="comment">// TODO(b/170539625): restore log level to WARNING after clarifying flaky tests.</span></span><br><span class="line">    <span class="built_in">resolv_set_log_severity</span>(<span class="built_in">isUserDebugBuild</span>() ? android::base::DEBUG : android::base::WARNING);</span><br><span class="line">    <span class="keyword">using</span> android::net::gApiLevel;</span><br><span class="line">    gApiLevel = <span class="built_in">getApiLevel</span>();</span><br><span class="line">    <span class="keyword">using</span> android::net::gResNetdCallbacks;</span><br><span class="line">    gResNetdCallbacks.check_calling_permission = callbacks-&gt;check_calling_permission;</span><br><span class="line">    gResNetdCallbacks.get_network_context = callbacks-&gt;get_network_context;</span><br><span class="line">    gResNetdCallbacks.log = callbacks-&gt;log;</span><br><span class="line">    <span class="keyword">if</span> (gApiLevel &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">        gResNetdCallbacks.tagSocket = callbacks-&gt;tagSocket;</span><br><span class="line">        gResNetdCallbacks.evaluate_domain_name = callbacks-&gt;evaluate_domain_name;</span><br><span class="line">    &#125;</span><br><span class="line">    android::net::gDnsResolv = android::net::DnsResolver::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">return</span> android::net::gDnsResolv-&gt;<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>DNS</code>服务的启动主要完成了三件事情: </p><ul><li>初始化私有DNS功能<code>DnsTlsDispatcher::getInstance()</code></li><li>启动<code>DNS</code>代理服务，启动一个名为<code>dnsproxyd</code>的<code>Unix Socket</code>服务，用于监听应用的域名解析请求</li><li>启动<code>IDnsResolver.aidl</code>的<code>HAL binder</code>服务，主要提供网络切换时设置<code>DNS</code>，创建缓存、清理缓存等接口</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DnsResolver::<span class="built_in">DnsResolver</span>() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> make them member variables after fixing the circular dependency:</span></span><br><span class="line">    <span class="comment">//   DnsTlsDispatcher.h -&gt; resolv_private.h -&gt; DnsResolver.h -&gt; DnsTlsDispatcher.h</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; dnsTlsDispatcher = DnsTlsDispatcher::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">auto</span>&amp; privateDnsConfiguration = PrivateDnsConfiguration::<span class="built_in">getInstance</span>();</span><br><span class="line">    privateDnsConfiguration.<span class="built_in">setObserver</span>(&amp;dnsTlsDispatcher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DnsResolver::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">verifyCallbacks</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: Callback verification failed&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDnsProxyListener.<span class="built_in">startListener</span>()) &#123;</span><br><span class="line">        <span class="built_in">PLOG</span>(ERROR) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: Unable to start DnsProxyListener&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">binder_status_t</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = DnsResolverService::<span class="built_in">start</span>()) != STATUS_OK) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: Unable to start DnsResolverService: &quot;</span> &lt;&lt; ret;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，<code>DNS</code>相关的功能完成了初始化。接下来，我们继续看第二部分: 应用是如何获取到域名的IP地址的。</p><h2 id="应用是如何解析域名的"><a href="#应用是如何解析域名的" class="headerlink" title="应用是如何解析域名的"></a><strong>应用是如何解析域名的</strong></h2><p>在深入细节之前，不妨看下<code>Android</code>中的<code>DNS</code>服务的大致框架。应用通过标准的JAVA接口<code>getAllByName</code>尝试解析域名，然后通过JNI调用<code>libc</code>中的接口，<code>libc</code>负责将域名解析请求通过名为<code>dnsproxyd</code>的<code>Unix Socket</code>发送给<code>DNS</code>代理服务，<code>DNS</code>服务查询到对应域名的IP地址列表再通过<code>socket</code>接口返回给应用。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/how_android_dns_works.png" alt="Android DNS服务框架"></p><ul><li>应用调用<code>InetAddress.getAllByName</code>获取域名对应的IP列表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* The implementation is always dual stack IPv6/IPv4 on android */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">InetAddressImpl</span> <span class="variable">impl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inet6AddressImpl</span>();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress[] getAllByName(String host)</span><br><span class="line">    <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">    <span class="comment">// Android-changed: Resolves a hostname using Libcore.os.</span></span><br><span class="line">    <span class="comment">// Also, returns both the Inet4 and Inet6 loopback for null/empty host</span></span><br><span class="line">    <span class="keyword">return</span> impl.lookupAllHostAddr(host, NETID_UNSET).clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>尝试从JAVA中的缓存中获取IP地址，如果没有缓存，则尝试解析域名, 并将结果保存到缓存中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resolves a hostname to its IP addresses using a cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InetAddress[] lookupHostByName(String host, <span class="type">int</span> netId)</span><br><span class="line">        <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">    BlockGuard.getThreadPolicy().onNetwork();</span><br><span class="line">    <span class="comment">// Do we have a result cached?</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cachedResult</span> <span class="operator">=</span> addressCache.get(host, netId);</span><br><span class="line">    <span class="keyword">if</span> (cachedResult != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedResult <span class="keyword">instanceof</span> InetAddress[]) &#123;</span><br><span class="line">            <span class="comment">// A cached positive result.</span></span><br><span class="line">            <span class="keyword">return</span> (InetAddress[]) cachedResult;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// A cached negative result.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnknownHostException</span>((String) cachedResult);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">StructAddrinfo</span> <span class="variable">hints</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StructAddrinfo</span>();</span><br><span class="line">        hints.ai_flags = AI_ADDRCONFIG;</span><br><span class="line">        hints.ai_family = AF_UNSPEC;</span><br><span class="line">        <span class="comment">// If we don&#x27;t specify a socket type, every address will appear twice, once</span></span><br><span class="line">        <span class="comment">// for SOCK_STREAM and one for SOCK_DGRAM. Since we do not return the family</span></span><br><span class="line">        <span class="comment">// anyway, just pick one.</span></span><br><span class="line">        hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">        InetAddress[] addresses = Libcore.os.android_getaddrinfo(host, hints, netId);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> should getaddrinfo set the hostname of the InetAddresses it returns?</span></span><br><span class="line">        <span class="keyword">for</span> (InetAddress address : addresses) &#123;</span><br><span class="line">            address.holder().hostName = host;</span><br><span class="line">            address.holder().originalHostName = host;</span><br><span class="line">        &#125;</span><br><span class="line">        addressCache.put(host, netId, addresses);</span><br><span class="line">        <span class="keyword">return</span> addresses;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (GaiException gaiException) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>Libcore.os.android_getaddrinfo</code>调用<code>libc</code>中的<code>DNS</code>接口<code>android_getaddrinfofornet</code>尝试解析域名:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> jobjectArray <span class="title">Linux_android_getaddrinfo</span><span class="params">(JNIEnv* env, jobject, jstring javaNode,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject javaHints, jint netId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    addrinfo hints;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints, <span class="number">0</span>, <span class="built_in">sizeof</span>(hints));</span><br><span class="line">    hints.ai_flags = env-&gt;<span class="built_in">GetIntField</span>(javaHints, flagsFid);</span><br><span class="line">    hints.ai_family = env-&gt;<span class="built_in">GetIntField</span>(javaHints, familyFid);</span><br><span class="line">    hints.ai_socktype = env-&gt;<span class="built_in">GetIntField</span>(javaHints, socktypeFid);</span><br><span class="line">    hints.ai_protocol = env-&gt;<span class="built_in">GetIntField</span>(javaHints, protocolFid);</span><br><span class="line"></span><br><span class="line">    addrinfo* addressList = <span class="literal">NULL</span>;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rc = <span class="built_in">android_getaddrinfofornet</span>(node.<span class="built_in">c_str</span>(), <span class="literal">NULL</span>, &amp;hints, netId, <span class="number">0</span>, &amp;addressList);</span><br><span class="line">    <span class="function">std::unique_ptr&lt;addrinfo, addrinfo_deleter&gt; <span class="title">addressListDeleter</span><span class="params">(addressList)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">throwGaiException</span>(env, <span class="string">&quot;android_getaddrinfo&quot;</span>, rc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count results so we know how to size the output array.</span></span><br><span class="line">    <span class="type">int</span> addressCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (addrinfo* ai = addressList; ai != <span class="literal">NULL</span>; ai = ai-&gt;ai_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ai-&gt;ai_family == AF_INET || ai-&gt;ai_family == AF_INET6) &#123;</span><br><span class="line">            ++addressCount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;android_getaddrinfo unexpected ai_family %i&quot;</span>, ai-&gt;ai_family);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Prepare output array.</span></span><br><span class="line">    jobjectArray result = env-&gt;<span class="built_in">NewObjectArray</span>(addressCount, JniConstants::<span class="built_in">GetInetAddressClass</span>(env), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Examine returned addresses one by one, save them in the output array.</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (addrinfo* ai = addressList; ai != <span class="literal">NULL</span>; ai = ai-&gt;ai_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ai-&gt;ai_family != AF_INET &amp;&amp; ai-&gt;ai_family != AF_INET6) &#123;</span><br><span class="line">            <span class="comment">// Unknown address family. Skip this address.</span></span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;android_getaddrinfo unexpected ai_family %i&quot;</span>, ai-&gt;ai_family);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert each IP address into a Java byte array.</span></span><br><span class="line">        sockaddr_storage&amp; address = *<span class="built_in">reinterpret_cast</span>&lt;sockaddr_storage*&gt;(ai-&gt;ai_addr);</span><br><span class="line">        <span class="function">ScopedLocalRef&lt;jobject&gt; <span class="title">inetAddress</span><span class="params">(env, sockaddrToInetAddress(env, address, <span class="literal">NULL</span>))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (inetAddress.<span class="built_in">get</span>() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        env-&gt;<span class="built_in">SetObjectArrayElement</span>(result, index, inetAddress.<span class="built_in">get</span>());</span><br><span class="line">        ++index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>继续调用<code>android_getaddrinfofornetcontext</code>:该函数实际通过<code>android_getaddrinfo_proxy</code>将域名解析请求通过<code>dnsproxyd</code>的<code>Unix Socket</code>发送给<code>netd</code>的<code>DNS</code>解析服务:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">__BIONIC_WEAK_FOR_NATIVE_BRIDGE</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">android_getaddrinfofornetcontext</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hostname, <span class="type">const</span> <span class="type">char</span> *servname,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="type">const</span> <span class="keyword">struct</span> android_net_context *netcontext,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> addrinfo **res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">addrinfo</span> *pai;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">explore</span> *ex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* hostname is allowed to be NULL */</span></span><br><span class="line">  <span class="comment">/* servname is allowed to be NULL */</span></span><br><span class="line">  <span class="comment">/* hints is allowed to be NULL */</span></span><br><span class="line">  <span class="built_in">assert</span>(res != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">assert</span>(netcontext != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;sentinel, <span class="number">0</span>, <span class="built_in">sizeof</span>(sentinel));</span><br><span class="line">  cur = &amp;sentinel;</span><br><span class="line">  pai = &amp;ai;</span><br><span class="line">  pai-&gt;ai_flags = <span class="number">0</span>;</span><br><span class="line">  pai-&gt;ai_family = PF_UNSPEC;</span><br><span class="line">  pai-&gt;ai_socktype = ANY;</span><br><span class="line">  pai-&gt;ai_protocol = ANY;</span><br><span class="line">  pai-&gt;ai_addrlen = <span class="number">0</span>;</span><br><span class="line">  pai-&gt;ai_canonname = <span class="literal">NULL</span>;</span><br><span class="line">  pai-&gt;ai_addr = <span class="literal">NULL</span>;</span><br><span class="line">  pai-&gt;ai_next = <span class="literal">NULL</span>;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏变量`__ANDROID__`是在`libc`库编译的时候设置的</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">  <span class="type">int</span> gai_error = <span class="built_in">android_getaddrinfo_proxy</span>(</span><br><span class="line">    hostname, servname, hints, res, netcontext-&gt;app_netid);</span><br><span class="line">  <span class="keyword">if</span> (gai_error != EAI_SYSTEM) &#123;</span><br><span class="line">    <span class="keyword">return</span> gai_error;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>函数<code>android_getaddrinfo_proxy</code>首先通过<code>NetdClient</code>中的函数<code>dns_open_proxy</code>创建与<code>DNS</code>服务的<code>socket</code>接口，然后向服务端发送一个<code>getaddrinfo www.google.com x x x x x</code>的指令, 然后尝试读取服务端返回的结果:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// Returns 0 on success, else returns on error.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">android_getaddrinfo_proxy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="type">char</span> *hostname, <span class="type">const</span> <span class="type">char</span> *servname,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, <span class="keyword">struct</span> addrinfo **res, <span class="type">unsigned</span> netid)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear this at start, as we use its non-NULLness later (in the</span></span><br><span class="line">    <span class="comment">// error path) to decide if we have to free up any memory we</span></span><br><span class="line">    <span class="comment">// allocated in the process (before failing).</span></span><br><span class="line">    *res = <span class="literal">NULL</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    FILE* proxy = <span class="built_in">fdopen</span>(__netdClientDispatch.<span class="built_in">dnsOpenProxy</span>(), <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (proxy == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> EAI_SYSTEM;</span><br><span class="line">    &#125;</span><br><span class="line">    netid = __netdClientDispatch.<span class="built_in">netIdForResolv</span>(netid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send the request.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fprintf</span>(proxy, <span class="string">&quot;getaddrinfo %s %s %d %d %d %d %u&quot;</span>,</span><br><span class="line">          hostname == <span class="literal">NULL</span> ? <span class="string">&quot;^&quot;</span> : hostname,</span><br><span class="line">          servname == <span class="literal">NULL</span> ? <span class="string">&quot;^&quot;</span> : servname,</span><br><span class="line">          hints == <span class="literal">NULL</span> ? <span class="number">-1</span> : hints-&gt;ai_flags,</span><br><span class="line">          hints == <span class="literal">NULL</span> ? <span class="number">-1</span> : hints-&gt;ai_family,</span><br><span class="line">          hints == <span class="literal">NULL</span> ? <span class="number">-1</span> : hints-&gt;ai_socktype,</span><br><span class="line">          hints == <span class="literal">NULL</span> ? <span class="number">-1</span> : hints-&gt;ai_protocol,</span><br><span class="line">          netid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">// read result code for gethostbyaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="built_in">sizeof</span>(buf), proxy) != <span class="built_in">sizeof</span>(buf)) &#123;</span><br><span class="line">      <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result_code = (<span class="type">int</span>)<span class="built_in">strtol</span>(buf, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// verify the code itself</span></span><br><span class="line">    <span class="keyword">if</span> (result_code != DnsProxyQueryResult) &#123;</span><br><span class="line">      <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="built_in">sizeof</span>(buf), proxy);</span><br><span class="line">      <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span>* ai = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span>** nextres = res;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">int32_t</span> have_more;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">readBE32</span>(proxy, &amp;have_more)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (have_more == <span class="number">0</span>) &#123;</span><br><span class="line">        success = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ai = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> addrinfo) + <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage));</span><br><span class="line">      <span class="keyword">if</span> (ai == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ai-&gt;ai_addr = (<span class="keyword">struct</span> sockaddr*)(ai + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// struct addrinfo &#123;</span></span><br><span class="line">      <span class="comment">//intai_flags;/* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */</span></span><br><span class="line">      <span class="comment">//intai_family;/* PF_xxx */</span></span><br><span class="line">      <span class="comment">//intai_socktype;/* SOCK_xxx */</span></span><br><span class="line">      <span class="comment">//intai_protocol;/* 0 or IPPROTO_xxx for IPv4 and IPv6 */</span></span><br><span class="line">      <span class="comment">//socklen_t ai_addrlen;/* length of ai_addr */</span></span><br><span class="line">      <span class="comment">//char*ai_canonname;/* canonical name for hostname */</span></span><br><span class="line">      <span class="comment">//structsockaddr *ai_addr;/* binary address */</span></span><br><span class="line">      <span class="comment">//structaddrinfo *ai_next;/* next structure in linked list */</span></span><br><span class="line">      <span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Read the struct piece by piece because we might be a 32-bit process</span></span><br><span class="line">      <span class="comment">// talking to a 64-bit netd.</span></span><br><span class="line">      <span class="type">int32_t</span> addr_len;</span><br><span class="line">      <span class="type">bool</span> success =</span><br><span class="line">          <span class="built_in">readBE32</span>(proxy, &amp;ai-&gt;ai_flags) &amp;&amp;</span><br><span class="line">          <span class="built_in">readBE32</span>(proxy, &amp;ai-&gt;ai_family) &amp;&amp;</span><br><span class="line">          <span class="built_in">readBE32</span>(proxy, &amp;ai-&gt;ai_socktype) &amp;&amp;</span><br><span class="line">          <span class="built_in">readBE32</span>(proxy, &amp;ai-&gt;ai_protocol) &amp;&amp;</span><br><span class="line">          <span class="built_in">readBE32</span>(proxy, &amp;addr_len);</span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set ai_addrlen and read the ai_addr data.</span></span><br><span class="line">      ai-&gt;ai_addrlen = addr_len;</span><br><span class="line">      <span class="keyword">if</span> (addr_len != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">size_t</span>) addr_len &gt; <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage)) &#123;</span><br><span class="line">          <span class="comment">// Bogus; too big.</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fread</span>(ai-&gt;ai_addr, addr_len, <span class="number">1</span>, proxy) != <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ai != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">// Clean up partially-built addrinfo that we never ended up</span></span><br><span class="line">      <span class="comment">// attaching to the response.</span></span><br><span class="line">      <span class="built_in">freeaddrinfo</span>(ai);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>服务端的代理<code>DnsProxyListener</code>收到域名解析指令<code>getaddrinfo</code>后，启动一个新的线程处理该请求:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DnsProxyListener::GetAddrInfoCmd::<span class="built_in">GetAddrInfoCmd</span>() : <span class="built_in">FrameworkCommand</span>(<span class="string">&quot;getaddrinfo&quot;</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> DnsProxyListener::GetAddrInfoCmd::<span class="built_in">runCommand</span>(SocketClient* cli, <span class="type">int</span> argc, <span class="type">char</span>** argv) &#123;</span><br><span class="line">    <span class="built_in">logArguments</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="type">char</span>* msg = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">asprintf</span>(&amp;msg, <span class="string">&quot;Invalid number of arguments to getaddrinfo: %i&quot;</span>, argc);</span><br><span class="line">        <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;GetAddrInfoCmd::runCommand: &quot;</span> &lt;&lt; (msg ? msg : <span class="string">&quot;null&quot;</span>);</span><br><span class="line">        cli-&gt;<span class="built_in">sendMsg</span>(ResponseCode::CommandParameterError, msg, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">free</span>(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string name = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">const</span> std::string service = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ai_flags = <span class="built_in">strtol</span>(argv[<span class="number">3</span>], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> ai_family = <span class="built_in">strtol</span>(argv[<span class="number">4</span>], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> ai_socktype = <span class="built_in">strtol</span>(argv[<span class="number">5</span>], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> ai_protocol = <span class="built_in">strtol</span>(argv[<span class="number">6</span>], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">unsigned</span> netId = <span class="built_in">strtoul</span>(argv[<span class="number">7</span>], <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> useLocalNameservers = <span class="built_in">checkAndClearUseLocalNameserversFlag</span>(&amp;netId);</span><br><span class="line">    <span class="type">const</span> <span class="type">uid_t</span> uid = cli-&gt;<span class="built_in">getUid</span>();</span><br><span class="line"></span><br><span class="line">    android_net_context netcontext;</span><br><span class="line">    gResNetdCallbacks.<span class="built_in">get_network_context</span>(netId, uid, &amp;netcontext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useLocalNameservers) &#123;</span><br><span class="line">        netcontext.flags |= NET_CONTEXT_FLAG_USE_LOCAL_NAMESERVERS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;addrinfo&gt; hints;</span><br><span class="line">    <span class="keyword">if</span> (ai_flags != <span class="number">-1</span> || ai_family != <span class="number">-1</span> || ai_socktype != <span class="number">-1</span> || ai_protocol != <span class="number">-1</span>) &#123;</span><br><span class="line">        hints.<span class="built_in">reset</span>((addrinfo*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(addrinfo)));</span><br><span class="line">        hints-&gt;ai_flags = ai_flags;</span><br><span class="line">        hints-&gt;ai_family = ai_family;</span><br><span class="line">        hints-&gt;ai_socktype = ai_socktype;</span><br><span class="line">        hints-&gt;ai_protocol = ai_protocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">new</span> <span class="built_in">GetAddrInfoHandler</span>(cli, name, service, <span class="built_in">move</span>(hints), netcontext))-&gt;<span class="built_in">spawn</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>处理域名解析请求的线程执行，首先会通过<code>resolv_getaddrinfo</code>尝试域名解析(如果没有cache，则会向域名解析服务器发送解析请求，这里默认是<code>53</code>的UDP端口)，拿到解析后的IP地址后，通过<code>socket</code>发送地址列表给客户端。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> DnsProxyListener::GetAddrInfoHandler::<span class="built_in">run</span>() &#123;</span><br><span class="line">    addrinfo* result = <span class="literal">nullptr</span>;</span><br><span class="line">    Stopwatch s;</span><br><span class="line">    <span class="built_in">maybeFixupNetContext</span>(&amp;mNetContext, mClient-&gt;<span class="built_in">getPid</span>());</span><br><span class="line">    <span class="type">const</span> <span class="type">uid_t</span> uid = mClient-&gt;<span class="built_in">getUid</span>();</span><br><span class="line">    <span class="type">int32_t</span> rv = <span class="number">0</span>;</span><br><span class="line">    NetworkDnsEventReported event;</span><br><span class="line">    <span class="built_in">initDnsEvent</span>(&amp;event, mNetContext);</span><br><span class="line">    <span class="keyword">if</span> (queryLimiter.<span class="built_in">start</span>(uid)) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* host = mHost.<span class="built_in">starts_with</span>(<span class="string">&#x27;^&#x27;</span>) ? <span class="literal">nullptr</span> : mHost.<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* service = mService.<span class="built_in">starts_with</span>(<span class="string">&#x27;^&#x27;</span>) ? <span class="literal">nullptr</span> : mService.<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">evaluate_domain_name</span>(mNetContext, host)) &#123;</span><br><span class="line">            rv = <span class="built_in">resolv_getaddrinfo</span>(host, service, mHints.<span class="built_in">get</span>(), &amp;mNetContext, &amp;result, &amp;event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rv = EAI_SYSTEM;</span><br><span class="line">        &#125;</span><br><span class="line">        queryLimiter.<span class="built_in">finish</span>(uid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Note that this error code is currently not passed down to the client.</span></span><br><span class="line">        <span class="comment">// android_getaddrinfo_proxy() returns EAI_NODATA on any error.</span></span><br><span class="line">        rv = EAI_MEMORY;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;GetAddrInfoHandler::run: from UID &quot;</span> &lt;&lt; uid</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, max concurrent queries reached&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">doDns64Synthesis</span>(&amp;rv, &amp;result, &amp;event);</span><br><span class="line">    <span class="type">const</span> <span class="type">int32_t</span> latencyUs = <span class="built_in">saturate_cast</span>&lt;<span class="type">int32_t</span>&gt;(s.<span class="built_in">timeTakenUs</span>());</span><br><span class="line">    event.<span class="built_in">set_latency_micros</span>(latencyUs);</span><br><span class="line">    event.<span class="built_in">set_event_type</span>(EVENT_GETADDRINFO);</span><br><span class="line">    event.<span class="built_in">set_hints_ai_flags</span>((mHints ? mHints-&gt;ai_flags : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (rv) &#123;</span><br><span class="line">        <span class="comment">// getaddrinfo failed</span></span><br><span class="line">        success = !mClient-&gt;<span class="built_in">sendBinaryMsg</span>(ResponseCode::DnsProxyOperationFailed, &amp;rv, <span class="built_in">sizeof</span>(rv));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        success = !mClient-&gt;<span class="built_in">sendCode</span>(ResponseCode::DnsProxyQueryResult);</span><br><span class="line">        addrinfo* ai = result;</span><br><span class="line">        <span class="keyword">while</span> (ai &amp;&amp; success) &#123;</span><br><span class="line">            success = <span class="built_in">sendBE32</span>(mClient, <span class="number">1</span>) &amp;&amp; <span class="built_in">sendaddrinfo</span>(mClient, ai);</span><br><span class="line">            ai = ai-&gt;ai_next;</span><br><span class="line">        &#125;</span><br><span class="line">        success = success &amp;&amp; <span class="built_in">sendBE32</span>(mClient, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">freeaddrinfo</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有关域名解析的具体实现<code>resolv_getaddrinfo</code>可以参考<code>packages/modules/DnsResolver</code>中的代码，这里就不具体展开分析了。</p><h2 id="网络切换时DNS缓存时如何清除的"><a href="#网络切换时DNS缓存时如何清除的" class="headerlink" title="网络切换时DNS缓存时如何清除的"></a><strong>网络切换时DNS缓存时如何清除的</strong></h2><p>发生网络切换时，<code>Android</code>需要确保<code>DNS</code>服务使用了正确的服务器进行域名解析，另外要清除掉之前网络域名解析的缓存，确保两个网络的解析结果是独立的。<code>Android</code>的网络管理都是由<code>ConnectivityService</code>系统服务来完成的，当两个网络发生切换时，<code>ConnectivityService</code>会更新网络的<code>DNS</code>配置, 并清除<code>DNS</code>服务中对应的缓存:</p><ul><li><code>updateLinkProperties</code>时网络状态切换: 设置<code>DNS</code>解析服务器，清除应用自身的缓存</li><li><code>destroyNetwork</code>: 断开网络时，会完全清除系统对应的<code>DNS</code>缓存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateLinkProperties</span><span class="params">(NetworkAgentInfo networkAgent, <span class="meta">@NonNull</span> LinkProperties newLp,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> LinkProperties oldLp)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">netId</span> <span class="operator">=</span> networkAgent.network.getNetId();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (isDefaultNetwork(networkAgent)) &#123;</span><br><span class="line">        updateTcpBufferSizes(newLp.getTcpBufferSizes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateRoutes(newLp, oldLp, netId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新DNS配置</span></span><br><span class="line">    updateDnses(newLp, oldLp, netId);</span><br><span class="line">    <span class="comment">// Make sure LinkProperties represents the latest private DNS status.</span></span><br><span class="line">    <span class="comment">// This does not need to be done before updateDnses because the</span></span><br><span class="line">    <span class="comment">// LinkProperties are not the source of the private DNS configuration.</span></span><br><span class="line">    <span class="comment">// updateDnses will fetch the private DNS configuration from DnsManager.</span></span><br><span class="line">    mDnsManager.updatePrivateDnsStatus(netId, newLp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDefaultNetwork(networkAgent)) &#123;</span><br><span class="line">        handleApplyDefaultProxy(newLp.getHttpProxy());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        updateProxy(newLp, oldLp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateWakeOnLan(newLp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Captive portal data is obtained from NetworkMonitor and stored in NetworkAgentInfo.</span></span><br><span class="line">    <span class="comment">// It is not always contained in the LinkProperties sent from NetworkAgents, and if it</span></span><br><span class="line">    <span class="comment">// does, it needs to be merged here.</span></span><br><span class="line">    newLp.setCaptivePortalData(mergeCaptivePortalData(networkAgent.networkAgentPortalData,</span><br><span class="line">            networkAgent.capportApiData));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法<code>updateDnses</code>主要做两件事情:</p><ul><li>设置当前网络的<code>DNS</code>服务器, 调用<code>IDnsResolver</code>的接口<code>setResolverConfiguration</code>设置当前系统的DNS服务的配置</li><li>清除当前系统的<code>DNS</code>解析缓存, 发送<code>ACTION_CLEAR_DNS_CACHE</code>来清除缓存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateDnses</span><span class="params">(LinkProperties newLp, LinkProperties oldLp, <span class="type">int</span> netId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldLp != <span class="literal">null</span> &amp;&amp; newLp.isIdenticalDnses(oldLp)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// no updating necessary</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mDnsManager.noteDnsServersForNetwork(netId, newLp);</span><br><span class="line">        mDnsManager.flushVmDnsCache();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        loge(<span class="string">&quot;Exception in setDnsConfigurationForNetwork: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于如何设置<code>DNS</code>配置，大家可以查看<code>DnsResolverService.cpp</code>的代码；这里，我们重点看下缓存清理的大致流程。清理系统<code>DNS</code>缓存时，向<code>ActivityManager</code>发送一个<code>ACTION_CLEAR_DNS_CACHE</code>广播：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flush DNS caches and events work before boot has completed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flushVmDnsCache</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Tell the VMs to toss their DNS caches</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(ConnectivityManager.ACTION_CLEAR_DNS_CACHE);</span><br><span class="line">    intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Connectivity events can happen before boot has completed ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(ident);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ActivityManager</code>收到清除的广播后，调用<code>IApplicationThread.clearDnsCache</code>清理所有进程的<code>DNS</code>缓存:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (mProcLock) &#123;</span><br><span class="line">    mProcessList.clearAllDnsCacheLOSP();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy(anyOf = &#123;&quot;mService&quot;, &quot;mProcLock&quot;&#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clearAllDnsCacheLOSP</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mLruProcesses.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">ProcessRecord</span> <span class="variable">r</span> <span class="operator">=</span> mLruProcesses.get(i);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">IApplicationThread</span> <span class="variable">thread</span> <span class="operator">=</span> r.getThread();</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.clearDnsCache();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Failed to clear dns cache for: &quot;</span> + r.info.processName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>IApplicationThread</code>的实现在<code>ActivityThread</code>中， 接口<code>clearDnsCache</code>清除的是应用自身的解析缓存:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearDnsCache</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// a non-standard API to get this to libcore</span></span><br><span class="line">    InetAddress.clearDnsCache();</span><br><span class="line">    <span class="comment">// Allow libcore to perform the necessary actions as it sees fit upon a network</span></span><br><span class="line">    <span class="comment">// configuration change.</span></span><br><span class="line">    NetworkEventDispatcher.getInstance().dispatchNetworkConfigurationChange();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>网络切换完成后，会断开之前的网络，清除系统中对应的解析缓存:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">destroyNetwork</span><span class="params">(NetworkAgentInfo nai)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nai.created) &#123;</span><br><span class="line">        <span class="comment">// Tell netd to clean up the configuration for this network</span></span><br><span class="line">        <span class="comment">// (routing rules, DNS, etc).</span></span><br><span class="line">        <span class="comment">// This may be slow as it requires a lot of netd shelling out to ip and</span></span><br><span class="line">        <span class="comment">// ip[6]tables to flush routes and remove the incoming packet mark rule, so do it</span></span><br><span class="line">        <span class="comment">// after we&#x27;ve rematched networks with requests (which might change the default</span></span><br><span class="line">        <span class="comment">// network or service a new request from an app), so network traffic isn&#x27;t interrupted</span></span><br><span class="line">        <span class="comment">// for an unnecessarily long time.</span></span><br><span class="line">        destroyNativeNetwork(nai);</span><br><span class="line">        mDnsManager.removeNetwork(nai.network);</span><br><span class="line">    &#125;</span><br><span class="line">    mNetIdManager.releaseNetId(nai.network.getNetId());</span><br><span class="line">    nai.onNetworkDestroyed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理系统缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">destroyNativeNetwork</span><span class="params">(<span class="meta">@NonNull</span> NetworkAgentInfo nai)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mNetd.networkDestroy(nai.network.getNetId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException | ServiceSpecificException e) &#123;</span><br><span class="line">        loge(<span class="string">&quot;Exception destroying network(networkDestroy): &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mDnsResolver.destroyNetworkCache(nai.network.getNetId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException | ServiceSpecificException e) &#123;</span><br><span class="line">        loge(<span class="string">&quot;Exception destroying network: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>本文阐述了Android中DNS解析的原理和实现细节，重点关注了三个方面：</p><ul><li>DNS服务的初始化</li><li>应用程序如何执行域名解析</li><li>网络变化时DNS域名解析缓存的变化</li></ul><p>在Android中，DNS服务是在NETD进程中实现的，系统在进程初始化时对DNS服务进行初始化。文章还讨论了应用程序如何执行域名解析以及网络从Wi-Fi切换到4G时DNS域名解析缓存是如何清除的。理清这些流程，一方面是为了更好的定位遇到的网络问题，也可以更深入的理解Android中系统架构设计的思路以及代码的整体框架。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://datatracker.ietf.org/doc/html/rfc7858">DNS over TLS</a></li><li><a href="https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/">什么是DNS</a></li><li><a href="https://en.wikipedia.org/wiki/Domain_Name_System">Wikipedia DNS</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain_Name_System&quot;&gt;&lt;code&gt;DNS(Domain Name System)&lt;/code&gt;&lt;/a&gt;即域名解析系统，是网络访问时用于将域名解析成对应IP地址的一种分布式网络服务。比如，要访问&lt;code&gt;www.google.com&lt;/code&gt;这个域名，&lt;code&gt;Android&lt;/code&gt;系统会首先发送一个&lt;code&gt;UDP&lt;/code&gt;请求到标准的&lt;code&gt;53&lt;/code&gt;端口系统的域名解析服务器，拿到对应的IP地址后才会与服务端建立连接。除了标准的&lt;code&gt;DNS&lt;/code&gt;服务外，目前还有&lt;code&gt;HttpDNS&lt;/code&gt;(&lt;a href=&quot;https://en.wikipedia.org/wiki/DNS_over_HTTPS&quot;&gt;&lt;code&gt;DNS over Https, DoH&lt;/code&gt;&lt;/a&gt;)以及基于&lt;code&gt;TSL&lt;/code&gt;的&lt;code&gt;DNS&lt;/code&gt;服务(&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7858&quot;&gt;&lt;code&gt;DNS over TLS， DoT&lt;/code&gt;&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;那么，&lt;code&gt;Android&lt;/code&gt;中&lt;code&gt;DNS&lt;/code&gt;解析的大致框架是怎么的？整个&lt;code&gt;DNS&lt;/code&gt;解析的流程又是怎么样的？ 在看具体实现细节之前，我们不妨思考一下几个问题，想一想，如果我们自己从零开始为&lt;code&gt;Android&lt;/code&gt;设计一个&lt;code&gt;DNS&lt;/code&gt;系统，应该怎么做？&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://sniffer.site/categories/Android/"/>
    
    
    <category term="DNS" scheme="https://sniffer.site/tags/DNS/"/>
    
    <category term="TCP/IP" scheme="https://sniffer.site/tags/TCP-IP/"/>
    
    <category term="域名解析" scheme="https://sniffer.site/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    
    <category term="Private DNS" scheme="https://sniffer.site/tags/Private-DNS/"/>
    
  </entry>
  
  <entry>
    <title>chatGPT之后，我们还能做什么?</title>
    <link href="https://sniffer.site/2023/03/23/chatGPT%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88/"/>
    <id>https://sniffer.site/2023/03/23/chatGPT%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88/</id>
    <published>2023-03-23T01:37:05.000Z</published>
    <updated>2023-04-18T12:17:43.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Those who cannot remember the past are condemned to repeat it</p><p><strong>George Santayana</strong></p></blockquote><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/JasonW_a_young_chinese_girl_ride_on_a_chinese_dragon.png" alt="龙女儿"></p><span id="more"></span><p>最近铺天盖地都是<code>chatGpt</code>的新闻，各种基于<code>GPT</code>的工具与应用不断涌现，十分热闹。这种狂热的情绪不禁让人浮想联翩。前几年热火朝天的比特币以及区块链技术，当时的人们也一度兴奋异常，说一场颠覆金融与银行的技术变革已然到来，结果在资本逐利与人性的贪婪之下，比特币与区块链在无数的涨涨跌跌中归于平淡。如今，人们谈及比特币没有了最初的热情，也没多少人聊区块链金融了。</p><p>可是，体验过<code>chatGPT</code>以及<code>AIGC(AI Gernerated Content)</code>相关的工具以后(开头的图片就是使用<a href="https://discord.com/"><code>midjourney</code></a>自动生成的,几分钟时间生成的图片效果不错)，还是觉得这次应该不一样了，这是人工智能历史上一次具有革命意义的变化，是人类自有了计算机以来，生产力工具的一次重大转折与突破。就好比从前我们使用的是镰刀与斧头，如今直接用上推土机与坦克了；<code>chatGPT</code>完成了从<code>深度学习</code>到<code>通用智能</code>的转变，可以把信息与知识的呈现完全以新的形式展现给用户,把人从简单繁琐的任务中解脱出来，让人可以有更多精力与时间做更多有价值的事情。比如，用开源的<a href="https://www.cursor.so/"><code>cursor编辑器</code></a>，可以查找函数的使用示例；写代码的单元测试；查看语言的特性等等，这能提升开发的效率。<code>chatGPT</code>让人跟机器的界限慢慢被打破，机器为人类的决策提供了更多的帮助，让生产效率成倍的增长。就像人类从石器时代一下到了铁器时代，新的生产力工具让人类社会有了更多的想象空间。</p><p>或许，<code>chatGPT</code>这种大语言模型(LLM)展现出来对自然语言上下文惊人的理解能力才是真正让人惊讶与恐怖的事情。<code>GPT-4</code>模型俨然是一个百科全书的知识库，具备了很好的推理能力，能把各种知识与信息组织的条理井然。这是通用智能的前奏，几十年前阿兰图灵设想的图灵测试恐怕就要被超越了，而一旦模型或算法本身进化成了具备自我意识的一个实体，人与机器的关系到底该如何界定？我们如何看到一个具备智能的机器？这个机器又如何看待人类？这不仅是技术的变革，而是人类社会伦理与存在的一次挑战。我们是否做好了充分准备来迎接这样的变革？</p><p>从技术角度来看，不论是<code>chatGPT</code>大语言模型还是如<code>midjourney</code>这样的<code>AIGC</code>工具，无非都是一个个简单的人工神经元组成的巨大网络，里面有上千亿的模型参数，通过复杂的网络布局以及适当的反馈回路，这种深度神经网络竟然会拥有如此强大的推理与泛化能力，不得不让人赞叹，就像一个个大脑细胞通过突触相互链接让人拥有了智能，拥有了自我意识一样，或许在某一天， 大规模的机器模型也会来到这个智慧的临界点-产生自我意识。人创造了一个智慧体，上帝是喜还是忧？</p><p>从人类现有历史来看，技术的发展与进化对社会的影响是深刻而不可逆的(这种不可逆可能也让人类常常想回到最初的那种原始自然的状态，就好像我们从乡村来到城市，却会时常想回到乡村去一样):</p><ul><li>人有了数字的概念，并发明了数字0，然后人类在数学方面完成了革新，重塑人类对自然的理解，奠定了科学进步的基础</li><li>人类学会利用火，不用再像其他动物一样生吃肉或者蔬菜了，饮食成了一种美味的享受，让人在数千年的进化中逐步蜕变，并利用各种能源如煤炭、石油、自然能源等让社会生产力得以提升</li><li>牛顿发现了万有引力，完成了认识宇宙的第一步，把人类文明提升到新的高度；爱因斯坦的相对论再一次扩展了人类对于宇宙与自身存在的认识，让我们对宇宙的历史不再望而却步</li></ul><p>今天，以<a href="https://openai.com/"><code>OpenAI</code></a>公司的<code>chatGPT</code>在通用智能上完成突破，其意义非凡，但也让人在深思熟虑之后产生些许忧虑与不安。对于一名软件开发人员，能使用这种生产力倍增的工具自然感到兴奋，但在整个人类社会，还有很多的人没有能力去获取或者接触到任何智能相关的技术与工具，这是一个鸿沟，短期内无法填平的数字鸿沟。这也就势必会给有技术领先优势的公司或者组织更多的掌控力与控制权，渐渐的形成<code>AI霸权</code>，带来更多的数字鸿沟:那些掌控了<code>AI</code>能力的群体自然而然有更多的话语权与影响力，从而得以维护自己的利益。这很难说不是现状，但恐怕未来随着<code>AI</code>技术的发展只会愈加明显。</p><p>随着<code>chatGPT</code>这种具备通用智能模型的不断进步与发展，很多没有太多原创性的工作可能被替代，比如秘书，文案写作者，但是不是就像许多耸人听闻的标题说的那样，人快成了完美的废物:35岁卷不动，只好吃喝等死了。从历史上来看，任何技术的进步都是一把双刃剑，让某些行业受益的同时，也会给其他行业造成冲击，但对社会总体而言是利大于弊，是有价值的。与其回避技术可能带来的变化，不如主动拥抱这种变化。作为一名技术人员，在这种快速变化的智能时代，我们应该怎么做？</p><ul><li>保持开放的心态，努力学习。如果不能成为这股技术变革中的一员，那么努力想想自己所在行业可以如何跟AI进行结合，是否可以在AI的帮助下做的更好</li><li>提升创新与创造的能力，主动寻求变化，跳出舒适区，让自己更具韧性与适应能力</li><li>做更多有价值的事情。为用户创造价值，为组织创造价值，为社会创造价值，让自己活的更有价值</li><li>学会从更大的视角看待事物，更高的维度思考问题。不满足于已有的答案，要有系统性的思维能力</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>二百多年前，英国数学家<code>Charles Babbage</code>便有了利用机器来计算的想法，并尝试制造了第一台差分机。而人工智能概念的出现到如今的<code>chatGPT</code>多模态的通用智能模型，也不过八十来年的历史。技术进步正在加速，我们该如何应对这种技术的变革，如何面对通用智能带来的挑战？需要改变的不仅仅是个人，而是教育体系。我们的下一代将生活在智能主导的世界，他们需要有新的思维与认知方式，需要创造与创新的能力去解决面临的问题。未来的教育不能再想如今一样只是教授知识，更多的应该要培养人的原创力。</p><p>而如今，在新的时代起点上，如何去选择？我们需要重新思考自身的价值，思考存在的意义，思考如何利用智能的工具创造更多的价值。人类在地球上生存了千百年，很多东西变了，很多仍然没有变化。那些让人类不断进化，不断创造的源动力并没有变。我们可以欣赏自然的美，可以感受爱与温情，可以体验快乐与幸福，可以创造与构建，可以思考这个世界一切的奥秘。而这正是每一个人存在的价值。</p><p>有关更多<code>GPT</code>哲学上的探讨，可以看下<a href="https://mp.weixin.qq.com/s/AnlhmRHoSJM-O9bLBlxOVw">赵汀阳：GPT在哪些问题上逼得思想无路可走？</a>这篇文章。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;Those who cannot remember the past are condemned to repeat it&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;George Santayana&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/JasonW_a_young_chinese_girl_ride_on_a_chinese_dragon.png&quot; alt=&quot;龙女儿&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="人工智能" scheme="https://sniffer.site/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="人工智能" scheme="https://sniffer.site/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="AI" scheme="https://sniffer.site/tags/AI/"/>
    
    <category term="chatGPT" scheme="https://sniffer.site/tags/chatGPT/"/>
    
    <category term="LLM" scheme="https://sniffer.site/tags/LLM/"/>
    
    <category term="AIGC" scheme="https://sniffer.site/tags/AIGC/"/>
    
  </entry>
  
  <entry>
    <title>Android中HAL服务无法使用网络的问题</title>
    <link href="https://sniffer.site/2023/03/09/Android%E4%B8%ADHAL%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://sniffer.site/2023/03/09/Android%E4%B8%ADHAL%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-03-09T06:19:09.000Z</published>
    <updated>2023-03-13T12:03:38.848Z</updated>
    
    <content type="html"><![CDATA[<p>最近有同学在<code>Android S(12)</code>上遇到了一个奇怪的网络问题，说自己的<code>audio HAL</code>服务尝试通过以太网创建<code>socket</code>与其他局域网的节点通讯时，总是提示<code>Operation Not Permitted</code>。原先怀疑是<code>Selinux</code>的问题，但是目前在开发版本中<code>selinux</code>是完全关闭的；从问题发生的现象看，只有属于<code>audioserver</code>这个<code>UID</code>的进程才有问题，其他的如<code>system/root</code>的进程则没有问题。</p><p>据此，我们可以推断，<code>audioserver</code>这个<code>UID</code>的进程没有相关权限，所以导致无法使用局域网的网络。记得在早前的<code>Android</code>版本中，很多网络系统调用会通过<code>netd</code>代理进行权限检查，比如<code>socket/connect/bind</code>等系统调用都会先通过<code>netdClient</code>这个库的接口进行权限检查，而后才真正进行系统调用。<span id="more"></span>查看了<code>Android S</code>中<code>netd/client</code>中的代码，果真有一个<code>socket</code>的代理接口会检查权限:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">netdClientSocket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Block creating AF_INET/AF_INET6 socket if networking is not allowed.</span></span><br><span class="line">    <span class="keyword">if</span> (FwmarkCommand::<span class="built_in">isSupportedFamily</span>(domain) &amp;&amp; !allowNetworkingForProcess.<span class="built_in">load</span>()) &#123;</span><br><span class="line">        errno = EPERM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> socketFd = <span class="built_in">libcSocket</span>(domain, type, protocol);</span><br><span class="line">    <span class="keyword">if</span> (socketFd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> netId = netIdForProcess &amp; ~NETID_USE_LOCAL_NAMESERVERS;</span><br><span class="line">    <span class="keyword">if</span> (netId != NETID_UNSET &amp;&amp; FwmarkClient::<span class="built_in">shouldSetFwmark</span>(domain)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">int</span> error = <span class="built_in">setNetworkForSocket</span>(netId, socketFd)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">closeFdAndSetErrno</span>(socketFd, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> socketFd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>有关<code>netd</code>的详细介绍可以参考<a href="https://sniffer.site/2018/12/18/android-netd%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">Android Netd工作原理详解</a></p></blockquote><p>继续跟踪这个代码路径，发现<code>Android</code>的<code>Zygote</code>进程创建应用进程的时候会调用<code>setAllowNetworkingForProcess</code>接口，根据进程是否在一个<code>INET_GID</code>用户组来设置该进程是否有权限访问网络:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 进程是否包含了在INET对应的用户组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">containsInetGid</span><span class="params">(<span class="type">int</span>[] gids)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gids.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gids[i] == android.os.Process.INET_GID) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">forkAndSpecialize</span><span class="params">(<span class="type">int</span> uid, <span class="type">int</span> gid, <span class="type">int</span>[] gids, <span class="type">int</span> runtimeFlags,</span></span><br><span class="line"><span class="params">        <span class="type">int</span>[][] rlimits, <span class="type">int</span> mountExternal, String seInfo, String niceName, <span class="type">int</span>[] fdsToClose,</span></span><br><span class="line"><span class="params">        <span class="type">int</span>[] fdsToIgnore, <span class="type">boolean</span> startChildZygote, String instructionSet, String appDataDir,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> isTopApp, String[] pkgDataInfoList, String[] allowlistedDataInfoList,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> bindMountAppDataDirs, <span class="type">boolean</span> bindMountAppStorageDirs)</span> &#123;</span><br><span class="line">    ZygoteHooks.preFork();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> nativeForkAndSpecialize(</span><br><span class="line">            uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">            fdsToIgnore, startChildZygote, instructionSet, appDataDir, isTopApp,</span><br><span class="line">            pkgDataInfoList, allowlistedDataInfoList, bindMountAppDataDirs,</span><br><span class="line">            bindMountAppStorageDirs);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Note that this event ends at the end of handleChildProc,</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;PostFork&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If no GIDs were specified, don&#x27;t make any permissions changes based on groups.</span></span><br><span class="line">        <span class="keyword">if</span> (gids != <span class="literal">null</span> &amp;&amp; gids.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            NetworkUtilsInternal.setAllowNetworkingForProcess(containsInetGid(gids));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the Java Language thread priority to the default value for new apps.</span></span><br><span class="line">    Thread.currentThread().setPriority(Thread.NORM_PRIORITY);</span><br><span class="line"></span><br><span class="line">    ZygoteHooks.postForkCommon();</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次检查<code>HAL</code>服务的<code>rc</code>配置，发现<code>group</code>用户组中已经包含了<code>inet</code>了。而且，从问题的现象来看，是跟进程的<code>UID</code>有关，与<code>GID</code>的关系不大。那么，到底是哪里设置了<code>UID</code>相关的权限了？ 跟同事一起确认发现，只要在<code>/system/etc/permission/platform.xml</code>中为<code>audioserver</code>添加一个<code>INTERNET</code>权限网络就可以正常访问了:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;assign-permission name=<span class="string">&quot;android.permission.INTERNET&quot;</span> uid=<span class="string">&quot;audioserver&quot;</span> /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>问题好像比较清晰了，应该是系统启动时，对于那些无法通过<code>AndroidManifest.xml</code>声明权限的服务，比如<code>native</code>的服务，包管理服务<code>PMS</code>会去解析对应<code>UID</code>的权限，然后再通过某种方式设置到系统，确保其在创建<code>socket</code>时相关的权限会被检查。查看<code>frameworks/base/services/../pm/permission</code>代码可以大概知道，<code>Android</code>中的所有权限都统一由系统服务<code>PermissionManagerService</code>来管理，系统启动时，就会通过这个服务解析<code>platform.xml</code>文件中各个<code>UID</code>的权限声明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">SystemConfig</span> <span class="variable">systemConfig</span> <span class="operator">=</span> SystemConfig.getInstance();</span><br><span class="line">mSystemPermissions = systemConfig.getSystemPermissions();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但继续跟踪代码，却没有看到是这个权限配置是如何与<code>socket</code>的创建控制关联在一起的。这个想来十分奇怪，按照实现逻辑来说，这种权限控制不会放在内核实现，而是应该在用户空间的某个地方设置。过了两天再来看这个问题，突然想起之前做流量统计功能时，<code>Android</code>中使用了<code>BPF</code>，很有可能这个网络权限的控制也是在<code>netd</code>对应的<code>BPF</code>中实现的。查看了下<code>/system/netd/bpf_progs/netd.c</code>的代码，确实有一个<code>bpf map</code>来控制<code>socket</code>的创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_BPF_PROG_KVER</span>(<span class="string">&quot;cgroupsock/inet/create&quot;</span>, AID_ROOT, AID_ROOT, inet_socket_create,</span><br><span class="line">                     <span class="built_in">KVER</span>(<span class="number">4</span>, <span class="number">14</span>, <span class="number">0</span>))</span><br><span class="line">(<span class="keyword">struct</span> bpf_sock* sk) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> gid_uid = <span class="built_in">bpf_get_current_uid_gid</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A given app is guaranteed to have the same app ID in all the profiles in</span></span><br><span class="line"><span class="comment">     * which it is installed, and install permission is granted to app for all</span></span><br><span class="line"><span class="comment">     * user at install time so we only check the appId part of a request uid at</span></span><br><span class="line"><span class="comment">     * run time. See UserHandle#isSameApp for detail.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> appId = (gid_uid &amp; <span class="number">0xffffffff</span>) % PER_USER_RANGE;</span><br><span class="line">    <span class="type">uint8_t</span>* permissions = <span class="built_in">bpf_uid_permission_map_lookup_elem</span>(&amp;appId);</span><br><span class="line">    <span class="keyword">if</span> (!permissions) &#123;</span><br><span class="line">        <span class="comment">// UID not in map. Default to just INTERNET permission.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A return value of 1 means allow, everything else means deny.</span></span><br><span class="line">    <span class="keyword">return</span> (*permissions &amp; BPF_PERMISSION_INTERNET) == BPF_PERMISSION_INTERNET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个<code>UID</code>权限<code>map</code>对象正是通过<code>Netd</code>的接口进行设置的，大致的路径如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PermissionMonitor.startMoniotr -&gt; (SystemServer)</span><br><span class="line">    NetdNativeService.trafficSetNetPermForUids --&gt; (Netd)</span><br><span class="line">    TrafficeController.setPermissionForUids</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是说<code>ConnectivityService</code>在启动过程中，通过<code>PermissionMonitor</code>读取到<code>SystemConfig</code>的用户权限配置后，会调用<code>NETD</code>的接口设置对应的<code>UID</code>的网络权限:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">startMonitoring</span><span class="params">()</span> &#123;</span><br><span class="line">    log(<span class="string">&quot;Monitoring&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">userAllContext</span> <span class="operator">=</span> mContext.createContextAsUser(UserHandle.ALL, <span class="number">0</span> <span class="comment">/* flags */</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">IntentFilter</span> <span class="variable">intentFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>();</span><br><span class="line">    intentFilter.addAction(Intent.ACTION_PACKAGE_ADDED);</span><br><span class="line">    intentFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);</span><br><span class="line">    intentFilter.addDataScheme(<span class="string">&quot;package&quot;</span>);</span><br><span class="line">    userAllContext.registerReceiver(</span><br><span class="line">            mIntentReceiver, intentFilter, <span class="literal">null</span> <span class="comment">/* broadcastPermission */</span>,</span><br><span class="line">            <span class="literal">null</span> <span class="comment">/* scheduler */</span>);</span><br><span class="line">    ...</span><br><span class="line">    List&lt;PackageInfo&gt; apps = mPackageManager.getInstalledPackages(GET_PERMISSIONS</span><br><span class="line">            | MATCH_ANY_USER);</span><br><span class="line">    <span class="keyword">if</span> (apps == <span class="literal">null</span>) &#123;</span><br><span class="line">        loge(<span class="string">&quot;No apps&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">SparseIntArray</span> <span class="variable">netdPermsUids</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SparseIntArray</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (PackageInfo app : apps) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">uid</span> <span class="operator">=</span> app.applicationInfo != <span class="literal">null</span> ? app.applicationInfo.uid : INVALID_UID;</span><br><span class="line">        <span class="keyword">if</span> (uid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mAllApps.add(UserHandle.getAppId(uid));</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNetwork</span> <span class="operator">=</span> hasNetworkPermission(app);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasRestrictedPermission</span> <span class="operator">=</span> hasRestrictedNetworkPermission(app);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isNetwork || hasRestrictedPermission) &#123;</span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">permission</span> <span class="operator">=</span> mApps.get(UserHandle.getAppId(uid));</span><br><span class="line">            <span class="comment">// If multiple packages share a UID (cf: android:sharedUserId) and ask for different</span></span><br><span class="line">            <span class="comment">// permissions, don&#x27;t downgrade (i.e., if it&#x27;s already SYSTEM, leave it as is).</span></span><br><span class="line">            <span class="keyword">if</span> (permission == <span class="literal">null</span> || permission == NETWORK) &#123;</span><br><span class="line">                mApps.put(UserHandle.getAppId(uid), hasRestrictedPermission);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> unify the management of the permissions into one codepath.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">otherNetdPerms</span> <span class="operator">=</span> getNetdPermissionMask(app.requestedPermissions,</span><br><span class="line">                app.requestedPermissionsFlags);</span><br><span class="line">        netdPermsUids.put(uid, netdPermsUids.get(uid) | otherNetdPerms);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mUsers.addAll(mUserManager.getUserHandles(<span class="literal">true</span> <span class="comment">/* excludeDying */</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> SparseArray&lt;String&gt; netdPermToSystemPerm = <span class="keyword">new</span> <span class="title class_">SparseArray</span>&lt;&gt;();</span><br><span class="line">    netdPermToSystemPerm.put(INetd.PERMISSION_INTERNET, INTERNET);</span><br><span class="line">    netdPermToSystemPerm.put(INetd.PERMISSION_UPDATE_DEVICE_STATS, UPDATE_DEVICE_STATS);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; netdPermToSystemPerm.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">netdPermission</span> <span class="operator">=</span> netdPermToSystemPerm.keyAt(i);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">systemPermission</span> <span class="operator">=</span> netdPermToSystemPerm.valueAt(i);</span><br><span class="line">        <span class="comment">//获取有INTERNET权限的UID</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span>[] hasPermissionUids =</span><br><span class="line">                mSystemConfigManager.getSystemPermissionUids(systemPermission);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; hasPermissionUids.length; j++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">uid</span> <span class="operator">=</span> hasPermissionUids[j];</span><br><span class="line">            netdPermsUids.put(uid, netdPermsUids.get(uid) | netdPermission);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">&quot;Users: &quot;</span> + mUsers.size() + <span class="string">&quot;, Apps: &quot;</span> + mApps.size());</span><br><span class="line">    update(mUsers, mApps, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置UID的网络权限</span></span><br><span class="line">    sendPackagePermissionsToNetd(netdPermsUids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，谜底终于解开了。感兴趣的可以查看<code>packages/modules/Connectivity/</code>下<code>PermissionMonitor.java</code>的代码。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近有同学在&lt;code&gt;Android S(12)&lt;/code&gt;上遇到了一个奇怪的网络问题，说自己的&lt;code&gt;audio HAL&lt;/code&gt;服务尝试通过以太网创建&lt;code&gt;socket&lt;/code&gt;与其他局域网的节点通讯时，总是提示&lt;code&gt;Operation Not Permitted&lt;/code&gt;。原先怀疑是&lt;code&gt;Selinux&lt;/code&gt;的问题，但是目前在开发版本中&lt;code&gt;selinux&lt;/code&gt;是完全关闭的；从问题发生的现象看，只有属于&lt;code&gt;audioserver&lt;/code&gt;这个&lt;code&gt;UID&lt;/code&gt;的进程才有问题，其他的如&lt;code&gt;system/root&lt;/code&gt;的进程则没有问题。&lt;/p&gt;
&lt;p&gt;据此，我们可以推断，&lt;code&gt;audioserver&lt;/code&gt;这个&lt;code&gt;UID&lt;/code&gt;的进程没有相关权限，所以导致无法使用局域网的网络。记得在早前的&lt;code&gt;Android&lt;/code&gt;版本中，很多网络系统调用会通过&lt;code&gt;netd&lt;/code&gt;代理进行权限检查，比如&lt;code&gt;socket/connect/bind&lt;/code&gt;等系统调用都会先通过&lt;code&gt;netdClient&lt;/code&gt;这个库的接口进行权限检查，而后才真正进行系统调用。</summary>
    
    
    
    <category term="Android" scheme="https://sniffer.site/categories/Android/"/>
    
    
    <category term="Android" scheme="https://sniffer.site/tags/Android/"/>
    
    <category term="网络使用权限" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E4%BD%BF%E7%94%A8%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>说说系统开发中的康威定律</title>
    <link href="https://sniffer.site/2023/02/27/%E8%AF%B4%E8%AF%B4%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B/"/>
    <id>https://sniffer.site/2023/02/27/%E8%AF%B4%E8%AF%B4%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B/</id>
    <published>2023-02-27T10:30:16.000Z</published>
    <updated>2023-03-23T01:10:55.496Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Work on stuff that matters: </p><ul><li>work on something that matters to you more than money</li><li>create more value than you capture</li><li>take the long view.</li></ul><p> <strong>Tim O’Reilly</strong></p></blockquote><p><img src="https://images.unsplash.com/photo-1487958449943-2429e8be8625?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80" alt="system design board"></p><span id="more"></span><p>最近在跟车载座舱中的紧急通话<code>ECALL</code>功能时，发现最开始的设计方案完全没有考虑到硬件与软件的复用。由于这个方案跨了两个中心的部门，<code>ECALL</code>的初始方案设计中竟然为<code>ECALL</code>增加了额外的一套录音与播放系统，不仅增加了硬件成本，也加大了软件开发的投入，而这样音频系统在座舱<code>SoC</code>上早就已经有一套了。如今，团队又不得不重新提出一个所谓降本的方案，以减少成本。这种系统设计的方案不禁让我联想到软件设计中著名的<a href="https://en.wikipedia.org/wiki/Conway%27s_law">康威定律(<code>Conway&#39;s law</code>)</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization&#x27;s communication structure</span><br><span class="line"></span><br><span class="line">— Melvin E. Conway， 1968</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>翻译过来，康威定律是说，在任何一个组织中诞生的系统, 在很大程度上会被设计成一个跟这个组织(沟通)结构类似的架构，就是说在系统设计的时候，我们自觉或不自觉的构建出了一个跟自己所在团队结构类似的系统框架了。关于康威定律，有一个更为直观的说法来自<a href="https://en.wikipedia.org/wiki/Eric_S._Raymond"><code>Eric Steven Raymond</code></a>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">If you have four groups working on a compiler, you&#x27;ll get a 4-pass compiler</span><br><span class="line"></span><br><span class="line">&lt;如果有四个团队开发一个编译器，最后会得到一个4阶段的编译器&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于汽车这样一个由诸多复杂零部件构成的系统来说，实际开发中涉及到主机厂、各级供应商，跨团队的合作与开发会特别多，所以容易出现这类系统设计的<code>事故</code>，举几个我知道的例子吧:</p><ul><li>自动驾驶团队在选摄像头型号时，只考虑方便训练机器学习模型的类型，没有考虑其他系统，比如座舱控制器也有可能需要行车数据，导致后期在车型上开展类似功能时十分痛苦，做出来的效果跟其他厂商比也差强人意</li><li>同属一个业务的功能，如<code>CarService</code>，由于应用端与系统开发分属在两个团队， 应用的开发在需要提供接口给第三方业务调用时，基于系统的API做了第二次封装，与现有的封装业务属性上基本重合了</li><li>不同团队在同一个平台上、同一个系统上同时进行开发，大家在同样的事情上重复的投入</li></ul><p>那么，我们不禁要问，为什么人们在跨团队合作时会出现这种事后看起来啼笑皆非的情况，做出让人难以置信的决策了？想了想，大致有如下两个原因:</p><ul><li>团队中经常出现屁股决定脑袋的事情，不同部门之间协作容易变成抢业务的情况，尤其是业务存在重叠时更是如此</li><li>做技术决策或者方案设计时，相关的专业人员没有深度参与其中，导致很多声音被埋没了，没有被听见</li></ul><p>从这两点上，我们不妨来推演下，如何避免跨团队设计方案时出现康威定律中的诅咒。一个公司在发展初期，人员比较少，很多业务在大公司都是几十个人承担的，在这里可能就一个人忙前忙后。这样大家做沟通与决策的成本相对而言比较少的。等到公司规模不断扩展，团队人员快速增加，沟通成本增加的同时，也带来了业务分配的问题，最后发现可能有多个团队在做类似或者相同的事情。</p><p>这类问题初期还容易比较根治，到了后期涉及到的人员多时就很难了。业务的重叠或者人员的冗余，说到底是公司技术体系的构建不合理，没有充分做到复用：人员的复用，团队能力的复用，系统设计的复用。所以，理想汽车的<code>CEO</code>李想在讲到公司的组织架构时(视频可以在哔哩哔哩上搜索到，值得看看)，就特别提到了公司体系的建设与构建-我想这大概就是尽可能去做到组织中各个团队不同业务的解耦，尽量避免重复造轮子，增加系统复用的程度，从而提高组织效率，从根源上减少开发成本。又或者，公司初期在组织体系上做的不够完善，欠了债务，那么等到团队初具规模时，一定要下定决心做重构，重新梳理不同业务部门的职能与负责的事情，尽量避免这种团队与业务的耦合扩散到无法收拾的程度。</p><p>关于第二点，在做系统方案设计时，专业声音被淹没的问题，由于涉及到不同专业背景的人，所以可能更难处理。对于一个想要在激烈市场竞争中获得胜利的团队，要想做出更好的产品，做出更明智的决策，让团队成员都有机会发声，强调高效、平等的沟通，打造专业、追求极致的文化氛围之外似乎没有更好的选择了。这是一个系统工程，也是一个想要长期取得领先定位的团队必须要思考面对的问题。只有从方方面面去构建高效、专业、极致的组织文化，才有可能避免这种专业声音石沉大海的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>这里借这康威定律讲了自己在系统设计与组织构建中的遇到一些问题，实际上这些问题的原因可能比我看到的要更为复杂多样。系统设计涉及到公司组织架构、技术能力、团队管理、产品定义等多个维度，要想做好其实是一个非常有难度而有挑战的事情。每个想要做好产品，为用户创造价值的团队都需要认真考虑康威定律可能带来的影响。有关康威定律，<code>Martin Fowler</code>写了一篇文章介绍了如何在软件开发如何应对，值得参考下<a href="https://martinfowler.com/bliki/ConwaysLaw.html">Conway’s law</a>。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;Work on stuff that matters: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;work on something that matters to you more than money&lt;/li&gt;
&lt;li&gt;create more value than you capture&lt;/li&gt;
&lt;li&gt;take the long view.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;strong&gt;Tim O’Reilly&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1487958449943-2429e8be8625?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1170&amp;q=80&quot; alt=&quot;system design board&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="软件工程" scheme="https://sniffer.site/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="软件开发" scheme="https://sniffer.site/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="Conway&#39;s Law" scheme="https://sniffer.site/tags/Conway-s-Law/"/>
    
    <category term="康威定律" scheme="https://sniffer.site/tags/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>为什么iperf测试时UDP会出现高丢包率</title>
    <link href="https://sniffer.site/2023/01/10/%E4%B8%BA%E4%BB%80%E4%B9%88iperf%E6%B5%8B%E8%AF%95%E6%97%B6UDP%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%AB%98%E4%B8%A2%E5%8C%85%E7%8E%87/"/>
    <id>https://sniffer.site/2023/01/10/%E4%B8%BA%E4%BB%80%E4%B9%88iperf%E6%B5%8B%E8%AF%95%E6%97%B6UDP%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%AB%98%E4%B8%A2%E5%8C%85%E7%8E%87/</id>
    <published>2023-01-10T07:13:25.000Z</published>
    <updated>2023-01-10T09:23:40.137Z</updated>
    
    <content type="html"><![CDATA[<p>这两天质量的同学反馈说<code>iperf</code>测试时结果很差，跟实际的千兆带宽差别很大。确认了半天，发现内核的各项参数都已经完全按照千兆的目标速率进行配置了，那为什么还是会出现<code>TCP/UDP</code>带宽不足的问题？ 记得当时优化参数时，自己摸底测试的<code>TCP</code>结果挺好的，都达到了预期的<code>900Mbps</code>以上，看起来最近有什么修改导致了这个测试结果差异。</p><p>偶然的一个机会查看内核配置时，发现最近有人打开了<code>trace</code>功能，看起来很可能是这个修改导致了网络性能的下降了。拿早前未开启<code>trace</code>功能的版本一对比，果真是<code>trace</code>功能影响了<code>TCP</code>的带宽。<span id="more"></span>但是测试<code>UDP</code>还是会出现如下结果，看起來好像网络很差(注意对<code>UDP</code>测试需要通过设置<code>-b</code>参数来限制可能的带宽，否则也可能出现测试结果偏差)：</p><ul><li>使用<code>iperf</code>默认的的包大小测试(看源码，对<code>UDP</code>来说，默认的包大小为<code>1024</code>， 最大为<code>65507</code>)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务端: iperf3 -s -p <span class="number">8989</span> -f m</span><br><span class="line">客户端: iperf3 -c <span class="number">172.20</span><span class="number">.2</span><span class="number">.40</span> -p <span class="number">8989</span> -f m -t <span class="number">30</span> -u -b <span class="number">1</span>G</span><br><span class="line"></span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-30.00</span>  sec   <span class="number">710</span> MBytes   <span class="number">198</span> Mbits/sec  <span class="number">0.000</span> ms  <span class="number">0</span>/<span class="number">509813</span> (<span class="number">0</span>%)  sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-30.19</span>  sec   <span class="number">701</span> MBytes   <span class="number">195</span> Mbits/sec  <span class="number">0.201</span> ms  <span class="number">6626</span>/<span class="number">509809</span> (<span class="number">1.3</span>%)  receiver</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于<code>UDP</code>没有流控，整体的丢包率<code>1.3%</code>还不错，但带宽明显太小了，只有理论值的<code>1/5</code>不到。从这个结果可以看到，实际带宽不足是因为发送端的速率太小了，导致整个通道未被充分占满。这就好比一个粗大的水管，但实际传输的水流太小了，容量利用率不够。要想提高利用率，只能想法提升发送端的速率。<code>iperf</code>中，我们可以通过<a href="https://serverfault.com/questions/691723/extreme-udp-packet-loss-at-300mbit-14-but-tcp-800mbit-w-o-retransmits">提高包大小来达到这一目的</a>：</p><ul><li>使用最大的<code>UDP</code>包大小(<code>65507</code>)进行测试</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务端: iperf3 -s -p <span class="number">8989</span> -f m</span><br><span class="line">客户端: iperf3 -c <span class="number">172.20</span><span class="number">.2</span><span class="number">.40</span> -p <span class="number">8989</span> -f m -t <span class="number">30</span> -u -b <span class="number">1</span>G -l <span class="number">65507</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ ID] Interval           Transfer     Bitrate         Jitter    Lost/Total Datagrams</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-10.00</span>  sec  <span class="number">1.16</span> GBytes  <span class="number">1000</span> Mbits/sec  <span class="number">0.000</span> ms  <span class="number">0</span>/<span class="number">19079</span> (<span class="number">0</span>%)  sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-10.18</span>  sec   <span class="number">723</span> MBytes   <span class="number">595</span> Mbits/sec  <span class="number">0.282</span> ms  <span class="number">7508</span>/<span class="number">19079</span> (<span class="number">39</span>%)  receiver</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这次测试带宽明显有所提升，但接收端的丢包率却达到了惊人的<code>39%</code>。为什么会出现如此高的丢包率了？这还是要从<code>UDP</code>的传输机制说起了。我们都知道，<a href="http://www.tcpipguide.com/free/t_UDPOverviewHistoryandStandards.htm"><code>UDP</code>是无连接的数据报文传输协议</a>，也没有类似<code>TCP</code>滑动窗口的流量控制机制，因此快速的一方很有可能会淹没慢速的一方。这个时候就需要适当的调整慢速一端的<code>socket</code>缓冲区大小了。</p><p>对于<code>UDP</code>来说，主要有如下几个参数会影响实际传输时<code>socket</code>缓冲区的大小(可以参考内核文档<code>ip-sysctl.txt</code>)：</p><ul><li><code>net.core.wmem_default/net.core.wmem_max</code>: 默认、最大的发送缓冲区大小(bytes)，如果没用通过<code>setsockopt</code>來设置<code>SO_SNDBUF</code>的值，则会使用内核默认的缓冲区大小</li><li><code>net.core.rmem_default/net.core.rmem_max</code>: 默认、最大的接收缓冲区大小(bytes), 类似的，如果没有通过<code>SO_RCVBUF</code>来设置发送缓冲区的值，则使用内核默认的<code>net.core.rmem_default</code>值</li><li><code>net.ipv4.udp_mem=&quot;min pressure max&quot;</code>: 系统中所有<code>UDP</code>连接<code>socket</code>可以使用的最小、压力、最大页数（页大小一般为<code>4K</code>)，默认值一般在系统启动的时候根据当前可用内存计算出来的</li><li><code>net.ipv4.udp_rmem_min/net.ipv4.udp_wmen_min</code>: 系统中单个<code>UDP</code>连接<code>socket</code>可用的最小内存(bytes), 默认是<code>4K</code>。</li></ul><p>要想减少测试中的丢包率，就需要提高慢速端(也就是接收端)的缓冲区大小，确保其有足够的空间来保存接收到的数据，不至于来不及处理而被内核丢弃。我们可以选择在发送端或者接收端设置缓冲区的大小，对于<code>iperf</code>只能通过<code>-w</code>控制客户端的缓冲区大小, 这里我们直接在客户端设置发送缓冲区的大小为<code>10M</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务端: iperf3 -s -p <span class="number">8989</span> -f m</span><br><span class="line">客户端: iperf3 -c <span class="number">172.20</span><span class="number">.2</span><span class="number">.40</span> -p <span class="number">8989</span> -f m -t <span class="number">30</span> -u -b <span class="number">1</span>G -l <span class="number">65507</span> -w <span class="number">10</span>M</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ ID] Interval           Transfer     Bitrate         Jitter    Lost/Total Datagrams</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-10.00</span>  sec  <span class="number">1.16</span> GBytes  <span class="number">1000</span> Mbits/sec  <span class="number">0.000</span> ms  <span class="number">0</span>/<span class="number">19081</span> (<span class="number">0</span>%)  sender</span><br><span class="line">[  <span class="number">5</span>]   <span class="number">0.00</span><span class="number">-10.19</span>  sec  <span class="number">1.16</span> GBytes   <span class="number">981</span> Mbits/sec  <span class="number">0.593</span> ms  <span class="number">0</span>/<span class="number">19079</span> (<span class="number">0</span>%)  receiver</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，丢包率速率下降了到预期的程度。如果我们要在服务端设置接收缓冲区的大小，可以有两种方式: 一种是通过设置<code>net.core.rmem_default</code>大小，一种是修改<code>iperf3</code>的源码，确保服务端也可以通过<code>-w</code>来设置缓冲区的大小。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>网络的带宽优化涉及了Linux内核协议栈和网卡驱动，充分理解网络数据的传输流程以及<code>TCP/UDP</code>等传输协议的机制，才有可能找到性能的瓶颈。总的来说，这些优化很值得很深入研究，可以让人完整的把各个知识点都梳理串联起来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这两天质量的同学反馈说&lt;code&gt;iperf&lt;/code&gt;测试时结果很差，跟实际的千兆带宽差别很大。确认了半天，发现内核的各项参数都已经完全按照千兆的目标速率进行配置了，那为什么还是会出现&lt;code&gt;TCP/UDP&lt;/code&gt;带宽不足的问题？ 记得当时优化参数时，自己摸底测试的&lt;code&gt;TCP&lt;/code&gt;结果挺好的，都达到了预期的&lt;code&gt;900Mbps&lt;/code&gt;以上，看起来最近有什么修改导致了这个测试结果差异。&lt;/p&gt;
&lt;p&gt;偶然的一个机会查看内核配置时，发现最近有人打开了&lt;code&gt;trace&lt;/code&gt;功能，看起来很可能是这个修改导致了网络性能的下降了。拿早前未开启&lt;code&gt;trace&lt;/code&gt;功能的版本一对比，果真是&lt;code&gt;trace&lt;/code&gt;功能影响了&lt;code&gt;TCP&lt;/code&gt;的带宽。</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="iperf" scheme="https://sniffer.site/tags/iperf/"/>
    
    <category term="UDP" scheme="https://sniffer.site/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>再见2022</title>
    <link href="https://sniffer.site/2022/12/31/%E5%86%8D%E8%A7%812022/"/>
    <id>https://sniffer.site/2022/12/31/%E5%86%8D%E8%A7%812022/</id>
    <published>2022-12-31T09:08:35.000Z</published>
    <updated>2023-01-10T07:18:34.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>创造力 &#x3D; 能力 × 热情 × 思维方式</p><ul><li>“能力”是指努力学到的知识、经验和技能</li><li>“热情”是指工作时所有的激情和渴望成功等因素</li><li>“思维方式”则指对待工作的心态、精神状态和价值偏好</li></ul><p>一个人和一个企业能够取得多大成就，就看三个因素的乘积</p><p><strong>稻盛和夫</strong></p></blockquote><p><img src="https://images.unsplash.com/photo-1661306118447-6eac9ce5866f?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1074&q=80" alt="flow on the sea"></p><span id="more"></span><p>即将迈入新的一年了，时不待人。未曾想到2022年终的几天是在与新冠病毒共存中度过的，从最初的感染到恢复，前后历经6天，最高发烧到39度，身体好几天都处于酸痛而乏力的状态，确实让人难受。所幸的是，家里的娃娃跟老人都没有感染。三年来，新冠病毒演化到今天的奥密克戎，看起来毒性确实减弱了不少，政策放开后，唯一让人的担心是，这个如此狡猾的新冠病毒是否会继续在交叉传播中变异，卷土重来？人类是否有能力研发出新的疫苗，从此让新冠病毒彻底偃旗息鼓，尚待确证。</p><p>不得不说，新冠病毒肆虐的这三年是人类历史上注定无法被遗忘的一段历史，纵然生活变化多端，那些被撕碎的感情，被摧残的个人、家庭，无不让人唏嘘，让人看到人自身的脆弱，看到自然更迭的无情与沧桑，看到社会治理中诸多折腾与无效。人，像是浮萍，像是沙子，又像是一滴水，随时被风吹走，被洪流裹挟，被卷到某个角落，再无人问津，被遗忘，仿佛从未来过这里。那么，人的价值到底在哪里？ 我们毕竟有血有肉、有意志、有信念；我们渴望温情，渴望创造，渴望活的有价值，而不是浑浑噩噩的度过上苍赋予的3万天。最近在想，为何我们成为了如今这个样子？ 为何这个社会、国家成为了现在这个状态而不是另外的状态了？ 究竟是什么力量在塑造着人的心灵，又是什么力量塑造了社会与国家？ 我们每个人可能都笃定自己掌握了生活的主动权，掌控着自己头脑中的信念与想法，但仔细想一想，很多我们头脑中深信不疑的观念只不过是在某个时间悄然溜进了我们的身体而已，那并不是我们自己思考出来的。如果不加检点，我们就有可能成为这些偷偷溜进来的想法的奴隶。</p><p>言归正传，总结下过去的一年吧。今天早上，翻开自己2022年的计划，大多数立下的flag都未能兑现，大都停留在纸上谈兵了。365天，忙忙碌碌竟然忘了自己的最初的目标了。定目标还是不能求多求大，能落地，越具体越好。</p><ul><li>阅读上有了广度，一年下来大概有十几本吧(不包括电子书)，印象比较深刻的有<code>这才是心理学</code>，吴军的<code>数学之美</code>、<code>计算之魂</code>，<code>经济学通识课</code>，<code>生命是什么</code>，<code>影响力</code>，<code>错误的行为</code>， <code>量子传-究竟什么才是现实</code>等。今年养成了一个习惯，就是好的书读完第一遍后，过一段时间再读第二遍，这样可以比较好的理解书中的某些观点。阅读这件事情，在以前看起来其实挺费时间，需要大块时间才能去做，如今发现随便一个时间，哪怕是几分钟也可以利用起来，随时翻一翻。这样一本书，可能个把月出头也就看完了。</li><li>工作上，发现只要自己足够用心，深入思考，完全可以把之前认为做不到或者别人认为难以完成的任务做到。从另一个角度来说，个人实际上是有潜力的，即便是到了而立之年也同样可以不断提高，只是提高的速度没能达到20岁出头那种程度而已。</li><li>每周都坚持打一次羽毛球，两个小时的锻炼确实让人获益匪浅，人的精力与状态都得到了足够的支撑。今年花点钱再改善下装备，希望再高手的带领下，水平能够再上一个台阶。</li><li>女儿三岁了，自己也在她的拉扯下慢慢成为一个有责任心的父亲。与小宝贝相处的过程，发现父母就是领导者，领导者要带领好跟队的人，让对方的行为符合预期，仅仅有言语的教导还远远不够，更重要的是以身作则，用榜样去引导，用耐心而温情的去陪伴。</li></ul><p>新的一年，以如下三点来勉励自己，希望能够在各个方面有更多更大的拓展与进步。</p><h2 id="专注于目标"><a href="#专注于目标" class="headerlink" title="专注于目标"></a><strong>专注于目标</strong></h2><p>人是一个情感的动物，很多时候都会被情绪控制，诸如别人为什么这么无礼；别人为什么会这么粗鲁；别人为什么会如此待人等等此类问题经常控制着我们日常的心绪，让我们分心费神而忘了生活本来的面目。加上网络上无数的新闻热点更是把我们的关注力都打散，然后真正投入到有价值的目标中的时间精力其实并不多。扪心自问，很多时候我们之所以没能做的更好，是因为我们没有足够专注，没有把时间与精力用到正确的地方，那些琐碎而毫无价值的事情占据了我们太多的心力，从而让我们看起来总是碌碌无为。</p><p>正本清源，关注人生中有价值的部分，长期专注的投入才能获得更长足的进步。</p><h2 id="追求卓越"><a href="#追求卓越" class="headerlink" title="追求卓越"></a><strong>追求卓越</strong></h2><p>偶然的机会，了解了稻盛和夫，听了两本他的有声书(&lt;思维方式&gt;，&lt;稻盛和夫给年轻人的忠告&gt;)，有种被敲醒的感觉，很多的道理看似简单，要放到之前我可能都认为是心灵鸡汤，不值得理会，但如今再深思，竟然觉得说的太对，太好了。真是<code>too young, too simple</code>。年轻气盛，实则是头脑简单，想的太少，段位太低了。从稻盛和夫的人生哲学中，我看到了追求卓越的价值与意义。在任何事情上，能做到95分，就决不能满足于90分，只要有提升的空间，都要不遗余力的为之努力。人生的价值在于创造，在于不断的发掘自身的潜能，在于追求卓越的过程。</p><h2 id="开放与自省"><a href="#开放与自省" class="headerlink" title="开放与自省"></a><strong>开放与自省</strong></h2><p>认真想一想，人经常竭力维护的骄傲与自尊实际上并没有太重要的价值，有时反而是阻碍我们获得真相的绊脚石。思维的桎梏部分是因为经年累月的懒惰造成，部分是社会文化的传染影响导致。要想获得创造力与想象力，打开心灵，保持开放与自省才是正道。开放，意味着准备接纳任何观念与事实，不去人为的设定限制；自省，则是给自己的心灵提供一个观察自我的窗口，让我们看到在内心的深处，我们并没有想的那么聪明，让我们懂得谦卑，懂得看到这个世界多元的价值与意义， 不至于走向偏执。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;创造力 &amp;#x3D; 能力 × 热情 × 思维方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“能力”是指努力学到的知识、经验和技能&lt;/li&gt;
&lt;li&gt;“热情”是指工作时所有的激情和渴望成功等因素&lt;/li&gt;
&lt;li&gt;“思维方式”则指对待工作的心态、精神状态和价值偏好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个人和一个企业能够取得多大成就，就看三个因素的乘积&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;稻盛和夫&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1661306118447-6eac9ce5866f?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1074&amp;q=80&quot; alt=&quot;flow on the sea&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="https://sniffer.site/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="新冠病毒" scheme="https://sniffer.site/tags/%E6%96%B0%E5%86%A0%E7%97%85%E6%AF%92/"/>
    
    <category term="个人总结" scheme="https://sniffer.site/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络优化之AVB/TSN</title>
    <link href="https://sniffer.site/2022/12/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BAVB-TSN/"/>
    <id>https://sniffer.site/2022/12/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BAVB-TSN/</id>
    <published>2022-12-06T10:15:35.000Z</published>
    <updated>2023-04-18T01:51:19.479Z</updated>
    
    <content type="html"><![CDATA[<p>这是<code>Linux</code>网络优化系列的第四篇文章，也是最后一篇了。最近有点忙，没有抽出时间来梳理这些知识点, 看了下文章历史，这个优化系列文章前后持续了大半年时间，今天总算达成了目标*_*。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>自从互联网诞生以来, 音视频(Audio&#x2F;Video, AV)在网络上传输已经是稀松平常的事情. 那么, 为什么还需要一个新的基于以太网的协议来传输AV数据了? 传统的音视频传输都是点对点单向连接, 比如音频通常使用<code>I2S</code>或<code>SPDIF/AES</code>; 视频则使用<code>SDI</code>或者<code>HDMI</code>, 这种专用的单向连接在多设备情况下往往容易出现杂乱无章的连接线束:</p><span id="more"></span><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/StudioWiring.png" alt="AV wiring"></p><p>为了解决上述问题, 满足音视频数据传输中<a href="https://web.archive.org/web/20140405091013if_/http://www.avnu.org/files/static_page_files/AAF3193A-1D09-3519-AD45FC42893D1949/No-excuses%20Audio%20Video%20Networking%20v2.pdf">低延迟&#x2F;严格时间同步的需求</a>, 解决音视频传输中丢包&#x2F;传输延迟等问题，在2004年左右, IEEE 802.3小组接收了一个<code>CFI(Call For Interest)</code>有关将以太网用于低时延(<code>Time-sensitive</code>)的音视频传输的方案. 传统以太网是没有时间同步的, 而且由于网络链路存在难以预料的时延以及拥塞, 很难满足AV数据的传输要求, 为此IEEE专门成立了一个<code>802.1 Audio/Video Bridging</code>任务小组, 该小组开发出了一系列新的协议来解决上面碰到的问题, 即<code>AVB(Audio/Video Bridging)</code>协议族。<code>AVB</code>最开始是面向音视频数据传输，但其低延迟的特性使得<code>AVB</code>能很好的解决汽车领域中诸如娱乐座舱（摄像头&#x2F;屏幕显示），车身控制以及自动驾驶等领域的问题。<code>AVB</code>核心的协议主要由如下三个标准协议组成：</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/protocol_for_AE.png" alt="protocol stack of AE"></p><ul><li><code>IEEE 802.1AS-2011 (gPTP)</code>： 精确的时间同步(<code>precise synchronization</code>)</li><li>支持对多媒体数据的流整形(<code>traffic shaping</code>), 用于数据流均衡, 对应<code>IEEE 802.1Qav-2009 (FQTSS, Forwarding and Queuing for Time-Sensitive Streams)</code></li><li>带宽允许控制(<code>admission controls</code>), 预分配足够的带宽用于AV数据传输, 即<code>IEEE 802.1Qat-2010 (Stream Reservation Protocol, SRP)</code>， 由<a href="https://www.juniper.net/documentation/us/en/software/junos/mvrp/multicast-l2/topics/concept/mvrp-mx-series-understanding.html"><code>MMRP</code>&#x2F;<code>MVRP</code>&#x2F;<code>MSRP</code></a>三个协议组成。</li></ul><p>同时, AVB还提供两个传输层协议: <code>IEEE 1722-2011(AV Transport Protocol, AVTP)</code>用于音视频数据的传输;<code>IEEE 1722.1-2013(Device Discovery, Connection Management, and Control Protocol)</code>用于AVB设备的发现与连接管理. 到2012年, 为了更好的体现AVB协议的核心理念: 通过IEEE 802(以太网)提供时间同步&#x2F;低延迟的流媒体数据传输服务, AVB被重新命名为<code>TSN(Time-Sensitive Network)</code>, 后续所有的标准化工作都在<code>IEEE 802.1 TSN</code>小组展开.</p><p>随着近年来智能座舱概念的落地, 在汽车中引入更多娱乐设备, 比如扬声器, 摄像头, 甚至直播设备逐渐成为未来的趋势. 加之车载以太网从原来的<code>100Mbps</code>成熟演变到如今的<code>1Gbps</code>, 以太网已经成为车上各个域控制器的相互通讯的标准接口, 成为将车上各种设备如摄像头，扬声器，自动驾驶控制器等相互连接的方式，因此可以预见, <code>AVB/TSN</code>会成为车载娱乐领域&#x2F;自动驾驶相关的支撑技术而得到更为广泛的应用.</p><h2 id="AVB协议"><a href="#AVB协议" class="headerlink" title="AVB协议"></a><strong>AVB协议</strong></h2><p>AVB协议基于MAC层(L2)改进而来, 发送AV数据的设备称为<code>Talker</code>, 而接收AV数据的设备则称为<code>Listener</code>. 接受端与发送端应用基于AVB通讯时(一个<code>Talker</code>可能对应多个<code>Listener</code>, 因此实际上AVB的数据流都是多播数据, 通常需要通过<code>VLAN</code>对数据流进行分组), 不再通过TCP&#x2F;IP协议栈, 而是直接用<code>RAW SOCKET</code>与MAC层进行通讯, 与<code>TCP/IP</code>的实现不同，AVB协议都是在用户空间中实现的:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/AVB%20stack.png" alt="AVB stack"></p><p>接下来, 我们就重点来看看AVB三个核心协议的具体是如何工作的.</p><h3 id="时间同步-gPTP"><a href="#时间同步-gPTP" class="headerlink" title="时间同步-gPTP"></a><strong>时间同步-gPTP</strong></h3><p>AVB设备需要通过一个基准时钟定时同步时间信息, 以确保多个数据流的时间严格同步, 同时保证数据的发送与接收处于相同的时间序列. 这个用于精确时间同步的协议就是<code>IEEE 802.1AS gPTP</code>(<code>generic Precise Time Protocol</code>), gPTP实际是另一个时间同步协议<a href="https://en.wikipedia.org/wiki/Precision_Time_Protocol">IEEE 1588 PTP</a>的子集. <code>IEEE 802.1AS gPTP</code>与<code>IEEE 1588 PTP</code>的区别在与, <code>gPTP</code>假定所有的节点的通讯都是基于<code>IEEE 802 MAC</code>的PDU格式以及寻址, 而<code>PTP</code>可以支持从MAC层(L2)到L3&#x2F;L4的通讯协议. 对于gPTP来说, 在一个时间同步域(<code>timing domain</code>, 遵循gPTP标准并使用其同步时间的所有设备构成一个同步域)内, 有一个设备提供主时钟信号, 为其他所有设备提供参考时钟, 这个设备被称为<code>Grand Master Clock(GMC)</code>.</p><p>对于<code>gPTP</code>协议来说, 有两个问题需要解决: </p><ul><li>如何选择<code>Grand Master Clock</code>?</li><li>各个通讯节点如何同步时间?</li></ul><p>一般来说, <code>Grand Master Clock</code>设备可以在连接初始化时动态选择也可以预先配置(对车载网络来说, 可以选择静态配置的方式, 通常选择网关作为<code>Grand Master</code>). 动态选择需要通过<code>BMCA(Best Master Clock selection Algorithm)</code>.<code>BMCA</code>是一个分布式算法, 其工作原理大致是: 每个可做<code>Grand Master</code>的节点收到<code>announce</code>消息后, 比较自身时间与当前最好的<code>Grand Master</code>时间之间的质量值(如何衡量时间相关的质量值?), 如果8次不同的评价产生了一个比当前<code>Grand Master</code>时钟更好的时间值, 则完成<code>Grand Master</code>选择过程, 该节点宣称自己成为<code>Grand Master</code>.</p><p><code>AVB</code>设备在物理连接建立的过程中, 会交换设备的能力信息, 如果对端设备支持PTP, 则两个设备会开始同步时钟, 否则就形成一个时间同步域(该过程通过<a href="https://en.wikipedia.org/wiki/Spanning_Tree_Protocol">生成树算法</a>完成):</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/1024px-AVB-Ethernet-connections.png" alt="AVB domains"></p><p>要同步各个节点的时间, 首先, 每个网络节点需要知道消息在网络中传递的延迟, 在<code>gPTP</code>协议中有一个被称为<code>pDelay</code>衡量的过程: 确保节点都能准确知道其与邻近节点的消息传播延迟. 为了得到准确的<code>pDelay</code>值, 最好利用网卡硬件的时间戳而不是软件时间来进行时间采样. 时间同步的最后关键一步是, <code>Grand Master</code>需要发送<code>sync/folow-up</code>两个消息来完成与各个节点的时间同步. <code>gPTP</code>的整个功能如下图所示:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/how_gPTP_works.png" alt="how gPTP works"></p><h3 id="带宽预留-SRP"><a href="#带宽预留-SRP" class="headerlink" title="带宽预留-SRP"></a><strong>带宽预留-SRP</strong></h3><p><code>IEEE 802.1Qat Stream Reservation Protocol(SRP)</code>用于AVB网络中各个节点预分配带宽以满足音视频数据传输带宽的要求. 其大致流程是, <code>Talker</code>(数据发送节点)会发送广播消息到其他AVB节点, 告知有可用的数据流; 如果某个<code>Listener</code>(数据接收节点)需要接收数据流, 同样需要广播该消息, 如此所有节点(包括switch)会预留足够的带宽以确保数据流可以通过.如果预留失败, 则<code>SRP</code>的带宽预留请求失败. 通常, 对于A类(<code>class A</code>, 优先级最高)流量可以最多预留50%的带宽; B类流量(<code>class B</code>)流量预留20%的带宽.</p><blockquote><p>对于车载应用来说, SRP预留带宽失败是不可接受的(万一此时有摄像头需要传递比较关键的ADAS数据就悲剧了), 因此可以采取静态预留带宽的方式, 由各个节点在网卡初始化时提前预留带宽.</p></blockquote><p>对于带宽预留请求而言, 只需要一个唯一的64bit的<code>stream ID</code>即可; <code>stream ID</code>通常由<code>Talker</code>的MAC地址, 一个16bit由<code>Talker</code>分配的数值以及该<code>stream</code>的质量数据(包括数据流类型, 包速率以及每个包的长度)组成. 下图是非压缩的立体声音频数据在不同数据流类型下所需要预留的带宽:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/required_bandwidth_for_audio.png" alt="required bandwidth for stereo audio data"></p><p>SRP协议使用了一组协议, <a href="(https://en.wikipedia.org/wiki/Multiple_Registration_Protocol)"><code>MMRP(Multiple MAC Registration Protocol)</code></a>(以太网协议ID为<code>0x88F6</code>)用于控制分组注册, <code>MVRP(Multiple VLAN Registration Protocol)</code>(协议ID为<code>0x88F6</code>)用于VLAN组成员管理, <a href="https://en.wikipedia.org/wiki/Multiple_Registration_Protocol"><code>MSRP(Multiple Stream Registration Protocol)</code></a>(协议ID为<code>0x22EA</code>)用于数据流带宽的预留.</p><h3 id="数据流整形-FQTSS"><a href="#数据流整形-FQTSS" class="headerlink" title="数据流整形-FQTSS"></a><strong>数据流整形-FQTSS</strong></h3><p>AVB要求数据包在传输过程中不能出现丢包, 因此就要求网络中各个节点确保AVB数据包进行高效&#x2F;快速(确保延迟满足要求)转发， 同时为了能够有效利用带宽，保证普通的数据包（<code>Best Effort</code>)与AVB数据直接的公平性，引入了<code>IEEE 802.1Qav Forwarding and Queuing for Time-Sensitive Streams</code>(简称<code>FQTSS</code>)协议。<code>FQTSS</code>主要用于流整形（<code>traffic shaping</code>)， 其基于<a href="https://en.wikipedia.org/wiki/Credit-based_fair_queuing"><code>基于信用的流整形(credit-based shaper)</code></a>的算法，对数据流进行排队与转发; 通常来说， AVB流量优先级要高于普通流量， 而AVB中的A类流量优先级又要高于B类流量。</p><p>下图是<code>CBS</code>算法的一个示意图，AVB数据与非AVB数据(<code>Best Effort, BE</code>)的传输都受到当前<code>credit</code>值的影响：</p><ul><li>当<code>credit &gt;= 0</code>时，如果没有AVB数据， <code>credit</code>就会设为0; 否则持续发送AVB数据直到<code>credit</code>的值变为负（根据<code>sendSlope</code>开始减小)</li><li>当<code>credit &lt; 0</code>时， 发送普通的BE类数据, <code>credit</code>会基于<code>idleSlope</code>不断累积直到等于0</li><li><code>credit</code>的变化由<code>sendSlope</code>以及<code>idleSlope</code>两个值确定， <code>sendSlope</code>与<code>idleSlope</code>的关系如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sendSlope = idleSlope − portTransmitRate</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里<code>portTransmitRate</code>即端口的理论速率， 比如对于<code>1000Mbps</code>网络来说，该值为<code>10000bit/s</code>。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/credit-based_shaping_with_fqtss.png" alt="traffic shaping using FQTSS"></p><p>Linux的网络驱动中增加了一个<code>CBS</code>的流量控制模块（代码路径<code>kernel/net/sched/sched_cbs.c</code>)， 支持软件模拟网关中硬件的<code>CBS</code>算法， 同时还可以将算法卸负（<code>offload</code>）到网卡。 详细信息也可以参考<code>http://manpages.ubuntu.com/manpages/bionic/man8/tc-cbs.8.html</code>.</p><h2 id="Open-AVB"><a href="#Open-AVB" class="headerlink" title="Open-AVB"></a><strong>Open-AVB</strong></h2><p>早在2013年左右， TSN标准化机构<a href="https://avnu.org/"><code>AVNU</code></a>开发了一套开源的AVB协议栈<a href="https://github.com/Avnu/OpenAvnu"><code>openAVB</code></a>, 其实现了常见的AVB协议， 如<code>gPTP</code>&#x2F;<code>SRP</code>&#x2F;<code>FQTSS</code>&#x2F;<code>AVTP</code>&#x2F;<code>AVDECC</code>等。基于这套协议， 我们可以开发自己的AVB应用， 更多有关该<code>AVB</code>协议开发的一些信息可以参考官方文档<a href="http://avnu.github.io/OpenAvnu/avtp-pipeline/html/index.html">Open-AVB AVTP Pipeline SDK</a>.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://en.wikipedia.org/wiki/Time-Sensitive_Networking">Time Sensitive Networking</a></li><li><a href="http://avnu.github.io/OpenAvnu/avtp-pipeline/html/sdk_overview.html">OpenAVB SDK overview</a></li><li><a href="https://github.com/Avnu/OpenAvnu">OpenAvnm AVB protocol stack</a></li><li><a href="https://tsn.readthedocs.io/avb.html">Getting Started with AVB on linux</a></li><li><a href="https://source.codeaurora.org/quic/la/platform/external/Open-AVB">Codeaurora Open-AVB</a></li><li><a href="https://www.ieee802.org/1/pages/802.1ba.html">IEEE 802 AVB相关协议</a></li><li><a href="https://web.archive.org/web/20140405091013if_/http://www.avnu.org/files/static_page_files/AAF3193A-1D09-3519-AD45FC42893D1949/No-excuses%20Audio%20Video%20Networking%20v2.pdf">AVB诞生的一些历史</a></li><li><a href="https://www.ijeat.org/wp-content/uploads/papers/v9i1s5/A13801291S52019.pdf">Qualitative Examination of Credit Based Shaper in IEEE 802.1AVB</a></li><li><a href="https://avnu.org/wp-content/uploads/2014/05/AVnu-AAA2C_Types-of-Traffic-in-AVB-2_Michael-Johas-Teener-Markus-Jochim.pdf">Types of Traffic in AVB 2</a></li><li><a href="https://www.amazon.com/Automotive-Ethernet-Kirsten-Matheus/dp/1108841953">Automative Ethernet 3rd Edition</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是&lt;code&gt;Linux&lt;/code&gt;网络优化系列的第四篇文章，也是最后一篇了。最近有点忙，没有抽出时间来梳理这些知识点, 看了下文章历史，这个优化系列文章前后持续了大半年时间，今天总算达成了目标*_*。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;自从互联网诞生以来, 音视频(Audio&amp;#x2F;Video, AV)在网络上传输已经是稀松平常的事情. 那么, 为什么还需要一个新的基于以太网的协议来传输AV数据了? 传统的音视频传输都是点对点单向连接, 比如音频通常使用&lt;code&gt;I2S&lt;/code&gt;或&lt;code&gt;SPDIF/AES&lt;/code&gt;; 视频则使用&lt;code&gt;SDI&lt;/code&gt;或者&lt;code&gt;HDMI&lt;/code&gt;, 这种专用的单向连接在多设备情况下往往容易出现杂乱无章的连接线束:&lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="Linux" scheme="https://sniffer.site/tags/Linux/"/>
    
    <category term="AVB" scheme="https://sniffer.site/tags/AVB/"/>
    
    <category term="TSN" scheme="https://sniffer.site/tags/TSN/"/>
    
    <category term="网络优化" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>如何用FFmpeg在Android上实现音视频解码</title>
    <link href="https://sniffer.site/2022/09/30/%E5%A6%82%E4%BD%95%E7%94%A8FFMPEG%E5%9C%A8Android%E4%B8%8A%E5%81%9A%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81/"/>
    <id>https://sniffer.site/2022/09/30/%E5%A6%82%E4%BD%95%E7%94%A8FFMPEG%E5%9C%A8Android%E4%B8%8A%E5%81%9A%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81/</id>
    <published>2022-09-30T09:44:43.000Z</published>
    <updated>2023-04-25T06:18:03.107Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发投屏功能，需要对<code>H.264</code>视频数据流进行解码，然后显示出来。Android原生的<code>MediaCodec</code>虽然使用了硬件解码，但是延迟较大（超过300ms），无法满足要求。于是研究了下如何基于<a href="https://ffmpeg.org/">FFMPEG</a>来做视频流的软解码。这里对整个过程做简要的总结，看下如何在<code>Android Studio</code>中完成<code>FFMPEG</code>的视频解码: </p><ul><li>简单介绍下FFMPEG框架</li><li>如何利用交叉编译生成所需要的FFMPEG共享库, 以及如何进行<code>Android Studio</code>的配置</li><li>FFMPEG解码H264的大致调用流程</li></ul><span id="more"></span><h2 id="FFMPEG框架介绍"><a href="#FFMPEG框架介绍" class="headerlink" title="FFMPEG框架介绍"></a><strong>FFMPEG框架介绍</strong></h2><p><a href="https://en.wikipedia.org/wiki/FFmpeg">FFmpeg(Fast Forward mpeg)</a>是音视频编解码开源框架的标杆，支持常见音视频格式的编解码，如<code>H.264</code>&#x2F;<code>AAC</code>&#x2F;<code>H.265</code>&#x2F;<code>MP4</code>等，也支持不同格式之间的转码，同时还支持流媒体协议如<code>RTSP</code>&#x2F;<code>RTMP</code>。目前，不少视频网站如<code>Youtube</code>&#x2F;<code>Bilibili</code>等都是通过<code>FFmpeg</code>来实现音视频的处理的。</p><p>按功能模块划分，<code>FFmpeg</code>大致分为如下几个部分:</p><ul><li><code>libavcodec</code>: 包含了所有音视频编解码的核心代码</li><li><code>libavdevice</code>: 用于操作内部、外部音视频设备，以达到硬件加速&#x2F;显示&#x2F;加速等功能</li><li><code>libavfilter</code>: 音视频滤波器的开发，如宽高比、裁剪、格式化、非格式化、伸缩等</li><li><code>libavformat</code>： 用于解析各种不同的音视频封装格式</li><li><code>libavutil</code>： 包含公共的工具函数，如算术运算、字符操作等</li><li><code>libswresample</code>： 原始音频格式转码</li><li><code>libswscale</code>： 用于视频场景比例缩放、色彩映射转换、图像颜色空间或格式转换,如RGB565&#x2F;RGB888等与 YUV420等之间的转换。</li></ul><p>同时，<code>FFmpeg</code>源码中包含了<code>ffprobe</code>(用于分析音视频数据流)&#x2F;<code>ffplay</code>(基于<a href="https://www.libsdl.org/">SDL</a>的播放器)&#x2F;<code>ffmpeg</code>(视频转换工具)等常用的工具。初次使用<code>FFmepg</code>接口时，可以参考源码中的示例<code>doc/examples</code>, 里面给出了很多常见接口的使用方法。</p><p>更多有关<code>FFmpeg</code>的资料，可以参考:</p><ul><li><a href="https://blog.csdn.net/leixiaohua1020/category_1360795.html?spm=1001.2014.3001.5482">雷霄骅(leixiaohua1020)的专栏</a></li><li><a href="https://ffmpeg.org/">FFmpeg官方网站</a></li></ul><p>下面我们就来看下如何在<code>Ubuntu</code>环境中交叉编译<code>FFmpeg</code>到基于Android的<code>ARM64</code>平台架构上。</p><blockquote><p>我使用的编译环境是 Ubuntu 18.04 + Android ndk 22.1.7171670</p></blockquote><h2 id="交叉编译FFmpeg到Android平台"><a href="#交叉编译FFmpeg到Android平台" class="headerlink" title="交叉编译FFmpeg到Android平台"></a><strong>交叉编译FFmpeg到Android平台</strong></h2><p>首先通过<code>git</code>下载<code>FFmpeg</code>源码, 为确保功能稳定，编译使用的是最近发布版本分支<code>release/5.1</code>的代码: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git clone https://github.com/FFmpeg/FFmpeg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到5.1分支</span></span><br><span class="line">git checkout -b rel_5.1 origin/release/5.1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下载完后，可以通过<code>./configure -h</code>来查看各种编译配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Usage: configure [options]</span><br><span class="line">Options: [defaults in brackets after descriptions]</span><br><span class="line"></span><br><span class="line">Help options:</span><br><span class="line">  --help                   print this message</span><br><span class="line">  --quiet                  Suppress showing informative output</span><br><span class="line">  --list-decoders          show all available decoders</span><br><span class="line">  --list-encoders          show all available encoders</span><br><span class="line">  --list-hwaccels          show all available hardware accelerators</span><br><span class="line">  --list-demuxers          show all available demuxers</span><br><span class="line">  --list-muxers            show all available muxers</span><br><span class="line">  --list-parsers           show all available parsers</span><br><span class="line">  --list-protocols         show all available protocols</span><br><span class="line">  --list-bsfs              show all available bitstream filters</span><br><span class="line">  --list-indevs            show all available input devices</span><br><span class="line">  --list-outdevs           show all available output devices</span><br><span class="line">  --list-filters           show all available filters</span><br><span class="line"></span><br><span class="line">Standard options:</span><br><span class="line">  --logfile=FILE           log tests and output to FILE [ffbuild/config.log]</span><br><span class="line">  --disable-logging        do not log configure debug information</span><br><span class="line">  --fatal-warnings         fail if any configure warning is generated</span><br><span class="line">  --prefix=PREFIX          install in PREFIX [/usr/local]</span><br><span class="line">  --bindir=DIR             install binaries in DIR [PREFIX/bin]</span><br><span class="line">  --datadir=DIR            install data files in DIR [PREFIX/share/ffmpeg]</span><br><span class="line">  --docdir=DIR             install documentation in DIR [PREFIX/share/doc/ffmpeg]</span><br><span class="line">  --libdir=DIR             install libs in DIR [PREFIX/lib]</span><br><span class="line">  --shlibdir=DIR           install shared libs in DIR [LIBDIR]</span><br><span class="line">  --incdir=DIR             install includes in DIR [PREFIX/include]</span><br><span class="line">  --mandir=DIR             install man page in DIR [PREFIX/share/man]</span><br><span class="line">  --pkgconfigdir=DIR       install pkg-config files in DIR [LIBDIR/pkgconfig]</span><br><span class="line">  --enable-rpath           use rpath to allow installing libraries in paths</span><br><span class="line">                           not part of the dynamic linker search path</span><br><span class="line">                           use rpath when linking programs (USE WITH CARE)</span><br><span class="line">  --install-name-dir=DIR   Darwin directory name for installed targets</span><br><span class="line"></span><br><span class="line">Licensing options:</span><br><span class="line">  --enable-gpl             allow use of GPL code, the resulting libs</span><br><span class="line">                           and binaries will be under GPL [no]</span><br><span class="line">  --enable-version3        upgrade (L)GPL to version 3 [no]</span><br><span class="line">  --enable-nonfree         allow use of nonfree code, the resulting libs</span><br><span class="line">                           and binaries will be unredistributable [no]</span><br><span class="line"></span><br><span class="line">Configuration options:</span><br><span class="line">  --disable-static         do not build static libraries [no]</span><br><span class="line">  --enable-shared          build shared libraries [no]</span><br><span class="line">  --enable-small           optimize for size instead of speed</span><br><span class="line">  --disable-runtime-cpudetect disable detecting CPU capabilities at runtime (smaller binary)</span><br><span class="line">  --enable-gray            enable full grayscale support (slower color)</span><br><span class="line">  --disable-swscale-alpha  disable alpha channel support in swscale</span><br><span class="line">  --disable-all            disable building components, libraries and programs</span><br><span class="line">  --disable-autodetect     disable automatically detected external libraries [no]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，为了便于编译，我们需要写一个编译脚本<code>build_android.sh</code>，用于配置交叉编译的参数与环境变量(这里只编译了64位系统的库，如果要编译32位的库，修改下ARCH、CPU变量即可: <code>ARCH=arm; CPU=armv7-a</code>):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export NDK=/xxx/AndroidSDK/ndk/22.1.7171670</span><br><span class="line">TOOLCHAIN=$NDK/toolchains/llvm/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">function build_android</span><br><span class="line">&#123;</span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--disable-postproc \</span><br><span class="line">--disable-debug \</span><br><span class="line">--disable-symver \</span><br><span class="line">--disable-static \</span><br><span class="line">--enable-shared \</span><br><span class="line">--disable-doc \</span><br><span class="line">--disable-ffmpeg \</span><br><span class="line">--cross-prefix=$CROSS_PREFIX \</span><br><span class="line">--target-os=android \</span><br><span class="line">--arch=$ARCH \</span><br><span class="line">--cpu=$CPU \</span><br><span class="line">--cc=$CC \</span><br><span class="line">--cxx=$CXX \</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--enable-gpl \</span><br><span class="line">--sysroot=$SYSROOT \</span><br><span class="line">--extra-cflags=&quot;-Os -fpic $OPTIMIZE_CFLAGS&quot; \</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--extra-ldflags=<span class="string">&quot;<span class="variable">$ADDI_LDFLAGS</span>&quot;</span></span></span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">echo &quot;============== build android arm64-v8a success ==============&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arm64-v8a</span></span><br><span class="line">ARCH=arm64</span><br><span class="line">CPU=armv8-a</span><br><span class="line">API=26</span><br><span class="line">CC=$TOOLCHAIN/bin/aarch64-linux-android$API-clang</span><br><span class="line">CXX=$TOOLCHAIN/bin/aarch64-linux-android$API-clang++</span><br><span class="line">SYSROOT=$NDK/toolchains/llvm/prebuilt/linux-x86_64/sysroot</span><br><span class="line">CROSS_PREFIX=$TOOLCHAIN/bin/aarch64-linux-android-</span><br><span class="line">PREFIX=$(pwd)/android/$CPU</span><br><span class="line">OPTIMIZE_CFLAGS=&quot;-march=$CPU&quot;</span><br><span class="line">ADDI_LDFLAGS=&quot;LDFLAGS=&#x27;-Wl,-z,relro -Wl,-z,now -pie&quot;</span><br><span class="line"></span><br><span class="line">echo $CC</span><br><span class="line"></span><br><span class="line">build_android</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行<code>chmod a+x ./build_android.sh; ./build_android.sh</code>就开始了编译。编译成功后，会有一个<code>android/armv8-a</code>的文件夹，里边包含了交叉编译生成的静态与动态库:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./android/armv8-a</span></span><br><span class="line"></span><br><span class="line">bin --&gt; 常用的工具，如`ffmpeg`, `ffprobe`</span><br><span class="line">lib --&gt; 共享库，如`libavcodec`,`libavformat`, `libswscale`等</span><br><span class="line">include --&gt; 包含所有开发所需的头文件</span><br><span class="line">share --&gt; 包含了相关示例与文档</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际开发时，我们只需要用到<code>include</code>&#x2F;<code>lib</code>两个目录中的文件即可。</p><h2 id="将共享库集成到Android-Studio"><a href="#将共享库集成到Android-Studio" class="headerlink" title="将共享库集成到Android Studio"></a><strong>将共享库集成到Android Studio</strong></h2><p>最开始配置的时候，把编译好的库放到<code>src/main/jniLibs/armv8-a</code>目录下面，编译虽然正常，但是运行时却找不到对应的库。只好新建一个目录<code>libs</code>将头文件跟预编译的库放在这里(参考<a href="https://developer.android.com/studio/projects/configure-cmake">配置CMAKE</a>):</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/as-ffmpeg-config.png" alt="FFmpeg config"></p><p>然后在<code>CMakeLists.txt</code>里添加对应的库与头文件:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">set</span>(ffmpeg_lib_dir ../../../../libs/arm64-v8a)</span><br><span class="line"><span class="built_in">set</span>(ffmpeg_head_dir ../../../../libs/arm64-v8a/include)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_library</span>( avcodec</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED)</span><br><span class="line"><span class="built_in">set_target_properties</span>(avcodec</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        $&#123;ffmpeg_lib_dir&#125;/libavcodec.so)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_library</span>( avformat</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED)</span><br><span class="line"><span class="built_in">set_target_properties</span>(avformat</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        $&#123;ffmpeg_lib_dir&#125;/libavformat.so)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_library</span>( avutil</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED)</span><br><span class="line"><span class="built_in">set_target_properties</span>(avutil</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        $&#123;ffmpeg_lib_dir&#125;/libavutil.so)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_library</span>( swscale</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED)</span><br><span class="line"><span class="built_in">set_target_properties</span>(swscale</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        $&#123;ffmpeg_lib_dir&#125;/libswscale.so)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">include_directories</span>(libs/arm64-v8a/include)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>开发使用的Android Studio的版本是<code>4.2.1</code>。</p></blockquote><p>配置完成就可以基于<code>FFmpeg</code>的接口开发了。下面我们简单来看看如何用<code>FFmpeg</code>解码<code>H264</code>的视频流。</p><h2 id="FFmpeg解码H264视频流"><a href="#FFmpeg解码H264视频流" class="headerlink" title="FFmpeg解码H264视频流"></a><strong>FFmpeg解码H264视频流</strong></h2><p>关于如何利用<code>FFmpeg</code>来解码音视频文件，网络上有很多参考资料了，比如:</p><ul><li>[FFmpeg官网参考代码]<a href="https://ffmpeg.org/doxygen/trunk/decode_video_8c-example.html">https://ffmpeg.org/doxygen/trunk/decode_video_8c-example.html</a></li><li><a href="https://www.sobyte.net/post/2022-03/android-ffmpeg/">基于Android的FFmpeg完整参考示例</a></li></ul><p>解码从网络端接收到的视频流，大致流程基本一致， 主要分为几个关键的步骤:</p><ul><li>初始化<code>FFmpeg</code>解码器, 如找到对应的解码器，配置解码器:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mVideoDecoder = <span class="built_in">avcodec_find_decoder</span>(AV_CODEC_ID_H264);</span><br><span class="line"><span class="keyword">if</span> (mVideoDecoder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;%s: fail to find h264 decoder&quot;</span>, __func__ );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mVCodecCtx = <span class="built_in">avcodec_alloc_context3</span>(mVideoDecoder);</span><br><span class="line"><span class="keyword">if</span> (mVCodecCtx == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;%s: fail to create codec context&quot;</span>, __func__ );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mVCodecCtx-&gt;flags |= AV_CODEC_FLAG_LOW_DELAY;</span><br><span class="line"><span class="comment">//mVCodecCtx-&gt;flags |= AV_CODEC_FLAG2_FAST;</span></span><br><span class="line"></span><br><span class="line">mVCodecCtx-&gt;width = mVideoW;</span><br><span class="line">mVCodecCtx-&gt;height = mVideoH;</span><br><span class="line">mVCodecCtx-&gt;bit_rate = IDecoder::BIT_RATE;</span><br><span class="line">mVCodecCtx-&gt;framerate = <span class="built_in">av_make_q</span>(IDecoder::FRAME_RATE, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">avcodec_open2</span>(mVCodecCtx, mVideoDecoder, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;%s: Fail to open codec: %s&quot;</span>, __func__ , <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="built_in">avcodec_free_context</span>(&amp;mVCodecCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>将接收到的<code>H264</code>数据流分片NAL(<code>Network Abstraction Layer</code>)后，放入队列</li><li>解码线程从队列中取出数据包，然后解码;解码的过程大致分为四个步骤：<ul><li>发送待解码的数据报给解码器<code>avcodec_send_packet</code></li><li>从解码器接收解码后的包<code>avcodec_receive_frame</code></li><li>将解码的包从<code>YUV</code>格式转换为<code>RGB</code>格式</li><li>将<code>RGB</code>格式的视频帧拷贝到<code>Surface</code>进行渲染</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FFmpegDecoder::doDecode</span><span class="params">(h264_decode_struct *packet)</span> </span>&#123;</span><br><span class="line">    AVPacket *raw_packet = mDecoderResources-&gt;avPacket;</span><br><span class="line">    <span class="keyword">if</span> (raw_packet != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        raw_packet-&gt;data = packet-&gt;data;</span><br><span class="line">        raw_packet-&gt;size = packet-&gt;data_len;</span><br><span class="line">        raw_packet-&gt;pts = packet-&gt;pts;</span><br><span class="line">        <span class="comment">/* send raw packet to decode */</span></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">avcodec_send_packet</span>(mCodecCtx, raw_packet);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span> &amp;&amp; res != <span class="built_in">AVERROR</span>(EAGAIN)) &#123;</span><br><span class="line">            <span class="built_in">LOGE</span>(<span class="string">&quot;%s: Could not send video packet&quot;</span>, __func__ );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* decode frame */</span></span><br><span class="line">        AVFrame *frame = mDecoderResources-&gt;decodeFrame;</span><br><span class="line">        res = <span class="built_in">avcodec_receive_frame</span>(mCodecCtx, frame);</span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            <span class="built_in">LOGD</span>(<span class="string">&quot;%s: decoded frame pts = %lld, pixel-format = %d, picture-type = %d&quot;</span>, __func__ , (<span class="type">long</span> <span class="type">long</span>)frame-&gt;pts, frame-&gt;format, frame-&gt;pict_type);</span><br><span class="line">            <span class="keyword">if</span> (frame-&gt;width != mVideoW || frame-&gt;height != mVideoH) &#123;</span><br><span class="line">                <span class="built_in">LOGE</span>(<span class="string">&quot;%s: video size changed, drop frame&quot;</span>, __func__ );</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * render to Surface</span></span><br><span class="line"><span class="comment">             * decoded frame is YUV format which need to transform to RGB before rendering</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            AVFrame *rgb_frame = mDecoderResources-&gt;rgbFrame;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">av_image_fill_arrays</span>(rgb_frame-&gt;data, rgb_frame-&gt;linesize, mDecodeOutBuf, AV_PIX_FMT_RGBA,</span><br><span class="line">                                 mVideoW, mVideoH, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">SwsContext</span> *data_convert_ctx = <span class="built_in">sws_getContext</span>(mVideoW, mVideoH, mCodecCtx-&gt;pix_fmt,</span><br><span class="line">                                                                 mVideoW, mVideoH, AV_PIX_FMT_RGBA,</span><br><span class="line">                                                                 SWS_BICUBIC, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">            <span class="comment">/* from YUV to RGA */</span></span><br><span class="line">            res = <span class="built_in">sws_scale</span>(data_convert_ctx, (<span class="type">const</span> <span class="type">uint8_t</span> * <span class="type">const</span> *) frame-&gt;data, frame-&gt;linesize, <span class="number">0</span>,</span><br><span class="line">                            mVideoH, rgb_frame-&gt;data, rgb_frame-&gt;linesize);</span><br><span class="line">            <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">sws_freeContext</span>(data_convert_ctx);</span><br><span class="line">                <span class="built_in">LOGE</span>(<span class="string">&quot;%s: Fail to scale frame : %s&quot;</span>, __func__ , <span class="built_in">strerror</span>(errno));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* render to screen */</span></span><br><span class="line">                res = <span class="built_in">ANativeWindow_lock</span>(mNativeWin, mWindowBuf, <span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">LOGE</span>(<span class="string">&quot;%s: Fail to lock window&quot;</span>, __func__ );</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">uint8_t</span> *bits = (<span class="type">uint8_t</span> *) mWindowBuf-&gt;bits;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mVideoH; ++i) &#123;</span><br><span class="line">                        <span class="built_in">memcpy</span>(bits + i * mWindowBuf-&gt;stride * <span class="number">4</span>,</span><br><span class="line">                               mDecodeOutBuf + i * rgb_frame-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                               rgb_frame-&gt;linesize[<span class="number">0</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">ANativeWindow_unlockAndPost</span>(mNativeWin);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sws_freeContext</span>(data_convert_ctx);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LOGE</span>(<span class="string">&quot;%s: fail to receive frame %d&quot;</span>, __func__ , res);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相比Android原生的<code>MediaCodec</code>硬解码，<code>FFmpeg</code>解码效率提升了很多，延迟从原来的<code>400+ms</code>减少到了<code>100ms</code>左右，改善明显。但是由于使用了CPU进行解码操作，系统的负载与CPU使用率都会有所升高。因此，在进行高清视频的解码时硬解码会更合适。</p><p>总结下来，<code>FFmpeg</code>框架确实十分强大，也有比较完善的生态社区，可以说是搞音视频开发必不可少的利器。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://www.sobyte.net/post/2022-03/android-ffmpeg/">https://www.sobyte.net/post/2022-03/android-ffmpeg/</a></li><li><a href="https://trac.ffmpeg.org/wiki/CompilationGuide/Android">https://trac.ffmpeg.org/wiki/CompilationGuide/Android</a></li><li><a href="https://yumichan.net/video-processing/video-compression/introduction-to-h264-nal-unit/">https://yumichan.net/video-processing/video-compression/introduction-to-h264-nal-unit/</a></li><li><a href="https://trac.ffmpeg.org/wiki/CompilationGuide/Ubuntu#FFmpeg">https://trac.ffmpeg.org/wiki/CompilationGuide/Ubuntu#FFmpeg</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近开发投屏功能，需要对&lt;code&gt;H.264&lt;/code&gt;视频数据流进行解码，然后显示出来。Android原生的&lt;code&gt;MediaCodec&lt;/code&gt;虽然使用了硬件解码，但是延迟较大（超过300ms），无法满足要求。于是研究了下如何基于&lt;a href=&quot;https://ffmpeg.org/&quot;&gt;FFMPEG&lt;/a&gt;来做视频流的软解码。这里对整个过程做简要的总结，看下如何在&lt;code&gt;Android Studio&lt;/code&gt;中完成&lt;code&gt;FFMPEG&lt;/code&gt;的视频解码: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单介绍下FFMPEG框架&lt;/li&gt;
&lt;li&gt;如何利用交叉编译生成所需要的FFMPEG共享库, 以及如何进行&lt;code&gt;Android Studio&lt;/code&gt;的配置&lt;/li&gt;
&lt;li&gt;FFMPEG解码H264的大致调用流程&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Android" scheme="https://sniffer.site/categories/Android/"/>
    
    
    <category term="Android" scheme="https://sniffer.site/tags/Android/"/>
    
    <category term="FFmpeg" scheme="https://sniffer.site/tags/FFmpeg/"/>
    
    <category term="H.264" scheme="https://sniffer.site/tags/H-264/"/>
    
    <category term="音视频" scheme="https://sniffer.site/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>如何通过QEMU启动Linux系统</title>
    <link href="https://sniffer.site/2022/08/27/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87QEMU%E5%90%AF%E5%8A%A8Linux%E7%B3%BB%E7%BB%9F/"/>
    <id>https://sniffer.site/2022/08/27/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87QEMU%E5%90%AF%E5%8A%A8Linux%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-08-27T12:00:03.000Z</published>
    <updated>2022-08-30T02:57:23.387Z</updated>
    
    <content type="html"><![CDATA[<p>看Linux驱动相关的代码， 却没有一个好的调试环境可以跟踪内核相关的调用流程。于是，想着用QEMU虚拟机来搭建一个Linux系统。花了大半天时间，终于能够启动一个简单的Linux系统了。中间踩了不少坑，找了不少资料，这里简单总结下整个过程。</p><blockquote><p>以下操作都是基于Ubuntu 18.04 x86_64平台</p></blockquote><p>最开始参考了<a href="https://yuankun.me/posts/running-raw-linux-kernel-in-qemu/">如何使用QEMU跑内核</a>，使用系统自带的QEMU工具，结果提示如下错误:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">qemu-system-aarch64 rom check and register reset failed</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>怀疑是QEMU的版本太低导致，于是只好又重新编译QEMU源码，最后总算大功告成。总的说来，大致要做的事情有这么几个:</p><ul><li>编译Linux内核，利用busybox来生成一个小的rootfs（关于什么是rootfs，可以参考<a href="https://tldp.org/LDP/sag/html/root-fs.html">The rootfs FS</a>)</li><li>编译QEMU，确保正常配置ARM64架构的虚拟环境</li><li>一切就绪，通过<code>qemu-system-aarch64</code>跑起来虚拟机来</li></ul><span id="more"></span><h2 id="编译Linux内核"><a href="#编译Linux内核" class="headerlink" title="编译Linux内核"></a><strong>编译Linux内核</strong></h2><p>交叉编译Linux内核，需要确保系统中存在必须的编译环境与工具:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install binutils-multiarch</span><br><span class="line">sudo apt-get install ncurses-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install gcc-aarch64-linux-gnu</span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">拷贝源码`git <span class="built_in">clone</span> https://github.com/torvalds/linux`， 进入对应目录, 执行:</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment">#创建编译目录，用于输出产物</span></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"></span><br><span class="line">make distclean</span><br><span class="line">make O=./build ARCH=arm64 defconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果需要编辑某些config，可以使用menuconfig来配置</span></span><br><span class="line">make O=./build ARCH=arm64 nconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">make O=./build ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j8</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译成功后，会在<code>arch/arm64/boot</code>下面生成内核镜像:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-rw-rw-r-- 1 jason jason 36M Aug 25 14:20 <span class="built_in">arch</span>/arm64/boot/Image</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个就是后面用于跑Linux内核的镜像文件。</p><h2 id="编译Qemu源码"><a href="#编译Qemu源码" class="headerlink" title="编译Qemu源码"></a><strong>编译Qemu源码</strong></h2><p>编译QEMU比较方便，先下载源码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/qemu/qemu</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> qemu</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">../configure</span><br><span class="line">make -j16</span><br><span class="line"></span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译大概会持续十几分钟的样子，最后记得编译完成后执行<code>make install</code>, 否则在最后启动虚拟机时会提示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">qemu-system-aarch64: failed to find romfile <span class="string">&quot;efi-virtio.rom&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编译Busybox-制作rootfs"><a href="#编译Busybox-制作rootfs" class="headerlink" title="编译Busybox,制作rootfs"></a><strong>编译Busybox,制作rootfs</strong></h2><p>编译Busybox稍微麻烦一点，需要编辑配置列表，确保生成的是静态库形式的执行文件, 大概有这么几个步骤:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"></span><br><span class="line">make O=../build/ ARCH=arm64 defconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过菜单配置config</span></span><br><span class="line">make O=../build/ ARCH=arm64 menuconfig</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/busybox_menuconfig.png" alt="busybox menuconfig"></p><p>菜单配置的方式与Linux内核的配置类似，按下<code>/</code>可以直接搜索你要设置的选项; 如果觉得菜单配置比较麻烦，也可以通过直接编辑生成的<code>.config</code>来配置选项编译为静态的方式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CONFIG_STATIC=y</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完成配置后，执行编译:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j16</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>busybox/_install</code>下面可以看到编译的产物。有了busybox我们就可以制作一个简单的rootfs文件系统了。对于busybox的系统来说，大致的启动顺序如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/sbin/init --&gt; /etc/inittab --&gt; /etc/init.d/rcS --&gt; /etc/fstab</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进入<code>busybox/_install</code>目录可以看到当前生成的目录结构:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4.0K./proc</span><br><span class="line">1.9M./bin</span><br><span class="line">16K./etc</span><br><span class="line">4.0K./tmp</span><br><span class="line">4.0K./root</span><br><span class="line">4.0K./sys</span><br><span class="line">4.0K./home</span><br><span class="line">4.0K./var</span><br><span class="line">4.0K./lib</span><br><span class="line">4.0K./mnt</span><br><span class="line">12K./usr</span><br><span class="line">4.0K./sbin</span><br><span class="line">12K./dev</span><br><span class="line">34M./</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>制作一个rootfs，可以按照如下几个步骤操作:</p><ul><li>创建目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建必要的目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p dev etc home lib mnt proc root sys tmp var</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>生成启动所需的文件</p><ul><li>etc&#x2F;inittab: 将如下内容写入到该文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::respawn:-/bin/sh</span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line">::cttlaltdel:/bin/umount -a -r</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编辑完成后，修改文件权限: <code>chmod 0755 etc/inittab</code></p><ul><li>etc&#x2F;init.d: 系统初始化脚本，可以用于创建设备以及执行文件系统挂载等操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p etc/init.d/</span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑rcS文件,输入如下内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;mount pseudo sys&quot;</span></span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">/sbin/mdev -s</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;init rc done&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了确保该文件正常执行，需要修改权限<code>chmod 0755 etc/init.d/rcS</code>. 如果除了上述<code>proc/sys</code>文件系统外，还有其他需要挂载的设备，可以放在<code>etc/fstab</code>中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">temps/tmp  rpoc  defaults 0 0</span><br><span class="line">none /tmp  ramfs defaults 0 0</span><br><span class="line">mdev /dev  ramfs defaults 0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>创建特殊文件节点</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cd</span> dev</span><br><span class="line">sudo <span class="built_in">mknod</span> console c 5 1</span><br><span class="line">sudo <span class="built_in">mknod</span> null c 1 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>将该目录的文件打包成rootfs压缩文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">find . | cpio -o -H newc &gt; rootfs.cpio </span><br><span class="line">gzip -c rootfs.cpio &gt; rootfs.cpio.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>到这里，所有的准备工作就绪了，就下来可以测试下虚拟机是否正常能跑起来了.</p><h2 id="QEMU跑起来"><a href="#QEMU跑起来" class="headerlink" title="QEMU跑起来"></a><strong>QEMU跑起来</strong></h2><p>执行如下命令，启动Linux虚拟机(具体的参数可以通过<code>qemu-system-aarch64 -h</code>查看)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">qemu-system-aarch64 \</span><br><span class="line">    -machine virt \</span><br><span class="line">    -cpu cortex-a57 \</span><br><span class="line">    -nographic -smp 1 \</span><br><span class="line">    -kernel ./Image \</span><br><span class="line">    -initrd ./rootfs.cpio.gz \</span><br><span class="line">    -append <span class="string">&quot;rdinit=/linuxrc console=ttyAMA0&quot;</span> \</span><br><span class="line">    -s <span class="comment"># 开启GDB TCP调试口</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正常启动的话，可以看到内核加载的日志以及一个虚拟的终端设备:</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/qemu-virt-linux.png" alt="Qemu Virt linux"></p><p>有了这个虚拟环境，无论是驱动开发，还是学习Linux内核都会方便很多了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://yuankun.me/posts/running-raw-linux-kernel-in-qemu/">https://yuankun.me/posts/running-raw-linux-kernel-in-qemu/</a></li><li><a href="https://ops.tips/notes/booting-linux-on-qemu/">https://ops.tips/notes/booting-linux-on-qemu/</a></li><li><a href="https://gts3.org/2017/cross-kernel.html">https://gts3.org/2017/cross-kernel.html</a></li><li><a href="http://events17.linuxfoundation.org/sites/events/files/slides/Shuah_Khan_cross_compile_linux.pdf">http://events17.linuxfoundation.org/sites/events/files/slides/Shuah_Khan_cross_compile_linux.pdf</a></li><li><a href="https://android.googlesource.com/platform/external/syzkaller/+/HEAD/docs/linux/setup_linux-host_qemu-vm_arm64-kernel.md">https://android.googlesource.com/platform/external/syzkaller/+/HEAD/docs/linux/setup_linux-host_qemu-vm_arm64-kernel.md</a></li><li><a href="http://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/">http://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;看Linux驱动相关的代码， 却没有一个好的调试环境可以跟踪内核相关的调用流程。于是，想着用QEMU虚拟机来搭建一个Linux系统。花了大半天时间，终于能够启动一个简单的Linux系统了。中间踩了不少坑，找了不少资料，这里简单总结下整个过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下操作都是基于Ubuntu 18.04 x86_64平台&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最开始参考了&lt;a href=&quot;https://yuankun.me/posts/running-raw-linux-kernel-in-qemu/&quot;&gt;如何使用QEMU跑内核&lt;/a&gt;，使用系统自带的QEMU工具，结果提示如下错误:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;qemu-system-aarch64 rom check and register reset failed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;怀疑是QEMU的版本太低导致，于是只好又重新编译QEMU源码，最后总算大功告成。总的说来，大致要做的事情有这么几个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译Linux内核，利用busybox来生成一个小的rootfs（关于什么是rootfs，可以参考&lt;a href=&quot;https://tldp.org/LDP/sag/html/root-fs.html&quot;&gt;The rootfs FS&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;编译QEMU，确保正常配置ARM64架构的虚拟环境&lt;/li&gt;
&lt;li&gt;一切就绪，通过&lt;code&gt;qemu-system-aarch64&lt;/code&gt;跑起来虚拟机来&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://sniffer.site/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://sniffer.site/tags/Linux/"/>
    
    <category term="Kernel" scheme="https://sniffer.site/tags/Kernel/"/>
    
    <category term="Qemu" scheme="https://sniffer.site/tags/Qemu/"/>
    
    <category term="busybox" scheme="https://sniffer.site/tags/busybox/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络优化之DPDK与XDP</title>
    <link href="https://sniffer.site/2022/08/12/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BDPDK%E4%B8%8EXDP/"/>
    <id>https://sniffer.site/2022/08/12/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BDPDK%E4%B8%8EXDP/</id>
    <published>2022-08-12T05:45:40.000Z</published>
    <updated>2022-08-12T05:56:20.588Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的一篇文章<a href="https://sniffer.site/2022/04/13/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/">Linux网络优化之链路层优化</a>中，我们已经看到，随着网卡速率超过<code>1Gbps</code>，增加到<code>10Gbps/100Gbps</code>时，CPU已经很难处理如此大量的数据包了。总结来说，主要有如下瓶颈：</p><ul><li>内核协议栈处理在<code>L3(IP)/L4(TCP)</code>的数据处理上，消耗了比较多的时间，会导致网络延迟与传输受限</li><li>高速网卡会在短时间内产生大量中断，导致CPU频繁发生上下文切换，性能收到影响，进而影响网络吞吐</li></ul><p>针对<code>10Gbps/100Gbps</code>等高速网卡中存在的延迟与带宽受限问题，<a href="https://en.wikipedia.org/wiki/Data_Plane_Development_Kit">Intel在2010年提出了<code>DPDK(Data Plane Development Kit)</code>基于用户空间的解决方案</a>，并开源了实现方案, 目前<code>DPDK</code>支持包括Intel&#x2F;ARM等多个芯片架构的指令集; 同样是Intel的工程师在2018年提出了<code>XDP(eXpress Data Path)</code>，与<code>DPDK</code>不一样的是，<code>XDP</code>基于现有内核<code>socket</code>接口，与<code>eBPF</code>相结合实现网卡与用户空间的数据传输，从而避免了内核协议栈的处理延迟。</p><span id="more"></span><p>下面我们来简单看下<code>DPDK</code>与<code>XDP</code>的实现原理。</p><blockquote><p>本文主要是简要介绍基本原理，收集一些参考资料</p></blockquote><h2 id="DPDK-Data-Plane-Development-Kit"><a href="#DPDK-Data-Plane-Development-Kit" class="headerlink" title="DPDK(Data Plane Development Kit)"></a><strong>DPDK(Data Plane Development Kit)</strong></h2><p><code>DPDK</code>是由一系列开源库组成的用于网络加速的工具集，其提供了数据平面(<code>data-plane</code>)以及用户空间基于poll模式的网卡驱动，以跳过内核<code>TCP/IP</code>协议栈， 加速网络数据的传输。<code>DPDK</code>为如<code>PowerPC</code>&#x2F;<code>Arm</code>&#x2F;<code>x86</code>等多个平台提供了一个框架，用于高速网络情况的数据处理，常用在数据中心节点之间的数据传输。</p><p><img src="https://www.accton.com/wp-content/uploads/2018/07/linux-kernel-w-DPDK-800x524.png" alt="DPDK in linux kernel"></p><p>有关更多<code>DPDK</code>实现原理与细节可以参考如下资料:</p><ul><li><a href="https://en.wikipedia.org/wiki/Data_Plane_Development_Kit">Wikipedia DPDK</a></li><li><a href="https://lwn.net/Articles/725254/">Network Acceleration with DPDK</a></li><li><a href="https://doc.dpdk.org/guides/linux_gsg/index.html">Linux development Guide</a></li><li><a href="https://www.cse.iitb.ac.in/~mythili/os/anno_slides/DPDK_deep_dive_slides.pdf">Deep-dive into DPDK</a></li><li><a href="https://www.intel.com/content/www/us/en/developer/articles/code-sample/introduction-to-the-dpdk-sample-applications.html">DPDK Sample Applications</a></li><li><a href="https://github.com/DPDK/dpdk">DPDK source code</a></li></ul><h2 id="XDP-eXpress-Data-Path"><a href="#XDP-eXpress-Data-Path" class="headerlink" title="XDP(eXpress Data Path)"></a><strong>XDP(eXpress Data Path)</strong></h2><p><code>XDP</code>方案与<code>DPDK</code>类似，都是尝试跳过内核协议栈从而加速数据包的处理，只不过<code>XDP</code>是基于内核已有的<code>socket</code>接口来实现，其增加了一个<code>AF_XDP</code>的地址类型，用户进程可以通过<code>AF_XDP</code>的接口来实现与内核的交互， 比如映射接收数据包的共享内存，加载接收网卡数据包的<code>BPF</code>内核程序(有关内核BFP可以参考<a href="https://sniffer.site/2019/11/07/bpf%E4%B8%8Eebpf/">BPF与eBPF</a>)。</p><p><img src="https://www.iovisor.org/wp-content/uploads/sites/8/2016/09/xdp-packet-processing-768x420.png" alt="XDP"></p><p>从<code>XDP</code>的实现原理来说，相比于<code>DPDK</code>， <code>XDP</code>更贴近Linux内核，因而使用起来更为方便，而且其总体性能可以接近于<code>DPDK</code>。有关<code>XDP</code>实现原理与细节可以参考如下资料:</p><ul><li><a href="https://www.iovisor.org/technology/xdp">Introduction to XDP</a></li><li><a href="https://lwn.net/Articles/750845/">Accelerating networking with AF_XDP</a></li><li><a href="https://www.kernel.org/doc/html/v4.18/networking/af_xdp.html">Kernel networking-XDP</a></li><li><a href="https://blog.cloudflare.com/l4drop-xdp-ebpf-based-ddos-mitigations/">DDos Mitigations based on XDP</a></li><li><a href="https://developers.redhat.com/blog/2021/04/01/get-started-with-xdp">Get started with XDP</a></li><li><a href="https://lwn.net/Articles/750293/">AF_XDP kernel patch</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://www.iovisor.org/technology/xdp">Introduction to XDP</a></li><li><a href="https://www.accton.com/Technology-Brief/intel-dpdk-performance-on-the-sau5081i-server/">Intel® DPDK Performance on the SAU5081I Server</a></li><li><a href="https://lwn.net/Articles/725254/">Network acceleration with DPDK</a></li><li><a href="https://lwn.net/Articles/750845/">Accelerating networking with AF_XDP</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面的一篇文章&lt;a href=&quot;https://sniffer.site/2022/04/13/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/&quot;&gt;Linux网络优化之链路层优化&lt;/a&gt;中，我们已经看到，随着网卡速率超过&lt;code&gt;1Gbps&lt;/code&gt;，增加到&lt;code&gt;10Gbps/100Gbps&lt;/code&gt;时，CPU已经很难处理如此大量的数据包了。总结来说，主要有如下瓶颈：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核协议栈处理在&lt;code&gt;L3(IP)/L4(TCP)&lt;/code&gt;的数据处理上，消耗了比较多的时间，会导致网络延迟与传输受限&lt;/li&gt;
&lt;li&gt;高速网卡会在短时间内产生大量中断，导致CPU频繁发生上下文切换，性能收到影响，进而影响网络吞吐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对&lt;code&gt;10Gbps/100Gbps&lt;/code&gt;等高速网卡中存在的延迟与带宽受限问题，&lt;a href=&quot;https://en.wikipedia.org/wiki/Data_Plane_Development_Kit&quot;&gt;Intel在2010年提出了&lt;code&gt;DPDK(Data Plane Development Kit)&lt;/code&gt;基于用户空间的解决方案&lt;/a&gt;，并开源了实现方案, 目前&lt;code&gt;DPDK&lt;/code&gt;支持包括Intel&amp;#x2F;ARM等多个芯片架构的指令集; 同样是Intel的工程师在2018年提出了&lt;code&gt;XDP(eXpress Data Path)&lt;/code&gt;，与&lt;code&gt;DPDK&lt;/code&gt;不一样的是，&lt;code&gt;XDP&lt;/code&gt;基于现有内核&lt;code&gt;socket&lt;/code&gt;接口，与&lt;code&gt;eBPF&lt;/code&gt;相结合实现网卡与用户空间的数据传输，从而避免了内核协议栈的处理延迟。&lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="Linux" scheme="https://sniffer.site/tags/Linux/"/>
    
    <category term="网络优化" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    
    <category term="DPDK" scheme="https://sniffer.site/tags/DPDK/"/>
    
    <category term="XDP" scheme="https://sniffer.site/tags/XDP/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络优化之TCP优化</title>
    <link href="https://sniffer.site/2022/06/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BTCP%E4%BC%98%E5%8C%96/"/>
    <id>https://sniffer.site/2022/06/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BTCP%E4%BC%98%E5%8C%96/</id>
    <published>2022-06-06T05:43:24.000Z</published>
    <updated>2022-06-06T05:53:47.023Z</updated>
    
    <content type="html"><![CDATA[<p>TCP(<code>Transmision Control Protocol</code>)即传输控制协议, 位于TCP&#x2F;IP协议栈的第三层(L3), 是一种提供了可靠连接的字节流协议; TCP是目前使用最为广泛的协议之一, HTTP&#x2F;MQTT&#x2F;FTP等诸多应用层协议都是基于TCP实现的, 更多关于TCP协议相关的具体内容可以参考标准文档<a href="https://datatracker.ietf.org/doc/html/rfc793">RFC793</a>以及早前写的一篇<a href="https://sniffer.site/2019/07/30/%E8%81%8A%E4%B8%80%E8%81%8Atcp%E5%8D%8F%E8%AE%AE/">聊一聊TCP协议</a>. </p><p>在上一篇文章中讲到了高速以太网如1Gbps&#x2F;10Gpbs中<a href="https://sniffer.site/2022/04/13/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/">Linux网络L2(链路层)</a>的一些优化方法, 包括了<code>offload(卸荷)</code>以及<code>scaling(缩放)</code>两种技术. 随着高速网络的不断普及, 1Gbps&#x2F;10Gpbs以太网已经被广泛使用, 40Gbps&#x2F;100Gbps也已经制定标准, TCP也在随着网络带宽的提升而不断进化.这篇文章我们就来看下如何在高速以太网下对TCP相关的参数的进行调优.</p><span id="more"></span><h2 id="TCP窗口大小"><a href="#TCP窗口大小" class="headerlink" title="TCP窗口大小"></a><strong>TCP窗口大小</strong></h2><p>TCP为了协调客户端与服务端数据的发送&#x2F;接收, 使用窗口机制来确保两者保持一致的速率, 确保快速的发送方不会超过慢速的接收方. 接收方需要通过窗口更新(<code>Window Update</code>)消息来告知发送方当前可以发送多少数据. 当接收方应用处理数据时, 可向发送方发送<code>窗口更新消息</code>; 窗口更新消息最快需要一个返回时间(<code>RTT-Round Trip Time</code>), 因此窗口越大, 同一个RTT可以接收的数据就越多; 类似地, RTT越大, 则同样的时间可以接收的数据会越少. 为此, 我们可以得到如下公式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">吞吐量 &lt;= 窗口大小/RTT</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TCP原始设计中, 窗口大小为<code>65535</code>字节(64KiB - 1), 这是发送方在收到窗口更新之前允许发送的最大数据量. 但随着网络带宽越来越高, 1Gbps&#x2F;10Gbps的网络已经得到广泛使用, 这个窗口值无法让高速网络的带宽得到有效利用. 为了让高速网络的带宽得到充分利用, 一般需要通过带宽时延成乘积BDP(<code>Bandwidth-delay product</code>)公式来计算真实的TCP窗口大小.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BDP（位）= 带宽（位/秒）* RTT（秒）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假如, 我们有一个<code>1Gbps</code>的网络, RTT为<code>10ms</code>, 通过BDP公式可以大致计算出网络实际的带宽:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">带宽(bit/s) = BDP/RTT </span><br><span class="line">           = (65535Byte * 8bit/Byte)/10ms</span><br><span class="line">           = 524280 bit/0.01s</span><br><span class="line">           = 5242800 bit/s</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也就是说, 如果按照TCP原始的<code>64KiB</code>的窗口设定, 一个千兆网络的实际吞吐量才不到50Mbps, 这远没有达到1000Mbps的理论值. 那么, 要如何解决这个问题了? 标准协议通过增加一个窗口缩放选项来扩张TCP窗口大小.</p><h3 id="TCP窗口缩放"><a href="#TCP窗口缩放" class="headerlink" title="TCP窗口缩放"></a><strong>TCP窗口缩放</strong></h3><p>为了改变TCP原有设计对窗口大小的限定, <a href="https://datatracker.ietf.org/doc/html/rfc7323">RFC7323</a>引入了扩展协议, 在TCP头中增加一个<code>Window Scaling Factor</code>的参数, 可以使窗口大小扩展到<code>1,073,725,440</code>字节(接近1GiB).具体可以参考<a href="https://datatracker.ietf.org/doc/html/rfc7323">RFC7323</a>中的说明.</p><p>要在Linux中确认是否开启了窗口缩放功能, 可以通过命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo sysctl net.ipv4.tcp_window_scaling</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果这个值为<code>1</code>, 则表示开启了该选项(看4.4的内核版本已经默认打开了)；如果没有打开, 要开启该选项, 只需要通过下述命令打开即可:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo sysctl -w net.ipv4.tcp_window_scaling=1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="调整TCP窗口大小"><a href="#调整TCP窗口大小" class="headerlink" title="调整TCP窗口大小"></a><strong>调整TCP窗口大小</strong></h2><p>现在开启了窗口缩放选项, 我们就可以根据<code>BDP</code>来计算给定理论带宽与延迟情况下, 对应的TCP窗口大小了. 还是以<code>1Gbps</code>网络为例, 假设延迟(可以通过ping来大致判断)为<code>3ms</code>, 那么对应的窗口大小应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">窗口大小 = (理论带宽 * 延迟)/8bit</span><br><span class="line">       = (1000Mbps * 0.03)/8bit</span><br><span class="line">       = 3750000b</span><br><span class="line">       = 3.6Mb</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是说至少需要将TCP窗口的大小设置为<code>3.6Mb</code>大小才能确保实际吞吐量达到网络的理论带宽. 在Linux中, 一般需要设置如下几个参数来设定TCP窗口大小:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">net.core.rmem_max</span><br><span class="line">net.core.wmem_max</span><br><span class="line">net.ipv4.tcp_rmem</span><br><span class="line">net.ipv4.tcp_wmem</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中前两个参数<code>rmem_max/wmem_max</code>表示应用最大可用的TCP窗口大小, <code>tcp_rmem</code>&#x2F;<code>tcp_wmem</code>表示单个应用允许分配的最大TCP窗口大小(对应有三个值, 分别表示最小&#x2F;默认&#x2F;最大的TCP窗口大小). 为了保证TCP的性能与理论比较接近, 我们可以将上述四个参数都按照上述计算得到的TCP窗口进行设定:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MaxExpectedBDP=3750000</span><br><span class="line">sudo sysctl -w net.core.rmem_max=$MaxExpectedBDP</span><br><span class="line">sudo sysctl -w net.core.wmem_max=$MaxExpectedBDP</span><br><span class="line">sudo sysctl -w net.ipv4.tcp_rmem=&quot;4096 87380 $MaxExpectedBDP&quot;</span><br><span class="line">sudo sysctl -w net.ipv4.tcp_wmem=&quot;4096 16384 $MaxExpectedBDP&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者可以通过直接写对应<code>/proc</code>的文件节点来设定上述参数, 如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MaxExpectedBDP=3750000</span><br><span class="line">echo $MaxExpectedBDP &gt; /proc/sys/net/core/wmem_max;</span><br><span class="line">echo $MaxExpectedBDP &gt; /proc/sys/net/core/rmem_max;</span><br><span class="line">echo 4096 1048576 $MaxExpectedBDP &gt; /proc/sys/net/ipv4/tcp_rmem;</span><br><span class="line">echo 4096 1048576 $MaxExpectedBDP &gt; /proc/sys/net/ipv4/tcp_wmem;</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/tcp_window_scaling;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了上述根据<code>BDP</code>公式来优化TCP窗口大小之外, 对于高速以太网, 通常还可以通过开启TCP时间戳(增加一次往返RTT时间的估算准确度), 对TCP头进行压缩(减少TCP传输数据的大小)等方式来优化, 具体可以参考<a href="https://datatracker.ietf.org/doc/html/rfc7323">RFC7323</a>.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>本文首先介绍了TCP在高速网络中需要解决的窗口不足的问题， 然后阐述了TCP标准协议是如何解决该问题的。接着着重说明了如何在Linux中配置TCP参数，确保TCP性能达到最优。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://en.wikipedia.org/wiki/TCP_tuning">TCP参数优化</a></li><li><a href="https://cloud.google.com/architecture/tcp-optimization-for-network-performance-in-gcp-and-hybrid">Google云服务器TCP参数调优</a></li><li><a href="https://datatracker.ietf.org/doc/html/rfc7323">TCP Extensions for High Performance</a></li><li><a href="https://datatracker.ietf.org/doc/html/rfc7414">A Roadmap for Transmission Control Protocol</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;TCP(&lt;code&gt;Transmision Control Protocol&lt;/code&gt;)即传输控制协议, 位于TCP&amp;#x2F;IP协议栈的第三层(L3), 是一种提供了可靠连接的字节流协议; TCP是目前使用最为广泛的协议之一, HTTP&amp;#x2F;MQTT&amp;#x2F;FTP等诸多应用层协议都是基于TCP实现的, 更多关于TCP协议相关的具体内容可以参考标准文档&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc793&quot;&gt;RFC793&lt;/a&gt;以及早前写的一篇&lt;a href=&quot;https://sniffer.site/2019/07/30/%E8%81%8A%E4%B8%80%E8%81%8Atcp%E5%8D%8F%E8%AE%AE/&quot;&gt;聊一聊TCP协议&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;在上一篇文章中讲到了高速以太网如1Gbps&amp;#x2F;10Gpbs中&lt;a href=&quot;https://sniffer.site/2022/04/13/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/&quot;&gt;Linux网络L2(链路层)&lt;/a&gt;的一些优化方法, 包括了&lt;code&gt;offload(卸荷)&lt;/code&gt;以及&lt;code&gt;scaling(缩放)&lt;/code&gt;两种技术. 随着高速网络的不断普及, 1Gbps&amp;#x2F;10Gpbs以太网已经被广泛使用, 40Gbps&amp;#x2F;100Gbps也已经制定标准, TCP也在随着网络带宽的提升而不断进化.这篇文章我们就来看下如何在高速以太网下对TCP相关的参数的进行调优.&lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="Linux" scheme="https://sniffer.site/tags/Linux/"/>
    
    <category term="网络优化" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    
    <category term="TCP" scheme="https://sniffer.site/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络优化之链路层优化</title>
    <link href="https://sniffer.site/2022/04/13/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/"/>
    <id>https://sniffer.site/2022/04/13/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BC%98%E5%8C%96/</id>
    <published>2022-04-13T11:51:44.000Z</published>
    <updated>2022-12-06T10:25:39.928Z</updated>
    
    <content type="html"><![CDATA[<p>现在车内网络都开始内卷到<code>1Gbps</code>了, 有同学给我反馈说以太网的吞吐量上不来, 跟理论带宽差距很大, 之前虽然优化了一波<code>TCP</code>相关的参数, 但估计不能解决全部问题. 遂决定重新学习下网络优化, 从底层链路对开发平台上的网络进行改善. 趁着这个机会, 索性写一个系列文章-Linux网络优化, 用来总结下Linux网络优化的一些方法与技术, 目前计划从如下几篇文章展开(希望不要放飞了):</p><ul><li>Linux网络优化之数据链路层优化: 数据链路层<code>L2</code>的优化, 如何从收发两个方面优化网卡吞吐量，即本篇。</li><li>Linux网络优化之TCP优化: <a href="https://sniffer.site/2022/06/06/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8Btcp%E4%BC%98%E5%8C%96/">以TCP协议为例, 说明<code>L3</code>协议栈优化</a></li><li>Linux网络优化之高速网络优化: <a href="https://sniffer.site/2022/08/12/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8Bdpdk%E4%B8%8Exdp/">基于<code>DPDK/XDP</code>解决高速网络传输延迟问题</a></li><li>Linux网络优化之AVB: <a href="https://sniffer.site/2022/12/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BAVB-TSN/">介绍以太网中用于音视频传输的低时延<code>TSN/AVB</code>协议</a></li></ul><p>这篇文章主要讲第一个话题: Linux是如何在数据链路层<code>L2</code>对网络数据的接收与发送进行优化的. </p><span id="more"></span><p>我们都知道, Linux的网络协议栈<code>L4</code>到<code>L2</code>(传输层)以下都是在内核实现的, 其主要存在的问题是日益增加的网络带宽与CPU处理能力(包括内核协议栈)之间矛盾, 随着后续100G甚至400G的网卡出现, 这个矛盾只会更加突出. 针对这种速度上的不平衡, 涌现出了各种解决方案, 有些是基于Linux内核协议栈, 在内核的基础上进行优化, 比如将部分耗时的操作丢给网卡处理(<code>offload</code>); 有些则是基于L4协议做优化, 比如优化TCP参数, 使用更好的拥塞控制算法, 使用<code>zero-copy</code>技术减少内存拷贝; 有些则完全跳过了内核协议, 直接把网卡的数据送往用户进程, 进而避免了内核处理慢的问题, 比如<a href="https://en.wikipedia.org/wiki/Express_Data_Path"><code>XDP/DPDK</code></a>; 还有一些是从<code>L2</code>到应用层针对音视频数据传输做了大量优化, 确保低延迟以及足够的预留带宽, 这就是<a href="https://en.wikipedia.org/wiki/Audio_Video_Bridging"><code>TSN/AVB</code></a>协议.</p><p>这篇文章, 就来看下那些Linux网络驱动以及协议栈中各种网络优化技术, 包括<code>offload</code>与<code>scaling</code>两个部分. 先来看下发送端的<code>offload</code>优化方案.</p><h2 id="链路层优化-offload技术"><a href="#链路层优化-offload技术" class="headerlink" title="链路层优化-offload技术"></a><strong>链路层优化-offload技术</strong></h2><p>内核协议栈在传输数据时(内核数据的传输流程可以参考之前的文章<a href="https://sniffer.site/2021/04/08/linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B/">Linux网络协议之数据发送流程</a>, 除了从内核空间拷贝数据耗时外, 还有两件事情需要消耗CPU资源:</p><ul><li>数据包传送到网络层L2时, 需要按照网卡的MTU对数据包进行分片</li><li>传送数据时需要对数据包进行校验和计算(checksum)</li></ul><p>一般来说网卡的MTU都默认设置为<code>1500</code>字节, 一旦TCP&#x2F;UDP等L3的数据包超过了设定的MTU, 网络层L2就需要将其分割成MTU大小的数据段. 比如为了传输<code>3200bytes</code>的数据, 通常需要分割成3个包进行发送. 为了避免分片, 可以通过设置一个大的MTU, 比如在需要高速网络传输时将MTU设置为9000(JUBO frame), 但这个在广域网中很难行的通, 因为不同的通讯节点很难保持统一的MTU设置. 这时就需要用到<code>segmentation offload</code>(分片卸荷)技术. <code>offloads</code>本质上就是将原本需要CPU处理的部分丢给网卡来处理, 其最高可支持<code>64KB</code>大小的数据包, 这样可以减少网络包的数量, 降低网络中断数量, 增加网络吞吐量.</p><p>常见的<code>offload</code>有如下几种:</p><ul><li>TSO(<code>TCP Segmentation Offload</code>): 开启TSO功能的网卡可以将一个大的单帧数据分割成固定大小(MTU)多个帧. TSO一般需要与网卡的<code>checksum offload</code>以及<code>scatter-gather</code>功能一起配置使用.</li><li>UFO(<code>UDP Fragmentation Offload</code>): 网卡可以将一个大的UDP报文分割成固定MTU大小的数据包; UFO目前已经废弃不用, 大部分内核不再支持.</li><li>GSO(<code>Generic Segmentation Offload</code>): GSO可以看作是TSO的补充, 当网卡无法支持TSO&#x2F;UFO时, GSO可以确保数据包进入驱动处理时按照MTU的大小进行分片处理, 从而避免数据包无法发送的情况. GSO一般要与GRO(<code>Generic Receive Offload</code>)一起使用.</li><li>LRO(<code>Large Receive Offload</code>): 在数据包进入协议栈之前进行重新组合成一个更大的报文, 以减少数据包的数量, 降低CPU负载.  LRO通常会忽略数据包头中的差异以及其他存在的错误. 通常来说, LRO无法与内核中的IP转发(<code>IP Forwarding</code>)功能一起使用, 因此在开启LRO时需要关闭IP转发功能.</li><li>GRO(<code>Generic Receive Offload</code>): 与LRO类似, 不过在合成包时会对每个数据包进行更严格的检查, 比如会检查数据包的MAC头; 查看TCP的时间戳. GRO可以通过软件或者在网卡中实现.</li></ul><p>在Linux中, 可以通过<code>ethtool</code>工具来查看以及设定网卡的<code>offload</code>配置:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 查看网卡offload配置</span></span><br><span class="line">ethtool --show-offload  enp0s31f6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到有如下输出:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Features <span class="keyword">for</span> enp0s31f6:</span><br><span class="line">rx-checksumming: on</span><br><span class="line">tx-checksumming: on</span><br><span class="line">tx-checksum-ipv4: off [fixed]</span><br><span class="line">tx-checksum-ip-generic: on</span><br><span class="line">tx-checksum-ipv6: off [fixed]</span><br><span class="line">tx-checksum-fcoe-crc: off [fixed]</span><br><span class="line">tx-checksum-sctp: off [fixed]</span><br><span class="line">scatter-gather: on</span><br><span class="line">tx-scatter-gather: on</span><br><span class="line">tx-scatter-gather-fraglist: off [fixed]</span><br><span class="line">tcp-segmentation-offload: on</span><br><span class="line">tx-tcp-segmentation: on</span><br><span class="line">tx-tcp-ecn-segmentation: off [fixed]</span><br><span class="line">tx-tcp-mangleid-segmentation: off</span><br><span class="line">tx-tcp6-segmentation: on</span><br><span class="line">udp-fragmentation-offload: off</span><br><span class="line">generic-segmentation-offload: on</span><br><span class="line">generic-receive-offload: on</span><br><span class="line">large-receive-offload: off [fixed]</span><br><span class="line">rx-vlan-offload: on</span><br><span class="line">tx-vlan-offload: on</span><br><span class="line">ntuple-filters: off [fixed]</span><br><span class="line">receive-hashing: on</span><br><span class="line">highdma: on [fixed]</span><br><span class="line">rx-vlan-filter: off [fixed]</span><br><span class="line">vlan-challenged: off [fixed]</span><br><span class="line">tx-lockless: off [fixed]</span><br><span class="line">netns-local: off [fixed]</span><br><span class="line">tx-gso-robust: off [fixed]</span><br><span class="line">tx-fcoe-segmentation: off [fixed]</span><br><span class="line">tx-gre-segmentation: off [fixed]</span><br><span class="line">tx-gre-csum-segmentation: off [fixed]</span><br><span class="line">tx-ipxip4-segmentation: off [fixed]</span><br><span class="line">tx-ipxip6-segmentation: off [fixed]</span><br><span class="line">tx-udp_tnl-segmentation: off [fixed]</span><br><span class="line">tx-udp_tnl-csum-segmentation: off [fixed]</span><br><span class="line">tx-gso-partial: off [fixed]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="数据链路层优化-scaling技术"><a href="#数据链路层优化-scaling技术" class="headerlink" title="数据链路层优化-scaling技术"></a><strong>数据链路层优化-scaling技术</strong></h2><p>上面讲到的<code>offload</code>技术主要是针对数据传输(包括接收与发送)的优化, 这里说的<code>scaling</code>(伸缩，即具备弹性，随着系统的增大而性能不会收到影响)技术则主要是针对接收的优化, 其主要是用于增加多核CPU系统中网络并发处理能力, 改善网络性能. </p><p>了解Linux网络协议栈数据接收的流程(参考<a href="https://sniffer.site/2020/05/12/%E4%BB%8Enapi%E8%AF%B4%E4%B8%80%E8%AF%B4linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/">从NAPI说一说Linux内核数据的接收流程</a>, 我们知道, 网卡接收到数据后, 会以DMA的形式拷贝到内存, 然后发送中断告知CPU进行处理. 对于多核CPU系统来说, 有如下几个问题需要仔细考量:</p><ul><li>如何减少网络中断: 在高速网卡中, 可能有大量的中断产生, 过多的中断会影响CPU的性能, 进而影响网络吞吐量. Linux内核协议栈采用了<code>NAPI</code>技术来达到减少中断的目的; 除了<code>NAPI</code>技术, 很多网卡也会提供中断合并(<code>Interrupt Coalescence</code>)方法来减少中断数量, 简单来说, 中断合并是指网卡会等某个超时时间或者传送了某个数量的帧后才会向CPU发送一个数据接收的中断.</li><li>中断在哪个CPU上处理: 多队列网卡上, 每个队列都可能有自己的中断, 如何将中断均衡的分配到每个CPU上在一定程度上影响网络性能.</li><li>数据包要在哪个CPU上处理: 默认情况下, 数据包会发送给处理中断的CPU上, 但这对多队列网卡来说, 这会造成一定程度上的CPU负载不均衡, 从而影响系统性能.</li></ul><p>内核中的<code>scaling</code>技术就是针对这后面两个情况进行优化的. 常见的<code>scaling</code>技术有如下几种:</p><ul><li><strong>RSS</strong>(<code>Receive Side Scaling</code>):  对现在的网卡来说, 可能存在多个队列, 每个队列又会有一个中断; 如何把数据包均衡的分布到每个队列,  将多个网卡中断均衡发送到每个CPU上就是RSS需要解决的问题. 对于数据包的均衡,  需要通过网卡中的<code>indirection table</code>来实现; 中断均衡可以通过设置中断的CPU亲和性来实现.</li><li><strong>RPS</strong>(<code>Receive Packet Steering</code>): RPS可以看作是RSS的软件实现版, 区别在于RPS是在中断处理之后CPU处理数据包时进行. RPS旨在把网卡发送的数据包发送给给定的CPU进行处理, 从而实现数据包的均衡.相比RSS, RPS具有更好的灵活性, 可以适配任何网卡与协议, 并且不会增加物理设备的中断频率. </li><li><strong>RPS Flow Limit</strong>(<code>RFS</code>): 在某些情况下, 网络数据可能呈现不均衡的情况, 一些数据流可能更大, 从而造成小数据流处理慢的情况. 针对这个问题, RFS在某个CPU输入队列的数据长度超过限值(<code>net.core.netdev_max_backlog</code>)时, 新的数据包会被丢弃. RFS默认是关闭的.</li><li><strong>RFS</strong>(<code>Receive Flow Steering</code>): RPS只是根据包的哈希值来选择处理数据包的CPU, 但没有考虑数据包接收端的本地性(<code>application locality</code>), 就是说处理的CPU可能并不是用户进程接收数据包的CPU. RFS正是用于解决该问题, 确保处理数据包的与用户接收进程同在一个CPU上, 从而增强数据缓存命中率.</li><li><strong>aRFS</strong>(<code>Accelerated Receive Flow Steering</code>): aRFS之于RFS类似于RSS之于RPS; aRFS就是RFS的硬件实现, 需要网卡支持硬件加速功能才能实现. 在一定程度上, 由于数据包是直接发送给消费进程所在的本地CPU(进程同一CPU, 或对应缓存架构上应用线程本地的CPU), aRFS在性能上要优于RFS. </li><li><strong>XPS</strong>(<code>Transmit Packet Steering</code>): XPS是针对多队列网卡如何选择发送队列问题的优化策略. 开启XPS时, 内核会记录网卡队列与CPU之间的映射关系, 确保网卡的某个队列与固定的CPU之间绑定, 确保传输完成的中断由对应队列的CPU处理, 这样做一可以减少CPU在网卡队列上的等待时间; 一可以减少内存缓存缺失.</li></ul><p>综合来看, 无论是RSS&#x2F;RPS, 还是RFS&#x2F;XPS, 都是尝试在多CPU与多队列网卡之间的数据包处理上达成均衡分配的目的, 以减少CPU处理压力, 增加内存缓存命中率, 提高网卡的吞吐量. 接下来就来看看如何在Linux中配置<code>scaling</code>的优化方案.</p><ul><li><strong>RSS配置</strong>: 将数据包均匀的发送到不同CPU上可以减少网卡的队列长度, 希望优化网络延迟的情况下可以打开该配置. 如果网卡本身支持RSS, 可以尝试通过<code>ethtool</code>来设置; 对中断均衡, 可以通过配置网卡中断亲和性来确保RSS起作用, 比如<code>echo 0xff &gt; /proc/irq/&lt;irq_no&gt;/smp_affinity</code>.</li><li><strong>RPS配置</strong>: RPS需要内核配置<code>CONFIG_RPS</code>才会编译; 如果要开启, 还需要显式的指定网卡队列需要绑定的CPU: <code> /sys/class/net/&lt;dev&gt;/queues/rx-&lt;n&gt;/rps_cpus</code>, 如果这个值是0, RPS是关闭状态, 这时数据包会发送到处理中断的CPU. 如果网卡本身是多队列的, 并且每个队列都对应映射到每个CPU上, RPS可以不用配置; 但如果网卡队列数量少于CPU数量, RPS仍然是有益的.</li><li><strong>RPS Flow Limit配置</strong>: RPS限流内核配置(<code>CONFIG_NET_FLOW_LIMIT</code>)是默认打开的, 但是功能本身是关闭状态, 需要通过设置<code> /proc/sys/net/core/flow_limit_cpu_bitmap</code>(与<code>rps_cpus</code>设置一样)来开启该功能.</li><li><strong>RFS配置</strong>: RFS只有在<code>CONFIG_RPS</code>打开的情况下才可用, 该功能需要配置两个参数, 一个用于配置全局流表, <code>/proc/sys/net/core/rps_sock_flow_entries</code>;  一个是用于配置网卡每个队列的限流数量, <code> /sys/class/net/&lt;dev&gt;/queues/rx-&lt;n&gt;/rps_flow_cnt</code>.</li><li><strong>aRFS配置</strong>: aRFS需要使能内核配置<code>CONFIG_RFS_ACCEL</code>并且需要网卡本身支持. 有硬件加速功能个的网卡通常都实现了<code>ndo_rx_flow_steer</code>这个函数.</li><li><strong>XPS配置</strong>: XPS需要配置内核<code>CONFIG_XPS</code>, 如果要打开该功能, 配置CPU的位图即可<code>/sys/class/net/&lt;dev&gt;/queues/tx-&lt;n&gt;/xps_cpus</code>.</li></ul><p>有关上述网络优化方案的详细配置可以参考内核文档<code>Documentation/networking/scaling.txt</code>.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rfs">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rfs</a></li><li>Linux Documentation&#x2F;networking(scaling&#x2F;segmentation-offloads)</li><li><a href="https://www.linkedin.com/pulse/modern-high-speed-networking-techniques-hardware-john-velegrakis">https://www.linkedin.com/pulse/modern-high-speed-networking-techniques-hardware-john-velegrakis</a></li><li><a href="https://lwn.net/Articles/188489/">GSO: Generic Segmentation Offload</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-nic-offloads">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-nic-offloads</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在车内网络都开始内卷到&lt;code&gt;1Gbps&lt;/code&gt;了, 有同学给我反馈说以太网的吞吐量上不来, 跟理论带宽差距很大, 之前虽然优化了一波&lt;code&gt;TCP&lt;/code&gt;相关的参数, 但估计不能解决全部问题. 遂决定重新学习下网络优化, 从底层链路对开发平台上的网络进行改善. 趁着这个机会, 索性写一个系列文章-Linux网络优化, 用来总结下Linux网络优化的一些方法与技术, 目前计划从如下几篇文章展开(希望不要放飞了):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux网络优化之数据链路层优化: 数据链路层&lt;code&gt;L2&lt;/code&gt;的优化, 如何从收发两个方面优化网卡吞吐量，即本篇。&lt;/li&gt;
&lt;li&gt;Linux网络优化之TCP优化: &lt;a href=&quot;https://sniffer.site/2022/06/06/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8Btcp%E4%BC%98%E5%8C%96/&quot;&gt;以TCP协议为例, 说明&lt;code&gt;L3&lt;/code&gt;协议栈优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Linux网络优化之高速网络优化: &lt;a href=&quot;https://sniffer.site/2022/08/12/linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8Bdpdk%E4%B8%8Exdp/&quot;&gt;基于&lt;code&gt;DPDK/XDP&lt;/code&gt;解决高速网络传输延迟问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Linux网络优化之AVB: &lt;a href=&quot;https://sniffer.site/2022/12/06/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8BAVB-TSN/&quot;&gt;介绍以太网中用于音视频传输的低时延&lt;code&gt;TSN/AVB&lt;/code&gt;协议&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章主要讲第一个话题: Linux是如何在数据链路层&lt;code&gt;L2&lt;/code&gt;对网络数据的接收与发送进行优化的. &lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://sniffer.site/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="Linux" scheme="https://sniffer.site/tags/Linux/"/>
    
    <category term="网络优化" scheme="https://sniffer.site/tags/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>重学现代C++</title>
    <link href="https://sniffer.site/2022/03/31/%E9%87%8D%E5%AD%A6C++/"/>
    <id>https://sniffer.site/2022/03/31/%E9%87%8D%E5%AD%A6C++/</id>
    <published>2022-03-31T06:58:15.000Z</published>
    <updated>2023-06-10T00:54:39.089Z</updated>
    
    <content type="html"><![CDATA[<p>断断续续看了Bjarne Stroustrup的’C++之旅(<code>a tour of C++</code>)’, 作者把很多原本看起来复杂的概念模型都讲的比较清晰, 也有不少好的代码示例, 有种拨云见雾的感觉. 于是想着写一篇文章来总结重新学习C++的一些经验, 主要阐述下现代C++(<code>&gt;=C++11</code>)中那些容易让人混淆而觉得陌生的技术.</p><p>了解C++历史的人都知道, <code>Bjarne Stroustrup</code>是在Bell实验室(就是Unix操作系统与C语言诞生的地方)发明了C++, 初衷是在C中加入类(class)的概念, 增强C语言在系统编程上的效率与灵活性, 也正式因为这个原因, C++在1979年最初的名字是<code>带类的C</code>(c with class), 直到1984年才改名为<code>C++</code>. 到今天, <code>C++</code>的发展历经了快40年历史, 但真正一次大的标准修改是在2011年, 这个版本也称为<code>C++11</code>(<code>C++11</code>之后的版本也统称为<code>Modern C++</code>).接下来我们就来一起来回顾下现代C++中那些曾经让人<code>头疼</code>的技术吧.</p><span id="more"></span><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/evolution_of_c%2B%2B.png" alt="history_of_cpp"></p><h2 id="constants"><a href="#constants" class="headerlink" title="constants"></a><strong>constants</strong></h2><p>除了<code>const</code>之外, C++还引入了<code>constexpr</code>这个关键字. <code>const</code>的意思是这个变量不会被修改, 编译器在编译的时候会确保这一点: 如果尝试修改<code>const</code>的赋值, 则会提示错误. 而<code>constexpr</code>是说这个表达式会在编译的时候进行判定(不用等到运行时):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vi)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;;  <span class="comment">//示例</span></span><br><span class="line"> <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">constexpr</span> <span class="type">double</span> m1 = <span class="number">1.6</span> * <span class="built_in">square</span>(im);</span><br><span class="line"><span class="comment">//constexpr double m2 = 1.6 * square(var); // 不允许使用非const变量</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vi = &#123;<span class="number">4</span>, <span class="number">58</span>, <span class="number">8</span> , <span class="number">9</span>&#125;; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> si = <span class="built_in">sum</span>(vi);</span><br><span class="line"><span class="comment">//constexpr int sii = sum(vi); // sum不是constexpr表达式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果一个函数要在<code>constexpr</code>表达式中使用, 则必须要以<code>constexpr</code>开头, 并且函数的实现需要足够简单: 只由一个返回值的表达式组成，且不能调用任何其他非<code>constexpr</code>的函数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于在编译时就完成了计算, 使用<code>constexpr</code>通常可以改善性能, 但据<code>c++ standar library: a tutorial and refernce</code>里边提到的, 引入<code>constexpr</code>是为了解决C++98<code>numeric_limits</code>标准库中的一个bug:<code>std::numeric_limits&lt;short&gt;::max()</code> 无法在常量表达式中使用.</p><h2 id="引用与右值"><a href="#引用与右值" class="headerlink" title="引用与右值"></a><strong>引用与右值</strong></h2><p>C++针对C中的指针引入了<code>引用(reference)</code>的概念, 引用类似于指针, 其通过<code>&amp;</code>进行声明, 但实际使用的时候无需在通过<code>*</code>来引用对象, 更重要的是引用一旦被初始化就不能再被修改, 引用其他的对象.</p><blockquote><p>引用类似指针，但非指针;引用只是对象的别名。引用与指针存在三个区别: 1) 没有空引用(<code>null reference</code>),就是说引用始终指向一个有效的对象 2) 所有引用需要初始化  3) 一个引用永远指向它初始化的那个对象</p></blockquote><p>引用对于不管理资源的对象来说, 一般不会有什么问题, 但涉及到大量的数据&#x2F;内存时(比如容器), 单纯的拷贝会变得低效. 有时, 我们只希望在不同对象之间<code>移动(move)</code>数据而不是拷贝, 以避免产生不必要的临时对象. 比如我们有一个<code>String</code>类, 包含了一个字符数组:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">String</span>(): <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>]) &#123;</span><br><span class="line"> data[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str): <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>]) &#123;</span><br><span class="line"> <span class="keyword">if</span> (str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"> <span class="built_in">strncpy</span>(data, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"> data[<span class="built_in">strlen</span>(str)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">String</span>(<span class="type">const</span> String&amp; str): <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">char</span>[str.<span class="built_in">size</span>() + <span class="number">1</span>]) &#123;</span><br><span class="line"> <span class="built_in">strncpy</span>(data, str.<span class="built_in">c_str</span>(), str.<span class="built_in">size</span>());</span><br><span class="line"> data[str.<span class="built_in">size</span>()] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> String&amp; <span class="keyword">operator</span>=(String &amp;rhs) &#123;</span><br><span class="line"> <span class="built_in">swap</span>(rhs);</span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ~<span class="built_in">String</span>() &#123;</span><br><span class="line"> <span class="keyword">delete</span>[] data;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">strlen</span>(data);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> data;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(String &amp;rhs)</span> </span>&#123;</span><br><span class="line"> std::<span class="built_in">swap</span>(data, rhs.data);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>比如我们要往一个容器中插入对象, 那么每次实际容器中实际得到的都是一个拷贝的对象, 这就导致了不必要的内存拷贝, 如果对象本身很大(占用较大内存), 则拷贝会消耗更多的时间.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">String <span class="title">s</span><span class="params">(<span class="string">&quot;agaga&quot;</span>)</span></span>;</span><br><span class="line">std::set&lt;String&gt; ss;</span><br><span class="line">ss.<span class="built_in">insert</span>(s); <span class="comment">// get a copy of s</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>针对这种临时对象的拷贝, <code>C++11</code>中引入了<code>移动(move)</code>语义, 这样就可以支持对象之间数据的转移而不是拷贝了, 从而改善了程序的性能. 要让上述<code>String</code>对象支持<code>move</code>语义, 其实也很简单:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// move constructor</span></span><br><span class="line"><span class="built_in">String</span>(String &amp;&amp;str): <span class="built_in">data</span>(str.data) &#123;</span><br><span class="line"> str.data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// move assignment</span></span><br><span class="line">String&amp; <span class="keyword">operator</span>=(String&amp;&amp; rhs) &#123;</span><br><span class="line"> data = rhs.data;</span><br><span class="line"> rhs.data = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码中<code>&amp;&amp;</code>表示一个右值引用(<code>rval refernece</code>), 就是说该引用跟一个右值绑定, 这通常有别于左值(赋值语句的左边), 由于右值引用无法进行赋值, 因此我们可以<code>偷取</code>它的值与资源. C++标准库中也有一个<code>move</code>函数可以用于操作右值引用(头文件<code>utility</code>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;gaga&quot;</span>)</span></span>;</span><br><span class="line">String s2 = s1; <span class="comment">// copy</span></span><br><span class="line">String s3 = std::<span class="built_in">move</span>(s2); <span class="comment">// move</span></span><br><span class="line"></span><br><span class="line">std::set&lt;String&gt; ss;</span><br><span class="line">ss.<span class="built_in">insert</span>(std::<span class="built_in">move</span>(s1)); <span class="comment">// move</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要留意的时, 对于函数返回值不应该返回右值或使用<code>move()</code>要返回的值, 对于如下函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">String <span class="title">fcn</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">s</span><span class="params">(<span class="string">&quot;hi, move&quot;</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>C++会确保返回值按照如下规则进行:</p><ul><li>如果<code>String</code>有move构造函数或者赋值函数, 编译器可能会忽略拷贝对象, 这种技术被称为返回值优化(<code>returned value optimization</code>), 在C++11之前就有了.</li><li>否则就使用move构造函数返回对象</li><li>如果没有move构造函数, 则使用拷贝构造函数返回拷贝对象</li><li>否则就会抛出编译时异常</li></ul><p>有关更多右值引用、移动语义可以参考如下两篇文章:</p><ul><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html#:~:text=Rvalue%20references%20is%20a%20small,performance%20and%20more%20robust%20libraries.">A Brief Introduction to Rvalue References</a></li><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">A Proposal to Add Move Semantics Support to the C++ Language</a></li></ul><h2 id="lamda表达式与函数对象"><a href="#lamda表达式与函数对象" class="headerlink" title="lamda表达式与函数对象"></a><strong>lamda表达式与函数对象</strong></h2><p>C++11引入了<code>lambda</code>表达式; <code>lambda</code>表达式可以用于创建简单的函数对象(<code>function object</code>), 构建匿名函数, 其返回的对象被称为闭包对象(<code>closure object</code>). 一般来说, <code>lambda</code>表达式由如下三个部分组成:</p><ul><li><p>捕获列表(<code>caputure list</code>): <code>[]</code> , 一个对象被捕获以后就可以在<code>lambda</code>函数内部使用(值复制或者引用的形式), <code>=</code>用于值的形式捕获所有本地变量;<code>&amp;</code>则表示以引用的形式捕获所有本地变量. 如果需要指定捕获的变量, 则需要在符号后面加上对应变量的名字, 如<code>=a</code>, <code>&amp;a</code>等. 不指定捕获符号则默认的捕获是值形式.</p></li><li><p>参数列表(<code>parameter list</code>): <code>()</code>, 参数列表与普通函数完全一致, 如果没有参数, 可以选择直接忽略表达式中的<code>()</code>(只有C++14以上的版本支持)</p></li><li><p>函数体(<code>function body</code>): <code>&#123;&#125;</code>表示函数体, 这与普通函数是一样的.</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[=(&amp;)] ()&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>lambda</code>表达式源自于<code>lambda calculus</code>, 是<code>Alonzo Church</code>在1930s用于研究逻辑与计算时使用的数学形式语言, 这也是函数式编程语言<code>LISP</code>的基础.</p></blockquote><p>比如实现判断一个数值是否大于<code>10</code>的<code>lamda</code>表达式, 可以这么做:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">[=a](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; a; &#125;;</span><br><span class="line"></span><br><span class="line">[&amp;a](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; a; &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认情况下, 未被显式指定捕获本地变量都无法在表达式函内使用, 但可以隐式的在函数体内捕获这些变量:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[=]() &#123; <span class="keyword">return</span> a + b; &#125;; <span class="comment">// a and b caputured by value</span></span><br><span class="line"></span><br><span class="line">[&amp;]() &#123; <span class="keyword">return</span> a + b; &#125;; <span class="comment">// a and b caputured by reference</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果同时使用了两种形式的捕获, 显式捕获会覆盖默认的捕获:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> a  = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">[=, &amp;b] () &#123;</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// Illegal, a is caputured by value and lamda is not mutable </span></span><br><span class="line">b = <span class="number">3</span>; <span class="comment">// OK , b is caputured by value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是, <code>lambda</code>表达式可以使用泛型参数, 这个在本质上是等同于函数式对象, 不妨来看个示例: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">auto</span> copy = [] (<span class="keyword">auto</span> x) &#123; <span class="keyword">return</span> x + x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">copy</span>(<span class="number">2</span>); <span class="comment">// i = 4</span></span><br><span class="line">std::string s = <span class="built_in">copy</span>(<span class="string">&quot;hi&quot;</span>); <span class="comment">// s = &quot;hihi&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述表达式可以写成如下形式的函数对象(标准库中很多算法广泛使用了函数对象来扩展实现, 如<code>for_each</code>, <code>bind</code>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CopyValue</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x + x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="智能指针-smart-pointers"><a href="#智能指针-smart-pointers" class="headerlink" title="智能指针(smart pointers)"></a><strong>智能指针(smart pointers)</strong></h2><p>长期以来, C被大家所诟病的一个缺陷就是指针引发的一系列内存管理问题, 比如空指针, 内存泄漏等, C++虽然通过引入了<code>引用(reference</code>)在一定程度上避免了指针带来内存管理的困扰, 但并没有从根源上解决指针所引发的资源管理问题. 现代C++普遍采用<a href="https://docs.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-170"><code>RAII(Resource Acquisition Is Initialization)</code></a>原则;从C++11开始, 标准库引入了智能指针(smart pointers)避免内存泄漏: <code>unique_ptr</code>&#x2F;<code>shared_ptr</code>, 用以替换之前的<code>auto_ptr</code>. </p><ul><li><code>unique_ptr</code>: 表示一个唯一的所属关系, 始终只有一个指针指向该对象</li><li><code>shared_ptr</code>: 表示一个共有的所属关系, 可以有多个指针共享对象资源</li></ul><p>标准库中提供了接口用于方便的创建<code>unique_ptr</code>&#x2F;<code>shared_ptr</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">std::unique_ptr&lt;X&gt; up &#123; <span class="keyword">new</span> X &#125;; <span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// since C++14</span></span><br><span class="line">std::unique_ptr&lt;X&gt; up = std::<span class="built_in">make_unique</span>&lt;X&gt;(); </span><br><span class="line"><span class="comment">// move unique_ptr to another</span></span><br><span class="line">std::unique_ptr&lt;X&gt; up1 = std::<span class="built_in">move</span>(up); <span class="comment">// now up is undefined</span></span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;X&gt; sp &#123;<span class="keyword">new</span> X&#125;; <span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// since C++14</span></span><br><span class="line">std::shared_ptr&lt;X&gt; sp = std::<span class="built_in">make_shared</span>&lt;X&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;X&gt; <span class="title">sp1</span><span class="params">(sp)</span></span>; <span class="comment">// shared with sp1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类型推断-auto-x2F-decltype"><a href="#类型推断-auto-x2F-decltype" class="headerlink" title="类型推断(auto&#x2F;decltype)"></a><strong>类型推断(auto&#x2F;decltype)</strong></h2><p>C++11引入了<code>auto</code>关键字用于告诉编译器对变量, 函数以及模板类进行推断, 从而避免让用户自己显式的声明类型(<code>auto</code>变量必须初始化，这样可以避免手动声明变量未被初始化的问题). 比如, 相比写一堆嵌套的模板实例类型, 使用<code>auto</code>可以简化声明:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>,list&lt;string&gt;&gt;::iterator i = m.<span class="built_in">begin</span>(); <span class="comment">// C-style</span></span><br><span class="line"><span class="keyword">auto</span> i = m.<span class="built_in">begin</span>(); <span class="comment">// modern C++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//using auto to simplify code</span></span><br><span class="line"><span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::const_iterator itr = myvec.<span class="built_in">cbegin</span>(); itr != myvec.<span class="built_in">cend</span>(); ++itr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> itr = myvec.<span class="built_in">cbegin</span>(); itr != myvec.<span class="built_in">cend</span>(); ++itr)</span><br></pre></td></tr></table></figure><p>需要注意的是，C++11开始支持括号列表初始化方式，如下的声明实际得到的两个变量<code>x1</code>&#x2F;<code>x2</code>是不一样的，编译器会把<code>x1</code>的类型推断为<code>int</code>值，而<code>x2</code>推断为<code>std::initializer_list</code>, 这类似与变量<code>x3</code>的类型(具体可以参考<a href="https://book.douban.com/subject/26793803/">Effective Modern C++</a>书中的第二条有关<code>auto</code>类型推断的解释)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">33</span>; <span class="comment">// or auto x1(33), x1 is int</span></span><br><span class="line"><span class="keyword">auto</span> x2 = &#123;<span class="number">35</span>&#125;; <span class="comment">// or auto x2&#123;35&#125;, x2 is std::initializer_list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x3 = &#123;<span class="number">2</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">13</span>&#125;;  <span class="comment">// x3 is std::initializer_list</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外, C++11还增加了一个关键字<code>decltype</code>, 用于在编译的时候获取某个变量或者表达式的类型, 例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">decltype</span>(a) c = <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不过需要注意的是, <code>decltype</code>推断出来的类型与<code>auto</code>的实际类型可能有差异(示例来自<a href="%60https://en.wikipedia.org/wiki/C++11%60">wikipedia</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> a = v[<span class="number">0</span>];        <span class="comment">// a has type int</span></span><br><span class="line"><span class="keyword">decltype</span>(v[<span class="number">0</span>]) b = <span class="number">1</span>; <span class="comment">// b has type const int&amp;, the return type of</span></span><br><span class="line"><span class="comment">//   std::vector&lt;int&gt;::operator[](size_type) const</span></span><br><span class="line"><span class="keyword">auto</span> c = <span class="number">0</span>;           <span class="comment">// c has type int</span></span><br><span class="line"><span class="keyword">auto</span> d = c;           <span class="comment">// d has type int</span></span><br><span class="line"><span class="keyword">decltype</span>(c) e;        <span class="comment">// e has type int, the type of the entity named by c</span></span><br><span class="line"><span class="keyword">decltype</span>((c)) f = c;  <span class="comment">// f has type int&amp;, because (c) is an lvalue</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">0</span>) g;        <span class="comment">// g has type int, because 0 is an rvalue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a><strong>标准库</strong></h2><p>C++标准库中已经实现了大量通用的算法, 包括查找, 排序, 过滤以及随机算法等, 如果你正瞅着自己实现某个算法时, 可以直接看看标准模板库(<code>STL</code>, Stardard Template Libarary)的算法. 举几个例子:</p><ul><li><code>for_each</code>: 可以利用迭代器<code>iterator</code>很方便的对容器进行遍历操作</li><li><code>transform</code>: 对容器元素根据某个特定规则进行变换</li><li><code>find_if</code>: 根据某个函数对象对进行搜索查找</li><li><code>sort</code>&#x2F;<code>lower_bound</code>: 排序&#x2F;搜索算法</li></ul><p>标准模板库<code>STL</code>包含了三大组件：容器（<code>Container</code>）、算法（<code>Algorithm</code>）以及迭代器（<code>Interator</code>）。</p><ul><li>容器用于容纳&#x2F;组织对象，是一种数据结构的抽象，以类模板的方式实现</li><li>算法执行对象的操作，是一种函数的抽象，通过函数模板来实现</li><li>迭代器用于访问容器中的元素，为容器与算法提供一种协同工作的机制。</li></ul><p>更多有关标注库的算法可以参考<a href="https://book.douban.com/subject/10440485/">The C++ Standard Library, 2nd Edition</a>.</p><h2 id="转型操作符"><a href="#转型操作符" class="headerlink" title="转型操作符"></a><strong>转型操作符</strong></h2><p>C++中引入了很多类型转换（cast）操作，比如<code>const_cast</code>, <code>dynamic_cast</code>等，为转换操作提供了明确的语法表达。</p><ul><li><code>const_cast</code>： 去除类型中的const信息，只是去掉转型类型修饰符。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> Shape *sp = <span class="keyword">new</span> Shape</span><br><span class="line">Share *sp1 = <span class="built_in">const_cast</span>&lt;Shape *&gt;(sp)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>static_cast</code>: 用于相对而言可跨平台的移植的转型，最常的用于将一个基类指针或者引用，向下转型为一个派生类指针与引用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Shape *sp = <span class="keyword">new</span> Circle;</span><br><span class="line"></span><br><span class="line">Circle *cp = <span class="built_in">static_cast</span>&lt;Circle *&gt;(sp)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>dynamic_cast</code>: 基类指针向下（downcast）转型为派生类指针, 与static_cast不同的是， dynamic_cast仅用于多态类型的向下转型（就是说被转型的类型中，必须是一个指向带有虚函数的类类型的指针），并且会执行运行期的检查，确保了转型的正确。这也为<code>dynamic_cast</code>带来了额外的开销。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> Circle *cp = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Circle*&gt;(<span class="built_in">getNextShape</span>());</span><br><span class="line"><span class="keyword">if</span> (cp) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果转型失败，会抛出一个<code>std::bad_cast</code>的异常。</p><ul><li><code>reinterpret_cast</code>: 允许从<code>bit</code>位的角度重新看待一个对象，将其看做是完全不同的东西</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">char</span> *cp =  <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(<span class="number">0x00ff0000</span>);</span><br><span class="line"><span class="type">int</span> *ip = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span> *&gt;(cp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通常来说，<code>reinterpret_cast</code>并不具备可移植性，因此使用时需要谨慎。用于类类型转换时，注意其与<code>static_cast</code>的区别，<code>reinterpret_cast</code>只是将基类指针假装成一个派生类指针而不改变其值，而<code>static_cast</code>则会执行地址操作。</p><p>更多关于类型转换可以参考<a href="https://belaycpp.com/2021/10/14/history-of-c-the-genesis-of-casting/">The genesis of casting.</a>.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><a href="https://book.douban.com/subject/25720141/">A Tour of C++</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?redirectedfrom=MSDN&view=msvc-170">Modern C++</a></li><li><a href="http://mindhacks.cn/2012/08/27/modern-cpp-practices/">C++11（及现代C++风格）和快速迭代式开发</a></li><li><a href="https://www.boost.org/doc/libs/1_78_0/libs/libraries.htm">Boost库参考资料</a></li><li><a href="https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list">C++必读书籍系列-从入门到高级</a></li><li><a href="https://coolshell.cn/articles/4119.html">如何学好C++</a></li><li><a href="http://www.parashift.com/c++-faq-lite/index.html">C++ FAQ系列</a></li><li><a href="http://norvig.com/21-days.html">Teach Yourself Programming in Ten Years</a></li><li><a href="https://isocpp.org/wiki/faq">C++ Super FAQ</a></li><li><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">Modern C++ Core Guidelines</a></li><li><a href="https://book.douban.com/subject/25923597/">Effective Modern C++</a></li><li><a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">Univeral reference in C++11</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;断断续续看了Bjarne Stroustrup的’C++之旅(&lt;code&gt;a tour of C++&lt;/code&gt;)’, 作者把很多原本看起来复杂的概念模型都讲的比较清晰, 也有不少好的代码示例, 有种拨云见雾的感觉. 于是想着写一篇文章来总结重新学习C++的一些经验, 主要阐述下现代C++(&lt;code&gt;&amp;gt;=C++11&lt;/code&gt;)中那些容易让人混淆而觉得陌生的技术.&lt;/p&gt;
&lt;p&gt;了解C++历史的人都知道, &lt;code&gt;Bjarne Stroustrup&lt;/code&gt;是在Bell实验室(就是Unix操作系统与C语言诞生的地方)发明了C++, 初衷是在C中加入类(class)的概念, 增强C语言在系统编程上的效率与灵活性, 也正式因为这个原因, C++在1979年最初的名字是&lt;code&gt;带类的C&lt;/code&gt;(c with class), 直到1984年才改名为&lt;code&gt;C++&lt;/code&gt;. 到今天, &lt;code&gt;C++&lt;/code&gt;的发展历经了快40年历史, 但真正一次大的标准修改是在2011年, 这个版本也称为&lt;code&gt;C++11&lt;/code&gt;(&lt;code&gt;C++11&lt;/code&gt;之后的版本也统称为&lt;code&gt;Modern C++&lt;/code&gt;).接下来我们就来一起来回顾下现代C++中那些曾经让人&lt;code&gt;头疼&lt;/code&gt;的技术吧.&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://sniffer.site/categories/C/"/>
    
    
    <category term="C++" scheme="https://sniffer.site/tags/C/"/>
    
    <category term="编程语言" scheme="https://sniffer.site/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
