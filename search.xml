<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IPV6地址的那些事儿]]></title>
    <url>%2F2020%2F10%2F14%2FIPV6%E5%9C%B0%E5%9D%80%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[前阵子在Android下调试一个只有IPv6地址的网络设备时，发现通过ping6来测试网络连通时提示错误： 123ping6 fe80::47af:e871:3c63:a272connect: Invalid argument stackoverflow上有人说这是一个link-local address本地链路地址， 123456use the following syntax on Android:ping6 fe80::405a:e0a5:e054:cbde%wlan0You must add %wlan0 since it is a link-local address, and your android device has multiple interfaces (Wi-Fi and mobile at least), so you need to tell your device the interface/link you want to use with this link-local address. 所以在ping时需要加上端口，或者像这样&lt;亲测，Android设备不支持如下指令&gt;： 12ping6 -I wlan0 fe80::47af:e871:3c63:a272 那么，什么是本地链路地址(link-local address)？ 其跟IPv4中的局域网地址有什么不同的地方了？ 这里就来看下IPv6地址的一些细节。 什么是link-local 地址按照维基百科的解释, link-local地址是一个只有在主机当前网段或者广播域才有效的地址。由于本地链路地址一般都是系统自动配置的，因此也被称为自动私有IP寻址(automatic private IP addressing)或者自动IP(auto IP): 对IPv4来说，本地链路地址范围为: 169.254.0.0/16 IPv6的本地链路地址一般为: `fe80::/10 在弄清楚IPv6link-local地址是如何自动分配之前，先来看下IPv6地址的格式以及分类。 IPv6地址格式相比IPv4地址的32位，IPv6地址扩到了128位，一般有两部分组成： Network Prefix(网络前缀): 占n位，跟IPV4的网络ID类似 Interface ID(网口ID): 占余下的(128 - n)位， 类似于IPV4的主机ID IPv6的地址类型有单播(unicast), 组播(anycast), 多播(multicast)三种，而广播地址(broadcast)的功能则由多播地址替代： unicast address: 单播地址对应唯一的一个网口，发送给单播地址的数据包都只会发送到对应的网口上，根据不同的功能需要，单播地址又可以分为如下几个： 单播地址类型 二进制前缀 IPV6缩写 link-local unicast addresss 1111111010 FE80::/10 unique local unicast address 1111110 FC00::/7 loopback address 00…1(128bits) ::1/128 unspecified address 00..0(128bits) ::/128 Global unicast adress 其他 anycast address: 用于标识一组网口（通常属于不同的网络节点），发送给组播地址的数据会发送到该组网络节点中的一个 multicast address: 与anycast address类似，只是发送到该地址的数据会发送给该组所有的网络节点 有关IPv6地址的具体描述，可以参考RFC4291 link-local address是如何生成的对IPv6来说，link-local地址一般通过NDP(Neighbour Discovery Protocol)协议来实现自动配置：IPv6地址在设置之前，系统会先通过NDP协议发送消息确保要配置的IPv6地址在当前链路上具有唯一性，不与其他节点的IP地址发生冲突。 NDP协议类似与IPv4的ARP(Address Resolution Protocol)，不同的是NDP是基于ICMPv6, 更多关于NDP细节可以参考RFC4862; Linux的实现可以参考源码：/net/ipv6/ndisc.c 参考文献 https://tools.ietf.org/html/rfc7404 https://tools.ietf.org/html/rfc4862 https://en.wikipedia.org/wiki/Link-local_address]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>IPv6</tag>
        <tag>ICMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由Policy Routing引发的一个奇怪问题]]></title>
    <url>%2F2020%2F06%2F03%2F%E7%94%B1Policy-Routing%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近新的项目又开始了, 开始还算顺利, 却不料碰到了一个奇怪的问题. 先来了解下问题的背景. 这个项目里, Android中有两个以太网网口, 一个用于内网通讯, 不具备上外网的能力;一个用于外网通讯, 使用该网口可以访问互联网. 在网络管理模块的工作完成后, 提交了代码我原本以为可以高枕无忧, 前两天组内的同学跑过来告诉我, 他有个系统服务一直没法通过与内网的其他设备上的服务建立TCP链接, 但是网络却一直可以ping通; 而另外的一个开发板上却不存在这个问题. 开始我有点不相信竟然会有这样的问题, 但事实摆在面前, 我也不好抵赖, 于是自己找来一个板子, 看了下, 才逐渐找到答案. 问题的根源在于Android配置的策略路由规则隐含了一个针对系统默认网络的fwmark规则, 要解决问题, 只要我们将包含了内网路由表的路由规则的优先级提升到高于Android隐含的这条规则即可. 虽然找到了解决方案, 但是还是决定花点时间把整个事情的来龙去脉都理清楚. 大致分如下几个部分来讲一讲这个问题: 介绍下什么是Policy Routing&lt;策略路由&gt; 分析具体的问题, 并给出方案 从源代码角度来分析下, 为何TCP无法建立, 但ping却可以 什么是Policy Routing我们都知道, 传统的Linux路由都是基于目标IP地址来进行路由设置, 策略路由不同的是, 在原有路由表的基础上, 添加一系列具有优先级的规则, 这些规则可以根据数据包的入口&lt;本地或者lo&gt;, 出口, TOS&lt;Type Of Service&gt;, fwmark标签值, 协议以及端口号等来进行路由表的选择, 所有这些策略规则都放在一个称为routing policy database的数据库中. 一般, 一条策略路由规则都由selector(选择器)以及action predicate(需要执行的动作)两部分组成; 通过ip rule指令, 我们可以修改/删除系统中的策略路由规则. 例如, 在Ubuntu系统中, 输入ip rule list, 大致是这样的: 12340: from all lookup local 32766: from all lookup main 32767: from all lookup default 这些策略路由规则都是内核初始化时默认生成的, 按照规则的优先级大小排列, 数字越小, 优先级越高: 优先级0: 会匹配任何数据包, 执行的动作是在local路由表查找路由 优先级32766: 匹配任何数据包, 执行的动作是在main路由表中查找路由 优先级32767: 匹配任何数据包, 执行的动作是在default路由表中查找路由 通过man ip rule我们可以查看到更多关于RP规则的信息. 而对于Android来说, 由于需要同时管理多个网络, 并根据网络权限/用户UID等来设置防火墙, 策略路由的规则就复杂了很多, 例如在我的开发板上输入adb shell ip rule list可以看到这么一大串的规则列表: 这里, eth0就是用来作内网通讯用的网口, 而usb0是用来连接外网的网口, 当前系统默认的默认网络&lt;具有默认路由&gt;即usb0. Android的Netd(负责网络管理的native进程, 可以参考早前的文章了解更多信息Android Netd详解)会把每个正常工作的网口都建立一个相应的路由表, 路由表的ID就是对应网络的netID&lt;每个网络在创建后都会分配一个唯一的ID&gt;, 例如通过输入ip route show table usb0查看路由表usb0实际是这样的: 123default via 192.168.225.1 dev usb0 proto static 192.168.225.0/24 dev usb0 proto static scope link 这张路由表包含了两个路由规则: 前一个是默认路由, 用于匹配外网数据(非192.168.225.*IP段的都会匹配该路由)的路由；后一个是用于该网卡局域网内IP地址的路由.上图中我们看到的这个RPDB实际是能正常工作的, 就是说通过eth0可以建立TCP连接, ping网络也正常, 后面在分析问题时会再贴出有问题的RPDB. 网络ping通但无法建立TCP的问题出问题时的路由表eth0只有一个路由规则: 12172.20.1.0/24 dev eth0 proto static scope link 相应的RPDB大致如下, 这里要说明的是21300: from all lookup main这个查找main路由表的规则是需要自己添加的, Android原生代码已经把main表的查找规则剔除了, 对于同时有对个网卡共存的情况, main表是必须的, 否则基于eth0网口的局域网就无法正常ping通. 12345678910111213141516171819200: from all lookup local 10000: from all fwmark 0xc0000/0xd0000 lookup legacy_system 10500: from all iif lo oif dummy0 uidrange 0-0 lookup dummy0 10500: from all iif lo oif eth0 uidrange 0-0 lookup eth0 10500: from all iif lo oif usb0 uidrange 0-0 lookup usb0 13000: from all fwmark 0x10063/0x1ffff iif lo lookup local_network 13000: from all fwmark 0x10064/0x1ffff iif lo lookup eth0 13000: from all fwmark 0x10065/0x1ffff iif lo lookup usb0 14000: from all iif lo oif dummy0 lookup dummy0 14000: from all iif lo oif eth0 lookup eth0 14000: from all iif lo oif usb0 lookup usb0 15000: from all fwmark 0x0/0x10000 lookup legacy_system 16000: from all fwmark 0x0/0x10000 lookup legacy_network 17000: from all fwmark 0x0/0x10000 lookup local_network 19000: from all fwmark 0x64/0x1ffff iif lo lookup eth0 19000: from all fwmark 0x65/0x1ffff iif lo lookup usb0 21300: from all lookup main 22000: from all fwmark 0x0/0xffff iif lo lookup usb0 32000: from all unreachable 基于上述RPDB规则, 尝试测试内网某个设备的连通性: ping 172.20.1.55有看到回应, 但是如果通过ssh指令ssh -vvv root@172.20.1.55尝试登录到对端, 就会提示No Route to Host, 其他上层TCP连接也没法正常建立成功. 细心的同学可能已经发现, 在之前讲到的那个正常RPDB与这里的异常的RPDB唯一的区别就是在与main路由表查找规则的优先级, 一个是21300, 一个18300, 那么为什么优先级的差异会导致不一样的结果? 对于一般的TCP连接, 并不会指定连接的网口(通过setsocktopt的SO_BINDTODEVICE选项指定), 所以可以判定那些指定了oif(数据包出口)的ip rule规则应该不会导致问题的发生, 这里我们可以通过ip rule add pref &lt;pref_no&gt; lookup main调整这个规则的优先级, 通过二分查找测试几次就知道了. 在另外一方面, 测试的同学反馈, 如果没有接usb0这个网络设备, 问题就不会存在. 这样这个问题就更清晰了: 跟usb0路由表相关的几条规则是问题的关键. 排除掉指定了oif相关的规则, 只剩下两条: 12313000: from all fwmark 0x10065/0x1ffff iif lo lookup usb0 19000: from all fwmark 0x65/0x1ffff iif lo lookup usb0 删除掉原有的规则ip rule del pref 21300 lookup main, 然后添加一个优先级高于第一条13000的规则ip rule add pref 12800 lookup main, 试验下发现TCP可以正常建立连接, 问题不存在;再次实验, 先删除main路由表对应的规则, 添加一条ip rule add pref 18300 lookup main的规则, 也可以正常建立TCP连接. 于是, 我们可以断定, 优先级为19000这条规则是罪魁祸首.解决问题的方案就是把原来的main查找的优先级高于19000即可. 12ip rule add pref 18300 lookup main 问题是解决了, 可以为什么会这样了? 这条包含了fwmark的规则为何会让TCP连接没法正常建立而ping又可以了? 还是要read the fucking source code才能找到根本原因了. 看看该死的源代码对于Android来说, 无论是Java的网络请求, 还是native的最终都会通过libc的封装的系统调用来完成. 因此, 第一步就来看看libc中对常用socket API的实现逻辑. 对应的源码位于/bionic/libc. 我们知道, 对于TCP客户端来说, 一般先调用socket创建套接字获取到文件描述符后, 会直接调用connect尝试连接到服务端, 由于创建socket不涉及到路由, 因此就来看看connect的具体调用逻辑. 找到connect.cpp, 代码很简单, 只有一行: 1234int connect(int sockfd, const sockaddr* addr, socklen_t addrlen) &#123; return __netdClientDispatch.connect(sockfd, addr, addrlen);&#125; 该函数直接是调用了__netdClientDispatch对应的实现, 从函数名字来看, 实际应该是把请求转发给Netd, 不妨接续看代码: 123456789101112131415161718192021222324252627282930313233// private/NetdClientDispatch.hstruct NetdClientDispatch &#123; int (*accept4)(int, struct sockaddr*, socklen_t*, int); int (*connect)(int, const struct sockaddr*, socklen_t); int (*socket)(int, int, int); unsigned (*netIdForResolv)(unsigned);&#125;;// NetdClientDispatch.cpp#ifdef __i386__#define __socketcall __attribute__((__cdecl__))#else#define __socketcall#endifextern "C" __socketcall int __accept4(int, sockaddr*, socklen_t*, int);extern "C" __socketcall int __connect(int, const sockaddr*, socklen_t);extern "C" __socketcall int __socket(int, int, int);static unsigned fallBackNetIdForResolv(unsigned netId) &#123; return netId;&#125;// This structure is modified only at startup (when libc.so is loaded) and never// afterwards, so it's okay that it's read later at runtime without a lock.__LIBC_HIDDEN__ NetdClientDispatch __netdClientDispatch __attribute__((aligned(32))) = &#123; __accept4, __connect, __socket, fallBackNetIdForResolv,&#125;; __netdClientDispatch实际是封装了几个外部函数而已, 那么__socket/__connect/__accept4这几个函数又在哪里实现的了? 搜索下libc下面的代码, 发现原来在libc初始化的时候, 会加载一个libnetd_client.so的库, 然后把相应的实现加载过来: 12345678910111213141516171819202122232425262728293031323334// NetdClient.cpptemplate &lt;typename FunctionType&gt;static void netdClientInitFunction(void* handle, const char* symbol, FunctionType* function) &#123; typedef void (*InitFunctionType)(FunctionType*); InitFunctionType initFunction = reinterpret_cast&lt;InitFunctionType&gt;(dlsym(handle, symbol)); if (initFunction != NULL) &#123; initFunction(function); &#125;&#125;static void netdClientInitImpl() &#123; void* netdClientHandle = dlopen("libnetd_client.so", RTLD_NOW); if (netdClientHandle == NULL) &#123; // If the library is not available, it's not an error. We'll just use // default implementations of functions that it would've overridden. return; &#125; netdClientInitFunction(netdClientHandle, "netdClientInitAccept4", &amp;__netdClientDispatch.accept4); netdClientInitFunction(netdClientHandle, "netdClientInitConnect", &amp;__netdClientDispatch.connect); netdClientInitFunction(netdClientHandle, "netdClientInitNetIdForResolv", &amp;__netdClientDispatch.netIdForResolv); netdClientInitFunction(netdClientHandle, "netdClientInitSocket", &amp;__netdClientDispatch.socket);&#125;static pthread_once_t netdClientInitOnce = PTHREAD_ONCE_INIT;extern "C" __LIBC_HIDDEN__ void netdClientInit() &#123; if (pthread_once(&amp;netdClientInitOnce, netdClientInitImpl)) &#123; async_safe_format_log(ANDROID_LOG_ERROR, "netdClient", "Failed to initialize netd_client"); &#125;&#125; 有兴趣的可以看看libc具体的初始化流程. 这里, 我们直接跳到libnetd_client.so这个库去看看netdClientInitConnect的实现. 共享库libnetd_client.so的代码位于/system/netd/client目录, 其中有个文件NetdClient.cpp即实现了该函数: 123456789101112131415161718192021222324252627282930// NetdClient.cppint netdClientConnect(int sockfd, const sockaddr* addr, socklen_t addrlen) &#123; const bool shouldSetFwmark = (sockfd &gt;= 0) &amp;&amp; addr &amp;&amp; FwmarkClient::shouldSetFwmark(addr-&gt;sa_family); if (shouldSetFwmark) &#123; FwmarkCommand command = &#123;FwmarkCommand::ON_CONNECT, 0, 0, 0&#125;; if (int error = FwmarkClient().send(&amp;command, sockfd, nullptr)) &#123; errno = -error; return -1; &#125; &#125; // Latency measurement does not include time of sending commands to Fwmark Stopwatch s; const int ret = libcConnect(sockfd, addr, addrlen); // Save errno so it isn't clobbered by sending ON_CONNECT_COMPLETE const int connectErrno = errno; const unsigned latencyMs = lround(s.timeTaken()); // Send an ON_CONNECT_COMPLETE command that includes sockaddr and connect latency for reporting if (shouldSetFwmark &amp;&amp; FwmarkClient::shouldReportConnectComplete(addr-&gt;sa_family)) &#123; FwmarkConnectInfo connectInfo(ret == 0 ? 0 : connectErrno, latencyMs, addr); // TODO: get the netId from the socket mark once we have continuous benchmark runs FwmarkCommand command = &#123;FwmarkCommand::ON_CONNECT_COMPLETE, /* netId (ignored) */ 0, /* uid (filled in by the server) */ 0, 0&#125;; // Ignore return value since it's only used for logging FwmarkClient().send(&amp;command, sockfd, &amp;connectInfo); &#125; errno = connectErrno; return ret;&#125; 看到这里的Fwmark等字样, 似乎有点眼熟了, 这个函数的逻辑是, 首先要判断一个socket链接是否要打上防火墙标签(Firewall Mark)shouldSetFwmark, 实际上对于TCP的socket来说, 该函数都返回True, 接着会将对应的socketFd通过一个本地fwmarkd这个socket发送给FwmarkServer, 由其负责将socket打上防火墙标签: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081int FwmarkServer::processClient(SocketClient* client, int* socketFd) &#123; FwmarkCommand command; FwmarkConnectInfo connectInfo; iovec iov[2] = &#123; &#123; &amp;command, sizeof(command) &#125;, &#123; &amp;connectInfo, sizeof(connectInfo) &#125;, &#125;; msghdr message; memset(&amp;message, 0, sizeof(message)); message.msg_iov = iov; message.msg_iovlen = ARRAY_SIZE(iov); union &#123; cmsghdr cmh; char cmsg[CMSG_SPACE(sizeof(*socketFd))]; &#125; cmsgu; memset(cmsgu.cmsg, 0, sizeof(cmsgu.cmsg)); message.msg_control = cmsgu.cmsg; message.msg_controllen = sizeof(cmsgu.cmsg); int messageLength = TEMP_FAILURE_RETRY(recvmsg(client-&gt;getSocket(), &amp;message, MSG_CMSG_CLOEXEC)); if (messageLength &lt;= 0) &#123; return -errno; &#125; if (!((command.cmdId != FwmarkCommand::ON_CONNECT_COMPLETE &amp;&amp; messageLength == sizeof(command)) || (command.cmdId == FwmarkCommand::ON_CONNECT_COMPLETE &amp;&amp; messageLength == sizeof(command) + sizeof(connectInfo)))) &#123; return -EBADMSG; &#125; // 检查当前用户是否有网络访问权限 Permission permission = mNetworkController-&gt;getPermissionForUser(client-&gt;getUid()); ... Fwmark fwmark; socklen_t fwmarkLen = sizeof(fwmark.intValue); // 获取当前socket上的fwmark if (getsockopt(*socketFd, SOL_SOCKET, SO_MARK, &amp;fwmark.intValue, &amp;fwmarkLen) == -1) &#123; return -errno; &#125; switch (command.cmdId) &#123; case FwmarkCommand::ON_ACCEPT: &#123; // Called after a socket accept(). The kernel would've marked the NetId and necessary // permissions bits, so we just add the rest of the user's permissions here. permission = static_cast&lt;Permission&gt;(permission | fwmark.permission); break; &#125; case FwmarkCommand::ON_CONNECT: &#123; // Called before a socket connect() happens. Set an appropriate NetId into the fwmark so // that the socket routes consistently over that network. Do this even if the socket // already has a NetId, so that calling connect() multiple times still works. // // But if the explicit bit was set, the existing NetId was explicitly preferred (and not // a case of connect() being called multiple times). Don't reset the NetId in that case. .... // 这里explicitlySelected为false, 因此实际会选择默认网络的netId if (!fwmark.explicitlySelected) &#123; if (!fwmark.protectedFromVpn) &#123; fwmark.netId = mNetworkController-&gt;getNetworkForConnect(client-&gt;getUid()); &#125; else if (!mNetworkController-&gt;isVirtualNetwork(fwmark.netId)) &#123; fwmark.netId = mNetworkController-&gt;getDefaultNetwork(); &#125; &#125; break; &#125; .... fwmark.permission = permission; // 将该socket打上防火墙的标签, 这个实际就是用来给内核选择路由时用的 if (setsockopt(*socketFd, SOL_SOCKET, SO_MARK, &amp;fwmark.intValue, sizeof(fwmark.intValue)) == -1) &#123; return -errno; &#125; return 0;&#125; 到这一步, 我们大概知道, fwmark实际是一个32位的整型数值, 其中网络的netId占了低16位, 网络权限permission占了2位, 这样系统所有的TCP连接都会被打上fwmark. 那么, 内核的RPDB规则又何时被添加过去的了? 我们再来看看Netd的代码. 123456789101112union Fwmark &#123; uint32_t intValue; struct &#123; unsigned netId : 16; bool explicitlySelected : 1; bool protectedFromVpn : 1; Permission permission : 2; bool uidBillingDone : 1; &#125;; constexpr Fwmark() : intValue(0) &#123;&#125;&#125;; Android对网络路由相关的管理与控制逻辑都放在/system/netd/server/RouteController.cpp中, 找到对应开始引起问题的那个RP规则, 其优先级为19000, 这正好是RULE_PRIORITY_IMPLICIT_NETWORK这个值. 119000: from all fwmark 0x65/0x1ffff iif lo lookup usb0 搜索这个关键字, 可以看到Netd会在创建无需任何权限的PhysicalNetwork对象时, 会根据网络的netId时生成一条隐性的策略路由规则modifyImplicitNetworkRule: 12345678910111213141516171819202122232425262728WARN_UNUSED_RESULT int RouteController::modifyPhysicalNetwork(unsigned netId, const char* interface, Permission permission, bool add) &#123; //if network id has register interface, other interface route add to the table with interface registered by netid .... if (int ret = modifyIncomingPacketMark(netId, interface, permission, add)) &#123; return ret; &#125; if (int ret = modifyExplicitNetworkRule(netId, table, permission, INVALID_UID, INVALID_UID, add)) &#123; return ret; &#125; if (int ret = modifyOutputInterfaceRules(interface, table, permission, INVALID_UID, INVALID_UID, add)) &#123; return ret; &#125; // Only set implicit rules for networks that don't require permissions. // // This is so that if the default network ceases to be the default network and then switches // from requiring no permissions to requiring permissions, we ensure that apps only use the // network if they explicitly select it. This is consistent with destroySocketsLackingPermission ... if (permission == PERMISSION_NONE) &#123; return modifyImplicitNetworkRule(netId, table, add); &#125; return 0;&#125; 这个函数会设置一个值为默认网络netId的fwmark, 也就是我们最开始看到的那条优先级为19000的规则, 并通过类型为NETLINK_ROUTE的netlink向内核配置该规则, 内核就会根据这条规则来匹配上对应的TCP包, 因而就会出现我们最开始的那个问题:使用TCP连接会提示No Route to Host, 那为何ping不存在这个问题了? 123456789101112131415161718WARN_UNUSED_RESULT int modifyImplicitNetworkRule(unsigned netId, uint32_t table, bool add) &#123; Fwmark fwmark; Fwmark mask; fwmark.netId = netId; mask.netId = FWMARK_NET_ID_MASK; fwmark.explicitlySelected = false; mask.explicitlySelected = true; fwmark.permission = PERMISSION_NONE; mask.permission = PERMISSION_NONE; return modifyIpRule(add ? RTM_NEWRULE : RTM_DELRULE, RULE_PRIORITY_IMPLICIT_NETWORK, table, fwmark.intValue, mask.intValue, IIF_LOOPBACK, OIF_NONE, INVALID_UID, INVALID_UID);&#125; 我们都知道ping一般是基于IPPROTO_ICMP协议, 实际发送ping的ECHO_REQUEST时, 只需要创建一个socket接口, 然后直接通过sendto发送对应的数据报文就好了;从刚开始的代码知道, libc会把socket相关的请求转发给Netd, 我们直接看Netd中NetdClient.cpp的建立socket相关的代码: 12345678910111213141516std::atomic_uint netIdForProcess(NETID_UNSET);int netdClientSocket(int domain, int type, int protocol) &#123; int socketFd = libcSocket(domain, type, protocol); if (socketFd == -1) &#123; return -1; &#125; unsigned netId = netIdForProcess; if (netId != NETID_UNSET &amp;&amp; FwmarkClient::shouldSetFwmark(domain)) &#123; if (int error = setNetworkForSocket(netId, socketFd)) &#123; return closeFdAndSetErrno(socketFd, error); &#125; &#125; return socketFd;&#125; 这个函数首先会调用libc创建socket, ping的时候并没有调用setNetworkForProcess指定网络netId, 因此实际路由时会跳过19000这条规则, 使用的是后面21300这个main路由规则来进行路由选择. 至此问题的谜团也算揭开了. 参考资料 http://linux-ip.net/html/routing-tables.html#list-routing-route-types https://www.man7.org/linux/man-pages/man8/ip-rule.8.html https://www.drdobbs.com/policy-routing-in-linux/199100936]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>网络管理</tag>
        <tag>Policy Routing</tag>
        <tag>策略路由</tag>
        <tag>Netd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件开发与BUG的那些事儿]]></title>
    <url>%2F2020%2F05%2F27%2F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%8EBUG%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[Excellence in any department can be attained only by the labor of a lifetime;it is not to be purchased at a lesser price Paul Graham 前段时间, 看新闻说“微软4万多的软件开发工程师, 每天产生进3万个BUG”, 当时感觉有点震惊, 然后就哑然失笑. 震惊的是连微软这样厉害的公司, 工程师应该都很优秀, 人才济济, 为何却会每天产生这么多的BUG了? 于是,再想想自己的开发经历, 才恍然明白: 开发人员一旦走进办公室,打开电脑写代码, 就不可避免的要写出BUG来. 与BUG纠缠不清似乎是每个开发人员的宿命.恰逢最近遇到了一个BUG, 让我纠结不已, 痛定思痛, 觉得有必要把自己的开发”心得经验”写下来, 权当是给自己一点警醒, 给自己一点回顾的资料, 分享下自己在开发过程中遇到的困难与挫折, 苦恼与迷惑. 对业务理解的越深, 你对可能发生的问题就越透彻；认真思考每个需求/每行代码背后蕴含的业务逻辑, 这对于实现更优秀的方案具有重要的作用. 要对你所负责的业务领域的知识有广泛的把握, 这样也能够帮助你快速深入的进入一个全新的领域. 对于要提交的每个PR(Pull Request), 在提交前自己先过一遍, 检查格式, 检查拼写, 检查PR的描述是否清晰简单明确, 检查功能实现是否与需求一致, 同时还要问问自己这个修改是否有可以优化改进的地方, 是否存在更好的解决策略? 是否有疏漏的地方? 只有完整的走了必须的checklist, 才真正加上代码reviewer. 在每次实现方案, 提交代码时, 首先要摒弃的是”这个实现很完美, 我敢打包票, 毫无疑问没有问题了”类似这种自信爆棚的观念, 首先要正视可能存在的缺陷, 正视自己当前对于问题的认知可能还有不完善的地方, 把可能存在漏洞的地方在代码实现处comment出来, 这样后面再来看代码时可能会有更好的思路. 现代软件项目开发的核心在于高质量且如期交付产品, 而要确保高质量与项目日程预期的达成, 核心在于管控软件开发中的风险点. 因此, 对于大部分公司开发软件来说, 都要有质量/测试/开发多个部门的通力合作才能达成这一目标.对与软件开发工程师而言, 在确保自己提交代码的质量, 减少BUG的数量的同时, 还要关注项目日程安排, 确保修改正常合入到正确的分支, 确保给到用户都是稳定可靠/BUG更少的版本.时刻铭记交付质量对于一个优秀工程师来说至关重要. 产生的任何BUG都要保持警惕, 而不是防御心态: 总觉得这个BUG不是我的责任, 不会是我代码实现产生的问题, 当别人指出来你的错误时, 不是保持开放的思考, 而是一味的浪费时间与人纠缠争吵, 不敢承认自己思维上存在的问题; 一旦确认了BUG, 就要坦然面对, 而不是藏着掩着;诚实的面对自己犯下的错误, 总结经验教训, 这不仅能让你赢得同事的认可与信任, 也能让领导对你放心. 不时的想一想你的客户是谁? 你的客户不仅是产品的使用者, 也是你的上司, 你的同事, 你要确保你的每个产出物都具备高质量, 能让使用者感到舒服, 感到可信赖.要对自己所做的每件事情都负责, 对上司交代的任务要反馈; 对同事的问题要多关心;对产品的质量要严格的把控. 不满足于已有的知识, 不停的学习新的技能, 反复总结打磨自己的知识系统, 长此以往, 你的能力与视野就会得到质的改变；学习的同时, 也要不断的总结, 将所学所思分享给身边的同事, 保持影响力 软件从业人员经常被工作进度压得传不过气来, 时间紧张, 以至于忽略了锻炼身体. 想要平时尽量产生BUG, 保持良好的生活习惯, 必不可少. 这么看起来, 写好代码, 少产生BUG, 不仅仅是一个逻辑问题, 更是一个程序员自我修养与提高的问题 养成良好的工作习惯: 不时的总结些提升工作效率的方法, 比如修改分支代码时, 先同步远端代码git pull --rebase; 修改好的代码要及时保存; 重要的数据要做好备份; 及时的梳理知识结构, 有时间最好将心得总结写下来 遵从项目流程，即便是日程紧急，也要遵守项目规范，确保发出的版本是可靠稳定的;定期发布版本，每个版本都要有对应的release分支(_笑，最近我们有个项目自始至终都只有一个dev分支，项目后期风险不断，时不时的掉坑里）]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件开发</tag>
        <tag>BUG</tag>
        <tag>软件工程</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从NAPI说一说Linux内核数据的接收流程]]></title>
    <url>%2F2020%2F05%2F12%2F%E4%BB%8ENAPI%E8%AF%B4%E4%B8%80%E8%AF%B4Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[NAPI(New API)是Linux内核针对网络数据传输做出的一个优化措施，其目的是在大量数据传输时， 在收到硬件中断后，通过poll方式将传输过来的数据包统一处理， 通过禁止网络设备中断以减少硬件中断数量((Interrupt Mitigation)，从而实现更高的数据传输。 基于NAPI接口， 一般的网络传输都有如下几个步骤： 网络设备驱动加载与初始化（配置IP等） 数据包从网络侧发送到网卡(Network Interface Controller, NIC) 通过DMA(Direct Memory Access)，将数据从网卡拷贝到内存的环形缓冲区(ring buffer) NIC产生硬件中断告知内核有新的数据包达到了 网卡驱动收到中断后调用NAPI接口开启poll线程（如果当前没有正在执行的线程）(常规数据传输直接处理NIC的中断时中间一般通过调用netif_rx来发起数据接收） ksoftirqd（内核启动时每个CPU上都会启动这样一个线程）线程负责调用NAPI的poll接口来获取内存环形缓冲区的数据包 通过DMA传输到内存中的数据包，最终通过sk_buff的形式传递给上层网络协议栈（TCP/IP层) 如果支持数据包转发(packet steering)或者NIC本身支持多个接收队列的话, 从网卡过来的数据会在不同的CPU之间进行分发 网络协议栈处理数据包，并将其发送到对应的socket接收缓冲区 下面就结合具体的代码来看看数据是如何一步步接收的（以intel的千兆以太网卡为例kernel/drivers/net/intel/e1000）。 驱动加载与设备初始化看e1000_main.c代码，驱动的初始化首先要做的是注册一个pci设备驱动到内核，这样设备枚举的时候会匹配到该网卡 1234567891011121314151617181920212223242526272829static int __init e1000_init_module(void)&#123; int ret; pr_info("%s - version %s\n", e1000_driver_string, e1000_driver_version); pr_info("%s\n", e1000_copyright); ret = pci_register_driver(&amp;e1000_driver); ... return ret;&#125;module_init(e1000_init_module);static struct pci_driver e1000_driver = &#123; .name = e1000_driver_name, .id_table = e1000_pci_tbl, .probe = e1000_probe, .remove = e1000_remove,#ifdef CONFIG_PM /* Power Management Hooks */ .suspend = e1000_suspend, .resume = e1000_resume,#endif .shutdown = e1000_shutdown, .err_handler = &amp;e1000_err_handler&#125;; 匹配到网卡后， pci总线会调用驱动的probe函数， 大致会做如下几个事情： 调用alloc_etherdev 分配一个网络设备对象，并注册到系统中 通过netif_napi_add添加NAPI的poll接口 设置网卡寄存器IO映射内存区域 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119static int e1000_probe(struct pci_dev *pdev, const struct pci_device_id *ent)&#123; .... err = pci_request_selected_regions(pdev, bars, e1000_driver_name); if (err) goto err_pci_reg; pci_set_master(pdev); err = pci_save_state(pdev); if (err) goto err_alloc_etherdev; err = -ENOMEM; // 分配以太网网络对象 netdev = alloc_etherdev(sizeof(struct e1000_adapter)); if (!netdev) goto err_alloc_etherdev; SET_NETDEV_DEV(netdev, &amp;pdev-&gt;dev); pci_set_drvdata(pdev, netdev); adapter = netdev_priv(netdev); adapter-&gt;netdev = netdev; adapter-&gt;pdev = pdev; adapter-&gt;msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE); adapter-&gt;bars = bars; adapter-&gt;need_ioport = need_ioport; hw = &amp;adapter-&gt;hw; hw-&gt;back = adapter; err = -EIO; // 映射寄存器IO区域 hw-&gt;hw_addr = pci_ioremap_bar(pdev, BAR_0); if (!hw-&gt;hw_addr) goto err_ioremap; if (adapter-&gt;need_ioport) &#123; for (i = BAR_1; i &lt;= BAR_5; i++) &#123; if (pci_resource_len(pdev, i) == 0) continue; if (pci_resource_flags(pdev, i) &amp; IORESOURCE_IO) &#123; hw-&gt;io_base = pci_resource_start(pdev, i); break; &#125; &#125; &#125; /* make ready for any if (hw-&gt;...) below */ err = e1000_init_hw_struct(adapter, hw); if (err) goto err_sw_init; ... // 设置网络设备对象的操作接口 netdev-&gt;netdev_ops = &amp;e1000_netdev_ops; e1000_set_ethtool_ops(netdev); netdev-&gt;watchdog_timeo = 5 * HZ; // 添加napi的poll接口 netif_napi_add(netdev, &amp;adapter-&gt;napi, e1000_clean, 64); strncpy(netdev-&gt;name, pci_name(pdev), sizeof(netdev-&gt;name) - 1); adapter-&gt;bd_number = cards_found; /* setup the private structure */ err = e1000_sw_init(adapter); if (err) goto err_sw_init; ... if (!is_valid_ether_addr(netdev-&gt;dev_addr)) e_err(probe, "Invalid MAC Address\n"); INIT_DELAYED_WORK(&amp;adapter-&gt;watchdog_task, e1000_watchdog); INIT_DELAYED_WORK(&amp;adapter-&gt;fifo_stall_task, e1000_82547_tx_fifo_stall_task); INIT_DELAYED_WORK(&amp;adapter-&gt;phy_info_task, e1000_update_phy_info_task); INIT_WORK(&amp;adapter-&gt;reset_task, e1000_reset_task); ... /* initialize the wol settings based on the eeprom settings */ adapter-&gt;wol = adapter-&gt;eeprom_wol; device_set_wakeup_enable(&amp;adapter-&gt;pdev-&gt;dev, adapter-&gt;wol); /* Auto detect PHY address */ if (hw-&gt;mac_type == e1000_ce4100) &#123; for (i = 0; i &lt; 32; i++) &#123; hw-&gt;phy_addr = i; e1000_read_phy_reg(hw, PHY_ID2, &amp;tmp); if (tmp == 0 || tmp == 0xFF) &#123; if (i == 31) goto err_eeprom; continue; &#125; else break; &#125; &#125; /* reset the hardware with the new settings */ e1000_reset(adapter); // 设置网卡名字，注册网络设备对象 strcpy(netdev-&gt;name, "eth%d"); err = register_netdev(netdev); if (err) goto err_register; ... /* carrier off reporting is important to ethtool even BEFORE open */ netif_carrier_off(netdev); e_info(probe, "Intel(R) PRO/1000 Network Connection\n"); cards_found++; return 0; ...&#125; 到这一步网卡还不是可用状态，需要通过手动ifconfig eth0 up/ifconfig eth0 &lt;ip&gt;， 设置网卡为UP时，会调用驱动的ndo_open函数： 请求硬件中断，并使能该中断 napi_enable开启napi 启动网络的发送队列，允许发送数据 1234567891011121314151617181920212223242526272829303132333435363738static int e1000_open(struct net_device *netdev)&#123; struct e1000_adapter *adapter = netdev_priv(netdev); struct e1000_hw *hw = &amp;adapter-&gt;hw; int err; netif_carrier_off(netdev); /* allocate transmit descriptors */ err = e1000_setup_all_tx_resources(adapter); /* allocate receive descriptors */ err = e1000_setup_all_rx_resources(adapter); e1000_power_up_phy(adapter); ... err = e1000_request_irq(adapter); /* From here on the code is the same as e1000_up() */ clear_bit(__E1000_DOWN, &amp;adapter-&gt;flags); napi_enable(&amp;adapter-&gt;napi); e1000_irq_enable(adapter); netif_start_queue(netdev); /* fire a link status change interrupt to start the watchdog */ ew32(ICS, E1000_ICS_LSC); return E1000_SUCCESS; ... return err;&#125; 到此时网卡正常工作， 再来看看数据接收的具体流程。 网卡数据接收网卡数据的接收大概有三个步骤： 网卡发送中断给驱动 驱动处理函数处理中断，并启动一个napi处理任务 发送接收数据的软中断NET_RX_SOFTIRQ 内核线程处理网络软中断，将数据包发送给上层协议栈 处理网卡中断在网卡驱动初始化的过程，我们看到驱动会向内核请求中断, 并注册一个中断处理函数： 12345678910111213static int e1000_request_irq(struct e1000_adapter *adapter)&#123; struct net_device *netdev = adapter-&gt;netdev; irq_handler_t handler = e1000_intr; int irq_flags = IRQF_SHARED; err = request_irq(adapter-&gt;pdev-&gt;irq, handler, irq_flags, netdev-&gt;name, netdev); ... return err;&#125; 当网卡产生数据中断后，调用中断处理函数： 对于napi来说，首先要禁止当前网卡的中断，如果当前没有在运行的napi任务，则调度一个新的napi任务__napi_schedule： 1234567891011121314151617181920212223242526static irqreturn_t e1000_intr(int irq, void *data)&#123; ... /* disable interrupts, without the synchronize_irq bit */ ew32(IMC, ~0); E1000_WRITE_FLUSH(); if (likely(napi_schedule_prep(&amp;adapter-&gt;napi))) &#123; adapter-&gt;total_tx_bytes = 0; adapter-&gt;total_tx_packets = 0; adapter-&gt;total_rx_bytes = 0; adapter-&gt;total_rx_packets = 0; __napi_schedule(&amp;adapter-&gt;napi); &#125; else &#123; /* this really should not happen! if it does it is basically a * bug, but not a hard error, so enable ints and continue */ if (!test_bit(__E1000_DOWN, &amp;adapter-&gt;flags)) e1000_irq_enable(adapter); &#125; return IRQ_HANDLED;&#125; 启动napi任务，发送软中断__napi_schedule在/kernel/net/core/dev.c中，其实际做了两件事： 将napi_struct添加到中断处理CPU的softnet_data对应的poll列表中 发出一个NET_RX_SOFTIRQ的软中断，让内核线程ksoftirqd来处理对应的该softirq软中断 1234567891011121314151617void __napi_schedule(struct napi_struct *n)&#123; unsigned long flags; local_irq_save(flags); ____napi_schedule(this_cpu_ptr(&amp;softnet_data), n); local_irq_restore(flags);&#125;static inline void ____napi_schedule(struct softnet_data *sd, struct napi_struct *napi)&#123; list_add_tail(&amp;napi-&gt;poll_list, &amp;sd-&gt;poll_list); __raise_softirq_irqoff(NET_RX_SOFTIRQ);&#125; __raise_softirq_irqoff函数在/kernel/softirq.c中定义，其实际做的事情就是将当前CPU对应的softirq状态标记为待运行状态： 123456void __raise_softirq_irqoff(unsigned int nr)&#123; trace_softirq_raise(nr); or_softirq_pending(1UL &lt;&lt; nr);&#125; 处理网络软中断内核在初始化的时候，每个CPU上都会启动一个专门的ksoftirqd%d（%d对应CPU的ID）内核线程用于处理CPU上的软中断（代码同样在softirq.c)中： 1234567891011121314151617static struct smp_hotplug_thread softirq_threads = &#123; .store = &amp;ksoftirqd, .thread_should_run = ksoftirqd_should_run, .thread_fn = run_ksoftirqd, .thread_comm = "ksoftirqd/%u",&#125;;static __init int spawn_ksoftirqd(void)&#123; register_cpu_notifier(&amp;cpu_nfb); BUG_ON(smpboot_register_percpu_thread(&amp;softirq_threads)); return 0;&#125;early_initcall(spawn_ksoftirqd); 每个内核线程ksoftirqd实际一直执行的是run_ksoftirqd函数： 12345678910111213141516static void run_ksoftirqd(unsigned int cpu)&#123; local_irq_disable(); if (local_softirq_pending()) &#123; /* * We can safely run softirq on inline stack, as we are not deep * in the task stack here. */ __do_softirq(); local_irq_enable(); cond_resched_rcu_qs(); return; &#125; local_irq_enable();&#125; 函数__do_softirq检查当前CPU所有待处理的软中断，并调用对应的处理函数softirq_action： 12345678910111213141516171819asmlinkage __visible void __softirq_entry __do_softirq(void)&#123; ... while ((softirq_bit = ffs(pending))) &#123; unsigned int vec_nr; int prev_count; h += softirq_bit - 1; vec_nr = h - softirq_vec; ... h-&gt;action(h); ... h++; pending &gt;&gt;= softirq_bit; &#125; ...&#125; 而softirq_action实际是在网络模块初始化的时候注册的(查看/kernel/net/dev.c)中的函数net_dev_init，通过调用open_softirq告知内核启动网络数据传输的两个软中断： 12345678910111213141516171819202122232425262728293031323334353637static int __init net_dev_init(void)&#123; ... if (register_pernet_subsys(&amp;netdev_net_ops)) goto out; /* * Initialise the packet receive queues. */ for_each_possible_cpu(i) &#123; struct softnet_data *sd = &amp;per_cpu(softnet_data, i); skb_queue_head_init(&amp;sd-&gt;input_pkt_queue); skb_queue_head_init(&amp;sd-&gt;process_queue); INIT_LIST_HEAD(&amp;sd-&gt;poll_list); sd-&gt;output_queue_tailp = &amp;sd-&gt;output_queue;#ifdef CONFIG_RPS sd-&gt;csd.func = rps_trigger_softirq; sd-&gt;csd.info = sd; sd-&gt;cpu = i;#endif sd-&gt;backlog.poll = process_backlog; sd-&gt;backlog.weight = weight_p; &#125; ... open_softirq(NET_TX_SOFTIRQ, net_tx_action); open_softirq(NET_RX_SOFTIRQ, net_rx_action); hotcpu_notifier(dev_cpu_callback, 0); dst_subsys_init(); rc = 0;&#125; 也就说h-&gt;action 调用的实际是net_rx_action函数： 不断的调用napi_poll获取CPU上的数据包，直到到达单个CPU处理的上限或者所有需要poll的列表完成处理。 12345678910111213141516171819202122232425262728293031323334353637static void net_rx_action(struct softirq_action *h)&#123; ... for (;;) &#123; struct napi_struct *n; if (list_empty(&amp;list)) &#123; if (!sd_has_rps_ipi_waiting(sd) &amp;&amp; list_empty(&amp;repoll)) return; break; &#125; n = list_first_entry(&amp;list, struct napi_struct, poll_list); budget -= napi_poll(n, &amp;repoll); /* If softirq window is exhausted then punt. * Allow this to run for 2 jiffies since which will allow * an average latency of 1.5/HZ. */ if (unlikely(budget &lt;= 0 || time_after_eq(jiffies, time_limit))) &#123; sd-&gt;time_squeeze++; break; &#125; &#125; local_irq_disable(); list_splice_tail_init(&amp;sd-&gt;poll_list, &amp;list); list_splice_tail(&amp;repoll, &amp;list); list_splice(&amp;list, &amp;sd-&gt;poll_list); if (!list_empty(&amp;sd-&gt;poll_list)) __raise_softirq_irqoff(NET_RX_SOFTIRQ); net_rps_action_and_irq_enable(sd);&#125; 而napi_poll则调用最初网卡驱动注册的poll函数e1000_clean： 12345678910111213141516171819202122232425262728293031static int napi_poll(struct napi_struct *n, struct list_head *repoll)&#123; void *have; int work, weight; list_del_init(&amp;n-&gt;poll_list); have = netpoll_poll_lock(n); weight = n-&gt;weight; /* This NAPI_STATE_SCHED test is for avoiding a race * with netpoll's poll_napi(). Only the entity which * obtains the lock and sees NAPI_STATE_SCHED set will * actually make the -&gt;poll() call. Therefore we avoid * accidentally calling -&gt;poll() when NAPI is not scheduled. */ work = 0; if (test_bit(NAPI_STATE_SCHED, &amp;n-&gt;state)) &#123; struct softnet_data *sd = this_cpu_ptr(&amp;softnet_data); sd-&gt;current_napi = n; work = n-&gt;poll(n, weight); trace_napi_poll(n); &#125; ... return work;&#125; 函数e1000_clean会将当前CPU中接收到的数据包放到skb_buff列表当中，并将数据发送给上层协议栈。 12345678910111213141516171819202122232425static int e1000_clean(struct napi_struct *napi, int budget)&#123; struct e1000_adapter *adapter = container_of(napi, struct e1000_adapter, napi); int tx_clean_complete = 0, work_done = 0; tx_clean_complete = e1000_clean_tx_irq(adapter, &amp;adapter-&gt;tx_ring[0]); adapter-&gt;clean_rx(adapter, &amp;adapter-&gt;rx_ring[0], &amp;work_done, budget); if (!tx_clean_complete) work_done = budget; /* If budget not fully consumed, exit the polling mode */ if (work_done &lt; budget) &#123; if (likely(adapter-&gt;itr_setting &amp; 3)) e1000_set_itr(adapter); napi_complete_done(napi, work_done); if (!test_bit(__E1000_DOWN, &amp;adapter-&gt;flags)) e1000_irq_enable(adapter); &#125; return work_done;&#125; 将skb_buff 发送给协议栈e1000_clean_rx_irq不断的从网卡对应的内存环形缓冲区中获取网络数据包，并将数据包以sk_buff的形式传给协议栈进行处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128static bool e1000_clean_rx_irq(struct e1000_adapter *adapter, struct e1000_rx_ring *rx_ring, int *work_done, int work_to_do)&#123; struct net_device *netdev = adapter-&gt;netdev; struct pci_dev *pdev = adapter-&gt;pdev; struct e1000_rx_desc *rx_desc, *next_rxd; struct e1000_rx_buffer *buffer_info, *next_buffer; u32 length; unsigned int i; int cleaned_count = 0; bool cleaned = false; unsigned int total_rx_bytes=0, total_rx_packets=0; i = rx_ring-&gt;next_to_clean; rx_desc = E1000_RX_DESC(*rx_ring, i); buffer_info = &amp;rx_ring-&gt;buffer_info[i]; while (rx_desc-&gt;status &amp; E1000_RXD_STAT_DD) &#123; struct sk_buff *skb; u8 *data; u8 status; if (*work_done &gt;= work_to_do) break; (*work_done)++; dma_rmb(); /* read descriptor and rx_buffer_info after status DD */ status = rx_desc-&gt;status; length = le16_to_cpu(rx_desc-&gt;length); data = buffer_info-&gt;rxbuf.data; prefetch(data); skb = e1000_copybreak(adapter, buffer_info, length, data); if (!skb) &#123; unsigned int frag_len = e1000_frag_len(adapter); skb = build_skb(data - E1000_HEADROOM, frag_len); if (!skb) &#123; adapter-&gt;alloc_rx_buff_failed++; break; &#125; skb_reserve(skb, E1000_HEADROOM); dma_unmap_single(&amp;pdev-&gt;dev, buffer_info-&gt;dma, adapter-&gt;rx_buffer_len, DMA_FROM_DEVICE); buffer_info-&gt;dma = 0; buffer_info-&gt;rxbuf.data = NULL; &#125; if (++i == rx_ring-&gt;count) i = 0; next_rxd = E1000_RX_DESC(*rx_ring, i); prefetch(next_rxd); next_buffer = &amp;rx_ring-&gt;buffer_info[i]; cleaned = true; cleaned_count++; /* !EOP means multiple descriptors were used to store a single * packet, if thats the case we need to toss it. In fact, we * to toss every packet with the EOP bit clear and the next * frame that _does_ have the EOP bit set, as it is by * definition only a frame fragment */ if (unlikely(!(status &amp; E1000_RXD_STAT_EOP))) adapter-&gt;discarding = true; if (adapter-&gt;discarding) &#123; /* All receives must fit into a single buffer */ netdev_dbg(netdev, "Receive packet consumed multiple buffers\n"); dev_kfree_skb(skb); if (status &amp; E1000_RXD_STAT_EOP) adapter-&gt;discarding = false; goto next_desc; &#125; ....process_skb: total_rx_bytes += (length - 4); /* don't count FCS */ total_rx_packets++; if (likely(!(netdev-&gt;features &amp; NETIF_F_RXFCS))) /* adjust length to remove Ethernet CRC, this must be * done after the TBI_ACCEPT workaround above */ length -= 4; if (buffer_info-&gt;rxbuf.data == NULL) skb_put(skb, length); else /* copybreak skb */ skb_trim(skb, length); /* Receive Checksum Offload */ e1000_rx_checksum(adapter, (u32)(status) | ((u32)(rx_desc-&gt;errors) &lt;&lt; 24), le16_to_cpu(rx_desc-&gt;csum), skb); e1000_receive_skb(adapter, status, rx_desc-&gt;special, skb);next_desc: rx_desc-&gt;status = 0; /* return some buffers to hardware, one at a time is too slow */ if (unlikely(cleaned_count &gt;= E1000_RX_BUFFER_WRITE)) &#123; adapter-&gt;alloc_rx_buf(adapter, rx_ring, cleaned_count); cleaned_count = 0; &#125; /* use prefetched values */ rx_desc = next_rxd; buffer_info = next_buffer; &#125; rx_ring-&gt;next_to_clean = i; cleaned_count = E1000_DESC_UNUSED(rx_ring); if (cleaned_count) adapter-&gt;alloc_rx_buf(adapter, rx_ring, cleaned_count); adapter-&gt;total_rx_packets += total_rx_packets; adapter-&gt;total_rx_bytes += total_rx_bytes; netdev-&gt;stats.rx_bytes += total_rx_bytes; netdev-&gt;stats.rx_packets += total_rx_packets; return cleaned;&#125; e1000_receive_skb实际调用napi_gro_receive将数据发送出去： 12345678910111213static void e1000_receive_skb(struct e1000_adapter *adapter, u8 status, __le16 vlan, struct sk_buff *skb)&#123; skb-&gt;protocol = eth_type_trans(skb, adapter-&gt;netdev); if (status &amp; E1000_RXD_STAT_VP) &#123; u16 vid = le16_to_cpu(vlan) &amp; E1000_RXD_SPC_VLAN_MASK; __vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid); &#125; napi_gro_receive(&amp;adapter-&gt;napi, skb);&#125; 函数napi_gro_receive首先会尝试通过GRO（Generic Receive Offload)的方式将数据发送出去，如果网卡本身不支持GRO则会直接将数据报传送给上层协议栈（简单来说GRO就是将数据包累积到一定数量后再传给上层，这样一次性的处理多个数据包从而提升效率，可以参考https://lwn.net/Articles/358910/)： 1234567891011// kernel/net/dev.cgro_result_t napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb)&#123; trace_napi_gro_receive_entry(skb); skb_gro_reset_offset(skb); return napi_skb_finish(dev_gro_receive(napi, skb), skb);&#125;EXPORT_SYMBOL(napi_gro_receive); Intel这个网卡没有开启GRO，所以实际dev_gro_receive直接返回了GRO_NORMAL，这样就通过netif_receive_skb_internal处理数据包： 123456789101112131415161718192021222324252627static gro_result_t napi_skb_finish(gro_result_t ret, struct sk_buff *skb)&#123; switch (ret) &#123; case GRO_NORMAL: if (netif_receive_skb_internal(skb)) ret = GRO_DROP; break; case GRO_DROP: kfree_skb(skb); break; case GRO_MERGED_FREE: if (NAPI_GRO_CB(skb)-&gt;free == NAPI_GRO_FREE_STOLEN_HEAD) napi_skb_free_stolen_head(skb); else __kfree_skb(skb); break; case GRO_HELD: case GRO_MERGED: break; &#125; return ret;&#125; 对于多核系统来说，一般数据传输处理的CPU跟中断处理的CPU是一致的，后来随着网卡速度的提升，如果把网卡的数据都放到一个CPU处理的话，会导致CPU负载过大进而导致数据传输的延迟，因此有人提出了RPS(Receive packet steering, 就是将数据包的处理任务均衡的分配到各个CPU；要支持该特性，需要打开配置CONFIG_RPS， 同时在内核的配置中/sys/class/net/ethx/queues/rx-0/rps_cpus中将需要处理数据包的CPU设置为1， 这样在处理数据的时候就会将数据包先放到各个CPU的数据队列中进行处理。 这里假定该网卡没有配置RPS，接着会调用__netif_receive_skb处理网络数据。 12345678910111213141516171819202122232425262728static int netif_receive_skb_internal(struct sk_buff *skb)&#123; int ret; net_timestamp_check(netdev_tstamp_prequeue, skb); if (skb_defer_rx_timestamp(skb)) return NET_RX_SUCCESS; rcu_read_lock();#ifdef CONFIG_RPS if (static_key_false(&amp;rps_needed)) &#123; struct rps_dev_flow voidflow, *rflow = &amp;voidflow; int cpu = get_rps_cpu(skb-&gt;dev, skb, &amp;rflow); if (cpu &gt;= 0) &#123; ret = enqueue_to_backlog(skb, cpu, &amp;rflow-&gt;last_qtail); rcu_read_unlock(); return ret; &#125; &#125;#endif ret = __netif_receive_skb(skb); rcu_read_unlock(); return ret;&#125; __netif_receive_skb实际调用__netif_receive_skb_core处理数据：__netif_receive_skb_core调用内核初始化时注册的协议类型，并调用其回调函数，由相应的协议来处理该数据包 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788static int __netif_receive_skb(struct sk_buff *skb)&#123; int ret; if (sk_memalloc_socks() &amp;&amp; skb_pfmemalloc(skb)) &#123; unsigned long pflags = current-&gt;flags; /* * PFMEMALLOC skbs are special, they should * - be delivered to SOCK_MEMALLOC sockets only * - stay away from userspace * - have bounded memory usage * * Use PF_MEMALLOC as this saves us from propagating the allocation * context down to all allocation sites. */ current-&gt;flags |= PF_MEMALLOC; ret = __netif_receive_skb_core(skb, true); tsk_restore_flags(current, pflags, PF_MEMALLOC); &#125; else ret = __netif_receive_skb_core(skb, false); return ret;&#125;static int __netif_receive_skb_core(struct sk_buff *skb, bool pfmemalloc)&#123; struct packet_type *ptype, *pt_prev; rx_handler_func_t *rx_handler; struct net_device *orig_dev; bool deliver_exact = false; int ret = NET_RX_DROP; __be16 type; net_timestamp_check(!netdev_tstamp_prequeue, skb); trace_netif_receive_skb(skb); orig_dev = skb-&gt;dev; skb_reset_network_header(skb); if (!skb_transport_header_was_set(skb)) skb_reset_transport_header(skb); skb_reset_mac_len(skb); pt_prev = NULL;another_round: skb-&gt;skb_iif = skb-&gt;dev-&gt;ifindex; __this_cpu_inc(softnet_data.processed); if (skb-&gt;protocol == cpu_to_be16(ETH_P_8021Q) || skb-&gt;protocol == cpu_to_be16(ETH_P_8021AD)) &#123; skb = skb_vlan_untag(skb); if (unlikely(!skb)) goto out; &#125; ... // 遍历已注册的协议，并调用其回调函数(一般是libpcap通过`AF_PACKET`传入的) list_for_each_entry_rcu(ptype, &amp;ptype_all, list) &#123; if (pt_prev) ret = deliver_skb(skb, pt_prev, orig_dev); pt_prev = ptype; &#125; // 协议栈 list_for_each_entry_rcu(ptype, &amp;skb-&gt;dev-&gt;ptype_all, list) &#123; if (pt_prev) ret = deliver_skb(skb, pt_prev, orig_dev); pt_prev = ptype; &#125;skip_taps:#ifdef CONFIG_NET_INGRESS if (static_key_false(&amp;ingress_needed)) &#123; skb = handle_ing(skb, &amp;pt_prev, &amp;ret, orig_dev); if (!skb) goto out; if (nf_ingress(skb, &amp;pt_prev, &amp;ret, orig_dev) &lt; 0) goto out; &#125;#endif ... &#125; 回调协议包struct packet_type注册的回调函数，把sk_buff传给该协议层处理。 12345678910static inline int deliver_skb(struct sk_buff *skb, struct packet_type *pt_prev, struct net_device *orig_dev)&#123; if (unlikely(skb_orphan_frags(skb, GFP_ATOMIC))) return -ENOMEM; atomic_inc(&amp;skb-&gt;users); return pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev, orig_dev);&#125; 所有这些struct packet_type实际都是在内核初始化的时候通过dev_add_pack注册的，有兴趣的可以跟踪下对应的代码逻辑。 参考文献 Driver porting: Network drivers https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#overview Generic Receive Offload RPS Redhat RPS https://blog.csdn.net/lucien_cc/article/details/11731463]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>Linux</tag>
        <tag>NAPI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由新冠病毒想到的一些事情]]></title>
    <url>%2F2020%2F04%2F04%2F%E8%AF%B4%E8%AF%B4%E8%BF%99%E6%AC%A1%E6%96%B0%E5%86%A0%E4%BC%A0%E6%9F%93%E7%97%85%E6%83%B3%E5%88%B0%E7%9A%84%E4%BA%8B%E6%83%85%2F</url>
    <content type="text"><![CDATA[Live as everything is a miracle or nothing is miracle 爱因斯坦 这次新型冠状病毒发展到现在估计已经超出了绝大多数人的预料, 现在国内的疫情基本稳定了, 但国外包括北美, 欧洲大部分国家都处于病毒爆发的高峰期, 截至4月3日全球已经有超过80多万的病毒感染者: 看这个图, 增长速率丝毫没有减缓的迹象, 新冠病毒的传染能力也可见一斑.那何时又是个头?我们不妨通过简单的数学模型来估算下最终可能感染的人数以及疫情控制的大致时间节点.按照生物学的规律, 一个生物种群数量的增长都遵循S型曲线的增长: 图中的横轴表示时间, 纵轴表示生物种群的个数, 将上述增长曲线写成对应的公式大致如下: $$ y(t) = \frac{k}{1 + Ae^{-rt}} $$ 这里t是时间, k/A是常数(k的值实际表示了最后可能感染的人数), y(t)即当前感染的人数, r是最大的增长率.参考百度疫情给出的数据, 为了简化计算, 从历史数据中大概计算了感染人数的增长率为15%(实际最大的增长率已经超过20%, 这里取了一个中间值);分别取了2020/02/20/2020/04/03两天的的数据, 得到k的值大约为2332345.16, 也就是说最后大概总共有200万左右的感染人数, 据此可以得到一个如下的简单感染人数模型: $$ y(t) = \frac{2332345.16}{1 + 2172.67e^{-0.15t}} $$ 画成图形可能看得比较直观, 下图中时间0对应2020/02/20, 从图上来看要等90天之后, 也就是2020/5/20左右疫情才能真正稳定下来, 当然后续控制力度加强可能这个时间会提前. 在全球化的今天, 这次疫情对每个人来说都有着重大的影响, 对那些因为病毒感染失去亲人朋友的人来说, 更是如此. 还记得当时跟同事讨论这个病毒, 病人的症状跟非典(SARS)很相似, 但官方却迟迟没有给出明确的结论是否存在比较强的感染, 还是含糊其词的说”有限人传人”, 直到后来包不住火了, 才实施封城, 最后还是比病毒的传播慢了半拍. 从湖北考察回来的管轶教授, 上来就说这次很失望, 很麻烦, 比SARS那会要严重很多, 感染人数至少10倍起, 当时很多人不以为然, 还质疑管教授的立场, 以为他是危言耸听, 出于报复心理才这么说的.但凡真的看过管教授履历的人都知道, 他本人是国际知名的传染病科学家,在这样影响大的传染病面前, 作为一个科学家, 他断不会因为一己之心而放弃对真相与道义的坚守.事情事实上比他预想的还要糟糕.面对这么一个局面, 不得不让人感慨深思. 自工业革命以来, 人类开始了轰轰烈烈的自然改造, 地上跑的有火车/汽车, 天上有飞机/火箭, 同时还把触角伸向了宇宙, 人类的成功恐怕让人自己都难以不陶醉. 人的权能感也达到了新的高度, 以至于都忘记了自己只是生活在一个小小的星球上的生物而已. 人类虽说成了地球生物的主宰, 活在生物链的最顶端, 享尽了自然的馈赠, 但却少了一份对自然的敬畏之心. 病毒其实早在人类诞生之前就存在了, 时间退回到第一个细胞出现的那一刻, 人和病毒其实都来自于同一个祖先, 只是病毒走了另外一条道路, 而进化成生物体的细胞走了另外一条叉路而已, 恐怕从生物学的角度, 病毒要比人类更了解人类自己, 也更聪明.病毒可以欺骗人类的免疫细胞, 然后自我繁殖变异, 通过人与人的传播, 这种独特的生存方式, 人类估计要花很长的时间精力才能真正研究清楚. 而再看看这次我们对待新冠病毒的方式, 就知道人类赖以生存的复杂社会体系其实有多么的脆弱.官僚体系的迟钝, 组织机构把个人生命安危置若罔闻, 发生重大危机时, 开始时没有百姓的声音, 最后收场时, 却是那些官员们领取功劳, 宣扬成就的表演, 也无法听到普通人的真实声音. 百姓仿佛一只猴子一般被玩弄于手掌. 如今这样的社会体系中, 政府与组织的权力触角实际已经够大够深了, 个人的空间被压缩挤占, 再这样下去, 实际上每个人都会被裹挟者往前走.难道,我们真的要把所有的隐私与权力都要让度于政府或组织吗? 在集体控制与个人权利之间如何才能达成平衡? 个人又要如何在这样的体系结构下生存? 从大的方面来讲, 在全球化的今天, 面对这样的危机, 个人是否还能明哲保身? 恐怕很难. 我们都没有机会从这种灾难中挣脱出来, 每个人的生活都与这种全球性的危难紧密相关;人与人之间, 国与国之间只有共同合作与互相帮助才能从危机中走过来, 人类能从进化中胜出, 依靠的也是这种团结与协作.最近, 浏览新闻, 时不时有人在兴高采烈的想着: 这次疫情, 美国估计抗不住了, 我们恐怕要赢了；有人也一直在宣扬, 新冠病毒乃美国的阴谋, 实际疫情在美国老早就发生了, 我们压根就不应该帮助美国.这些怪异的言论, 说的头头是道, 却是毫无道义与来由的说辞.不论新冠病毒来自何方, 但目前从发生的时间来看, 就是从武汉传染出去的, 这个毋庸置疑, 如今病毒扩散的其他国家, 我们作为负责任的大国, 理应尽力去帮助其他国家共同抵抗疫情的进一步恶化. 这首先是出于道义, 然则是出于经济发展与社会稳定的考虑.如果此时不去积极帮助美国在内的国家抗击病毒, 我们的国家形象只会变得更加矮小;而其他国家一日不稳定下来, 依靠出口的企业就难以维系, 社会经济压力就会越大.这样的时刻, 只有合作与协作才有利于彼此, 而不是只考虑到眼前的一己之利. 再具体到个人, 想要在这样的全球性危机中安稳的过渡, 首先还是要积蓄能量, 不论是学习, 提升个人能力还是锻炼身体都不能落下, 同时还要多做些资金的储备, 不要乱花钱. 这样等疫情缓过来后, 方能找到机会去改变与突破. 参考文献 https://www.khanacademy.org/science/biology/ecology/population-growth-and-regulation/a/exponential-logistic-growth https://voice.baidu.com/act/newpneumonia/newpneumonia]]></content>
      <categories>
        <category>社会万象</category>
      </categories>
      <tags>
        <tag>哲学</tag>
        <tag>社会</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android是如何实现流量统计的?]]></title>
    <url>%2F2020%2F04%2F01%2F%E8%AF%B4%E8%AF%B4Android%E4%B8%AD%E7%9A%84%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[使用Android手机时, 我们不仅可以看到当前系统的流量使用情况, 还可以查看每个应用消耗了多少流量, 借此我们可以发现有那些流氓APP在偷偷在背后消耗流量.那么, Android是具体如何实现流量统计的? 又是如何对每个应用的流量使用进行监控? 这篇文章我们就来看看Android流量统计的具体实现原理. 大致说来, Android从如何几个方面进行流量统计: 统计每个网口当前发送/接收的流量数据 监控每个应用(对应唯一的UID)所消耗的流量 支持对总的流量配额进行限制, 如达到一定的流量阈值后, 会对网络进行限制 而具体到每个应用(比如system应用, UID=1000), Android还支持对应用内的每个socket进行标记(tag), 用于区分每个应用(UID)内部具体使用了那些流量.后面, 我们会讲到如何通过标签来区分UID内部的流量. 下图是Android流量统计的原理框图: 为了实现流量统计, Android在Linux内核增加了一个netfilter模块: xt_qtaguid(源码可以在kernel/net/netfilter中找到), 用于统计当前系统所有流量, 该模块初始化时, 会初始化一个/proc/net/xt_qtaguid目录供用户空间的进程使用;NetworkStatsService系统服务就是周期性的读取该目录的数据来获取当前系统消耗的实时流量的;而如果要对某个特定的socket打上标签, 则需要通过JNI接口调用,然后发请求给netd将该socket标签信息通过接口/proc/net/xt_qtaguid/ctrl写入内核. 接下来就一起看下Android具体是如何进行流量统计的. Android流量统计实现Android有一个系统服务NetworkStatsService来负责流量统计管理. 在系统启动的时候会创建该服务, 对其进行初始化: 创建一个NetworkStatsService, 并返回给SystemServer, 服务内有一个线程用于数据统计业务的处理. 1234567891011121314151617181920public static NetworkStatsService create(Context context, INetworkManagementService networkManager) &#123; AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE); PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG); NetworkStatsService service = new NetworkStatsService(context, networkManager, alarmManager, wakeLock, getDefaultClock(), TelephonyManager.getDefault(), new DefaultNetworkStatsSettings(context), new NetworkStatsObservers(), getDefaultSystemDir(), getDefaultBaseDir()); HandlerThread handlerThread = new HandlerThread(TAG); Handler.Callback callback = new HandlerCallback(service); handlerThread.start(); Handler handler = new Handler(handlerThread.getLooper(), callback); service.setHandler(handler, callback); return service;&#125; 等到SystemServer完成对系统服务的初始化后, 会调用NetworkStatsService.systemReady(), 告诉服务可以正常启动了, 启动时NetworkStatsService需要做如下几件事情: 创建四个流量统计的类型, 实际对应放在/data/system/netstats目录的四个类型的文件而已, 分别用于统计每个网口的消耗的流量(PREFIX_DEV), 视频通话以及热点分享所消耗的流量(PREFIX_XT), 每个用户所消耗的流量(PREFXI_UID)以及每个用户对应的每个标签所消耗的流量(PREFIX_UID_TAG) 更新每个流量统计数据写入的阈值: 即流量消耗达到某个阈值后, 需要将当前统计数据写入磁盘, 目前默认统一使用的是2MB；接着还要看下是否需要从早前版本中把老的流量统计数据迁移过来 注册并监听系统广播, 比如定时从系统拉取流量统计数据(ACTION_NETWORK_STATS_POLL), Android默认30分钟拉取一次; 系统用户增加与删除的广播;关机的广播等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void systemReady() &#123; mSystemReady = true; synchronized (mStatsLock) &#123; // create data recorders along with historical rotators mDevRecorder = buildRecorder(PREFIX_DEV, mSettings.getDevConfig(), false); mXtRecorder = buildRecorder(PREFIX_XT, mSettings.getXtConfig(), false); mUidRecorder = buildRecorder(PREFIX_UID, mSettings.getUidConfig(), false); mUidTagRecorder = buildRecorder(PREFIX_UID_TAG, mSettings.getUidTagConfig(), true); updatePersistThresholdsLocked(); // upgrade any legacy stats, migrating them to rotated files maybeUpgradeLegacyStatsLocked(); // read historical network stats from disk, since policy service // might need them right away. mXtStatsCached = mXtRecorder.getOrLoadCompleteLocked(); // bootstrap initial stats to prevent double-counting later bootstrapStatsLocked(); &#125; // watch for tethering changes final IntentFilter tetherFilter = new IntentFilter(ACTION_TETHER_STATE_CHANGED); mContext.registerReceiver(mTetherReceiver, tetherFilter, null, mHandler); // listen for periodic polling events final IntentFilter pollFilter = new IntentFilter(ACTION_NETWORK_STATS_POLL); mContext.registerReceiver(mPollReceiver, pollFilter, READ_NETWORK_USAGE_HISTORY, mHandler); // listen for uid removal to clean stats final IntentFilter removedFilter = new IntentFilter(ACTION_UID_REMOVED); mContext.registerReceiver(mRemovedReceiver, removedFilter, null, mHandler); // listen for user changes to clean stats final IntentFilter userFilter = new IntentFilter(ACTION_USER_REMOVED); mContext.registerReceiver(mUserReceiver, userFilter, null, mHandler); // persist stats during clean shutdown final IntentFilter shutdownFilter = new IntentFilter(ACTION_SHUTDOWN); mContext.registerReceiver(mShutdownReceiver, shutdownFilter); try &#123; mNetworkManager.registerObserver(mAlertObserver); &#125; catch (RemoteException e) &#123; // ignored; service lives in system_server &#125; registerPollAlarmLocked(); registerGlobalAlert();&#125; NetworkStatsService启动后, 注册了一个定时广播com.android.server.action.NETWORK_STATS_POLL, 每隔一段时间就会定时拉取当前系统消耗的流量统计数据, 收到该广播后, 系统会尝试将统计数据写入到磁盘永久保存下来: 123456789101112131415161718192021222324private BroadcastReceiver mPollReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; // on background handler thread, and verified UPDATE_DEVICE_STATS // permission above. performPoll(FLAG_PERSIST_ALL); // verify that we're watching global alert registerGlobalAlert(); &#125;&#125;;// 拉取当前流量数据private void performPoll(int flags) &#123; synchronized (mStatsLock) &#123; mWakeLock.acquire(); try &#123; performPollLocked(flags); &#125; finally &#123; mWakeLock.release(); &#125; &#125;&#125; 方法performPollLocked首先会获取当前的统计数据快照, 然后将其自动写入到磁盘/data/system/netstats目录: recordSnapShotLocked()实际通过NetworkManagementService提供的接口从/proc/net/xt_qtaguid这个目录读取当前的历史统计数据并将其保存到mDevRecorder/mXtRecorder/mUidRecorder中 根据传入的标志位, 来确定各个NetworkStatsRecorder是否将数据写入磁盘: 可以强制写入(forcePersistLocked), 也可以等到消耗流量达到阈值(就是之前说的2MB)之后再写入(maybePersistLocked) 1234567891011121314151617181920212223242526272829303132333435363738private void performPollLocked(int flags) &#123; if (!mSystemReady) return; final boolean persistNetwork = (flags &amp; FLAG_PERSIST_NETWORK) != 0; final boolean persistUid = (flags &amp; FLAG_PERSIST_UID) != 0; final boolean persistForce = (flags &amp; FLAG_PERSIST_FORCE) != 0; // TODO: consider marking "untrusted" times in historical stats final long currentTime = mClock.millis(); try &#123; recordSnapshotLocked(currentTime); &#125; catch (IllegalStateException e) &#123; Log.wtf(TAG, "problem reading network stats", e); return; &#125; catch (RemoteException e) &#123; // ignored; service lives in system_server return; &#125; // persist any pending data depending on requested flags if (persistForce) &#123; mDevRecorder.forcePersistLocked(currentTime); mXtRecorder.forcePersistLocked(currentTime); mUidRecorder.forcePersistLocked(currentTime); mUidTagRecorder.forcePersistLocked(currentTime); &#125; else &#123; if (persistNetwork) &#123; mDevRecorder.maybePersistLocked(currentTime); mXtRecorder.maybePersistLocked(currentTime); &#125; if (persistUid) &#123; mUidRecorder.maybePersistLocked(currentTime); mUidTagRecorder.maybePersistLocked(currentTime); &#125; &#125;&#125; 最后, 我们来看看流量统计的数据是如何写入磁盘, 又如何从磁盘读取的. Android将系统消耗的流量按照时间切割成一段段固定时间长度的统计值(NetworkStatsHistory), 并将其与NetworkIdentitySet(表示一个网口集合)组成一个统计的哈希列表(NetworkStatsCollection), 然后每次更新当前消耗的流量时, NetworkStatsRecorder都会不断的将数据写入到磁盘: NetworkStatsRecorder中包含了两个流量统计数据: 当前未写入磁盘的数据(pending)以及开机以来的统计数据(mSinceBoot) FileRotator负责将NetworkStatsRecorder中的数据定时写入到磁盘, 并按照一定的老化时间来创建新的统计文件, 而且每个统计文件在达到一定的生命周期后, 会自动被删除 利用标签来统计特定Socket流量TrafficStats中提供了接口, 可以在特定的socket(也可以使用socket对应的文件描述符)上打上标签,从而实现对每个应用你内部的流量消耗进行细分.Android系统已经定义了部分的TAG值, 比如用户DHCP协议的数据(TAG_SYSTEM_DHCP), 用于获取NTP网络时间的流量(TAG_SYSTEM_NTP), 用于探测网络的流量(TAG_SYSTEM_PROBE). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public class TrafficStats &#123; /** * Default tag value for &#123;@link DownloadManager&#125; traffic. * * @hide */ public static final int TAG_SYSTEM_DOWNLOAD = 0xFFFFFF01; /** * Default tag value for &#123;@link MediaPlayer&#125; traffic. * * @hide */ public static final int TAG_SYSTEM_MEDIA = 0xFFFFFF02; /** * Default tag value for &#123;@link BackupManager&#125; backup traffic; that is, * traffic from the device to the storage backend. * * @hide */ public static final int TAG_SYSTEM_BACKUP = 0xFFFFFF03; /** * Default tag value for &#123;@link BackupManager&#125; restore traffic; that is, * app data retrieved from the storage backend at install time. * * @hide */ public static final int TAG_SYSTEM_RESTORE = 0xFFFFFF04; /** * Default tag value for code (typically APKs) downloaded by an app store on * behalf of the app, such as updates. * * @hide */ public static final int TAG_SYSTEM_APP = 0xFFFFFF05; /** @hide */ public static final int TAG_SYSTEM_DHCP = 0xFFFFFF40; /** @hide */ public static final int TAG_SYSTEM_NTP = 0xFFFFFF41; /** @hide */ public static final int TAG_SYSTEM_PROBE = 0xFFFFFF42; /** @hide */ public static final int TAG_SYSTEM_NEIGHBOR = 0xFFFFFF43; /** @hide */ public static final int TAG_SYSTEM_GPS = 0xFFFFFF44; /** @hide */ public static final int TAG_SYSTEM_PAC = 0xFFFFFF45; .... /** * Set active tag to use when accounting &#123;@link Socket&#125; traffic originating * from the current thread. Only one active tag per thread is supported. * &lt;p&gt; * Changes only take effect during subsequent calls to * &#123;@link #tagSocket(Socket)&#125;. * &lt;p&gt; * Tags between &#123;@code 0xFFFFFF00&#125; and &#123;@code 0xFFFFFFFF&#125; are reserved and * used internally by system services like &#123;@link DownloadManager&#125; when * performing traffic on behalf of an application. * * @see #clearThreadStatsTag() */ public static void setThreadStatsTag(int tag) &#123; NetworkManagementSocketTagger.setThreadSocketStatsTag(tag); &#125; /** * Set active tag to use when accounting &#123;@link Socket&#125; traffic originating * from the current thread. Only one active tag per thread is supported. * &lt;p&gt; * Changes only take effect during subsequent calls to * &#123;@link #tagSocket(Socket)&#125;. * &lt;p&gt; * Tags between &#123;@code 0xFFFFFF00&#125; and &#123;@code 0xFFFFFFFF&#125; are reserved and * used internally by system services like &#123;@link DownloadManager&#125; when * performing traffic on behalf of an application. * * @return the current tag for the calling thread, which can be used to * restore any existing values after a nested operation is finished */ public static int getAndSetThreadStatsTag(int tag) &#123; return NetworkManagementSocketTagger.setThreadSocketStatsTag(tag); &#125;&#125;... /** * Tag the given &#123;@link Socket&#125; with any statistics parameters active for * the current thread. Subsequent calls always replace any existing * parameters. When finished, call &#123;@link #untagSocket(Socket)&#125; to remove * statistics parameters. * * @see #setThreadStatsTag(int) */ public static void tagSocket(Socket socket) throws SocketException &#123; SocketTagger.get().tag(socket); &#125; /** * Remove any statistics parameters from the given &#123;@link Socket&#125;. * &lt;p&gt; * In Android 8.1 (API level 27) and lower, a socket is automatically * untagged when it's sent to another process using binder IPC with a * &#123;@code ParcelFileDescriptor&#125; container. In Android 9.0 (API level 28) * and higher, the socket tag is kept when the socket is sent to another * process using binder IPC. You can mimic the previous behavior by * calling &#123;@code untagSocket()&#125; before sending the socket to another * process. */ public static void untagSocket(Socket socket) throws SocketException &#123; SocketTagger.get().untag(socket); &#125; 要使用一个socket的标签其实很简单, 只要在创建通讯的socket的连接后, 主动调用setThreadStatsTag就可以了, 来看一个示例: 1234567891011121314151617181920private void setupSocket(int sockType, int prot, long writeTimeout, long readTimeout, int destPort) throws ErrnoException, IOException &#123; // 将当前socket打上PROBE标签 int oldTag = TrafficStats.getAndSetThreadStatsTag(TrafficStats.TAG_SYSTEM_PROBE); try &#123; mFd = Os.socket(mAddrFamily, sockType, prot); &#125; finally &#123; TrafficStats.setThreadStatsTag(oldTag); &#125; Os.setsockoptTimeval(mFd, SOL_SOCKET, SO_SNDTIMEO, StructTimeval.fromMillis(writeTimeout)); Os.setsockoptTimeval(mFd, SOL_SOCKET, SO_RCVTIMEO, StructTimeval.fromMillis(readTimeout)); if (!TextUtils.isEmpty(mIface)) &#123; Os.setsockoptIfreq(mFd, SOL_SOCKET, SO_BINDTODEVICE, mIface); &#125; Os.connect(mFd, mTarget, destPort); mSockAddr = Os.getsockname(mFd);&#125; 如果要获取某个UID对应的标签数据, 只要调用NetworkStatsManager.java的queryDetailsForUid接口, 传入对应的开始/结束时间就可以了: 12345678910111213141516171819202122/** * Query network usage statistics details for a given uid. * * #see queryDetailsForUidTagState(int, String, long, long, int, int, int) */public NetworkStats queryDetailsForUid(int networkType, String subscriberId, long startTime, long endTime, int uid) throws SecurityException &#123; return queryDetailsForUidTagState(networkType, subscriberId, startTime, endTime, uid, NetworkStats.Bucket.TAG_NONE, NetworkStats.Bucket.STATE_ALL);&#125;/** * Query network usage statistics details for a given uid and tag. * * #see queryDetailsForUidTagState(int, String, long, long, int, int, int) */public NetworkStats queryDetailsForUidTag(int networkType, String subscriberId, long startTime, long endTime, int uid, int tag) throws SecurityException &#123; return queryDetailsForUidTagState(networkType, subscriberId, startTime, endTime, uid, tag, NetworkStats.Bucket.STATE_ALL);&#125; 总结Android流量统计在9.0还是基于xt_qtaguid来实现的, 后面实际会通过BPF来做(参考文章BPF与eBPF).]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>流量统计</tag>
        <tag>网络管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用SSH隧道访问局域网]]></title>
    <url>%2F2020%2F02%2F24%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8SSH%E9%9A%A7%E9%81%93%E8%AE%BF%E9%97%AE%E5%B1%80%E5%9F%9F%E7%BD%91%2F</url>
    <content type="text"><![CDATA[SSH(Secure SHell)是一种基于加密算法的网络安全协议, 其在TCP/IP协议的基础上通过非对称公钥算法对用户身份进行验证. SSH在网络中有广泛的应用, 比如平常在远程登录时就会用到SSH, Github的代码仓库提交也会基于SSH协议来验证提交者的合法性, 而对常年生活在局域网内的人来说, SSH更多的用途则是搭建穿越防火墙的VPN实现网络自由. 一台服务器如果有公共域名或者IP地址, 只需要事先将客户端的公钥放到服务器上就可以正常登录, 但如果服务器本身位于防火墙之外(比如某个端口被禁)或者位于NAT(Network Address Translation)网关之后, 这个方法就不起作用了. 用过VPN的同志应该比较清楚, 穿透防火墙或者某个局域网的NAT网关, 一般要用到SSH隧道技术(SSH tunneling);SSH隧道技术也被称为端口转发(port forwarding).简单来说, 建立SSH隧道大致有两个流程: 由位于局域网的设备A向服务器PC发起SSH连接, 建立一个安全加密的通信通道, 并基于该通道监听某个特定的端口 接着, 服务器基于已有的加密通道再建立一个SSH通信链路,基于这个通道服务器就可以登录到大屏, 执行交互指令 SSH隧道技术的端口转发具体说有两种, 一种叫本地端口转发(local port forwarding), 就是在客户端做端口转发;一种叫远端端口转发(remote port forwarding), 就是在服务端做端口的数据转发, 这篇文章用到的技术是后一种. 这里就来看看如何通过SSH隧道技术来实现对局域网内某个服务器的登录: 局域网内有一台设备A(服务端), 只有私有IP地址, 通过NAT网关访问外部网络, 设备B(客户端)是外部网络的一个PC, 现在要通过该PC(设备B)正常登录到设备A. 实现SSH隧道功能在开启SSH隧道功能之前, 确保客户端/服务器都正常配置了ssh(SSH的客户端程序)/sshd(SSH守护进程): ssh: ssh登录的客户端, 负责发起ssh登录请求, 其配置一般放在/etc/ssh/ssh_config sshd: sshd是服务端的守护进程, 负责监听来自客户端的请求, 其配置放在/etc/ssh/sshd_config 为了确保ssh可以正常进行端口转发, 需要打开AllowTcpForwarding: 设置AllowTcpForwarding为yes, 确保能够使用端口转发功能 另外SSH密钥交换时要用到主机的密钥(host key), 可以通过ssh-keygen产生, 对于Ubuntu系统来说, 主机密钥一般放在/etc/ssh目录下. 为了避免每次ssh登录都要输入密码, 可以事先分别在客户端/服务器产生一个rsa密钥对, 并将公钥放到服务器/客户端的/.ssh/authorized_keys中保存下来, 并在执行ssh指令时指定对应的私钥文件, 这样身份验证就会在密钥验证阶段完成无需再输入用户密码了. 启动sshd配置完成后, 如果没有sshd进程, 需要在设备A(服务端)/设备B(用户端)都启动sshd: 1sshd -ddd -h /etc/ssh/ssh_host_rsa_key -f /etc/ssh/sshd_config 其中参数-ddd用于输出调试信息, -h指定host密钥文件, -f指定sshd的配置;启动完成后, 设备就可以正常收到来其他ssh客户端的请求了. 启动ssh远程登录在大屏输入如下指令, 尝试与设备A(客户端)建立SSH链接: 1ssh -vvv -TN -i &lt;identity_file&gt; -R 8989:localhost:22 user_name@remote_host -vvv参数用于输出debug信息, -TN告诉ssh在登录后不要开启终端执行指令而是监听某个指定的端口, -i制定身份验证的密钥文件目录, 参数-R指定了远端转发端口的规则: 将来自远端8989的数据都转发到本地的22端口; 执行该命令后, 身份验证通过, 可能会输入服务器密码, 然后我们就可以看到ssh会一直在监听8989这个端口, 接着在设备A(服务器)输入指令: 1ssh -vvv -i &lt;identity_file&gt; -p 8989 root@localhost 身份认证完成后, 就可以看到一个输入shell指令的命令窗口, 就算登录完成了. 参考资料 https://www.ssh.com/ssh/tunneling https://www.booleanworld.com/guide-ssh-port-forwarding-tunnelling/ http://arondight.me/2016/02/17/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/ https://en.wikipedia.org/wiki/Secure_Shell The Secure Shell (SSH) Protocol Architecture man ssh/sshd/sshd_config]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>远程登录</tag>
        <tag>反向隧道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Recovery模式如何支持ADB]]></title>
    <url>%2F2019%2F12%2F31%2FRecovery%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81ADB%2F</url>
    <content type="text"><![CDATA[这两天顺着recovery模式下一个网络需求, 为了便于调试又在recovery下做了ADB功能. 在Android早期的如4.4版本, recovery模式下支持ADB配置起来比较简单(支持adb devices/adb reboot/adb pull/push等常用指令), 但在Android 9.0下USB辅助设备一般都通过configfs的方式来配置了, 因此相对来说要适配的东西就多一些, 如果额外要适配adb shell命令, 则要修改adbd的源代码了.这篇文章就来看看如何在Recovery模式下解决这几个问题. 在进入正题之前, 先了解下USB相关的基础知识. USB全称是Universal Serial Bus, 是一种广泛用于主机与外设之间的连接的串行总线.USB设备使用的是一种层级的结构, 最多可支持多达127个设备, 每个USB设备对应一个功能(function), 比如USB打印机提供了打印服务; 存储设备则提供了存储数据的功能. Android中的USB支持OTG(On The Go), 因此有两种模式, 一种是Android自身作为host,可以接入其他USB设备;一种是Android作为peripheral设备, Android可以连接到PC端, 比如要查看Android设备的存储内容时, 使用ADB时都必须将Android设置为peripheral模式.ADB是Android中用于开发调试的一个工具, 更详细的说明可以参考官网的说明Android Debuge Bridge. Recovery下的ADB适配的第一步是首先看看源码. 进入Recovery的代码/bootable/recovery下面有一个README.md的文档, 里边有大致说明了如何在recovery下使用ADB. 对USESRDEBUG/ENG版本, 默认是启动了adbd, 并且对于recovery模式通过adb devices看到的是一个如下设备: 1234$ adb devicesList of devices attached1234567890abcdef recovery 还需要明确的一点是, 在recovery模式下, 只有部分adb指令可用, 比如adb root/adb push/pull, 如果要使用adb shell需要把/system分区挂载上来.看起来一切都比较简单了, 可通过adb reboot recovery之后却无法找到设备, 在PC端查看dmesg也没有任何USB设备枚举上来. 继续看文档, 上面说到, 如果设备使用了configfs这个配置文件系统的话, 需要设置相关的配置.那问题可能就出在这里: 使用了configfs来配置USB设备, 但是在recovery模式没有正常配置. 123456If device is using [configfs](https://www.kernel.org/doc/Documentation/usb/gadget_configfs.txt),check if configfs has been properly set up in init rc scripts. See the [exampleconfiguration](https://android.googlesource.com/device/google/wahoo/+/master/init.recovery.hardware.rc)for Pixel 2 devices. Note that the flag set via sysfs (i.e. the one above) is no-op when usingconfigfs. 简单来说, 在Linux中, USB Gadget是一个具有UDC(USB Device Controller)的可以连接到一个USB Host的设备, 其通常具有串口通讯/数据存储的功能.而对于Host来说, 一个USB Gadget就是一个配置的集合而已, 每个配置包含很多接口, 也被称为功能(functions). 目前Linux已经包含了很多功能供USB Gadgets使用, 具体可以参看Linux的源码/kernel/drivers/usb/gadget. 那么具体来说ADB适配要经历哪几个步骤了? 接下来就来看一看recovery下适配ADB需要做的事情. Recovery下的ADB适配 挂载FunctionFs将USB用于ADB通信 在recovery代码目录/bootable/recovery/etc/init.rc中对ADB对应的FunctionFs做了配置: 123456on fs write /sys/class/android_usb/android0/f_ffs/aliases adb mkdir /dev/usb-ffs 0770 shell shell mkdir /dev/usb-ffs/adb 0770 shell shell mount functionfs adb /dev/usb-ffs/adb uid=2000,gid=2000 这个有什么用了?看ADB的源码(/system/core/daemon), 大致可以看到, 只有挂载了functionfs, ADB才能基于USB的ep0端口进行通讯: 123456789101112131415161718192021222324252627282930313233343536373839// /dev/usb-ffs/adb/ep0 (main.cpp)if (access(USB_FFS_ADB_EP0, F_OK) == 0) &#123; // Listen on USB. usb_init(); is_usb = true;&#125;// usb.cppvoid usb_init() &#123; dummy_fd = adb_open("/dev/null", O_WRONLY); CHECK_NE(dummy_fd, -1); usb_ffs_init();&#125;// usb.cppstatic void usb_ffs_init() &#123; D("[ usb_init - using FunctionFS ]"); usb_handle* h = new usb_handle(); if (android::base::GetBoolProperty("sys.usb.ffs.aio_compat", false)) &#123; // Devices on older kernels (&lt; 3.18) will not have aio support for ffs // unless backported. Fall back on the non-aio functions instead. h-&gt;write = usb_ffs_write; h-&gt;read = usb_ffs_read; &#125; else &#123; h-&gt;write = usb_ffs_aio_write; h-&gt;read = usb_ffs_aio_read; aio_block_init(&amp;h-&gt;read_aiob); aio_block_init(&amp;h-&gt;write_aiob); &#125; h-&gt;kick = usb_ffs_kick; h-&gt;close = usb_ffs_close; D("[ usb_init - starting thread ]"); std::thread(usb_ffs_open_thread, h).detach();&#125; 需要了解USBFunctionFs的同学可以参考Linux的文档https://www.kernel.org/doc/Documentation/usb/functionfs.txt. 创建ADB相关的功能配置 挂载configfs到某个目录, 并生成ADB相关的配置, 主要是USB的ProductID/VendorID以及设备序列号等信息 12345678910111213on init mount configfs none /config mkdir /config/usb_gadget/g1 0770 shell shell write /config/usb_gadget/g1/idVendor &lt;youre_usb_vendor_id&gt; write /config/usb_gadget/g1/idProduct &lt;youre_usb_product_id&gt; mkdir /config/usb_gadget/g1/strings/0x409 0770 write /config/usb_gadget/g1/strings/0x409/serialnumber $&#123;ro.serialno&#125; write /config/usb_gadget/g1/strings/0x409/manufacturer $&#123;ro.product.manufacturer&#125; write /config/usb_gadget/g1/strings/0x409/product $&#123;ro.product.model&#125; mkdir /config/usb_gadget/g1/functions/ffs.adb write /config/usb_gadget/g1/os_desc/use 1 setprop sys.usb.configfs 1 配置完成后, /config/usb_gadget/g1目录下大致如下: 使能对应的USB Gadgets 在Android设备文件目录/sys/class/udc找到对应USB设备控制器的名称, 将其写入到对应的配置, 从而使得USB主机端可以正常枚举到该USB设备: 12345678on property:sys.usb.ffs.ready=1 mkdir /config/usb_gadget/g1/configs/b.1 0777 shell shell symlink /config/usb_gadget/g1/configs/b.1 /config/usb_gadget/g1/os_desc/b.1 mkdir /config/usb_gadget/g1/configs/b.1/strings/0x409 0770 shell shell write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration &quot;adb&quot; symlink /config/usb_gadget/g1/functions/ffs.adb /config/usb_gadget/g1/configs/b.1/f1 write /config/usb_gadget/g1/UDC &quot;a800000.dwc3&quot; # 这里写入对应的UDC名字 配置完成后, 重新打包下BOOT分区, 刷写后, 输入adb devices可以看到: 123List of devices attached 1297270a recovery 说明修改起作用了, 但目前输入adb shell还是会提示/system/bin/sh目前找不到的错误, 原因是recovery并没有正常挂载system分区, 那么有没有可能不挂载system分区同时又能使用adb shell了? 看/bootable/recovery/etc/init.rc, recovery下实际有集成了一个命令工具集合busybox, 通过busybox我们应该也可以实现类似与正常模式下/system/bin/sh的功能, 这就需要修改Android中ADBD的源码了, 具体可以看下/system/core/adb/shell_serivce.cpp中的代码逻辑. 参考文献 Linux USB相关的资料文档 USB Nutshell USB Gadget Configfs https://www.kernel.org/doc/Documentation/usb/functionfs.txt]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Recovery</tag>
        <tag>ADB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SELinux在Android中的应用]]></title>
    <url>%2F2019%2F12%2F07%2FSelinux%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SELinux(Security Enhanced Linux)是Linux下的安全控制机制, 为进程访问系统资源提供了访问控制(access control)策略. 早期, Linux基于用户身份/用户组的DAC(Discretionary Access Control作为访问控制策略: 每个进程都有所属的UID, 每个文件都有所属的UID/GID以及文件模式(读写执行等), 一个进程是否可以访问某个文件就是基于UID/GID/文件模式来管理的.换句话说,只要某个资源序属于该用于或该用户组, 则该用户对该资源具有绝对控制权力, 这样一旦用户获得了root权限, 那么整个系统就成了肉鸡. 可见, DAC的安全控制策略比较粗放. SELinux最初是由美国Utah大学与NSA(National Security Agency)的安全小组研究出来的安全框架FLASK演变而来, 后被合入到Linux 2.6版本.相较于DAC, SELinux采用的是更细粒度的MAC(Mandatory Access Control).对于DAC而言, 资源的权限是由每个用户自己控制的, 而MAC则将所有的权限收拢, 由一个统一的管理者(SELinux)统一来分配所有的资源权限, 如果访问者没有事先分配到某个资源的权限, 则不会允许访问.这样即使是root用户也要收到安全策略的约束. Android在4.3开始引入SELinux, 到了5.0版本之后, 则开始全面支持了. 在SELinux机制下, Android中所有的对象(进程/文件/socket/property)都打上了标签(label), 进程访问对象时, SELinux根据事先配置好的安全策略(security policy)判断访问者是否有权限. 另外, Android系统是同时支持DAC与SELinux的, 就是说, 在一个进程访问某个资源时,会按照如下规则进行权限控制: 首先根据DAC规则, 检查进程权限, 是否具有对应资源的读写/执行权限, 如果没有则拒绝执行; 如果DAC规则检查通过, 则执行SELinux安全规则的检查, 如果不通过,则拒绝访问. 初识SELinuxSELinux的首要原则是: 任何未被声明允许执行的都会被拒绝, 其有两种运行模式: Permissive模式: 访问控制的策略不会强制执行, 但是会被日志记录下来 Enforcing模式: 访问控制策略会被强制执行并被记录下来 在Android下可以通过 adb getenforce来查看当前SELinux处于何种模式, 也可以通过adb setenforce来设置SELinux的模式(USER版本默认是enforcing, USERDEBUG/ENG可以设置模式): 123adb setenforce 0 // permissive模式adb setenforce 1 // enforcing模式 在SELinux中, 主要有Subject/Object/Object Manager/Security Server等几个核心的组成部分(见下图): Subject: 在SELinux中, Subject是一个进程, 每个Subject都有与之关联的一个安全上下文(security context); Subject负责发起访问某个对象的请求,比如读文件/建立socket链接 Object: 一个对象就是一个资源, 比如文件, socket, pipes以及网络接口；每个对象都由一个类型标识其用途(file, socket), 并且与一个权限(permissions)集合关联, 该权限集合描述了对象能提供什么样的服务(比如read/write/send等) Object Manager: 对象管理者负责管理所有对象以及这些对象上能够执行的动作 Access Vecctor Cache: 用于缓存Security Server的访问决策,以改善系统性能 Security Server: 安全服务器根据安全策略来决定某个对象上的动作是否被执行 Security Policy: 用于描述SELinux的访问规则 接下来我们看看SELinux具体是如何给每个对象打标签以及实现安全策略规则的. 标签(label)与策略规则SELinux是通过标签(label)来匹配执行动作以及策略的.标签决定了何种动作是允许被执行的, socket/文件/进程都有自己的标签. SELinux的访问控制就是根据各个对象上的的标签来决定的, 而策略文件则定义了这些对象是如何相互交互的. 一个标签通常有如下的形式: 12user:role:type:mls_level 这样一个标签也通常被成为Security Context. 在Android中, 通常不用关心user/role/msl_level, user一般只有u, role对于进程来说是r, 对其他对象是object_r, msl_level是s0, 而type则用来标识对象的类型, 其决定了该对象的所具备的能力, 因此Android中的SELinux又称为基于TE(Type Enforcement)的安全机制, 在Android中, 所有的SELinux策略文件都以te结尾. 通过ls/ps指令中加入-Z参数, 可以查看文件/进程的SELinux状态, 如输入ls -aZ /init*查看init文件夹的标签: 上图中的init可执行程序以及文件夹都是在/system/sepolicy/private/file_contexts中定义的: 12345678910111213141516# Data files/adb_keys u:object_r:adb_keys_file:s0/build\.prop u:object_r:rootfs:s0/default\.prop u:object_r:rootfs:s0/fstab\..* u:object_r:rootfs:s0/init\..* u:object_r:rootfs:s0/res(/.*)? u:object_r:rootfs:s0/selinux_version u:object_r:rootfs:s0/ueventd\..* u:object_r:rootfs:s0/verity_key u:object_r:rootfs:s0# Executables/charger u:object_r:rootfs:s0/init u:object_r:init_exec:s0/sbin(/.*)? u:object_r:rootfs:s0 同样输入ps -Z可以查看进程的标签: 策略规则(policy rules)决定了进程是如何访问对象的, 其通常是如下格式: 12 allow domains types:classes permissions 这里, Domain: 域是一个进程或一组进程的标签,也被成为域类型 Type: 对象的标签(如file/socket等)或者一个对象集合 Class: 访问对象的类型 Permission: 请求的权限(read/write) 举个例子: 12allow appdomain app_data_file:file rw_file_perms; 这个规则的意思是允许所有应用域的进程访问标签为app_data_file的文件. 所有这些规则需要依赖于global_macros/te_macros的宏定义(位于/system/sepolicy目录下). 除了像上面的规则指定某个特定的域或类型, 也可以通过指定一个属性(attribute)来表示一组域或类型;当通过一个规则有属性时, 会被自动扩展成为了相应的域或类型. 按照上述方式写成的规则如下: 12RULE_VARIANT SOURCE_TYPES TARGET_TYPES: CLASSES PERMISSIONS 在这个规则下, 只要一个Subject标识了SOURCE_TYPES就可以有权在类型为CLASSES/标签为TAEGET_TYPES的对象上执行任何在PERMISSONS中声明的操作.例如: 12allow domain null_device:chr_file &#123; getattr open read ioctl write&#125;; 这个条规则意思是允许任何有domain域的进程访问null_device类型(对应/dev/null)的字符设备.最后我们来看下Android是如何应用SELinux的. SELiunx在Android中的应用Android的SELinux配置(以下均以Android P 9.0的代码为例)在Android源码中有两个目录: /system/sepolicy /device/&lt;manufactory&gt;/&lt;device-name&gt;/sepolicy 而/system/sepolicy主要是Android原生已有的SELinux文件, 包括所有SELinux标签以及策略文件.te的定义, 一般不做修改;/device目录下的SELinux配置通过编译宏BOARD_SEPOLICY_DIRS引入, 所有SELinux相关的编译都要依靠/system/sepolicy/Android.mk这个makefile. 具体来说, SELinux的配置大致有如下几个部分: 配置目录 说明 /system/sepolicy/public 包含了系统sepolicy相关的API /system/sepolicy/private 包含了系统sepolicy的具体实现(与vendor无关) /system/sepolicy/vendor 提供给厂商(vendor)自由实现的配置 BOARD_SEPOLICY_DIRS 包含厂商sepolicy的定制化配置 所有以.te结尾的都是安全策略文件, 其定义了对象的域(domain)和类型(types); 而SELinux标签文件(也称为SELinux context文件), 大致有如下几种: file_contexts: 为用户空间的文件分配标签 genfs_contexts: 为不支持扩展属性的文件分配标签(如proc/vfat) property_contexts: 为Android所有属性分配标签,init进程在初始化时会读取该配置 service_contexts: 为Android所有binder服务分配标签, 用于控制哪些进程可以注册/查找这些服务 seapp_contexts: 为/data/data目录下的应用分配标签, 应用启动时zygote进程以及在应用安装时installd都会读取该配置 mac_permissions.xml: 根据应用的签名(也可能包括包名)分配seinfo tag;seinfo tag在seapp_contexts文件中可以当作一个密钥用于分配特定的标签给所有的应用. 该配置在system_sever启动时会被读取 那么, 这些SELinux的标签配置以及策略文件是如何编译的? 大致有两个编译路径,所有的file_contexts标签文件都会编译生成一个file_contexts.bin;而其他的如security_classes/*.te/genfs_contexts/port_contexts等文件都会编译生成一个sepolicy的二进制文件, 整体的编译逻辑如下图所示: 有关SELinux在Android的编译可以参考https://source.android.com/security/selinux/build. 有了SELinux的基础知识, 要如何修改或者添加SELinux规则? 一般, 通过dmesg | grep avc或则logcat | grep avc查看系统当前的SELinux访问的记录, 如果出现avc: denied等字样, 说明有进程违反了安全策略, 举个例子: 12[ 42.357295] selinux: avc: denied &#123; set &#125; for property=net.usb0.dns1 pid=473 uid=0 gid=0 scontext=u:r:network_manager:s0 tcontext=u:object_r:system_prop:s0 tclass=proper1 这个访问拒绝的提示说明, 进程473(network_manager)的标签u:r:network_manager:s0不具备访问标签为u:object_r:system_prop:s0, 类型为system_prop的属性值, 需要添加安全规则: 12set_prop(network_manager, system_prop) 再次编译验证后就不会出现访问拒绝的日志了. 参考文献 SELinux for Android SEAndroid的介绍 SELinux NoteBook SELinux在Android应用的挑战与问题 Introduction to SELinux]]></content>
      <categories>
        <category>Android</category>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SELinux</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BPF与eBPF]]></title>
    <url>%2F2019%2F11%2F07%2FBPF%E4%B8%8EeBPF%2F</url>
    <content type="text"><![CDATA[最近了解Linux的性能优化时, 偶然接触到了BPF(Berkeley Packet Filter)这个有意思的东西, 觉得很好玩.把学到的一些基本原理与知识记录下来, 算是一个初步的总结. 这篇文章主要从如下几个方面介绍下BPF : BPF的原理 什么是eBPF 如何在Linux中使用BPF 用过tcpdump的同学应该都了解pcap, 实际上pcap就是基于BPF来实现网络数据包的过滤的. tcpdump的原理如下图所示: tcpdump将包过滤的表达式, 如查看某个网口所有udp包, 输入tcpdump -n -i eth0 udp, 这个表达式通过PCAP库编译成伪机器字节码后, 通过系统调用发送给内核(内核中有对应的机器码解释器)解释执行, 这样只要系统有udp包, 内核都会过滤出来转发给用户进程tcpdump: BPF全称Berkeley Packet Filters, 最初是Steven MaCanne, Van Jacobson在文章‘The BSD Packet Filter: A New Architecture for User-level Packet Capture’中提出的一种基于BSD Unix操作系统的包过滤器, 其原理是将包过滤的表达式编译成特定伪机器码后, 由Kernel中的虚拟机执行; 每当网卡中有数据包过来时, 将其拷贝发送给BPF模块, 由BPF根据对应的过滤条件将过滤后的包发送给用户进程: 针对tcpdump, linux有专门用于包过滤的表达式, 参考pcap-filter BPF在Linux中的发展大致经历三个阶段: Linux 2.1.75最初的实现基于原有的socket接口, 被称为Linux Socket Filter(LSF) Linux 3.0版本中,在BPF中加入JIT(Just-In-Time Compiler), 提升BPF的性能与速度 Linux 3.15开始将BPF扩展成为通用的模块, BPF不仅可用于数据包过滤, 也可以用来进行内核事件跟踪/应用性能调优/流量控制(Traffic Control)等, 代码也统一整合到了/kernel/bpf, 这也是目前被称为eBPF(extended BPF)的原因, 而早前的BPF实现则被称为cBPF(classic BPF). 首先来看下传统的cBPF是如何实现的. cBPFBPF最初的BSD实现方案是通过打开一个字符设备/dev/bpf*(/dev/bpf0, /dev/bpf1 etc), 再通过ioctl来控制该设备, 而Linux内核则基于现有的socket接口加入新的选项SO_ATTACH_FILTER/SO_DETACH_FILTER来执行系统调用, 具体的代码实现在/net/core/filter.c. 通过一个简单的示例来看下cBPF是如何工作的. 首先通过tcpdump指令来产生数据包的过滤代码: tcpdump dst port 53 -dd(这里过滤所有目标端口为53的数据包) 然后创建一个AF_PACKET(用于接收所有的数据包)的socket用于向kernel传递过滤代码, 并接收过滤后的数据包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// tcpdump dst port 53 -ddstatic struct sock_filter filter_code[] = &#123; &#123; 0x28, 0, 0, 0x0000000c &#125;, &#123; 0x15, 0, 8, 0x000086dd &#125;, &#123; 0x30, 0, 0, 0x00000014 &#125;, &#123; 0x15, 2, 0, 0x00000084 &#125;, &#123; 0x15, 1, 0, 0x00000006 &#125;, &#123; 0x15, 0, 17, 0x00000011 &#125;, &#123; 0x28, 0, 0, 0x00000036 &#125;, &#123; 0x15, 14, 0, 0x00000035 &#125;, &#123; 0x28, 0, 0, 0x00000038 &#125;, &#123; 0x15, 12, 13, 0x00000035 &#125;, &#123; 0x15, 0, 12, 0x00000800 &#125;, &#123; 0x30, 0, 0, 0x00000017 &#125;, &#123; 0x15, 2, 0, 0x00000084 &#125;, &#123; 0x15, 1, 0, 0x00000006 &#125;, &#123; 0x15, 0, 8, 0x00000011 &#125;, &#123; 0x28, 0, 0, 0x00000014 &#125;, &#123; 0x45, 6, 0, 0x00001fff &#125;, &#123; 0xb1, 0, 0, 0x0000000e &#125;, &#123; 0x48, 0, 0, 0x0000000e &#125;, &#123; 0x15, 2, 0, 0x00000035 &#125;, &#123; 0x48, 0, 0, 0x00000010 &#125;, &#123; 0x15, 0, 1, 0x00000035 &#125;, &#123; 0x6, 0, 0, 0x00040000 &#125;, &#123; 0x6, 0, 0, 0x00000000 &#125;,&#125;;static struct sock_fprog bpf = &#123; .len = sizeof(filter_code)/(sizeof(struct sock_filter)), .filter = filter_code,&#125;;int main(int argc, char *argv[]) &#123; int sock_fd, bytes; char buf[4096]; struct sockaddr_ll addr; struct iphdr *ip_header; char src_addr[INET_ADDRSTRLEN], dst_addr[INET_ADDRSTRLEN]; char *iface_name; if (argc != 2) &#123; printf("Usage: %s iface_name\n", argv[0]); return 1; &#125; // 1. create socket sock_fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)); if (sock_fd &lt; 0) &#123; perror("socket created failure"); return 1; &#125; iface_name = argv[1]; memset(&amp;addr, 0, sizeof(addr)); addr.sll_ifindex = if_nametoindex(iface_name); addr.sll_family = AF_PACKET; addr.sll_protocol = htons(ETH_P_ALL); // 2. attach filter (no need to call bind) if (setsockopt(sock_fd, SOL_SOCKET, SO_ATTACH_FILTER, &amp;bpf, sizeof(bpf)) &lt; 0) &#123; perror("attaching filter failed"); return 2; &#125; for (;;) &#123; bytes = recv(sock_fd, buf, sizeof(buf), 0); if (bytes &lt; 1) &#123; perror("received data failed"); return -1; &#125; ip_header = (struct iphdr *) (buf + sizeof(struct ether_header)); inet_ntop(AF_INET, &amp;ip_header-&gt;saddr, src_addr, sizeof(src_addr)); inet_ntop(AF_INET, &amp;ip_header-&gt;daddr, dst_addr, sizeof(dst_addr)); printf("IPv%d proto=%d src=%s dest=%s\n", ip_header-&gt;version, ip_header-&gt;protocol, src_addr, dst_addr); &#125; return 0;&#125; 刚才说到在Linux 3.0版本中BPF加入了JIT; JIT能够提升伪机器码的执行效率. 从执行流程来说, 主要区别在于传入内核的socket_filter伪机器代码都会通过bpf_jit_compile进行优化处理, 然后再通过字节码解释器执行. 具体来说, 不同的平台bpf_jit_compile的实现不一样, 内核中的代码路径位于arch/&lt;platform&gt;/net/, 感兴趣的可以跳转到这里看下. eBPFeBPF即extended BPF, 顾名思义是对原有BPF进行了扩展, 这样不仅BPF可以用来过滤网络数据包(tcpdump/XDP), 也可以用于性能分析, 将BPF代码插入到内核的跟踪点(tracepoints), kprobes, perf事件, 收集相应的数据.除了扩展了cBPF的功能外, eBPF另一个不同于cBPF的地方在于调用的方式: eBPF提供了一个统一的bpf()系统调用来执行相应的操作,同时应用与内核的数据传递也统一通过map这种数据结构来进行. 比如用BPF_MAP_CREATE命令来创建一个eBPF的map对象(不同的内核事件对应的map类型不同): 12int bpf(int cmd, union bpf_attr *attr, unsigned int size) 我们可以通过man bpf来查看bpf系统调用的具体用法. eBPF对于内核的开发, 以及性能分析无疑是一大利器, 先通过具体的实例来看一看如何使用eBPF(Linux源码中有很多示例samples/bpf): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static int test_sock(void)&#123; int sock = -1, map_fd, prog_fd, i, key; long long value = 0, tcp_cnt, udp_cnt, icmp_cnt; // 创建一个bpf的array map用于保存结果 map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(key), sizeof(value), 256); if (map_fd &lt; 0) &#123; printf("failed to create map '%s'\n", strerror(errno)); goto cleanup; &#125; // eBPF对应的伪机器码 struct bpf_insn prog[] = &#123; BPF_MOV64_REG(BPF_REG_6, BPF_REG_1), BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr, protocol) /* R0 = ip-&gt;proto */), BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4), /* *(u32 *)(fp - 4) = r0 */ BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), /* r2 = fp - 4 */ BPF_LD_MAP_FD(BPF_REG_1, map_fd), BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2), BPF_MOV64_IMM(BPF_REG_1, 1), /* r1 = 1 */ BPF_RAW_INSN(BPF_STX | BPF_XADD | BPF_DW, BPF_REG_0, BPF_REG_1, 0, 0), /* xadd r0 += r1 */ BPF_MOV64_IMM(BPF_REG_0, 0), /* r0 = 0 */ BPF_EXIT_INSN(), &#125;; // 加载eBPF伪机器码到内核 prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, sizeof(prog), "GPL", 0); if (prog_fd &lt; 0) &#123; printf("failed to load prog '%s'\n", strerror(errno)); goto cleanup; &#125; sock = open_raw_sock("lo"); // 将该eBPF的伪代码绑定到某个socket上 if (setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd, sizeof(prog_fd)) &lt; 0) &#123; printf("setsockopt %s\n", strerror(errno)); goto cleanup; &#125; // 查询过滤得到的结果 for (i = 0; i &lt; 10; i++) &#123; key = IPPROTO_TCP; assert(bpf_lookup_elem(map_fd, &amp;key, &amp;tcp_cnt) == 0); key = IPPROTO_UDP; assert(bpf_lookup_elem(map_fd, &amp;key, &amp;udp_cnt) == 0); key = IPPROTO_ICMP; assert(bpf_lookup_elem(map_fd, &amp;key, &amp;icmp_cnt) == 0); printf("TCP %lld UDP %lld ICMP %lld packets\n", tcp_cnt, udp_cnt, icmp_cnt); sleep(1); &#125;cleanup: /* maps, programs, raw sockets will auto cleanup on process exit */ return 0;&#125; 可以看到,对于eBPF而言, 大概有如下几个执行步骤: 编写ePBF伪机器代码 调用bpf创建对应的map对象, 并将伪机器码加载到内核 内核对加载得到伪机器码进行优化/校验, 验证其是否合法(是否有非法指令等) 用户程序通过bpf的接口读取内核事件的结果 这个例子用的是类似汇编语言的方式来实现eBPF伪机器代码, 这个对于非专业的开发者来说实在有点痛苦. 那么, 能否通过其他高级语言来编写eBPF的代码了? 这就要用到专门的编译器LLVM(Lower Level Virtual Machine)了.通过LLVM, 我们只需要将需要执行的eBPF代码用C语言编写好后, 将其编译成elf格式的镜像(image)文件, 然后通过libelf库加载解析后, 装载到内核中执行. 如果去看samples/bpf中的其他示例, 都是通过类似的方式实现的. 了解了eBPF大致的执行流程, 我们一起来看下eBPF原理的框架简图(eBPF涉及的内核知识比较多, 刚开始建立一个整体的框架有助于理解): BCC即使有现成的编译工具LLVM, 有加载解析elf的库, 但对大部分开发者来说, 日常并没有太多时间精力一步步来开发这些eBPF工具与代码. 于是, 一些大牛们便搞出了一套BCC(BPF Compilation Collection)的eBPF工具集合, 这个工具集合把所有eBPF内核代码编写/编译以及错误处理的流程都封装好了, 使用时只需通过python/Lua等脚本语言进行调用,这里从BCC的示例中选出一个简单的例子, 可以看到BCC极大的简化了eBPF的开发与使用流程: 1234567891011121314#!/usr/bin/python# Copyright (c) PLUMgrid, Inc.# Licensed under the Apache License, Version 2.0 (the "License")# run in project examples directory with:# sudo ./hello_world.py"# see trace_fields.py for a longer examplefrom bcc import BPF# 每当发生`clone`系统调用时, 该脚本都会打印`hello world`# This may not work for 4.17 on x64, you need replace kprobe__sys_clone with kprobe____x64_sys_cloneBPF(text='int kprobe__sys_clone(void *ctx) &#123; bpf_trace_printk("Hello, World!\\n"); return 0; &#125;').trace_print() 如果Linux内核版本在4.4以上(如Ubuntu 16.04等), 可以通过如下指令安装BCC使用: 12345# echo "deb [trusted=yes] https://repo.iovisor.org/apt/xenial xenial-nightly main" | \ sudo tee /etc/apt/sources.list.d/iovisor.list# sudo apt-get update# sudo apt-get install bpfcc-tools # or the old package name: bcc-tools 相应的, BCC的工具会安装到/usr/share/bcc/tools下面.更多BCC功能的解锁说明可以参考Brendan D.Gregg性能优化大牛的eBPF介绍以及BCC的[官网]https://github.com/iovisor/bcc). 安装完成后, 无论是对CPU, 内存, 磁盘I/O还是网络数据的传输都可以利用这一套工具进行监控了. 参考文献 Breadan Gregg大牛的博客, 性能优化的大牛 BPF系统调用的说明 BPF的很详尽的介绍资料 Linux BPF实现的说明 LLVM开源项目的官网 BCC Github主页, 如何使用/安装/开发资料很全面 BCC入门级介绍 收集了很多eBPF相关的资料 BPF资料合集]]></content>
      <categories>
        <category>网络协议</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Berkeley Packet Filters</tag>
        <tag>extended Berkeley Packet Filters</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说Process.waitfor()引起的进程阻塞问题]]></title>
    <url>%2F2019%2F09%2F04%2F%E8%AF%B4%E8%AF%B4Process-waitfor-%E5%BC%95%E8%B5%B7%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近碰到一个看似很怪异的问题, 在两个APP上调用同样的本地指令得到的结果却大相径庭; 看源代码, 这个本地进程做的事情其实并不复杂: 从一个串口/dev/ttyUSBX读取数据 将数据写入到本地目录(读缓存大小为1KB) 本地进程的代码逻辑其实相当简单: 主线程起来后主动创建一个负责读/写的子线程, 然后通过pthread_join主动等待子线程完成后退出. 问题是, 应用A调用的时保存的日志大小雷打不动的停留在不到4M就停止了, 而应用B可以一直写数据. 看应用A调用时, 通过debuggerd -b &lt;tid&gt;查看本地进程的堆栈, 大概是这样的: 说明此时本地进程一直在”卡”在写数据上了, 那到底卡在哪里了? 查看cat /proc/&lt;pid&gt;/wchan(也可以通过strace -p &lt;pid&gt;来查看目前进程所调用的系统调用), 就是本地进程的正在执行的系统调用, 发现是pipe_wait, 这个是怎么回事? 本地进程本身并不会用到pipe来进行数据的传输, 那很可能是Java父进程与本地进程之间的数据通信管道了. 回到最开始的问题, 为何两个APP调用同样的指令会有如此大的差异了? 我们再来看看应用A与应用B之间执行的代码到底有多少的差异? 应用A的调用逻辑 123456789101112131415Process process = null;try &#123; process = Runtime.getRuntime().exec(COMMAND); process.waitFor();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; finally &#123; if(process != null) &#123; process.destroy(); &#125;&#125; 应用B的调用逻辑 12345678910111213Process process = null;try &#123; process = Runtime.getRuntime().exec(COMMAND);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; finally &#123; if(process != null) &#123; process.destroy(); &#125;&#125; 这么一对比, 看起来问题是出在Process.waitfor()上了, 看了网上一个类似的案例https://www.cnblogs.com/embedded-linux/p/6986525.html, 顿时觉得豁然开朗, 这个不就是我碰到问题末! 看 java.lang.Process的文档说明(这里只拿了最关键的一段话): 1234567891011121314By default, the created process does not have its own terminalor console. All its standard I/O (i.e. stdin, stdout, stderr)operations will be redirected to the parent process, where they canbe accessed via the streams obtained using the methods&#123;@link #getOutputStream()&#125;,&#123;@link #getInputStream()&#125;, and &#123;@link #getErrorStream()&#125;.The parent process uses these streams to feed input to and get outputfrom the process. Because some native platforms only providelimited buffer size for standard input and output streams, failureto promptly write the input stream or read the output stream ofthe process may cause the process to block, or even deadlock. 这段话的大概意思是, 通过Java创建的本地子进程本身是没有标准输入/输出以及错误流的, 这三个流都会被重定向到父进程; 父进程则通过Process.getInputStream()/getOutputStream等来获取子进程的流, 而如果父进程如果一直不读取子进程的输出流, 由于平台本身的输入输出流的缓冲大小是有限的, 此时子进程就可能阻塞, 甚至死锁(如果父进程也在等待子进程的话). 这样看起来, 问题的原因就很明显了: 应用A没有处理子进程的输出流, 且调用了Process.waitfor(), 由于本地进程一直在打印输出日志, 导致输出缓冲区满了之后发生阻塞, 而父进程并不知道子进程发生了阻塞, 一直傻傻的等.现在看来, 调用任何接口之前看看文档总是有益的, 至少在定位分析问题的时候可以少走弯路. 我们先来看下Java调用本地进程的整个处理流程, 再来看具体如何解决这个问题. 调用Runtime.exec(cmd): 12345678910111213141516171819202122232425262728293031 public Process exec(String prog) throws java.io.IOException &#123;return exec(prog, null, null); &#125; public Process exec(String prog, String[] envp, File directory) throws java.io.IOException &#123;// Sanity checksif (prog == null) &#123; throw new NullPointerException("prog == null");&#125; else if (prog.isEmpty()) &#123; throw new IllegalArgumentException("prog is empty");&#125;// Break down into tokens, as described in Java docsStringTokenizer tokenizer = new StringTokenizer(prog);int length = tokenizer.countTokens();String[] progArray = new String[length];for (int i = 0; i &lt; length; i++) &#123; progArray[i] = tokenizer.nextToken();&#125;// Delegatereturn exec(progArray, envp, directory); &#125; public Process exec(String[] progArray, String[] envp, File directory) throws IOException &#123; // ProcessManager is responsible for all argument checking. return ProcessManager.getInstance().exec(progArray, envp, directory, false); &#125; 接着调用ProcessManager.getInstance().exec(): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Executes a process and returns an object representing it. */public Process exec(String[] taintedCommand, String[] taintedEnvironment, File workingDirectory, boolean redirectErrorStream) throws IOException &#123; // Make sure we throw the same exceptions as the RI. if (taintedCommand == null) &#123; throw new NullPointerException("taintedCommand == null"); &#125; if (taintedCommand.length == 0) &#123; throw new IndexOutOfBoundsException("taintedCommand.length == 0"); &#125; // Handle security and safety by copying mutable inputs and checking them. String[] command = taintedCommand.clone(); String[] environment = taintedEnvironment != null ? taintedEnvironment.clone() : null; // Check we're not passing null Strings to the native exec. for (int i = 0; i &lt; command.length; i++) &#123; if (command[i] == null) &#123; throw new NullPointerException("taintedCommand[" + i + "] == null"); &#125; &#125; // The environment is allowed to be null or empty, but no element may be null. if (environment != null) &#123; for (int i = 0; i &lt; environment.length; i++) &#123; if (environment[i] == null) &#123; throw new NullPointerException("taintedEnvironment[" + i + "] == null"); &#125; &#125; &#125; FileDescriptor in = new FileDescriptor(); FileDescriptor out = new FileDescriptor(); FileDescriptor err = new FileDescriptor(); String workingPath = (workingDirectory == null) ? null : workingDirectory.getPath(); // Ensure onExit() doesn't access the process map before we add our // entry. synchronized (processReferences) &#123; int pid; try &#123; // 调用JNI方法, 创建一个子进程, 并返回对应的PID pid = exec(command, environment, workingPath, in, out, err, redirectErrorStream); &#125; catch (IOException e) &#123; IOException wrapper = new IOException("Error running exec()." + " Command: " + Arrays.toString(command) + " Working Directory: " + workingDirectory + " Environment: " + Arrays.toString(environment)); wrapper.initCause(e); throw wrapper; &#125; ProcessImpl process = new ProcessImpl(pid, in, out, err); ProcessReference processReference = new ProcessReference(process, referenceQueue); processReferences.put(pid, processReference); /* * This will wake up the child monitor thread in case there * weren't previously any children to wait on. */ processReferences.notifyAll(); return process; &#125;&#125; 在看下对应的JNI方法java_lang_ProcessManager.cpp, 看到ExecuteProcess中将子进程的输入输出以及错误流均重定向到pipe的一端, 而pipe的另一端则对应着父进程的输出输入以及错误流, 这样一看子进程所阻塞的函数pipe_wait正是因为输出流缓冲满了, 无法再继续写了(那么, 可能还有疑问? 为何本地进程一直要写pipe了, 手动输入命令调用下就知道, 这个本地进程一直变态的在打印自己写入数据的文件名到标准输出). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144static pid_t ProcessManager_exec(JNIEnv* env, jclass, jobjectArray javaCommands, jobjectArray javaEnvironment, jstring javaWorkingDirectory, jobject inDescriptor, jobject outDescriptor, jobject errDescriptor, jboolean redirectErrorStream) &#123; ExecStrings commands(env, javaCommands); ExecStrings environment(env, javaEnvironment); // Extract working directory string. const char* workingDirectory = NULL; if (javaWorkingDirectory != NULL) &#123; workingDirectory = env-&gt;GetStringUTFChars(javaWorkingDirectory, NULL); &#125; pid_t result = ExecuteProcess(env, commands.get(), environment.get(), workingDirectory, inDescriptor, outDescriptor, errDescriptor, redirectErrorStream); // Clean up working directory string. if (javaWorkingDirectory != NULL) &#123; env-&gt;ReleaseStringUTFChars(javaWorkingDirectory, workingDirectory); &#125; return result;&#125;/** Executes a command in a child process. */static pid_t ExecuteProcess(JNIEnv* env, char** commands, char** environment, const char* workingDirectory, jobject inDescriptor, jobject outDescriptor, jobject errDescriptor, jboolean redirectErrorStream) &#123; // Create 4 pipes: stdin, stdout, stderr, and an exec() status pipe. int pipes[PIPE_COUNT * 2] = &#123; -1, -1, -1, -1, -1, -1, -1, -1 &#125;; for (int i = 0; i &lt; PIPE_COUNT; i++) &#123; if (pipe(pipes + i * 2) == -1) &#123; jniThrowIOException(env, errno); ClosePipes(pipes, -1); return -1; &#125; &#125; int stdinIn = pipes[0]; int stdinOut = pipes[1]; int stdoutIn = pipes[2]; int stdoutOut = pipes[3]; int stderrIn = pipes[4]; int stderrOut = pipes[5]; int statusIn = pipes[6]; int statusOut = pipes[7]; pid_t childPid = fork(); // If fork() failed... if (childPid == -1) &#123; jniThrowIOException(env, errno); ClosePipes(pipes, -1); return -1; &#125; // If this is the child process... if (childPid == 0) &#123; // Note: We cannot malloc(3) or free(3) after this point! // A thread in the parent that no longer exists in the child may have held the heap lock // when we forked, so an attempt to malloc(3) or free(3) would result in deadlock. // Replace stdin, out, and err with pipes. dup2(stdinIn, 0); dup2(stdoutOut, 1); if (redirectErrorStream) &#123; dup2(stdoutOut, 2); &#125; else &#123; dup2(stderrOut, 2); &#125; // Close all but statusOut. This saves some work in the next step. ClosePipes(pipes, statusOut); // Make statusOut automatically close if execvp() succeeds. fcntl(statusOut, F_SETFD, FD_CLOEXEC); // Close remaining unwanted open fds. CloseNonStandardFds(statusOut); // Switch to working directory. if (workingDirectory != NULL) &#123; if (chdir(workingDirectory) == -1) &#123; AbortChild(statusOut); &#125; &#125; // Set up environment. if (environment != NULL) &#123; extern char** environ; // Standard, but not in any header file. environ = environment; &#125; // Execute process. By convention, the first argument in the arg array // should be the command itself. execvp(commands[0], commands); AbortChild(statusOut); &#125; // This is the parent process. // Close child's pipe ends. close(stdinIn); close(stdoutOut); close(stderrOut); close(statusOut); // Check status pipe for an error code. If execvp(2) succeeds, the other // end of the pipe should automatically close, in which case, we'll read // nothing. int child_errno; ssize_t count = TEMP_FAILURE_RETRY(read(statusIn, &amp;child_errno, sizeof(int))); close(statusIn); if (count &gt; 0) &#123; // chdir(2) or execvp(2) in the child failed. // TODO: track which so we can be more specific in the detail message. jniThrowIOException(env, child_errno); close(stdoutIn); close(stdinOut); close(stderrIn); // Reap our zombie child right away. int status; int rc = TEMP_FAILURE_RETRY(waitpid(childPid, &amp;status, 0)); if (rc == -1) &#123; ALOGW("waitpid on failed exec failed: %s", strerror(errno)); &#125; return -1; &#125; // Fill in file descriptor wrappers. jniSetFileDescriptorOfFD(env, inDescriptor, stdoutIn); jniSetFileDescriptorOfFD(env, outDescriptor, stdinOut); jniSetFileDescriptorOfFD(env, errDescriptor, stderrIn); return childPid;&#125; 如果有兴趣还可以继续看下kernel的代码fs/pipe.c是如何实现pipe_write/pipe_read以及pipe_wait是如何发生的. 这么一看代码流程, 如何解决这个问题的思路也有了, 大致有这么几种: 直接在Java代码中去掉Process.waitfor(), 这个方法可能还是会有导致子进程阻塞的风险, 虽然不会死锁 在新的线程中读取子线程的输出流:Process.getInputStream(), 这样确保子进程不会被阻塞 直接将子进程的流全部丢弃(如果本身不感兴趣的话) 要写本地进程的人把所有这些不必要的打印全部去掉(这个最好不要当作终极解决方案)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Process</tag>
        <tag>waitfor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊TCP协议]]></title>
    <url>%2F2019%2F07%2F30%2F%E8%81%8A%E4%B8%80%E8%81%8ATCP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[TCP(Transmission Control Protocol)即传输控制协议, 位于TCP/IP协议栈的第三层传输层, 与UDP不同的是, TCP号称提供有链接的(connection-oriented), 可靠的(reliable)字节流服务, 很多其他应用层协议如HTTP/SMTP/MQTT都是基于TCP协议实现. 这篇文章我们就从定义的角度来看一看TCP协议的具体工作原理. 首先看下有链接的(connection-oriented)具体含义. TCP在发送数据之前, 第一件事情就是要在通信的双方建立一个通信的链路, 这个有点像日常生活中的打电话: A向B发起通话请求, B确认后双方建立通信链接才能正式通话. TCP也一样, 在发送任何数据之前必须要建立链接(connection), 这个建立通信链接的过程就是我们常说的”三次握手”；同样, 如果要想结束通信, 也需要有一个挥手的过程(四次挥手).有关TCP链接的建立与关闭可以参考之前的一篇文章(TCP的链接建立与状态迁移). 那么, TCP建立链接主要完成哪几件事情了? 交换双方的ISN(Initial Sequence Number): ISN的作用(后面在讲重传时会再讲到)是用来确保每个TCP数据包都是唯一的, 接收端如果收到了重复包可以根据每个包的序列号来实现去重 确认发送数据的MSS(Maximum Segment Size): MSS是TCP能发送的数据的最大值, 通过TCP头中的options交换, 默认值是536, 一般是当前系统MTU(Maximum Transmission Unit)的值减去TCP/IP协议头的大小之和(40byte), 其与MTU关系如下图所示 接收窗口的大小: 在TCP头中有一个window项, 用来告诉对端自己接收缓冲区的大小, 这个窗口在拥塞与流量控制中扮演着十分重要的角色, 用于告诉发送方最大可以发送的数据大小 通信双方在三次握手完成之后, 都知道了对方的初始序列号(ISN), 接收窗口大小以及MSS, 这样发送方就可以开始愉快的发送数据了. 接着讲第二个方面: TCP是如何做到要数据的可靠(reliable)传输的? 为了实现这一目标,TCP需要解决很多问题: 数据在网络上丢包了如何办? TCP对于每个数据包都有个定时器, 如果接收方长时间没有回应, 在定时器超是后就会发起重传, 那么如何选择这个定时器的时长? 重传时间(Retransmission Timeout, RTO)太长, 导致数据传输效率太低; RTO太短, 则可能导致重传的数据包太多, 引发更大的网络拥堵. 发送方如何来控制自己数据的发送速率, 确保接收方能够处理的过来. 发送方不能不顾一切的发送数据, 而不管接收方是否有足够的空间来接受数据. 因此, TCP在接收方忙/没有足够空间接收数据时都会主动降低发送速度, 让接收方可以有机会及时恢复.这个是TCP流量控制(flow control)需要做的事情 如果网络发生拥塞, TCP应该如何处理?发送端不能不顾及网络带宽以及拥堵状态而只管发送数据包, 进而影响其他用户正常使用网络.为了体现网络使用的公平性, 确保不同用户能够都能均衡的使用网络, 减少用户之间的相互干扰, TCP通过多种拥塞控制(Congestion Control)手段来减少网络拥堵, 并且在发生拥堵时尝试尽快恢复. 具体说来TCP主要通过如下几个方式来解决上述几个问题: 重传时间的计算: 如何实时调整RTO(retransmission timeout)的大小, 确保重传的频率在合适的范围 流量控制(flow control): 通过滑动窗口(sliding window)机制来实现数据发送的流量控制 拥塞控制(Congestion Control): 拥塞控制主要有 (1) 慢启动 ; (2) 拥塞避免； (3) 拥塞发生； (4) 快速恢复. 在后面会一一介绍这几个算法的原理. 何时重传为了确保数据的可靠传达, TCP每发送一个数据包, 接收方都要回应一个ACK包, 发送方在发送完一个数据包后就会启动一个重传定时器(retransmission timer), 如果在定时器超时后都未能收到对方的ACK包, 就会重传. 那么如何发送方如何知道重传的超时时间(Retransmission Timeout, RTO)? (在TCP的标准协议文档RFC793中给出了一个低通滤波的计算方式, 式中alpha一般为0.9, RTT(Round Trip Time)表示测量得到的返程时间, R表示平滑后的RTT: $$ R = \alpha R + (1 - \alpha) RTT$$ 而RTO是在平滑后的RTT乘以一个系数beta(一般取值为2)得到: $$ RTO = \beta R $$ 按照上述的计算得到RTO, 由于采用低通滤波,因而没有考虑到在网络发生波动(比如网络拥堵, 路由故障等)等情况下RTT变大的情况, 导致不必要的重传, 反而带来更大的网络负载, 导致网络陷入持久的拥堵.针对该问题, Jacobson在1988年提出了一个改进的RTO计算方法(链接, 该算法考虑到了由于网络波动导致的延迟, 因此可以更准确的反映网络拥塞状态: 上述公式, MRTT代表实际测量得到的RTT, SRTT表示平滑后的RTT值, D实际表示的是RTT的平均方差(不是平方差), g一般设为1/8(0.125), 而h设为0.25.对于发生了重传的情况, RTO一般会通过指数回退的方式进行倍乘(Karn and Partridge 1987). 流量控制: 如何控制发送速率收发数据的两端常常在网络带宽以及性能上都存在差异, (快的)发送方如果不控制发送的速度, 可能会让处在慢速网络中的接收方不知所措.因此, 为了实现数据的可靠传输, TCP需要根据接收方的信息及时调整发送速率, 这个控制发送流量的技术就是著名的滑动窗口(sliding window)协议.简单地讲, 滑动窗口是要根据接收方的可用window(TCP缓存)的大小来达到调整接收方流量大小的目的, 下图是一个滑动窗口示意图(图片来自TCP/IP Guide): 图中的数据主要分为4个部分: ‘#1’: 表示已经发送的数据, 并且收到了ACK ‘#2’: 表示发送了的数据, 但是没有收到ACK确认 ‘#3’: 尚未发送的数据(接收方还有空间) ‘#4’: 不可发送的数据(接收方没有足够空间, 无能为力) 当发送了部分#3的数据更新后的滑动窗口如下图所示(图片来自TCPIP Guide): 可以看到此时可用的部分窗口大小变成了0, 后续要等到接收方确认了#2部分的数据后, 窗口才会继续往前滑动.那么TCP协议是如何在数据传输过程中调整窗口大小(window size)的了? 了解TCP协议的人应该记得, 在TCP协议头有一个专门的字段window用于通信的两端来告知对方当前窗口的大小(能接收多少数据), 而通过socket的SO_RCVBUF参数可以来设置通信时接收缓冲区的大小(socket(7)). 下图是一个接发数据过程通信两端TCP窗口大小的更新过程: 在发送数据的开始, 接收端会在三次握手时告知发送端自己的window size(图中为360) 随着发送端不断发送数据, 接收端的window会逐渐减少, 直到为0, 此时发送端会暂停发送数据 问题来了, 如果接收方的window为0, 要如何处理?对于接收端, 在接收缓冲区可用后(如应用从读取了部分数据), 会发送一个window update的ACK包, 那万一这个ACK在传输过程中丢失了怎么办? 这样就会导致发送端的TCP无法正常关闭, 因此需要通过在发送端每隔一段时间就发送一个Zero Window Probe的探测包, 来获取接收端窗口的状态, 关于ZWP的说明可以参考(RFC1122)的讨论. Silly Window SyndromeSilly Window Syndrome(中译为糊涂窗口综合症)的意思是, 接收端的应用可能每次都只拿走很少的一部分(比如几个字节)的数据, 因此每次window update后发送端也只会发送几个字节的数据, 而我们知道, 光TCP+IP两个协议头都需要40个字节的空间,这样的传输效率看起来太低了.针对该问题, 有两种策略: 如果问题发生在接收端(接收端处理太慢等), 则可以在window小于某个值时, 直接向发送端ACK一个window=0的包, 告诉发送端暂停发送, 等window大于某个值(比如MSS/2)时再发送window update包让发送方继续发送数据; 而如果问题发生在发送方,则可以考虑Nagle在1984年提出的Nagle AlgorithmRFC896: 对于一个TCP连接, 只要还有一个数据包的没有被确认, 就将应用发送的数据缓存下来, 直到接收到该数据包的ACK之后才允许发送新的数据.这样TCP就尽可能的发送”大”的数据包, 而不是发送多个小包, 导致效率降低. 但对于某些交互式应用如Telenet/SSH/Rlogin, 为了避免延时带来的交互延时, 通常需要关闭Nagle算法, 可以通过socket的选项参数TCP_NODELAY来关闭该算法, 从而提升交互体验. 拥塞控制TCP的滑动窗口很好的控制了接收端与发送端的包速率, 但并没有考虑到中间网络如路由器/交换机拥塞/故障引发的网络拥堵, 为了避免网络拥塞引起网络瘫痪(congestion collapse), TCP需要对网络的拥塞信号做出反应(发生丢包/包乱序等). 总的说来, TCP的拥塞控制(congestion control)是为了: (1) 尽可能减少拥塞导致的网络瘫痪(如某个路由节点由于不堪重负崩溃或者卡死)； (2) 网络使用的公平性(faireness): TCP的目标是尽可能使每个网络的使用者都达到比较好的体验, 避免某一个发送端或者接收端过度的占用网络带宽. 在RFC5681(TCP Congestion Control)中总结了四个拥塞控制算法: 慢启动TCP慢启动(slow start)的意思是开始发送数据时, 尽量逐步增加发送的数据量, 而不是最开始就发送一个大的数据包, 这样试探性的发送数据可以减少网络拥塞.为了实现慢启动以及拥塞避免(与慢启动配套的算法, 接下来会讲到), 需要引入两个状态变量: (1) 拥塞窗口(congestion window) cwnd; (2) 慢启动阈值(slow start threshold) ssthresh, 这个阈值用于慢启动与拥塞避免两个算法之间的切换. 慢启动算法的大致步骤如下: 将cwnd设为1, 表示一个MSS大小(目前一般Linux系统都按照Google的建议将该值设为10) 每次接收到一个ACK后, cwnd += 1 这样收到一个ACK后,cwnd变为2,接着会发出两个MSS的数据包, ACK会变成4, 最终发送的包数量呈指数上升.等到cwnd &gt; ssthresh, 则进入拥塞避免阶段, TCP会根据收发包的丢包重传的情况, 适当调整cwnd的值, 确保不要让网络变得过度拥堵. 拥塞避免当cwnd &gt; ssthresh时, TCP进入拥塞避免(congestion avoidance), 此时cwnd会进入线性调整阶段: sshthresh的值大小一般初始化为65535(0x7ffffff) cwnd += 1/cwnd(参考[https://tools.ietf.org/html/rfc5681] 每过一个RTT, 则cwnd = cwnd + 1 当发生RTO重传时, 需要减少sshthresh的值, 同时减少cwnd的值: sshthresh = max(FlightSize/2, 2*MSS) cwnd = 1 这样在重传之后TCP又进入了慢启动模式, 逐步增加发送数据包的速率. 快速重传与快速恢复先来了解下快速重传(fast restransmition)与快速恢复(fast recovery)的具体含义: 快速重传: 在TCP接收到连续3次DACK(duplicate ACK)后, 主动重传丢失的数据包, 而不是等到RTO超时 快速恢复: 当TCP完成快速重传后, 会进入拥塞避免而不是慢启动, 这样确保发送的流量在适当的拥塞之后保持稳定 一般来说, 快速重传与快速恢复是同一起实现的, 具体的流程如下: 如果连续收到三个DACk包, 则重传丢失的数据包 更新拥塞窗口以及慢启动阈值: sshthresh = max(FlightSize/2, 2*MSS) 以及cwnd = ssthresh + 3 * MSS 后续每收到一个DACK, 增加将拥塞窗口加一: cwnd = cwnd + 1 如果收到ACK, 则cwnd = sshthresh, 这样TCP会再次进入拥塞控制 实际TCP针对丢包与重传的情况还有很多改善型算法, 详细可以参考RFC5681 参考文献 TCP流量控制 TCP滑动窗口 TCP的那些事情, 耗子叔的力作 Congestion Control Principles TCP roadmap TCP congestion control TCP/IP协议的各种问题的总结]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>拥塞控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP链接建立与状态迁移]]></title>
    <url>%2F2019%2F07%2F15%2FTCP%E9%93%BE%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[学习TCP协议的第一步是要了解熟悉TCP的三次握手/四次挥手以及状态迁移图. 这篇文章用三个图展示TCP链接的建立与关闭以及状态的迁移. TCP状态迁移根据TCP协议的文档RFC793, 一个TCP链接有下图中的几个状态(图中实粗线为Client端的正常情况下状态迁移图, 虚线为Server端正常情况下的状态迁移图): CLOSED: TCP链接的初始状态, 表示没有任何链接 LISTEN: (服务端)等待来自远程客户端的请求 SYN_SENT: 发送了一个建立TCP链接的SYN请求, 等待对端返回结果 SYN_RCVD: 收到了TCP建立链接的SYN包, 等待对方的回应(ACK) ESTABLISHED: TCP链接建立成功, 从这里开始可以交换数据包了 FIN_WAIT1: 应用进程关闭了TCP链接(发送FIN包), 并等待对端的响应 FIN_WAIT2: 接收到关闭回应后, 等待对端结束TCP链接(等待FIN包) CLOSING: 如果两端同时接收到了FIN包, 则进入该状态 CLOSE_WAIT:处于被动关闭一端接受到FIN请求后, 等待本地进程的关闭TCP链接 LAST_ACK: 服务端本地进程关闭TCP链接后, 发送FIN包, 等待回应 TIME_WAIT: 等待2*MSL(TCP包的最大存活时间)后关闭该TCP链接, 等待足够长的时间是为了确保最后关闭链接的ACK包有足够长的时间达到对端, 如果对端未能收到该包, 则会重传FIN包, 这样对端也可以重传ACK包, 一般MSL为60s TCP三次握手与四次挥手正常情况下, TCP的三次握手与四次挥手如下图所示: 同时关闭时的TCP状态变化如果TCP通信的两端同时请求关闭链接, 流程如下图所示: 关于TCP协议的参考资料: RFC793: 这是有关TCP协议的标准文本, 信息的源头 &lt;TCP/IP详解 卷1&gt;: W. Richard Stevens的经典, 必看]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PPP拨号时拿到错误DNS的问题解析]]></title>
    <url>%2F2019%2F07%2F05%2FPPP%E6%8B%A8%E5%8F%B7%E6%97%B6%E6%8B%BF%E5%88%B0%E9%94%99%E8%AF%AFDNS%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近碰到一个PPP拨号拿到了假的DNS地址10.11.12.13/14, 之前也发生过一次, 但是一直没有有效的日志, 所以就简单粗暴的做了一个方案: 在PPP拨号进行网络参数协商时, 如果发现拿到了10.11.12.13/14这样的DNS地址就修改为指定的运营商DNS地址. 本来以为万事大吉了, 没想到运营商DNS一改, 问题又暴露了, 好在重现抓到了现场日志, 终于找到了原因. 网上看有原来也有不少人碰到了类似现象(https://bugzilla.redhat.com/show_bug.cgi?id=467004#c31), 在这里简要的描述下整个问题的来龙去脉并给出几种可能的解决方案. 在介绍这个问题的根因之前, 先来了解下PPP协议的一些基本概念. PPP协议介绍PPP(Point-to-Point Protocol)是在SLIP(Serial Line Internet Protocol)的基础上发展而来, 其通过在终端与远端(remote peer)之间建立一个IPPP数据链路, 将终端设备接入网络. 早些年上网的时候, 把一个ADSL modem跟电脑连接后, 拿着运营商给的用户名与密码, 然后拨号接入互联网,这里边用到的协议就是PPP. PPP协议位于TCP/IP协议栈的第二层-数据链路层(见下图), 其主要有三个部分组成: 包封装: 如何将网络报文如IP报文封装成类似与HDLC的格式 LCP协议: Link Control Protocol, 负责建立数据链路, 验证用户身份以及测试链路的连通状态 NCP协议: Network Control Protocol, 负责适配其他协议, 如针对IP协议有IPCP协议, 该协议的功能是从网络侧拿到IP地址以及DNS地址 一般来说, PPP拨号上网有如下几个阶段: 链路建立阶段(Establish): LCP协议负责建立数据链路, 建立链路过程主要是协商数据的压缩格式以及最大传输单元MRU(Maximum Receive Unit, 类似于MTU) 身份验证阶段(Authenticate): 主要是通过PAP/CHAP等协议验证用户的身份(用户名与密码) 网络阶段(Network): 协商网络参数, 如IP地址, DNS地址等. 网络阶段完成后, 就可以真正进行数据报文的接发了. 在NCP阶段, PPP拨号进行参数协商过程中一般都有如下几个指令: Configure-Request(发起参数协商), Configure-Ack(如果同意该参数则发送ACK给对端), Configure-Nak(如果参数合法, 但是有不同意对方的某些参数, 则发送NAK给对端), Configure-Reject(如果不同意对方发送过来的参数, 则直接发送Reject), 具体可以参考RFC1661的文档(rfc1661).下图是一个完整基于IPCP协议的消息交换过程: 有了这些知识背景, 就来看下具体的问题是怎么样的. 假DNS问题的来由问题发生终端大致的网络架构如下图所示:终端通过modem与运营商的LNS节点建立一个PPP的链路, 然后通过该链路接入私有网络: 图中的LAC/LNS分别指L2TP Access Concentrator/L2TP Network Server， 参考Wikipedia 这里系统使用的是高通的modem, 在LTE网络下使用PPP拨号从运营商网关拿IP/DNS地址. PPP拨号时, 实际已经通过了身份验证, 但在IPCP协议进行参数协商时, 前面一直拿到了10.11.12.13/14这样的DNS地址, 后面运营商下发了正确的DNS地址, modem也未能把正确的DNS地址发送过来, PPPD拨号的过程日志如下, 1234567891011121314151617181920212223242526272829303132333435363738394041424344454607-02 20:40:37.024 3183 3183 D pppd : using channel 307-02 20:40:37.024 3183 3183 D pppd : sent [LCP ConfReq id=0x1 &lt;asyncmap 0x0&gt; &lt;magic 0x6c3c9df8&gt; &lt;pcomp&gt; &lt;accomp&gt;]07-02 20:40:37.024 3183 3183 D pppd : rcvd [LCP ConfReq id=0x3 &lt;asyncmap 0x0&gt; &lt;auth pap&gt; &lt;magic 0xf2cb3c8d&gt; &lt;pcomp&gt; &lt;accomp&gt;]07-02 20:40:37.024 3183 3183 D pppd : sent [LCP ConfAck id=0x3 &lt;asyncmap 0x0&gt; &lt;auth pap&gt; &lt;magic 0xf2cb3c8d&gt; &lt;pcomp&gt; &lt;accomp&gt;]07-02 20:40:37.024 3183 3183 D pppd : rcvd [LCP ConfAck id=0x1 &lt;asyncmap 0x0&gt; &lt;magic 0x6c3c9df8&gt; &lt;pcomp&gt; &lt;accomp&gt;]07-02 20:40:37.034 3183 3183 D pppd : rcvd [LCP DiscReq id=0x4 magic=0xf2cb3c8d]07-02 20:40:37.034 3183 3183 D pppd : rcvd [PAP AuthAck id=0x1 ""]07-02 20:40:37.034 3183 3183 I pppd : PAP authentication succeeded07-02 20:40:37.034 3183 3183 D pppd : sent [CCP ConfReq id=0x1 &lt;deflate 15&gt; &lt;deflate(old#) 15&gt; &lt;bsd v1 15&gt;]// IPCP开始协商IP地址, DNS地址等参数07-02 20:40:37.034 3183 3183 D pppd : sent [IPCP ConfReq id=0x1 &lt;compress VJ 0f 01&gt; &lt;addr 0.0.0.0&gt; &lt;ms-dns1 0.0.0.0&gt; &lt;ms-dns3 0.0.0.0&gt;]07-02 20:40:37.034 3183 3183 D pppd : rcvd [LCP ProtRej id=0x5 80 fd 01 01 00 0f 1a 04 78 00 18 04 78 00 15 03 2f]07-02 20:40:38.034 3183 3183 D pppd : rcvd [IPCP ConfNak id=0x1 &lt;ms-dns1 10.11.12.13&gt; &lt;ms-dns3 10.11.12.14&gt; &lt;ms-wins 10.11.12.13&gt; &lt;ms-wins 10.11.12.14&gt;]07-02 20:40:38.034 3183 3183 D pppd : sent [IPCP ConfReq id=0x2 &lt;compress VJ 0f 01&gt; &lt;addr 0.0.0.0&gt; &lt;ms-dns1 10.11.12.13&gt; &lt;ms-dns3 10.11.12.14&gt;]07-02 20:40:39.034 3183 3183 D pppd : rcvd [IPCP ConfNak id=0x2 &lt;ms-dns1 10.11.12.13&gt; &lt;ms-dns3 10.11.12.14&gt; &lt;ms-wins 10.11.12.13&gt; &lt;ms-wins 10.11.12.14&gt;]07-02 20:40:39.034 3183 3183 D pppd : sent [IPCP ConfReq id=0x3 &lt;compress VJ 0f 01&gt; &lt;addr 0.0.0.0&gt; &lt;ms-dns1 10.11.12.13&gt; &lt;ms-dns3 10.11.12.14&gt;]07-02 20:40:40.034 3183 3183 D pppd : rcvd [IPCP ConfNak id=0x3 &lt;ms-dns1 10.11.12.13&gt; &lt;ms-dns3 10.11.12.14&gt; &lt;ms-wins 10.11.12.13&gt; &lt;ms-wins 10.11.12.14&gt;]07-02 20:40:40.034 3183 3183 D pppd : sent [IPCP ConfReq id=0x4 &lt;compress VJ 0f 01&gt; &lt;addr 0.0.0.0&gt; &lt;ms-dns1 10.11.12.13&gt; &lt;ms-dns3 10.11.12.14&gt;]07-02 20:40:41.044 3183 3183 D pppd : rcvd [IPCP ConfNak id=0x4 &lt;ms-dns1 10.11.12.13&gt; &lt;ms-dns3 10.11.12.14&gt; &lt;ms-wins 10.11.12.13&gt; &lt;ms-wins 10.11.12.14&gt;]07-02 20:40:41.044 3183 3183 D pppd : sent [IPCP ConfReq id=0x5 &lt;compress VJ 0f 01&gt; &lt;addr 0.0.0.0&gt; &lt;ms-dns1 10.11.12.13&gt; &lt;ms-dns3 10.11.12.14&gt;]07-02 20:40:42.044 3183 3183 D pppd : rcvd [IPCP ConfNak id=0x5 &lt;ms-dns1 10.11.12.13&gt; &lt;ms-dns3 10.11.12.14&gt; &lt;ms-wins 10.11.12.13&gt; &lt;ms-wins 10.11.12.14&gt;]07-02 20:40:42.044 3183 3183 D pppd : sent [IPCP ConfReq id=0x6 &lt;compress VJ 0f 01&gt; &lt;addr 0.0.0.0&gt;]07-02 20:40:43.044 3183 3183 D pppd : rcvd [IPCP ConfNak id=0x6 &lt;ms-dns1 10.11.12.13&gt; &lt;ms-dns3 10.11.12.14&gt; &lt;ms-wins 10.11.12.13&gt; &lt;ms-wins 10.11.12.14&gt;]07-02 20:40:43.044 3183 3183 D pppd : sent [IPCP ConfReq id=0x7 &lt;compress VJ 0f 01&gt; &lt;addr 0.0.0.0&gt;]07-02 20:40:44.044 3183 3183 D pppd : rcvd [IPCP ConfNak id=0x7 &lt;ms-dns1 10.11.12.13&gt; &lt;ms-dns3 10.11.12.14&gt; &lt;ms-wins 10.11.12.13&gt; &lt;ms-wins 10.11.12.14&gt;]07-02 20:40:44.044 3183 3183 D pppd : sent [IPCP ConfReq id=0x8 &lt;compress VJ 0f 01&gt; &lt;addr 0.0.0.0&gt;]07-02 20:40:45.044 3183 3183 D pppd : rcvd [IPCP ConfNak id=0x8 &lt;ms-dns1 10.11.12.13&gt; &lt;ms-dns3 10.11.12.14&gt; &lt;ms-wins 10.11.12.13&gt; &lt;ms-wins 10.11.12.14&gt;]07-02 20:40:45.044 3183 3183 D pppd : sent [IPCP ConfReq id=0x9 &lt;compress VJ 0f 01&gt; &lt;addr 0.0.0.0&gt;]// 到现在才收到远端(remote peer)的IP协商请求07-02 20:40:45.644 3183 3183 D pppd : rcvd [IPCP ConfReq id=0x2]07-02 20:40:45.644 3183 3183 D pppd : sent [IPCP ConfNak id=0x2 &lt;addr 0.0.0.0&gt;]07-02 20:40:45.644 3183 3183 D pppd : rcvd [IPCP ConfRej id=0x9 &lt;compress VJ 0f 01&gt;]07-02 20:40:45.644 3183 3183 D pppd : sent [IPCP ConfReq id=0xa &lt;addr 0.0.0.0&gt;]07-02 20:40:45.644 3183 3183 D pppd : rcvd [IPCP ConfReq id=0x3]07-02 20:40:45.644 3183 3183 D pppd : sent [IPCP ConfAck id=0x3]07-02 20:40:45.644 3183 3183 D pppd : rcvd [IPCP ConfNak id=0xa &lt;addr 10.200.16.23&gt;]07-02 20:40:45.644 3183 3183 D pppd : sent [IPCP ConfReq id=0xb &lt;addr 10.200.16.23&gt;]07-02 20:40:45.644 3183 3183 D pppd : rcvd [IPCP ConfAck id=0xb &lt;addr 10.200.16.23&gt;]07-02 20:40:45.644 3183 3183 W pppd : Could not determine remote IP address: defaulting to 10.64.64.6407-02 20:40:45.654 3183 3183 I pppd : local IP address 10.200.16.2307-02 20:40:45.654 3183 3183 I pppd : remote IP address 10.64.64.6407-02 20:40:45.654 3183 3183 I pppd : primary DNS address 10.11.12.1307-02 20:40:45.654 3183 3183 I pppd : secondary DNS address 10.11.12.1407-02 20:40:45.654 3183 3183 D pppd : Script /etc/ppp/ip-up started (pid 3229)07-02 20:40:45.714 3183 3183 D pppd : Script /etc/ppp/ip-up finished (pid 3229), status = 0x0 可以看到在第一次PPP参数协商时, PPPD就收到了这样的配置, 这里ms-wins参数是针对微软的客户端产生的配置(在Linux系统下并没有什么作用): 1207-02 20:40:38.034 3183 3183 D pppd : rcvd [IPCP ConfNak id=0x1 &lt;ms-dns1 10.11.12.13&gt; &lt;ms-dns3 10.11.12.14&gt; &lt;ms-wins 10.11.12.13&gt; &lt;ms-wins 10.11.12.14&gt;] 再来对比下正常的PPPD拨号的情况, PPPD拨号时首先很快就收到了IPCP ConfReq id=0x0的请求, 这个请求是告诉客户端可以发起IP地址的协商了, 于是客户端就发了NAK包告诉服务端自己的IP地址是空的sent [IPCP ConfNak id=0x0 &lt;addr 0.0.0.0&gt;]: 123456789101112131415161718192021222324252627282907-02 20:40:01.510 1643 1643 D pppd : using channel 107-02 20:40:01.510 1643 1643 D pppd : sent [LCP ConfReq id=0x1 &lt;asyncmap 0x0&gt; &lt;magic 0x2d6bff1&gt; &lt;pcomp&gt; &lt;accomp&gt;]07-02 20:40:01.510 1643 1643 D pppd : rcvd [LCP ConfReq id=0x0 &lt;asyncmap 0x0&gt; &lt;auth pap&gt; &lt;magic 0xf2cab769&gt; &lt;pcomp&gt; &lt;accomp&gt;]07-02 20:40:01.510 1643 1643 D pppd : sent [LCP ConfAck id=0x0 &lt;asyncmap 0x0&gt; &lt;auth pap&gt; &lt;magic 0xf2cab769&gt; &lt;pcomp&gt; &lt;accomp&gt;]07-02 20:40:01.510 1643 1643 D pppd : rcvd [LCP ConfAck id=0x1 &lt;asyncmap 0x0&gt; &lt;magic 0x2d6bff1&gt; &lt;pcomp&gt; &lt;accomp&gt;]07-02 20:40:01.510 1643 1643 D pppd : rcvd [LCP DiscReq id=0x1 magic=0xf2cab769]07-02 20:40:01.510 1643 1643 D pppd : rcvd [PAP AuthAck id=0x1 ""]07-02 20:40:01.510 1643 1643 I pppd : PAP authentication succeeded07-02 20:40:01.510 1643 1643 D pppd : sent [CCP ConfReq id=0x1 &lt;deflate 15&gt; &lt;deflate(old#) 15&gt; &lt;bsd v1 15&gt;]07-02 20:40:01.510 1643 1643 D pppd : sent [IPCP ConfReq id=0x1 &lt;compress VJ 0f 01&gt; &lt;addr 0.0.0.0&gt; &lt;ms-dns1 0.0.0.0&gt; &lt;ms-dns3 0.0.0.0&gt;]07-02 20:40:01.510 1643 1643 D pppd : rcvd [LCP ProtRej id=0x2 80 fd 01 01 00 0f 1a 04 78 00 18 04 78 00 15 03 2f]// 很快收到IP地址协商请求07-02 20:40:01.970 1643 1643 D pppd : rcvd [IPCP ConfReq id=0x0]07-02 20:40:01.970 1643 1643 D pppd : sent [IPCP ConfNak id=0x0 &lt;addr 0.0.0.0&gt;]07-02 20:40:01.970 1643 1643 D pppd : rcvd [IPCP ConfRej id=0x1 &lt;compress VJ 0f 01&gt;]07-02 20:40:01.970 1643 1643 D pppd : sent [IPCP ConfReq id=0x2 &lt;addr 0.0.0.0&gt; &lt;ms-dns1 0.0.0.0&gt; &lt;ms-dns3 0.0.0.0&gt;]07-02 20:40:01.970 1643 1643 D pppd : rcvd [IPCP ConfReq id=0x1]07-02 20:40:01.970 1643 1643 D pppd : sent [IPCP ConfAck id=0x1]07-02 20:40:01.970 1643 1643 D pppd : rcvd [IPCP ConfNak id=0x2 &lt;addr 10.200.16.23&gt; &lt;ms-dns1 211.xxx.xxx.xxx&gt; &lt;ms-dns3 211.xxx.xxx.xxx&gt;]07-02 20:40:01.970 1643 1643 D pppd : sent [IPCP ConfReq id=0x3 &lt;addr 10.200.16.23&gt; &lt;ms-dns1 211.xxx.xxx.xxx&gt; &lt;ms-dns3 211.xxx.xxx.xxx&gt;]07-02 20:40:01.970 1643 1643 D pppd : rcvd [IPCP ConfAck id=0x3 &lt;addr 10.200.16.23&gt; &lt;ms-dns1 211.xxx.xxx.xxx&gt; &lt;ms-dns3 211.xxx.xxx.xxx&gt;]07-02 20:40:01.970 1643 1643 W pppd : Could not determine remote IP address: defaulting to 10.64.64.6407-02 20:40:01.980 1643 1643 I pppd : local IP address 10.200.16.2307-02 20:40:01.980 1643 1643 I pppd : remote IP address 10.64.64.6407-02 20:40:01.980 1643 1643 I pppd : primary DNS address 211.xxx.xxx.xxx07-02 20:40:01.980 1643 1643 I pppd : secondary DNS address 211.xxx.xxx.xxx07-02 20:40:01.980 1643 1643 D pppd : Script /etc/ppp/ip-up started (pid 1682)07-02 20:40:02.060 1643 1643 D pppd : Script /etc/ppp/ip-up finished (pid 1682), status = 0x0 接着又发了一个地址配置的请求, 在收到服务端的配置后,并相互确认后最终拿到了正确的IP地址/DNS地址: 12345sent [IPCP ConfReq id=0x2 &lt;addr 0.0.0.0&gt; &lt;ms-dns1 0.0.0.0&gt; &lt;ms-dns3 0.0.0.0&gt;]rcvd [IPCP ConfNak id=0x2 &lt;addr 10.200.16.23&gt; &lt;ms-dns1 211.xxx.xxx.xxx&gt; &lt;ms-dns3 211.xxx.xxx.xxx&gt;]sent [IPCP ConfReq id=0x3 &lt;addr 10.200.16.23&gt; &lt;ms-dns1 211.xxx.xxx.xxx&gt; &lt;ms-dns3 211.xxx.xxx.xxx&gt;]rcvd [IPCP ConfAck id=0x3 &lt;addr 10.200.16.23&gt; &lt;ms-dns1 211.xxx.xxx.xxx&gt; &lt;ms-dns3 211.xxx.xxx.xxx&gt;] 单纯从PPPD拨号的LOG来看, 流程上就有不小的差异: 异常情况迟迟收不到远端(这是是运营商的服务器)的IP地址协商的请求ConfReq, 而发出去的IPCP ConfReq参数协商请求一直拿到了假的DNS地址10.11.12.13/14(这个地址实际是modem产生的不是来自网络), 对端回过来的地址一直都是全零0.0.0.0, 导致客户端一直发送ConfReq,直到远端(remote peer)的NAK超过最大的次数(PPPD代码默认是5)后,才停止DNS的协商过程(看pppd的代码是默认关闭了对DNS的协商请求). 那么问题的根源在哪里了? 抓了modem的日志给供应商分析才发现, 本端(local peer)在PDN(Packet Data Network)数据链接尚未建立的情况下(相当于终端与运营商还没有建立物理上的通路)就去发起IPCP参数协商了, 此时modem还没有拿到IP地址和DNS地址, 因此就给了一个假的DNS地址了. 等到几秒钟后PDN建立成功, 运营商网络正常下发分配的IP地址与DNS地址后, modem却没有主动下发正确的DNS地址, 而本端的pppd也没有再次请求DNS地址, 这样到了PPP拨号完成本地拿到的始终是一个假的DNS地址. 找到了问题的原因之后, 解决问题就好办了. 大概有这么几个解决方案: 在modem侧修改: 如果PDN链接建立成功后, 主动下发正确的DNS地址(运营商给的DNS地址) 在本端的PPPD中修改: 如果发现拿到的DNS地址为10.11.12.13/14, 则在接收到远端的NAK时将该地址拒绝, 并且在下次参数协商时主动告诉远端自己没有拿到DNS地址, 这样远端会在下一个NAK中主动将正确的DNS发送过来(如果已经有了的话) 在PPPD拨号时将参数connect-delay设置为5000(5s, 默认是1000), 这个相当于尽量等待PDN的链接, 等成功后再进行参数协商. 这个方案只能在一定程度上缓解问题发生的概率, 并不能从根本上解决问题. 如果收到假的DNS地址10.11.12.13/14, 则强制修改为正确的运营商DNS地址(如果运营商DNS地址发生变化, 又会出问题, 不是终极解决方案) 目前采用了方案二, 初步验证可以拿到正确的DNS地址.]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>PPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Android Studio中添加自定义framework.jar?]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%9C%A8Android-Studio%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89framework-jar%2F</url>
    <content type="text"><![CDATA[这两天有一个新的功能需求要实现, 要在Android原生代码的Settings(代码目录android/frameworks/base/core/java/android/provider)数据库添加一个新的数据项, 一个系统应用(独立于Android系统源码编译)需要引用该数据项. 那么, 怎么将新的数据项引用到系统应用中了? &lt;! – more –&gt; 备注: 以下所有的示例都基于Android Studio 3.2/操作系统Ubuntu 18.04.1 首先, 在Android源码中修改完成后, 执行本地编译, 在/android/out目录下, 找到编译产生的新的framework模块的jar包: 1out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes-full-debug.jar 最开始, 打开该jar包, 将/android/provider/目录下的所有class文件复制到Android Studio中的SDK的platforms/android-23, 重新clean/build一次, 项目中对新建的数据项的符号引用立刻就正常了.但一提交到远程服务器, 后台编译出错, 提示找不到符号了~~~what! 马上就要发布版本了, 怎么办?只好硬着头皮找其他法子了…参考了网上已有的很多文档, 编译一直报错. 不得已开始想着要通过广播的形式来替换掉现有的通过ContentProvider的方式, 这样就避开修改Android SDK了, 但广播存在这么几个问题: 任何人都可以监听接收该广播, 安全性与性能都大打折扣; 如果接收方线程阻塞, 会导致广播超时, 造成应用ANR 整个需求的方案已经定了, 再去该明显会被打回的, 而且就该功能的实现而言, 只有在某个状态变化时, 才要求告知上层, 这个正是ContentProvider可以达成的逻辑. 转了一圈, 只好又回到原来的方案. 跟同事沟通了配置的方法, 编译终于通过, 但是验证测试时又碰到了问题….这里记录下来整个过程, 也算是为后来的Android SDK定制积攒点经验. 添加framework.jar到AS将编译好的Android框架层jar包framework.jar放到/app/libs/下面, 然后在应用app的配置build.gradle下面添加一个依赖项, 这里的provided表示该依赖只在编译时起作用, 不会把对应的jar文件编译到最终的APK中去: 1234dependencies &#123; provided files(&apos;libs/framework.jar&apos;) //compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)&#125; 将framework.jar设置为bootclass为了让库生效, 需要在编译开始时, 将framework.jar设置为当前所有子项目的启动文件(boot class): 12345678910111213allprojects &#123; repositories &#123; jcenter() &#125; // 设置为bootclass gradle.projectsEvaluated &#123; tasks.withType(JavaCompile) &#123; options.compilerArgs &lt;&lt; &apos;-Xbootclasspath/p:app/libs/framework.jar&apos; &#125; &#125;&#125; 同时, 还需要在app/build.gradle中添加一个编译的类路径(class path): 123456789project.afterEvaluate &#123; JavaCompile javaTask = project.tasks.compileDebugAndroidTestJavaWithJavac if (javaTask) &#123; FileCollection dependentFiles = javaTask.getClasspath() dependentFiles = dependentFiles.plus(project.files(&apos;libs/framework.jar&apos;)) javaTask.setClasspath(dependentFiles) &#125;&#125; 网上的大部分资料都说到了这一步就好了, 但是这时看引用的Java文件中, 仍然提示找不到新的符号, 重新看了下网络上的教程, 原来还需要更改下app.iml中的引用先后顺序. 修改app.iml中的库引用顺序app.iml包含了某个项目的信息以及依赖状态, 找到framework.jar以及Android SDK对应的&lt;orderEntry&gt;, 将framework.jar对应的调整到Android SDK之前就可以了: 123456&lt;orderEntry type=&quot;sourceFolder&quot; forTests=&quot;false&quot; /&gt;&lt;orderEntry type=&quot;library&quot; exported=&quot;&quot; name=&quot;app/libs/framework.jar:unspecified@jar&quot; level=&quot;project&quot; /&gt;....&lt;orderEntry type=&quot;module&quot; module-name=&quot;lib_config&quot; exported=&quot;&quot; /&gt;&lt;orderEntry type=&quot;jdk&quot; jdkName=&quot;Android API 23 Platform&quot; jdkType=&quot;Android SDK&quot; /&gt; 在实际操作过程, 注意不要在app/build.gradle中添加如下两个配置, 不然编译虽然可以通过, 但是执行时会出现异常: 12345dependencies &#123; provided files(&apos;libs/framework.jar&apos;) //compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)&#125; 参考资料 https://developer.android.com/studio/build/gradle-tips http://google.github.io/android-gradle-dsl/ https://docs.gradle.org/current/dsl/ https://docs.gradle.org/current/userguide/userguide_single.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android studio</tag>
        <tag>Android framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下常用网络工具使用总结]]></title>
    <url>%2F2019%2F01%2F17%2FLinux%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[平时在Android/Ubuntu这样的Linux系统中, 经常跟网络打交道, 不可避免的要使用网络工具来定位问题；这里对Linux常用的网络工具进行简单的总结, 方便后续查阅使用. 主要看看以下几个常用的网络工具 : ping: 基于ICMP协议, 发送ICMP数据包用于测试网络连通状态 traceroute: 基于UDP/ICMP/TCP协议用于跟踪网络连通状态, 打印达到目标地址的路由信息 tcpdump : 用于抓取tcp/ip包, 分析网络问题的必需神器 iproute2 : 查看/添加/删除当前路由信息 netstat: 查看网络状态 netcfg: 配置网口(使能网口以及配置IP等) iptables: 网络数据包的过滤以及防火墙策略配置 netcat: 用于快速建立TCP/UDP链接,检测网络的连通性 iPerf: 网络性能测试工具, 用来衡量网络吞吐量/带宽 tc: Traffic Control, 用于显示/修改网卡配置的工具 curl: 基于libcurl的数据传输工具, 支持HTTP/HTTPS/FTP/RTMP/RTSP/SCP等常见协议 iw: 用于显示/设置WiFi设备接口的工具, 比如展示当前设备WiFi热点信息, 主动扫描周围WiFi热点等 pingping通过向目标节点发送ICMP的ECHO_REQUEST包来测试目标地址的可达性与连通性；向目标地址发送ECHO_REQUEST包后, 如果正常接收到ECHO_RESPONSE, 则说明网络是连通的; 但如果没有接收到任何回应,并不能说明网络的不通, 有可能是请求或者响应在某个地方丢失了.通过ping的洪峰测试模式, 持续发包到目标地址, 也可以查看当前网络状态, 如RTT(Round-trip time)时间, 网络的丢包率等信息. 一般测试中常用的参数有如下几个: -c: 设置发多少个ECHO_REQUEST包 -i: 两个包之间的时间间隔, 默认是1s -I: 指定数据包出去的端口 -w: ping测试的超时时间, 多久结束 -f: 洪峰测试, 持续(两个包的时间间隔为0)向目标主机发送数据包 -s: 指定发送数据包的大小 -M: 选择Path MTU发现策略， 有三个选择： do代表不要对数据包进行分片， want表示执行PMTU发现， 但是可以在本地进行数据包的分片，`dont`表示不要设置分片标志位（可以分片） 示例: 向某个域名发送10包, 12ping -c 10 www.google.com 持续向某个主机连续20s发送数据包, 并指定出口为wlp5s0: 12ping -f -w 20 -I wlp5s0 www.google.com 通过指定包大小以及PMTU的策略，可以用来发现某个路径上最大的MTU大概是多少： 12ping -v -w 20 -M do -s 1460 www.baidu.com 一般, ping测试完成后, 会打印发生了多少个包, 接收的包个数以及丢包率, 总的测试时间以及RTT: traceroutetraceroute能够跟踪打印通往某个网络主机的路由信息, 用于定位网络不通时,在哪个路由节点发生的异常. traceroute利用的是IP协议中的包的TTL(Time-To-Live)字段不断发送”探针”包;其首先会向网络发送一个TTL为1的包, 返回后接着向网络发送一个TTL为2的包, 以此持续发送, 直到最后到达目标主机或者超时为止.traceroute的参数较多, 可以通过man traceroute或者traceroute --help查看具体的用法. 示例, 查找到达www.google.com的路由: 12traceroute www.google.com tcpdumptcpdump用于抓取网络数据包的利器, 最初的版本是由Van Jacobson, Sally Floyd, Vern Paxson在1988年编码, 后来在各种操作系统中都得到了广泛的使用, 更多详细信息可以参考https://www.tcpdump.org/；如果你使用的是Linux系统, 可以通过man tcpdump来查看tcpdump的具体使用信息. 这里来看下Linux下的tcpdump工具具体如何使用. 以Ubuntu系统为例, tcpdump有很多参数: 常用的参数主要有如下几个: -i *interface*/--interface=*interface*: 设置需要抓包的网口, 在Ubuntu系统可以通过ifconfig查看每个网络接口信息; 在Android下可以通过busybox ifconfig查看; -n: 不要将IP地址转换成域名; -s *snaplen*/ --snapshot--length=*snaplen*: 为了保持兼容性, 一般将该值设为0; -w *file*: 保存网络数据包到某个文件; expression: 表达式, 由于网络数据包的过滤, 关于表达式的语法格式可以参考man pcap-filter; 示例: 比如我要抓取某个端口wlp5s0上的所有数据包, 可以使用: 12tcpdump -i wlp5s0 -s 0 -n -w ~/all.pcap 如果只是想看某个端口指定一个协议, 如tcp的数据包, 则可以: 12tcpdump -i wlp5s0 -s 0 -w ip proto \\tcp 这里ip proto \\tcp就是包过滤的表达式, 具体的写法可以参考man pcap-filter或者http://alumni.cs.ucr.edu/~marios/ethereal-tcpdump.pdf iproute2看名字大概也知道iproute2这个是用来管理linux系统路由表的, 但在这个工具系列中其实也集成了其他有用的功能, 比如地址/链路的管理, 查看ARP信息, 配置网络接口信息以及配置策略路由(policy routing)等(man ip查看对应信息), 对于Ubuntu系统可以通过man ip-route来查看如何使用iproute: 示例: 想看下系统的路由表, 12ip route # 等价于 ip route show default 如果想要看某个具体的路由表信息: 12ip route show table main # local, main, or all 那么, 如果要在某个路由表中添加一项路由信息, 如何操作?假定现在, 需要在main路由表中对应的端口ppp0中添加一个目标ip为211.137.20.302的路由: 12ip route add table main scope link dev ppp0 211.137.20.302 想要删除路由表中的某一项, 语法跟路由表添加很相似: 12ip route del table main scope link dev ppp0 211.137.20.302 在某个网口上添加默认路由: 1ip route add default proto static scope link dev wlp5s0 netstatnetstat主要用来看路由表, 当前网络链接状态以及网络数据统计等, 最新的Linux系统已经使用ip(man ip)来替代(具体的信息可以通过man netstat查看).不过在Android的busybox中仍然可以发挥作用: 例如输入adb shell busybox netstat -rn显示路由表: netcfg在Ubuntu系统中并没有看到netcfg工具, Android里边有一个netcfg工具用于配置网口: 12usage: netcfg [&lt;interface&gt; &#123;dhcp|up|down&#125;] 通过ADB命令adb shell netcfg可以查看当前网口的配置: 如果要在Android中配置一个以太网口(Ethernet), 确保驱动加载完成后, 输入以下指令即可: 使能网口 12netcfg &lt;interface&gt; up 通过DHCP获取IP地址 12netcfg &lt;interface&gt; dhcp iptablesiptables是netfilter(https://www.netfilter.org/)在用户空间的工具, 可以用来读网络数据包进行转发, 拦截, 过滤以及修改. 简单说来, netfilter是在tcp/ip的内核传输路径添加各种hooks函数,如PREROUTING, INPUT, FORWARD, OUTPUT, POSTROUTING; 这些hooks函数负责将数据包发送个各个队列(tables), 示意图如下: 在Linux中内置的tables有如下几个: Filter: 用于数据包过滤(接收或者丢弃) Nat: IP地址转换, 有源地址(snat), 目标地址(dnat)以及masquerade(装饰)三种 Managle: 修改数据包的头(ttl/tos等) Raw: 主要用于配置链接跟踪(connection tracking) 在Ubuntu系统中, 输入man iptables可以查看iptables的具体用法: 比如要查看当前iptables规则, 可以通过iptables --list; 一般iptables命令有如下几个部分组成: 假定你现在需要拦截所有来自某个IP地址的数据包, 可以这样操作: 12iptables -A INPUT -s 182.23.23.23 -i wlp5s0 -j DROP 如果只是想丢弃某种协议的数据包, 比如UDP, 则可以指定协议类型: 12iptables -A INPUT -s 182.23.23.23 -i wlp5s0 -j DROP -p udp 查看当前规则的流量使用情况可以使用： 12iptables -L -v -n 通过iptables的规则链条, 我们可以很方便的构造一系列防火墙规则, 看起来是非常强大的一个工具了. 很值得学习~ netcatnetcat通常简写成nc, 是一个用于建立TCP/UDP连接的小工具, 在Linux下netcat -h或者nc -h都可以查看其使用说明；Android也包含了一个缩减版的netcat, 可以通过nc -h查看. 以Ubuntu为例, 通常nc有如下几个参数: 比如要测试下跟google的TCP连接是否正常(设置-v可以输出连接的状态信息): 12nc -v www.google.com 80 类似的, 也可以建立一个UDP连接: 1nc -v -u www.google.com 80 netcat有个比较有用的功能就是扫描某个主机给定范围的端口是否正常可连接: 如下这个指令用来查看网关192.168.225.1上1-10000的端口是否可用 12nc -v -z 192.168.225.1 1-10000 如果我们想要测试两个主机给定端口的连通性,可以按照如下步骤操作: 123456#在HOST1监听2323这个端口nc -v -l -p 2323 #在HOST2上主动连接2323这个端口nc -v -X connect 192.168.225.1 2323 关于nc更多有趣的应用, 可以到官网上查看 http://nc110.sourceforge.net/. iPerfiPerf是一个基于TCP/UPD协议的网络测试工具, 常用来测试网络吞吐量以及带宽. 在测试时需要客户端与服务端都支持. 目前有iperf3/iperf2两个版本, 相关文档参考https://iperf.fr/iperf-doc.php. 这里我们基于iperf2介绍下如何来使用iperf. iPerf的参数主要分为三类, 一类是通用参数, 如参数格式, 多线程测试等；一类是客户端使用的参数, 如目标地址；一类是服务端的参数, 如基于UDP或者通过Daemon进程执行等. 比如简单来测试下网络带宽(ping.online.net是免费用来测试网络的服务器): 12iperf -f M -m -c ping.online.net 测试完成后, 会输出如下信息: 这里只是简单引出iperf的使用方法, 更多使用场景可以到官网上看看文档https://iperf.fr/. tctc即Traffic Control, 可以显示/修改网卡的配置, 如设置网卡的延时, 传输速率, 控制包的传输顺序等, 在linux上输入man tc可以查看具体的使用说明: 比如要看下当前网卡队列的状态, 可以输入: 12tc -s qdisc show dev eth0 curlcurl一般用于客户端数据的下载传输, 目前支持Web协议如HTTP(S)/FTP到视频流传输协议如RTMP/RTSP等, 其使用起来也非常简单: 1curl [options...] &lt;url&gt; 比如要尝试下载某个网页: 12curl -v www.baidu.com 这里-v会输出更多的过程信息: iwiw常用于WiFi设备的管理, 配置, 通过man iw可以看到相关的使用说明: 要查看所有相关命令的使用可以输入iw help.如要查看当前设备WiFi信息, 可以输入iw dev. 通过: 12iw &lt;wlan_interface&gt; info 可以查看到当前连接的WiFi热点信息, 如果要扫描附近的WiFi热点, 可以通过iw &lt;wlan_interface&gt; scan, 这样会得到一个完整的热点列表. 以上便是常用几个网络工具的总结了, 大家有什么好的Linux工具可以推荐下~以后持续更新 参考文献 http://stud.netgroup.uniroma2.it/cgrl/2018/slides/5-netfilter.pdf https://en.wikipedia.org/wiki/Netfilter https://iperf.fr/(iPerf官网) http://linux-ip.net/html/tools-ip-route.html https://en.wikipedia.org/wiki/Iptables https://linux.die.net/man/8/tc]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Network tools</tag>
        <tag>ip route</tag>
        <tag>tcpdump</tag>
        <tag>iptables</tag>
        <tag>iperf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成王败寇与丛林法则-看纪录片有感]]></title>
    <url>%2F2019%2F01%2F04%2F%E6%88%90%E7%8E%8B%E8%B4%A5%E5%AF%87%E4%B8%8E%E4%B8%9B%E6%9E%97%E6%B3%95%E5%88%99-%E7%9C%8B%E7%BA%AA%E5%BD%95%E7%89%87-%E8%8B%B1%E5%9B%BD%E5%8F%B2-%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[People donot see; they only recognize. And what they donot recognize remains invisible to them Simon Leys 最近断断续续的看完了BBC的《英国史》(网易公开课链接)，从史前文明讲到宗教改革;从罗马帝国的征服讲到光荣革命, 加上醇厚的英式英语, 整个纪录片看起来十分的有趣而汤气回肠。在英国人看来，国王只是上帝在人间的代表，执行着上帝的意志，而不是独揽大权的独裁者。纵然，英国历史上也出现过暴君，但最终并没有什么好下场，弄不好还被送上断头台，掉了脑袋。印象深刻的是，在英国内战期间，当乡绅克伦威尔赶走暴君，掌握军权之后，并没有依靠独裁加冕成为国王，而是给自己冠上了护国公。这就告诉人民，国王是上帝的代表，是荣誉与信仰的象征，有血统而赋有担当与责任，并不是每个出生草莽之辈能戴上王冠，纵使像克伦威尔这样的乡绅也不能。这种贵族式的统治，加上议会这种代表民主与自由的分权机构，英国终于成为了欧洲乃至世界近代历史的领头羊，将人类文明带入新的高度。 再对比中国历史上的权力游戏，却是截然不同的画面。当秦朝末年，人民被折腾的苦不堪言时，陈胜吴广说的是“王侯将相宁有种乎”，他秦始皇能做一国之君，我陈胜吴广为何不能？陈胜吴广起义也绝非为了执行上帝的意志，消除社会不公平，而是挣脱套牢在他们自己身上的枷锁。这个即便是到了近代的太平天国起义也是如此。他们揭竿而起并不是为了某种上帝的意志与信念而战，也不是为了某种信仰而赴汤蹈火，而是做另一个秦始皇，在万人之上，成为人人害怕而崇拜的对象，成为坐拥万千宾妃的皇上。这里，看不到任何关于荣誉与尊严，看不到任何对于自由与民主的追求，有的只是对成王败寇的推崇，以及“宁可我负天下人，不可天下人负我”的自私与偏狭。从这个角度看，五千年历史一直上演的都是弱肉强食，适者生存的丛林游戏。没有对人的荣誉与尊严的保护，没有对社会不公制度性的建设，没有对自由与人性的追求,野蛮从未消失过。 记得小时候长辈劝年轻人要努力读书时, 常会说一句”吃得苦中苦, 方为人上人”.我们读书学习, 只是成为”人上人”而已, 所谓”学而优则仕”, 一切的努力付出都只是为了成为”统治阶层”的一员.这种功利与对权力的极力推崇的态度在当今的社会依然屡见不鲜.可回顾下人类文明的发展历程, 所有的社会或文化的变革最终都指向一个目标:把人类自身从各种束缚中解脱出来, 解放人性,让人可以发挥自己的创造潜能.文艺复兴也好, 工业革命与信息技术革命, 再到影响了千千万万国人的改革开放而言, 都是为了去除套牢在人心上的枷锁,解放压抑沉闷的人性, 让每个个体都有机会发挥自身的才能与智慧.到今天, 中国进行改革开放40年来, 经济一直在高速发展, 可是社会的发展却相对停滞, 人们讨论最多的是如何挣钱, 如何谋取财富;大部分人满足于吃喝玩乐, 对于社会公平与精神追求要么无所追求, 要么有心无力.在发生问题时, 小到个人, 大到一个企业或者组织, 再到政府,都在极力推卸责任;不管是立法, 司法还是执法, 整个社会对于个体权利的保护都远远不够, 在遇到实际的法律问题时常常只能依靠道德来衡量, 显得十分捉襟见肘. 历经40年的发展, 普遍程度上, 我们的生活水平都有了质的提高,工业化建设也有了长足的进步.如果我们的社会想要进一步发展, 想要涌现更大的活力, 我们的古老的文明想要焕发更多的生命力, 整个国家从上至下都必须进行一次思想观念的解放:不能再仅仅满足于口号上的民族复兴/伟大使命, 而是要实实在在的作出变革, 放开对个人的束缚, 放开对自由的限制,更多的激发个人的活力.不过, 从目前来看, 我们的最高领导者似乎还在老路上沉浸不可自拔, 所谓的变革实际上显得困难重重.历史再一次将中国摆在了有趣的十字路口, 如何选择是每一个中国人都要思考的问题.]]></content>
      <categories>
        <category>思考</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>英国史</tag>
        <tag>丛林法则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android netd工作原理详解]]></title>
    <url>%2F2018%2F12%2F18%2FAndroid-netd%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[NETD是Android一个专门管理网络链接, 路由/带宽/防火墙策略以及iptables的系统Daemon进程, 其在Anroid系统启动时加载 : 1234567service netd /system/bin/netd class main socket netd stream 0660 root system socket dnsproxyd stream 0660 root inet socket mdns stream 0660 root system socket fwmarkd stream 0660 root inet 启动netd时, 会创建四个socket,用于其他进程与netd进行通信: netd: 主要与Framework的NetworkManagementService交互, 用于控制网口状态, 路由表 dnsproxyd: DNS代理的控制与配置，用于私有DNS（DNS Over TLS)的请求转发 mdns: 多播DNS（Multicast DNS，参考RFChttps://tools.ietf.org/html/rfc6762), 用于基于WIFI连接的服务发现（NSD, Network Service Discovery) fwmarkd: iptables的(fwmark)策略路由的配置(策略路由, 如设置网络权限， 连接打标签等 总的说来, netd进程在Android中间层服务NetworkManagementService以及内核之间建立了一个沟通的桥梁: 对Java层系统服务NetworkManagementService,netd通过socket接口为其提供了控制指令的通道 对内核, netd通过netlink socket与内核进行数据/指令的收发, 并将来自内核的消息发送给上层 从Android 8.0开始， Netd同时提供了一个HAL Binder的接口提供给其他进程调用INetd.aidl 接下来, 本文从三个方面来看下netd的具体工作原理与实现. netd的初始化与启动 NetworkManagementService与netd的交互 netd与内核的交互 关于netlink socket可以参考: http://qos.ittc.ku.edu/netlink/html/node4.html netd的启动与初始化netd进程启动时, 主要处理做以下事情: 创建一个NetlinkManager, 用于管理与内核通信的netlink连接 初始化网络控制类, 如路由控制RouteController, 带宽控制BandwidthController 启动各类事件监听类: DnsProxyListener监听DNS代理; CommandListener监听来自NetworkManagement的指令 启动NetdHwService, 为HAL层提供接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103int main() &#123; using android::net::gCtls; Stopwatch s; ALOGI("Netd 1.0 starting"); blockSigpipe(); NetlinkManager *nm = NetlinkManager::Instance(); if (nm == nullptr) &#123; ALOGE("Unable to create NetlinkManager"); exit(1); &#125;; gCtls = new android::net::Controllers(); gCtls-&gt;init(); CommandListener cl; nm-&gt;setBroadcaster((SocketListener *) &amp;cl); if (nm-&gt;start()) &#123; ALOGE("Unable to start NetlinkManager (%s)", strerror(errno)); exit(1); &#125; std::unique_ptr&lt;NFLogListener&gt; logListener; &#123; auto result = makeNFLogListener(); if (!isOk(result)) &#123; ALOGE("Unable to create NFLogListener: %s", toString(result).c_str()); exit(1); &#125; logListener = std::move(result.value()); auto status = gCtls-&gt;wakeupCtrl.init(logListener.get()); if (!isOk(result)) &#123; ALOGE("Unable to init WakeupController: %s", toString(result).c_str()); // We can still continue without wakeup packet logging. &#125; &#125; // Set local DNS mode, to prevent bionic from proxying // back to this service, recursively. setenv("ANDROID_DNS_MODE", "local", 1); DnsProxyListener dpl(&amp;gCtls-&gt;netCtrl, &amp;gCtls-&gt;eventReporter); if (dpl.startListener()) &#123; ALOGE("Unable to start DnsProxyListener (%s)", strerror(errno)); exit(1); &#125; MDnsSdListener mdnsl; if (mdnsl.startListener()) &#123; ALOGE("Unable to start MDnsSdListener (%s)", strerror(errno)); exit(1); &#125; FwmarkServer fwmarkServer(&amp;gCtls-&gt;netCtrl, &amp;gCtls-&gt;eventReporter); if (fwmarkServer.startListener()) &#123; ALOGE("Unable to start FwmarkServer (%s)", strerror(errno)); exit(1); &#125; Stopwatch subTime; status_t ret; if ((ret = NetdNativeService::start()) != android::OK) &#123; ALOGE("Unable to start NetdNativeService: %d", ret); exit(1); &#125; ALOGI("Registering NetdNativeService: %.1fms", subTime.getTimeAndReset()); /* * Now that we're up, we can respond to commands. Starting the listener also tells * NetworkManagementService that we are up and that our binder interface is ready. */ if (cl.startListener()) &#123; ALOGE("Unable to start CommandListener (%s)", strerror(errno)); exit(1); &#125; ALOGI("Starting CommandListener: %.1fms", subTime.getTimeAndReset()); write_pid_file(); // Now that netd is ready to process commands, advertise service // availability for HAL clients. NetdHwService mHwSvc; if ((ret = mHwSvc.start()) != android::OK) &#123; ALOGE("Unable to start NetdHwService: %d", ret); exit(1); &#125; ALOGI("Registering NetdHwService: %.1fms", subTime.getTimeAndReset()); ALOGI("Netd started in %dms", static_cast&lt;int&gt;(s.timeTaken())); IPCThreadState::self()-&gt;joinThreadPool(); ALOGI("Netd exiting"); remove_pid_file(); exit(0);&#125; CommandListener用于接收处理来自上层NetworkManagementService指令, 在netd启动时, 会监听netd这个socket, 并允许最多4个客户端请求的处理: 123456789101112131415161718192021222324252627282930313233343536373839int SocketListener::startListener() &#123; return startListener(4);&#125;int SocketListener::startListener(int backlog) &#123; if (!mSocketName &amp;&amp; mSock == -1) &#123; SLOGE("Failed to start unbound listener"); errno = EINVAL; return -1; &#125; else if (mSocketName) &#123; if ((mSock = android_get_control_socket(mSocketName)) &lt; 0) &#123; SLOGE("Obtaining file descriptor socket '%s' failed: %s", mSocketName, strerror(errno)); return -1; &#125; SLOGV("got mSock = %d for %s", mSock, mSocketName); fcntl(mSock, F_SETFD, FD_CLOEXEC); &#125; if (mListen &amp;&amp; listen(mSock, backlog) &lt; 0) &#123; SLOGE("Unable to listen on socket (%s)", strerror(errno)); return -1; &#125; else if (!mListen) mClients-&gt;push_back(new SocketClient(mSock, false, mUseCmdNum)); if (pipe(mCtrlPipe)) &#123; SLOGE("pipe failed (%s)", strerror(errno)); return -1; &#125; if (pthread_create(&amp;mThread, NULL, SocketListener::threadStart, this)) &#123; SLOGE("pthread_create (%s)", strerror(errno)); return -1; &#125; return 0;&#125; 这里创建了一个专门的线程用于处理来自上层客户端的命令请求: 检查控制pipe的数据,是否有必要停止监听; 监听来自客户端的请求, 如果有, 则新建一个SocketClient保存下来 从已有的SocketClient中检查是否有可用的数据, 如果有则通过onDataAvailable 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899void *SocketListener::threadStart(void *obj) &#123; SocketListener *me = reinterpret_cast&lt;SocketListener *&gt;(obj); me-&gt;runListener(); pthread_exit(NULL); return NULL;&#125;void SocketListener::runListener() &#123; SocketClientCollection pendingList; while(1) &#123; SocketClientCollection::iterator it; fd_set read_fds; int rc = 0; int max = -1; FD_ZERO(&amp;read_fds); if (mListen) &#123; max = mSock; FD_SET(mSock, &amp;read_fds); &#125; FD_SET(mCtrlPipe[0], &amp;read_fds); if (mCtrlPipe[0] &gt; max) max = mCtrlPipe[0]; pthread_mutex_lock(&amp;mClientsLock); for (it = mClients-&gt;begin(); it != mClients-&gt;end(); ++it) &#123; // NB: calling out to an other object with mClientsLock held (safe) int fd = (*it)-&gt;getSocket(); FD_SET(fd, &amp;read_fds); if (fd &gt; max) &#123; max = fd; &#125; &#125; pthread_mutex_unlock(&amp;mClientsLock); SLOGV("mListen=%d, max=%d, mSocketName=%s", mListen, max, mSocketName); if ((rc = select(max + 1, &amp;read_fds, NULL, NULL, NULL)) &lt; 0) &#123; if (errno == EINTR) continue; SLOGE("select failed (%s) mListen=%d, max=%d", strerror(errno), mListen, max); sleep(1); continue; &#125; else if (!rc) continue; if (FD_ISSET(mCtrlPipe[0], &amp;read_fds)) &#123; char c = CtrlPipe_Shutdown; TEMP_FAILURE_RETRY(read(mCtrlPipe[0], &amp;c, 1)); if (c == CtrlPipe_Shutdown) &#123; break; &#125; continue; &#125; if (mListen &amp;&amp; FD_ISSET(mSock, &amp;read_fds)) &#123; int c = TEMP_FAILURE_RETRY(accept4(mSock, nullptr, nullptr, SOCK_CLOEXEC)); if (c &lt; 0) &#123; SLOGE("accept failed (%s)", strerror(errno)); sleep(1); continue; &#125; pthread_mutex_lock(&amp;mClientsLock); mClients-&gt;push_back(new SocketClient(c, true, mUseCmdNum)); pthread_mutex_unlock(&amp;mClientsLock); &#125; /* Add all active clients to the pending list first */ pendingList.clear(); pthread_mutex_lock(&amp;mClientsLock); for (it = mClients-&gt;begin(); it != mClients-&gt;end(); ++it) &#123; SocketClient* c = *it; // NB: calling out to an other object with mClientsLock held (safe) int fd = c-&gt;getSocket(); if (FD_ISSET(fd, &amp;read_fds)) &#123; pendingList.push_back(c); c-&gt;incRef(); &#125; &#125; pthread_mutex_unlock(&amp;mClientsLock); /* Process the pending list, since it is owned by the thread, * there is no need to lock it */ while (!pendingList.empty()) &#123; /* Pop the first item from the list */ it = pendingList.begin(); SocketClient* c = *it; pendingList.erase(it); /* Process it, if false is returned, remove from list */ if (!onDataAvailable(c)) &#123; release(c, false); &#125; c-&gt;decRef(); &#125; &#125;&#125; netd启动完成后, 就可以处理来自中间层的指令请求以及与内核进行交互了. netd与NetworkManagerService的交互SystemServer进程启动时, 创建NetworkManagementService(以下简称(NMS)), 此时NMS会主动与netd建立socket链接: 123456789101112// SystemServer.java if (!disableNetwork) &#123; traceBeginAndSlog("StartNetworkManagementService"); try &#123; networkManagement = NetworkManagementService.create(context); ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement); &#125; catch (Throwable e) &#123; reportWtf("starting NetworkManagement Service", e); &#125; traceEnd(); &#125; 创建NMS时, 启动一个新的线程用于与netd通信, 123456789101112131415161718192021222324252627282930313233343536373839404142434445 static NetworkManagementService create(Context context, String socket) throws InterruptedException &#123; final NetworkManagementService service = new NetworkManagementService(context, socket); final CountDownLatch connectedSignal = service.mConnectedSignal; if (DBG) Slog.d(TAG, "Creating NetworkManagementService"); service.mThread.start(); if (DBG) Slog.d(TAG, "Awaiting socket connection"); connectedSignal.await(); service.connectNativeNetdService(); return service; &#125; private NetworkManagementService(Context context, String socket) &#123; mContext = context; // make sure this is on the same looper as our NativeDaemonConnector for sync purposes mFgHandler = new Handler(FgThread.get().getLooper()); // Don't need this wake lock, since we now have a time stamp for when // the network actually went inactive. (It might be nice to still do this, // but I don't want to do it through the power manager because that pollutes the // battery stats history with pointless noise.) //PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE); PowerManager.WakeLock wl = null; //pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, NETD_TAG); mConnector = new NativeDaemonConnector( new NetdCallbackReceiver(), socket, 10, NETD_TAG, 160, wl, FgThread.get().getLooper()); mThread = new Thread(mConnector, NETD_TAG); mDaemonHandler = new Handler(FgThread.get().getLooper()); // Add ourself to the Watchdog monitors. Watchdog.getInstance().addMonitor(this); LocalServices.addService(NetworkManagementInternal.class, new LocalService()); synchronized (mTetheringStatsProviders) &#123; mTetheringStatsProviders.put(new NetdTetheringStatsProvider(), "netd"); &#125;&#125; NMS通过NativeDaemonConnector与netd建立socket通信, NativeDaemonConnector主要做两个事情: 与netd建立一个数据链接 不断读取socket中的数据流: 一种是netd主动上报的命令, 一种是NMS发送给netd后的指令的响应 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119@Overridepublic void run() &#123; mCallbackHandler = new Handler(mLooper, this); while (true) &#123; try &#123; listenToSocket(); &#125; catch (Exception e) &#123; loge(&quot;Error in NativeDaemonConnector: &quot; + e); SystemClock.sleep(5000); &#125; &#125;&#125; private void listenToSocket() throws IOException &#123; LocalSocket socket = null; try &#123; socket = new LocalSocket(); LocalSocketAddress address = determineSocketAddress(); socket.connect(address); InputStream inputStream = socket.getInputStream(); synchronized (mDaemonLock) &#123; mOutputStream = socket.getOutputStream(); &#125; mCallbacks.onDaemonConnected(); FileDescriptor[] fdList = null; byte[] buffer = new byte[BUFFER_SIZE]; int start = 0; while (true) &#123; int count = inputStream.read(buffer, start, BUFFER_SIZE - start); if (count &lt; 0) &#123; loge(&quot;got &quot; + count + &quot; reading with start = &quot; + start); break; &#125; fdList = socket.getAncillaryFileDescriptors(); // Add our starting point to the count and reset the start. count += start; start = 0; for (int i = 0; i &lt; count; i++) &#123; if (buffer[i] == 0) &#123; // Note - do not log this raw message since it may contain // sensitive data final String rawEvent = new String( buffer, start, i - start, StandardCharsets.UTF_8); boolean releaseWl = false; try &#123; final NativeDaemonEvent event = NativeDaemonEvent.parseRawEvent(rawEvent, fdList); log(&quot;RCV &lt;- &#123;&quot; + event + &quot;&#125;&quot;); if (event.isClassUnsolicited()) &#123; Message msg = mCallbackHandler.obtainMessage( event.getCode(), uptimeMillisInt(), 0, event.getRawEvent()); if (mCallbackHandler.sendMessage(msg)) &#123; releaseWl = false; &#125; &#125; else &#123; mResponseQueue.add(event.getCmdNumber(), event); &#125; &#125; catch (IllegalArgumentException e) &#123; log(&quot;Problem parsing message &quot; + e); &#125; finally &#123; if (releaseWl) &#123; mWakeLock.release(); &#125; &#125; start = i + 1; &#125; &#125; // We should end at the amount we read. If not, compact then // buffer and read again. if (start != count) &#123; final int remaining = BUFFER_SIZE - start; System.arraycopy(buffer, start, buffer, 0, remaining); start = remaining; &#125; else &#123; start = 0; &#125; &#125; &#125; catch (IOException ex) &#123; loge(&quot;Communications error: &quot; + ex); throw ex; &#125; finally &#123; synchronized (mDaemonLock) &#123; if (mOutputStream != null) &#123; try &#123; loge(&quot;closing stream for &quot; + mSocket); mOutputStream.close(); &#125; catch (IOException e) &#123; loge(&quot;Failed closing output stream: &quot; + e); &#125; mOutputStream = null; &#125; &#125; try &#123; if (socket != null) &#123; socket.close(); &#125; &#125; catch (IOException ex) &#123; loge(&quot;Failed closing socket: &quot; + ex); &#125; &#125;&#125; socket链接建立完成之后, NMS与netd可以相互通信, 发送指令与数据了. NMS通过NativeDaemonConnector执行相应的指令, 比如NMS设置网络接口的配置(打开/关闭网口): 12345678910111213141516171819202122@Overridepublic void setInterfaceConfig(String iface, InterfaceConfiguration cfg) &#123; mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG); LinkAddress linkAddr = cfg.getLinkAddress(); if (linkAddr == null || linkAddr.getAddress() == null) &#123; throw new IllegalStateException("Null LinkAddress given"); &#125; final Command cmd = new Command("interface", "setcfg", iface, linkAddr.getAddress().getHostAddress(), linkAddr.getPrefixLength()); for (String flag : cfg.getFlags()) &#123; cmd.appendArg(flag); &#125; try &#123; mConnector.execute(cmd); &#125; catch (NativeDaemonConnectorException e) &#123; throw e.rethrowAsParcelableException(); &#125;&#125; NativeDaemonConnector会将每个指令都指定一个唯一的序列, 并将其响应放到一个阻塞队列, 等待netd返回指令的结果, 如果超过指定的超时时间, 则抛出一个超时的异常. 在第一部分时, 讲到SocketListener拿到上层发过来的指令后, 会将其分发给对应的指令类进行处理(看SocketListener的子类FrameworkListener): 12345678910111213141516171819202122232425262728293031323334353637bool FrameworkListener::onDataAvailable(SocketClient *c) &#123; char buffer[CMD_BUF_SIZE]; int len; len = TEMP_FAILURE_RETRY(read(c-&gt;getSocket(), buffer, sizeof(buffer))); if (len &lt; 0) &#123; SLOGE("read() failed (%s)", strerror(errno)); return false; &#125; else if (!len) &#123; return false; &#125; else if (buffer[len-1] != '\0') &#123; SLOGW("String is not zero-terminated"); android_errorWriteLog(0x534e4554, "29831647"); c-&gt;sendMsg(500, "Command too large for buffer", false); mSkipToNextNullByte = true; return true; &#125; int offset = 0; int i; for (i = 0; i &lt; len; i++) &#123; if (buffer[i] == '\0') &#123; /* IMPORTANT: dispatchCommand() expects a zero-terminated string */ if (mSkipToNextNullByte) &#123; mSkipToNextNullByte = false; &#125; else &#123; dispatchCommand(c, buffer + offset); &#125; offset = i + 1; &#125; &#125; mSkipToNextNullByte = false; return true;&#125; 函数dispatchCommmand会检查所有指令处理类, 匹配相应的类去执行指令: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void FrameworkListener::dispatchCommand(SocketClient *cli, char *data) &#123; FrameworkCommandCollection::iterator i; int argc = 0; char *argv[FrameworkListener::CMD_ARGS_MAX]; char tmp[CMD_BUF_SIZE]; char *p = data; char *q = tmp; char *qlimit = tmp + sizeof(tmp) - 1; bool esc = false; bool quote = false; bool haveCmdNum = !mWithSeq; memset(argv, 0, sizeof(argv)); memset(tmp, 0, sizeof(tmp)); ... *q = '\0'; if (argc &gt;= CMD_ARGS_MAX) goto overflow; argv[argc++] = strdup(tmp); if (quote) &#123; cli-&gt;sendMsg(500, "Unclosed quotes error", false); goto out; &#125; if (errorRate &amp;&amp; (++mCommandCount % errorRate == 0)) &#123; /* ignore this command - let the timeout handler handle it */ SLOGE("Faking a timeout"); goto out; &#125; for (i = mCommands-&gt;begin(); i != mCommands-&gt;end(); ++i) &#123; FrameworkCommand *c = *i; if (!strcmp(argv[0], c-&gt;getCommand())) &#123; if (c-&gt;runCommand(cli, argc, argv)) &#123; SLOGW("Handler '%s' error (%s)", c-&gt;getCommand(), strerror(errno)); &#125; goto out; &#125; &#125; cli-&gt;sendMsg(500, "Command not recognized", false);out: int j; for (j = 0; j &lt; argc; j++) free(argv[j]); return;overflow: cli-&gt;sendMsg(500, "Command too long", false); goto out;&#125; 比如这里执行的是, 网络接口相关的设置, 因此会调用InterfaceCmd来执行该指令. NETD与内核进行交互NETD通过netlink事件与内核进行消息的交换.在第一部分时看到, netd启动时, 会配置socket与内核进行通信: netlink事件NETLINK_KOBJECT_UEVENT: 用于内核向netd发生消息, 如网口的状态变化; netlink事件NETLINK_ROUTE:用于接收路由信息, 如路由表的更新与删除; netlink事件NETLINK_NFLOG:用于接收数据流量使用配额的消息, 如数据使用超限; netlink事件NETLINK_NETFILTER用于接收包过滤(netfilter)的消息; 12345678910111213141516171819202122232425262728293031int NetlinkManager::start() &#123; if ((mUeventHandler = setupSocket(&amp;mUeventSock, NETLINK_KOBJECT_UEVENT, 0xffffffff, NetlinkListener::NETLINK_FORMAT_ASCII, false)) == NULL) &#123; return -1; &#125; if ((mRouteHandler = setupSocket(&amp;mRouteSock, NETLINK_ROUTE, RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV6_IFADDR | RTMGRP_IPV6_ROUTE | (1 &lt;&lt; (RTNLGRP_ND_USEROPT - 1)), NetlinkListener::NETLINK_FORMAT_BINARY, false)) == NULL) &#123; return -1; &#125; if ((mQuotaHandler = setupSocket(&amp;mQuotaSock, NETLINK_NFLOG, NFLOG_QUOTA_GROUP, NetlinkListener::NETLINK_FORMAT_BINARY, false)) == NULL) &#123; ALOGW("Unable to open qlog quota socket, check if xt_quota2 can send via UeventHandler"); // TODO: return -1 once the emulator gets a new kernel. &#125; if ((mStrictHandler = setupSocket(&amp;mStrictSock, NETLINK_NETFILTER, 0, NetlinkListener::NETLINK_FORMAT_BINARY_UNICAST, true)) == NULL) &#123; ALOGE("Unable to open strict socket"); // TODO: return -1 once the emulator gets a new kernel. &#125; return 0;&#125; 每一个netlink的socket都会新建一个NetlinkHandler, 用于处理内核的消息, 并将该消息广播给上层: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586void NetlinkHandler::onEvent(NetlinkEvent *evt) &#123; const char *subsys = evt-&gt;getSubsystem(); if (!subsys) &#123; ALOGW("No subsystem found in netlink event"); return; &#125; if (!strcmp(subsys, "net")) &#123; NetlinkEvent::Action action = evt-&gt;getAction(); const char *iface = evt-&gt;findParam("INTERFACE"); if (action == NetlinkEvent::Action::kAdd) &#123; notifyInterfaceAdded(iface); &#125; else if (action == NetlinkEvent::Action::kRemove) &#123; notifyInterfaceRemoved(iface); &#125; else if (action == NetlinkEvent::Action::kChange) &#123; evt-&gt;dump(); notifyInterfaceChanged("nana", true); &#125; else if (action == NetlinkEvent::Action::kLinkUp) &#123; notifyInterfaceLinkChanged(iface, true); &#125; else if (action == NetlinkEvent::Action::kLinkDown) &#123; notifyInterfaceLinkChanged(iface, false); &#125; else if (action == NetlinkEvent::Action::kAddressUpdated || action == NetlinkEvent::Action::kAddressRemoved) &#123; const char *address = evt-&gt;findParam("ADDRESS"); const char *flags = evt-&gt;findParam("FLAGS"); const char *scope = evt-&gt;findParam("SCOPE"); if (action == NetlinkEvent::Action::kAddressRemoved &amp;&amp; iface &amp;&amp; address) &#123; // Note: if this interface was deleted, iface is "" and we don't notify. SockDiag sd; if (sd.open()) &#123; char addrstr[INET6_ADDRSTRLEN]; strncpy(addrstr, address, sizeof(addrstr)); char *slash = strchr(addrstr, '/'); if (slash) &#123; *slash = '\0'; &#125; int ret = sd.destroySockets(addrstr); if (ret &lt; 0) &#123; ALOGE("Error destroying sockets: %s", strerror(ret)); &#125; &#125; else &#123; ALOGE("Error opening NETLINK_SOCK_DIAG socket: %s", strerror(errno)); &#125; &#125; if (iface &amp;&amp; iface[0] &amp;&amp; address &amp;&amp; flags &amp;&amp; scope) &#123; notifyAddressChanged(action, address, iface, flags, scope); &#125; &#125; else if (action == NetlinkEvent::Action::kRdnss) &#123; const char *lifetime = evt-&gt;findParam("LIFETIME"); const char *servers = evt-&gt;findParam("SERVERS"); if (lifetime &amp;&amp; servers) &#123; notifyInterfaceDnsServers(iface, lifetime, servers); &#125; &#125; else if (action == NetlinkEvent::Action::kRouteUpdated || action == NetlinkEvent::Action::kRouteRemoved) &#123; const char *route = evt-&gt;findParam("ROUTE"); const char *gateway = evt-&gt;findParam("GATEWAY"); const char *iface = evt-&gt;findParam("INTERFACE"); if (route &amp;&amp; (gateway || iface)) &#123; notifyRouteChange(action, route, gateway, iface); &#125; &#125; &#125; else if (!strcmp(subsys, "qlog") || !strcmp(subsys, "xt_quota2")) &#123; const char *alertName = evt-&gt;findParam("ALERT_NAME"); const char *iface = evt-&gt;findParam("INTERFACE"); notifyQuotaLimitReached(alertName, iface); &#125; else if (!strcmp(subsys, "strict")) &#123; const char *uid = evt-&gt;findParam("UID"); const char *hex = evt-&gt;findParam("HEX"); notifyStrictCleartext(uid, hex); &#125; else if (!strcmp(subsys, "xt_idletimer")) &#123; const char *label = evt-&gt;findParam("INTERFACE"); const char *state = evt-&gt;findParam("STATE"); const char *timestamp = evt-&gt;findParam("TIME_NS"); const char *uid = evt-&gt;findParam("UID"); if (state) notifyInterfaceClassActivity(label, !strcmp("active", state), timestamp, uid); &#125;&#125; 至此， Netd的介绍就结束了。 总的说来， Netd服务是Android网络管理的核心进程之一， 对于了解Android网络管理很有帮助， 看下其实现细节对于掌握网络相关的问题至关重要。 参考资料 http://linux-ip.net/html/index.html https://en.wikipedia.org/wiki/Netfilter netfilter connection tracking system]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>netd</tag>
        <tag>NetworkManagerService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式及其应用]]></title>
    <url>%2F2018%2F11%2F30%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[正则表达式(regular expression)是指一种操作字符串的搜索模式/模板(Pattern Template)，可用于文本的搜索、编辑等操作。如下是一个正则表达式： ^[0-9] 其定义了一个搜索非数字字符的模式。正则表达式在如Shell(sed/gawk)/Python/Java等语言中都有广泛的应用. 正则表达式规则字符匹配符下表是常用的字符匹配符： 表1 字符匹配符 正则表达式 说明 . 匹配任意字符 ^ 一行的开始 $ 是否一行的末尾 [] 匹配在[ch]中的任意一个字符 () 从正则表达式匹配结果中产生子字符串, ma(tri)?x匹配max或者matrix / Oct (1st / 2nd)匹配 Oct 1st或者Oct 2nd \ 转义字符, 将特殊字符转义, 如a\.b匹配的是a.b而不是ajb ^regex 在一行的开始出匹配regex regex$ 在一行的末尾匹配regex [abc] 匹配字符a或b或c [abc][vz] 匹配a/b/c后跟v/z的字符串 [^abc] 匹配除了a/b/c之外的任意字符 [a-d] 匹配a到d之间的字符 [0-8] 匹配0到8之间的数字 XZ 搜索 XZ x/z 搜索 X 或者 Z 由于hexo排版的原因, 上表中/实际为 | 元字符为了简化表达式规则，正则表达式提供了几种元字符(meta characters)： 表2 元字符 正则表达式 说明 \d 任意数字,[0-9]的简写 \D 非数字匹配，[^0-9]的简写 \s 空白字符，[ \t\n\x0b\r\f]的简写 \S 非空白字符，[^\s]的简写 \w 单词匹配符，[a-zA-Z_0-9]的简写 \W 非单词匹配符，[^\w]的简写 \S+ 多个非空白字符 \b 单词[a-zA-Z0-9_]边界字符匹配 \r 回车符 数量匹配符另外，正则表达式还提供了数量匹配符(Quantifier),用于标识一个元素出现的频次，主要有以下几种： 表3 数量匹配符 正则表达式 说明 示例 * 出现次数 &gt;= 0,等同{0,} x* 查找零个或者多个字符x; .*匹配任意字符串 + 出现次数 &gt;= 1,等同 {1,} x+ 匹配出现次数大于1的字符x ? 出现次数不多于1次，等同{0,1} x? 查找出现次数不大于1次的字符x {n} 出现次数为 n \d{3} 搜索长度为3的数字字符串 {n1,n2} 出现次数在 n1 与 n2 之间 \d{1,4} 数字字符长度在1 ~ 4之间的字符串 *? ?放在一个数量匹配符的后面时，定义为一个“懒惰数量匹配符” (reluctant/lazy quantifier),该匹配符找到最小的一个匹配，然后搜索到第一个匹配字符时，即不再搜索 s.*?o 匹配 *stacko*verflow, 而s.*o匹配的是*stackoverflo*w 给定正则表达式的模式可以在一个正则表达式的开始给定一个模式修改符(mode modifiers): (?i) 使正则表达式不区分大小写 (?s) 单行模式,匹配包括换行符在内的所有字符(makes the dot match all characters, including line breaks) (?m) 多行模式(makes the caret and dollar match at the start and end of each line in the subject string.) 若需要指定多种模式，则将其组合在一起即可: (?ism) 正则表达式的应用在shell脚本中使用正则表达式在shell脚本命令find, grep中, 经常需要使用正则表达式来查找字符: 比如在ifconfig中查找ip地址: 12ifconfig | grep -E "[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;" 在tcpdump中过滤IP地址: 12tcpdump | grep -E "[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;" 在某个文件中查找所有单词: 1cat xxx.log | grep -E &quot;[a-zA-Z+] 在Java中使用正则表达式Java中的 String 支持正则表达式来操作字符串，这给文本操作带来了很大的方便： 表4 String中的正则表达式方法 方法 说明 str.matches(&quot;regex&quot;) 判断字符串str是否与regex相匹配 str.split(&quot;regex&quot;) 通过regex分割字符串str str.replaceFirst(&quot;regex&quot;,&quot;replacement&quot;) 用replacement替换字符串中第一次出现 regex的字符串 str.replaceAll(&quot;regex&quot;,&quot;replacement&quot;) 用于replacement替换所有匹配regex的字符串 参考示例: 123456789101112131415161718 package de.vogella.regex.test; public class RegexTestStrings &#123; public static final String EXAMPLE_TEST = "This is my small example " + "string which I'm going to " + "use for pattern matching."; public static void main(String[] args) &#123; System.out.println(EXAMPLE_TEST.matches("\\w.*")); String[] splitString = (EXAMPLE_TEST.split("\\s+"));System.out.println(splitString.length);// should be 14 for (String string : splitString) &#123; System.out.println(string); &#125; // replace all whitespace with tabs System.out.println(EXAMPLE_TEST.replaceAll("\\s+", "\t")); &#125; &#125; 注意: 在Java中斜杠\是一个转义字符，因此为了得到单个的斜杠字符，需要用\\来实现 Pattern/Matcher对于更高级的应用，Java提供了两个类Pattern(java.util.regex.Pattern) 和 Matcher (java.util.regex.Matcher): 首先，使用 Pattern 得到对应的正则表达式； 然后，利用 Matcher 来操作相应的字符串 参考示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 import java.util.regex.Pattern;import java.util.regex.Matcher;public class RegularExpression &#123; private String regx = null; private Pattern pattern = null; private Matcher matcher = null; public static void main(String[] args)&#123; // regular expression test String input = new String("here 2016, now we encounter very confusing things. On the one hand, we human beings feel " + "very confident, but on the other hand, we are so fucking lost in our self-built world! we do waste our energy" + "and time on useless things. We are totally lost."); String regDigit = new String("\\d"); String regChars = new String("hand|useless"); String regWild = new String("[^af]"); String regWord = new String("\\w"); String regTimes = new String("[a-z]&#123;5&#125;"); RegularExpression reg = new RegularExpression(regDigit); reg.getMatcherResult(input); reg.setRegx(regChars); reg.getMatcherResult(input); reg.setRegx(regWild); reg.getMatcherResult(input); reg.setRegx(regWord); reg.getMatcherResult(input); reg.setRegx(regTimes); reg.getMatcherResult(input); &#125; public RegularExpression()&#123; &#125; public RegularExpression(String reg)&#123; this.regx = reg; this.pattern = Pattern.compile(regx); &#125; public void getMatcherResult(String in)&#123; System.out.println("current regression expression is " + regx); this.matcher = pattern.matcher(in); while(matcher.find())&#123; System.out.println(matcher.group()); &#125; &#125; public void setRegx(String regx)&#123; this.regx = regx; this.pattern = Pattern.compile(regx); &#125;&#125; 正则表达式注意事项 正则表达式区分大小写 正则表达式模式会匹配数据流中文本的任何位置, 因此要注意模式的开头与结尾 参考文章 http://www.vogella.com/tutorials/JavaRegularExpressions/article.html http://www.ntu.edu.sg/home/ehchua/programming/howto/regexe.html https://www.regular-expressions.info/repeat.html GAWK manual Sed manual]]></content>
      <categories>
        <category>Regular Expression</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>Regular Expression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket编程与IO multiplexing]]></title>
    <url>%2F2018%2F07%2F21%2Fsocket%E7%BC%96%E7%A8%8B%E4%B8%8EIO%E5%A4%8D%E7%94%A8%2F</url>
    <content type="text"><![CDATA[socket通常用于跨进程通信(Inter-Process Communication,IPC)，由于其最早BSD Unix发行版中使用，因此也叫做Barkeley sockets。socket封装了底层网络通信协议细节，为上层应用提供了一个统一的接口，按照使用的“域”不同，又分为用于网络通信的internet socket以及用于本地进程通信的Unix domain socket。 那么，如何利用socket实现IPC通信了？在多个客户端的情况下，服务端要如何实现同时响应多个客户请求了，即如何实现多个IO端口的监听(I/O multiplex)？这篇文章，就来看看这两个问题。首先，来看下socket编程的一些基本知识。 socket编程基础一个socket由三个元素唯一确定： internet地址(如果是Unix domain socket,则对应一个本地文件名) 端到端的协议类型(面向连接的TCP或者无连接的UDP） 用于确定传送数据应用的端口号（port） 在使用socket前，首先需要通过系统调用socket创建一个socket对象，并返回该socket对应的文件描述符： 12345#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol); 创建一个socket需要指定三个参数: 通信域，确定协议族，比如AF_UNIX/AF_LOCAL用于本地通信；AF_INET/AF_INET6基于TCP/IP协议族，用于网络通信;AF_NETLINK用于进程与内核通信；AF_APPLETALK用于AppleTalk通信 socket类型：SOCK_STREAM提供了序列化、可靠、全双工的字节流通信；SOCK_DGRAM提供了无连接、不可靠的数据报文通信 协议：指定使用的协议类型，比如是TCP（IPPROTO_TCP)还是UDP(IPPROTO_UDP)，其在sys/un.h中定义； | 有关socket参数的具体说明，可参考http://www.man7.org/linux/man-pages/man2/socket.2.html 下图是一个基于TCP协议的socket通信流程图(包括握手与挥手流程，这里只说明三次握手流程）： 对于客户端与服务端进程，都需要通过socket(int, int, int)来创建一个socket，得到一个socket文件描述符用于后续的通信； 在服务端，首先要将创建的socket文件描述符与本的某个地址进行绑定，并监听该地址对应的文件，并通过accept接口准备接受来自客户端的通信请求； 在客户端，通过调用connect尝试与服务端建立通信链路，在此过程中，客户端与服务端会进行三次握手来建立一个连接； 至此，一个全双工的通信链接就建立完成了，客户端与服务端都可以同时向对方发送数据了 按照上述流程，来看看一个client/server的socket通信示例: 客户端不断发送消息给服务端，服务端接受到消息后，原封不动的将其发送给客户端 客户端代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;#include&lt;netinet/in.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;errno.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;const static char* SERVER_ADDR = "127.0.0.1";const static int MAX_BUF_SIZE = 256;int socket_fd;int main(int argc, char* argv[])&#123; if (argc != 2) &#123; printf("Usage: %s &lt;port&gt;\n", argv[0]); exit(0); &#125; struct sockaddr_in sa; int res; /** 1. create a TCP based socket */ socket_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (socket_fd &lt; 0) &#123; perror("cannot create socket"); exit(EXIT_FAILURE); &#125; memset(&amp;sa, 0, sizeof(sa)); /** 2. set network address of the server */ sa.sin_family = AF_INET; /* address familiy*/ sa.sin_port = htons(atoi(argv[1])); /* address port */ sa.sin_addr.s_addr = inet_addr(SERVER_ADDR); /* internet address */ /** 3. try to connect server */ if (connect(socket_fd, (struct sockaddr*) &amp;sa, sizeof(sa)) &lt; 0) &#123; perror("connect failure"); close(socket_fd); exit(EXIT_FAILURE); &#125; printf("Client: server is connected\n"); char buf[MAX_BUF_SIZE]; /* keep sending message to server */ while(1) &#123; fgets(buf, MAX_BUF_SIZE, stdin); if (strncmp(buf, "quit", 4) == 0 || strncmp(buf, "q", 1) == 0) &#123; printf("quit\n"); write(socket_fd, "quit", 4); break; &#125; else &#123; printf("Client: %s\n", buf); int len = strlen(buf); if (send(socket_fd, buf, len, 0) != len) &#123; printf("client: send message error\n"); break; &#125; memset(buf, 0, MAX_BUF_SIZE); if (recv(socket_fd, buf, MAX_BUF_SIZE, 0) &lt; 0) &#123; printf("fail to receive message from server\n"); break; &#125; printf("Server:%s", buf); &#125; &#125; close(socket_fd); return 0;&#125; 服务端代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 #include&lt;sys/types.h&gt; #include&lt;sys/socket.h&gt; #include&lt;netinet/in.h&gt; #include&lt;arpa/inet.h&gt; #include&lt;errno.h&gt; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;unistd.h&gt;const static int SERVER_PORT = 2100;const static int MAX_PENDING = 10;const static int MAX_RCV_BUF = 256;int main(int argc, char* argv[])&#123; if (argc != 2) &#123; printf("Usage %s &lt;port&gt;\n", argv[0]); exit(EXIT_FAILURE); &#125; char buf[MAX_RCV_BUF]; int socket_fd; struct sockaddr_in sa; if ((socket_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) &#123; printf("fail to create socket"); exit(EXIT_FAILURE); &#125; sa.sin_family = AF_INET; /** htonl/htons 将host字节序转为network字节序 */ sa.sin_addr.s_addr = htonl(INADDR_ANY); /* INADDR_ANY表示该端口可接受任何入境消息 */ sa.sin_port = htons(atoi(argv[1])); /* 将socket与地址进行绑定*/ if (bind(socket_fd, (struct sockaddr*) &amp;sa, sizeof(sa)) &lt; 0) &#123; perror("fail to bind socket address\n"); goto errout; &#125; /* 监听socket */ if (listen(socket_fd, MAX_PENDING) &lt; 0) &#123; perror("fail to listen port\n"); goto errout; &#125; printf("server is started\n"); for(; ;) &#123; /* accept any requests from clients */ int connect_fd = accept(socket_fd, NULL, NULL); if (connect_fd &lt; 0) &#123; perror("fail to accept"); goto errout; &#125; /* keep receving message from client */ while(1) &#123; if (read(connect_fd, buf, MAX_RCV_BUF) &lt; 0) &#123; perror("fail to read"); break; &#125; buf[strlen(buf)] = 0; printf("Client: %s\n", buf); if (write(connect_fd, buf, strlen(buf)) &lt; 0) &#123; perror("fail to send to client\n"); break; &#125; if (strncmp(buf, "quit", 4) == 0) &#123; printf("talk is done*_*\n"); break; &#125; &#125; close(connect_fd); &#125;errout: close(socket_fd); exit(EXIT_FAILURE); exit(EXIT_SUCCESS);&#125; 在服务端，如果等待请求队列中有client的请求，则accept返回一个新的fd用于数据的读写；如果没有，则阻塞当前进程直到有客户请求为止。因此，上述服务端是无法同时响应多个客户请求的。如果服务端需要同时响应多个客户请求，不阻塞当前进程，则需要使用select或者poll/epoll来监听socket，如果有客户请求，kernel会及时通知用户进程；对每个客户请求，服务端可通过启动新的进程与线程来处理。作为演示，这里使用下面的方法来解决进程阻塞以及多个客户请求的问题： 服务端进程同时监听多个端口，客户端可通过不同的端口向服务端发送数据 分别使用select或者poll/epoll来监听这些端口，对于每个请求都启动一个新的线程进行处理 IO复用：服务端如何同时处理多个客户请求目前在Linux下，常见的IO复用(I/O multiplexing)方式有: select: 可监听的文件描述符(fd)最大不超过1024(由_SC_OPEN_MAX确定）； poll:对监听的fd个数没有限制，但是随着fd数目的增加，性能也会随着下降，因为每次收到有可用fd事件时，poll都需要遍历整个监听集合； epoll: 对监听的fd个数无限制，不同与poll的地方时，epoll监听返回的是一个可用fd的集合，而不是整个监听fd的集合，因此效率上比poll更高； 接下来，就具体看看这种IO复用方式如何处理服务端的请求。 为了监听多个端口，需要在服务端进程启动时，创建多个socket: 123456789101112131415161718192021222324252627int main(int argc, char* argv[])&#123; if (argc &lt; 2) &#123; printf("Usage %s &lt;port_1&gt; &lt;port_2&gt; ... \n", argv[0]); exit(0); &#125; /* io multiplex */ fd_set sockset; struct timeval timeout; /* is server running */ int running = 1; /* max file descriptors of socket */ int maxFd = -1; int* serverSock; int portNum = 0; serverSock = (int*)malloc((argc - 1) * sizeof(int)); for (int i = 1; i &lt; argc; ++i) &#123; int port = atoi(argv[i]); serverSock[portNum++] = createServerSocket(port); maxFd = serverSock[portNum-1] &gt; maxFd ? serverSock[portNum-1] : maxFd; &#125; ... &#125; 接着，利用select或者poll或者epoll来实现上述端口的监听： select使用select需要做以下几个事情： 创建一个fd集合: fd_set sockset; 每次使用前都需要将其清空:FD_ZERO(&amp;sockset); 将所要监听的fd保存到sockset中: FD_SET(serverSock[p], &amp;sockset); 设置监听的超时时间，监听对应的fd集合：select(maxFd + 1, &amp;sockset, NULL, NULL, &amp;timeout),如果该调用返回-1则意味着超时，否则表示有新的IO事件了，可通过FD_ISSET(serverSock[p], &amp;sockset)来检查对应的fd是否处于可读写的状态 123456789101112131415161718192021222324252627282930313233while(running) &#123; /* this must be reset for every time select() is called */ FD_ZERO(&amp;sockset); FD_SET(STDIN_FILENO, &amp;sockset); for (int p = 0; p &lt; portNum; ++p) &#123; FD_SET(serverSock[p], &amp;sockset); &#125; /* timeout for select IO */ /* must be called every time select() is called */ timeout.tv_sec = DEFAULT_TIMEOUT; timeout.tv_usec = 0; if (select(maxFd + 1, &amp;sockset, NULL, NULL, &amp;timeout) &lt; 0) &#123; printf("fail to get ready fd for %d seconds, waiting...again", DEFAULT_TIMEOUT); &#125; else &#123; if (FD_ISSET(STDIN_FILENO, &amp;sockset)) &#123; printf("server is gonna to shut down\n"); running = 0; &#125; for (int p = 0; p &lt; portNum; ++p) &#123; if (FD_ISSET(serverSock[p], &amp;sockset)) &#123; pthread_t tid; int clientFd = acceptConnection(serverSock[p]); /* create pthread to handle client request */ pthread_create(&amp;tid, NULL, (void*)handleRequest, (void*)&amp;clientFd); &#125; &#125; &#125;&#125; | select linux man page: http://man7.org/linux/man-pages/man2/select.2.html pollpoll有一个专门的数据结构pollfd来记录监听的fd: 其由三部分组成，一个是监听的fd，一个是需要监听的事件，比如POLLIN/POLLPRI；一个监听返回的事件，比如‵POLLOUT/POLLERR/POLLHUP`， 123456struct pollfd &#123; int fd; /* file descriptor */ short events; /* requested events */ short revents; /* returned events */&#125;; 利用poll来监听多个IO事件，需要： 创建一个pollfd数组用于保存监听的fd集合: struct pollfd pollFds[MAX_PORTS]; 将需要监听的fd添加到该集合: 12345 for (i = 1; i &lt; argc; ++i) &#123;pollFds[i].fd = createServerSocket(atoi(argv[i]));pollFds[i].events = POLLIN; &#125; 指定超时时间，监听fd集合: int ready = poll(pollFds, maxFds, MAX_POLL_TIMEOUT);, 如果返回小于0的值，则表示出现了错误；如果返回值为0，则表示超时，返回一个大于0的值，表示当前可用的fd的个数 123456789101112131415161718192021222324252627282930313233343536373839404142434445int running = 1;while (running) &#123; int ready = poll(pollFds, maxFds, MAX_POLL_TIMEOUT); if (ready &lt; 0) &#123; perror("fail to poll"); goto errout; &#125; else if (ready == 0) &#123; //printf("timeout\n"); continue; &#125; else &#123; memset(buf, 0, MAX_BUF_SIZE); for (i = 0; i &lt; maxFds; ++i) &#123; if (pollFds[i].fd &gt; 0 &amp;&amp; (pollFds[i].events &amp; POLLIN)) &#123; if (pollFds[i].fd == STDIN_FILENO) &#123; // read from stdin stream if (fgets(buf, MAX_BUF_SIZE, stdin) == NULL) &#123; perror("fail to read stdin"); continue; &#125; int len = strlen(buf); if (send(pollFds[i].fd, buf, len , 0) != len) &#123; perror("fail to send data"); continue; &#125; &#125; else &#123; int fd = acceptConnection(pollFds[i].fd); if (fd &lt; 0) &#123; perror("fail to accept connection"); &#125; else &#123; pthread_t tid; if (pthread_create(&amp;tid, NULL, handleRequst, (void*)&amp;fd) != 0) &#123; perror("fail to create handle thread"); close(fd); goto errout; &#125; &#125; &#125; &#125; &#125; &#125;&#125; | poll man page： http://man7.org/linux/man-pages/man2/poll.2.html epollepoll使用一个数据结构epoll_event来描述所监听的fd集合: 123456789101112typedef union epoll_data &#123; void *ptr; int fd; uint32_t u32; uint64_t u64; &#125; epoll_data_t; struct epoll_event &#123; uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ &#125;; 这里的events表示所发生的事件类型，有EPOLLIN/EPOLLOUT/EPOLLHUP，这里的取值跟poll中的事件基本一致。使用epoll的步骤: 声明两个epoll_event集合,一个用于监听，一个用于监听返回: struct epoll_event polledEv[MAX_PORTS], readyEv[MAX_PORTS]; 在kernel创建一个epoll的fd: int epollFd = epoll_create1(0); 将需要监听的fd保存到epoll_event中：epoll_ctl(epollFd, EPOLL_CTL_ADD, sockFd, &amp;polledEv[i]) 等待可用的集合: int ready = epoll_wait(epollFd, readyEv, MAX_PORTS, 5);， 返回小于零表示出现错误；返回0表示超时；返回大于0，表示当前有多少个可用的文件描述符。相应的集合保存到readyEv中，因此只需要遍历这个子集即可得到对应可用的fd 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364struct epoll_event polledEv[MAX_PORTS], readyEv[MAX_PORTS]; int i; for (i = 0; i &lt; argc; ++i) &#123;polledEv[i].data.fd = -1; &#125; int epollFd = epoll_create1(0); if (epollFd &lt; 0) &#123;perror("fail to create epoll for stdin");exit(EXIT_FAILURE); &#125; polledEv[0].data.fd = STDIN_FILENO; polledEv[0].events = EPOLLIN; if (epoll_ctl(epollFd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;polledEv[0]) &lt; 0) &#123;perror("epoll_ctl: stdin");exit(EXIT_FAILURE); &#125; for (i = 1; i &lt; argc; ++i) &#123;int sockFd = createServerSocket(atoi(argv[i]));if (sockFd &lt; 0) &#123; perror("fail to create socket"); continue; &#125; polledEv[i].data.fd = sockFd;polledEv[i].events = EPOLLIN;if (epoll_ctl(epollFd, EPOLL_CTL_ADD, sockFd, &amp;polledEv[i]) &lt; 0) &#123; perror("epoll_ctl"); close(sockFd); exit(EXIT_FAILURE);&#125; &#125; int running = 1; while (running) &#123;int ready = epoll_wait(epollFd, readyEv, MAX_PORTS, 5);if (ready &lt; 0) &#123; perror("epoll_wait:"); goto errout;&#125; else if (ready == 0) &#123; //printf("timeout\n") continue;&#125; else &#123; for (i = 0; i &lt; ready; ++i) &#123; int fd = acceptConnecton(readyEv[i].data.fd); if (fd &lt; 0) &#123; perror("fail to accept request"); continue; &#125; pthread_t tid; if (pthread_create(&amp;tid, NULL, handleRequest, (void*)&amp;fd) != 0) &#123; perror("fail to create handle thread"); close(fd); goto errout; &#125; &#125;&#125; &#125; | epoll man page: http://man7.org/linux/man-pages/man7/epoll.7.html 最后，对于每个客户请求，都创建一个新的线程来处理请求： 12345678910111213141516171819202122232425262728293031void handleRequest(void* args)&#123; int fd = *((int*)args); if (fd &lt; 0) &#123; pthread_exit(NULL); &#125; printf("handleRequest(): from fd=%d\n", fd); char buf[MAX_BUF_SIZE]; while(1) &#123; if (recv(fd, buf, MAX_BUF_SIZE, 0) &lt; 0) &#123; printf("fail to receive message from client\n"); break; &#125; printf("Client(%d): %s\n", fd, buf); int len = strlen(buf); buf[len] = 0; if (send(fd, buf, len, 0) != len) &#123; printf("fail to echo"); break; &#125; &#125; close(fd); pthread_exit(NULL);&#125; 这里分别采用select，poll以及epoll在服务端监听客户IO事件，只是作为演示学习用，实际服务器端使用的是更为复杂的IO复用模型，更多相关的资料可参考C10K: http://www.kegel.com/c10k.html。 参考文献 https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_71/rzab6/howdosockets.htm http://beej.us/guide/bgipc/html/multi/index.html http://www.kegel.com/c10k.html LWN email list: epoll as a system call https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html https://lwn.net/Articles/14168/ https://www.programering.com/a/MzN4IDMwATM.html https://notes.shichao.io/unp/ch6/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>socket programming</tag>
        <tag>I/O multiplexing</tag>
        <tag>network programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于技术发展的一些思考]]></title>
    <url>%2F2018%2F06%2F22%2F%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[社会或法律就是这样或者应当这样起源的。它们给弱者新的桎梏， 给富人以新的力量。 卢梭 最近一年，在智能终端出现的第十一个年头，有关5G/物联网/车联网，人工智能/深度学习方面的消息层出不穷，一场新的技术变革正在悄然来临，人们的生活方式与思维方式也如智能终端出现时那样注定要被深刻的被影响与改变。 在Android终端做了将近四年的开发，对移动通信行业有了一定的了解。从2G到3G再到4G(LTE))，移动通信技术正在加速变化。未来，随着5G的大规模商用，传统的CS(Circuit Switching)网络业务终将告别历史舞台，我们所熟知的2G/3G网络将不可避免的被抛弃，而终端所有的通讯应用，无论是打电话，发短信等传统业务，还是像IMS/VOLTE等视频业务都会统一到一个通信方式上来:PS(Packet Switching)。LTE（4G)与5G本质上都只有PS一种数据传输模式了，但LTE为了支持CS语音通话，还会支持CSFB，SRVCC以实现LTE网络与CS网络的平滑过渡。那么，为何5G能够带来如此多的话题与想象了?4G与5G又有那些根本上的差异？相比LTE网络，5G速度更快（峰值速度可达100Mbit/s),延时更小（数据建立过程只需1ms左右），单位面积可接入的设备密度更高(每平方公里可达106接入设备), 移动性更强（移动速度最高可到500km/h仍然可以保证通信质量）。 具体来说, 5G提供了比4G更丰富的应用场景: eMBB(enhanced Mobile Broadband): 提供更快速的连接, 更高的吞吐量, 更大的容量. 适用于大量用户集中的场景, 比如大型活动场所(体育馆/演唱会等) URLLC(Ultra Reliable Low Latency Communications): 提供低于10ms延迟的链接, 适用于需要低延迟的场景, 如自动驾驶 mMTC(Massive Machine-Type Communications): 大规模低功耗设备的互联, 适用于大量IoT设备的相互通讯 5G的到来，让智能终端与设备链接有了更多的想象空间： 物联网（Internet of Things): 有了5G ， 万物皆可连接网络，成为产生数据的节点，也有了消费数据的能力； 智能家居成为每个家庭的标配，让人们的生活更加方便舒适； 车联网(Internet of Vehicle): 汽车不再仅仅是一个出行工具，还是网络的一部分，为人们的出行做出优化，为用户带来更多的便捷；借助自动驾驶，长途自驾出行不再是件痛苦的事情； 在高铁上，不用担心没有网络了，5G网络在终端高速移动的情况下仍然可以保持良好的服务与体验； 工业生产设备也可以通过5G网络连接上网络，把采集到的数据采集到数据中心节点上，为工业生产流程优化提供决策支持； 无论是芯片厂商还是网络设备厂商，都对5G的商用做了诸多的畅想： Ericsson Qualcomm Huawei 大量的设备链接意味着产生的数据量也会成倍的增加。有了海量的数据我们可以做些什么了？通过数据，个人与企业都可以对自己的决策做出更多的优化。个人可以通过追踪身体指标来把握自己的身体健康状态，保持自己与家庭设备时刻连接的状态；互联网企业通过深度学习与大规模数据的挖掘来发掘用户行为，为企业决策提供更多支持；工业企业通过大数据可以控制与优化生产流程，提升效益，创造更多的价值。未来，无疑是一个数据流与信息流的社会。人们的生活依赖于数据的支撑，也离不开数据。 对于大部分个人与中小企业而言，数据的存放与挖掘都需要依赖于大企业提供服务。很多的基础功能与服务都可以通过云计算 来实现。今天，人们已经可以通过云端来部署诸如数据存储，网页托管，内容分发以及视频直播，未来，很多常见的智能设备所拥有的功能都可能通过云化来实现；人们不再需要一个“笨重”的移动设备，而是一个很“轻”的终端，这个终端只是一个服务的入口，所有的应用甚至操作系统都放在云端，核心的计算与功能都通过云端来实现，人们实际操作的是一个虚拟的云端设备。这有点类似于今天的浏览器，人们通过浏览器可以得到各种各样的服务，而无须安装其他的应用软件。云无处不在，成为像水、电一样的基础设施服务。 可以想见，在不远的未来，5G与物联网， 云，大数据以及人工智能将成为科技发展的引擎，在更深程度的影响与改变人类的生活与思维方式。]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>5G</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAL binder工作流程-以RILJ/RILD通信为例]]></title>
    <url>%2F2018%2F06%2F17%2FHAL-binder%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-%E4%BB%A5RILJ-RILD%E9%80%9A%E4%BF%A1%E4%B8%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Telephony(RIL Java,以下简称RILJ）与RILD(RIL Daemon)的通信在Android OO8.0以前都是基于socket通信，而Android 8.0则是基于HAL binder进行IPC的数据交换。有关RILJ与RILD的工作原理可以参考之前的两篇文章：Android RIL概述以及RILD详解。这篇文章主要分析RILJ与RILD是如何通过HAL Binder进行通信。 RILJ与RILD的通信，服务端是RILD,客户端是RILJ。对于RILD而言，其对应的HAL接口是/android/hardware/interfaces/radio/1.0/IRadio.hal: 123456789101112131415161718192021222324252627282930/** * This interface is used by telephony &amp; telecom to talk to cellular radio. * All the functions have minimum one parameter: * serial: which corresponds to serial no. of request. Serial numbers must only be memorized for the * duration of a method call. If clients provide colliding serials (including passing the same * serial to different methods), multiple responses (one for each method call) must still be served. */interface IRadio &#123; /** * Set response functions for radio requests &amp; radio indications. * * @param radioResponse Object containing response functions * @param radioIndication Object containing radio indications */ setResponseFunctions(IRadioResponse radioResponse, IRadioIndication radioIndication); /** * Requests status of the ICC card * * @param serial Serial number of request. * * Response function is IRadioResponse.getIccCardStatusResponse() * */ oneway getIccCardStatus(int32_t serial); ...&#125; 而RILJ对应的回调接口有两个：/android/hardware/interfaces/radio/1.0/IRadioResponse.hal(RILJ发送给RILD的请求响应）; /android/hardware/interfaces/radio/1.0/IRadioIndication.hal（RILD主动上班的事件）： IRadioResponse.hal 123456789101112131415161718192021222324252627282930/** * Interface declaring response functions to solicited radio requests. * Response functions defined in this interface are as per following convention: * &lt;xyz&gt;Response is response to IRadio.&lt;xyz&gt; */interface IRadioResponse &#123; /** * @param info Response info struct containing response type, serial no. and error * @param cardStatus ICC card status as defined by CardStatus in types.hal * * Valid errors returned: * RadioError:NONE */ oneway getIccCardStatusResponse(RadioResponseInfo info, CardStatus cardStatus); /** * @param info Response info struct containing response type, serial no. and error * @param remainingRetries Number of retries remaining, must be equal to -1 if unknown. * * Valid errors returned: * RadioError:NONE * RadioError:RADIO_NOT_AVAILABLE (radio resetting) * RadioError:PASSWORD_INCORRECT */ oneway supplyIccPinForAppResponse(RadioResponseInfo info, int32_t remainingRetries); ....&#125; IRadioIndication.hal 12345678910111213141516171819202122232425262728293031323334353637/** * Interface declaring unsolicited radio indications. */interface IRadioIndication &#123; /** * Indicates when radio state changes. * * @param type Type of radio indication * @param radioState Current radio state */ oneway radioStateChanged(RadioIndicationType type, RadioState radioState); /** * Indicates when call state has changed. * Callee must invoke IRadio.getCurrentCalls() * Must be invoked on, for example, * "RING", "BUSY", "NO CARRIER", and also call state * transitions (DIALING-&gt;ALERTING ALERTING-&gt;ACTIVE) * * Redundent or extraneous invocations are tolerated * * @param type Type of radio indication */ oneway callStateChanged(RadioIndicationType type); /** * Indicates when voice or data network state changed * Callee must invoke IRadio.getVoiceRegistrationState(), IRadio.getDataRegistrationState(), * and IRadio.getOperator() * * @param type Type of radio indication */ oneway networkStateChanged(RadioIndicationType type); ....&#125; RILJ与RILD的通信大致要经历三个步骤： RILD启动后，向HwServiceManager注册服务slot1(第二个RILD对应slot2); RILJ启动后，从HwServiceManager获取RILD服务，并且注册两个回调函数: IRadioRepsone.java以及IRadioIndication.java分别用于接收来自RILD的消息； RILD收到来自RILJ的回调注册后，注册一个RILJ的死亡通知对象，并且发送消息告知RILJ链接建立成功。 注册RILD服务在RILD启动后，加载完vendor RIL之后，vendor RIL注册一个回调函数RIL_RadioFunctions: 关于RILD的详细介绍可以参考 123456789101112131415161718192021222324252627282930313233343536373839404142// ril_service.cppextern "C" voidRIL_register (const RIL_RadioFunctions *callbacks) &#123; int ret; int flags; RLOGI("SIM_COUNT: %d", SIM_COUNT); if (callbacks == NULL) &#123; RLOGE("RIL_register: RIL_RadioFunctions * null"); return; &#125; RLOGE("RIL_register: RIL version %d", callbacks-&gt;version); if (s_registerCalled &gt; 0) &#123; RLOGE("RIL_register has been called more than once. " "Subsequent call ignored"); return; &#125; memcpy(&amp;s_callbacks, callbacks, sizeof (RIL_RadioFunctions)); s_registerCalled = 1; RLOGI("s_registerCalled flag set, %d", s_started); // Little self-check for (int i = 0; i &lt; (int)NUM_ELEMS(s_commands); i++) &#123; assert(i == s_commands[i].requestNumber); &#125; for (int i = 0; i &lt; (int)NUM_ELEMS(s_unsolResponses); i++) &#123; assert(i + RIL_UNSOL_RESPONSE_BASE == s_unsolResponses[i].requestNumber); &#125; // 注册RILD服务 radio::registerService(&amp;s_callbacks, s_commands); RLOGI("RILHIDL called registerService");&#125; 注册RILD服务:(1) 启动RILD服务所需的HAL binder线程池，线程数目为1；（2）将RIL服务RadioImpl注册为系统服务，供客户端调用。 1234567891011121314151617181920212223242526272829303132333435363738394041void radio::registerService(RIL_RadioFunctions *callbacks, CommandInfo *commands) &#123; using namespace android::hardware; int simCount = 1; const char *serviceNames[] = &#123; android::RIL_getServiceName() #if (SIM_COUNT &gt;= 2) , RIL2_SERVICE_NAME #if (SIM_COUNT &gt;= 3) , RIL3_SERVICE_NAME #if (SIM_COUNT &gt;= 4) , RIL4_SERVICE_NAME #endif #endif #endif &#125;; #if (SIM_COUNT &gt;= 2) simCount = SIM_COUNT; #endif configureRpcThreadpool(1, true /* callerWillJoin */); for (int i = 0; i &lt; simCount; i++) &#123; pthread_rwlock_t *radioServiceRwlockPtr = getRadioServiceRwlock(i); int ret = pthread_rwlock_wrlock(radioServiceRwlockPtr); assert(ret == 0); radioService[i] = new RadioImpl; radioService[i]-&gt;mSlotId = i; oemHookService[i] = new OemHookImpl; oemHookService[i]-&gt;mSlotId = i; RLOGD("registerService: starting IRadio %s", serviceNames[i]); android::status_t status = radioService[i]-&gt;registerAsService(serviceNames[i]); status = oemHookService[i]-&gt;registerAsService(serviceNames[i]); ret = pthread_rwlock_unlock(radioServiceRwlockPtr); assert(ret == 0); &#125; s_vendorFunctions = callbacks; s_commands = commands;&#125; RadioImpl实际继承了IRadio.hal中定义的接口，这个接口在编译时，Android利用HIDL的工具hidl-gen来产生对应的客户端代理Proxy对象以及服务端存根Stub对象，但IRadio.hal中并没有声明registerAsService接口，那么这个接口是从何而来了？猜测应该是由HIDL工具主动生成的接口。不妨看看hidl-gen的代码/android/system/tools/hidl/。找到相应的main函数: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293int main(int argc, char **argv) &#123; std::string outputPath; std::vector&lt;std::string&gt; packageRootPaths; std::vector&lt;std::string&gt; packageRoots; const char *me = argv[0]; OutputHandler *outputFormat = nullptr; // 解析参数 int res; while ((res = getopt(argc, argv, "ho:r:L:")) &gt;= 0) &#123; switch (res) &#123; case 'o': &#123; outputPath = optarg; break; &#125; case 'r': &#123; std::string val(optarg); auto index = val.find_first_of(':'); CHECK(index != std::string::npos); auto package = val.substr(0, index); auto path = val.substr(index + 1); packageRootPaths.push_back(path); packageRoots.push_back(package); break; &#125; case 'L': &#123; CHECK(outputFormat == nullptr) &lt;&lt; "Only one -L option allowed."; for (auto &amp;e : formats) &#123; if (e.mKey == optarg) &#123; outputFormat = &amp;e; break; &#125; &#125; CHECK(outputFormat != nullptr) &lt;&lt; "Output format not recognized."; break; &#125; case '?': case 'h': default: &#123; usage(me); exit(1); break; &#125; &#125; &#125; argc -= optind; argv += optind; .... // 负责产生.hal接口的头文件，源文件 Coordinator coordinator(packageRootPaths, packageRoots); for (int i = 0; i &lt; argc; ++i) &#123; FQName fqName(argv[i]); if (!fqName.isValid()) &#123; fprintf(stderr, "ERROR: Invalid fully-qualified name.\n"); exit(1); &#125; OutputHandler::ValRes valid = outputFormat-&gt;validate(fqName, outputFormat-&gt;mKey); if (valid == OutputHandler::FAILED) &#123; fprintf(stderr, "ERROR: output handler failed.\n"); exit(1); &#125; // 产生对应的代理与存根文件 status_t err = outputFormat-&gt;generate(fqName, me, &amp;coordinator, outputPath); if (err != OK) &#123; exit(1); &#125; &#125; return 0;&#125; hidl-gen大致包含了以下几个参数: 输出路径； 产生的语言类型,C++还是Java还是头文件; 接口所在的根目录； 接口的全限定名(Full qulified name); 12hidl-gen -o output-path -L language (-r interface-root) fqname 对于RILD服务来说，其生成的指令如下(参考对应接口目录的Android.bp脚本）: 12hidl-gen -o $(genDir) -Lc++-sources -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport android.hardware.radio@1.0", 对于C++源文件，最后会调用generatedCpp.cpp中的generateCppSources函数产生接口对应的Proxy/Stub代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147status_t AST::generateCppSources(const std::string &amp;outputPath) const &#123; std::string path = outputPath; path.append(mCoordinator-&gt;convertPackageRootToPath(mPackage)); path.append(mCoordinator-&gt;getPackagePath(mPackage, true /* relative */)); std::string ifaceName; std::string baseName; const Interface *iface = nullptr; bool isInterface; if (!AST::isInterface(&amp;ifaceName)) &#123; baseName = "types"; isInterface = false; &#125; else &#123; iface = mRootScope-&gt;getInterface(); baseName = iface-&gt;getBaseName(); isInterface = true; &#125; path.append(baseName); if (baseName != "types") &#123; path.append("All"); &#125; path.append(".cpp"); CHECK(Coordinator::MakeParentHierarchy(path)); FILE *file = fopen(path.c_str(), "w"); if (file == NULL) &#123; return -errno; &#125; Formatter out(file); out &lt;&lt; "#include &lt;android/log.h&gt;\n"; out &lt;&lt; "#include &lt;cutils/trace.h&gt;\n"; out &lt;&lt; "#include &lt;hidl/HidlTransportSupport.h&gt;\n\n"; if (isInterface) &#123; // This is a no-op for IServiceManager itself. out &lt;&lt; "#include &lt;android/hidl/manager/1.0/IServiceManager.h&gt;\n"; // TODO(b/34274385) remove this out &lt;&lt; "#include &lt;hidl/LegacySupport.h&gt;\n"; generateCppPackageInclude(out, mPackage, iface-&gt;getProxyName()); generateCppPackageInclude(out, mPackage, iface-&gt;getStubName()); generateCppPackageInclude(out, mPackage, iface-&gt;getPassthroughName()); for (const Interface *superType : iface-&gt;superTypeChain()) &#123; generateCppPackageInclude(out, superType-&gt;fqName(), superType-&gt;fqName().getInterfaceProxyName()); &#125; out &lt;&lt; "#include &lt;hidl/ServiceManagement.h&gt;\n"; &#125; else &#123; generateCppPackageInclude(out, mPackage, "types"); generateCppPackageInclude(out, mPackage, "hwtypes"); &#125; .... if (err == OK &amp;&amp; isInterface) &#123; const Interface *iface = mRootScope-&gt;getInterface(); // need to be put here, generateStubSource is using this. out &lt;&lt; "const char* " &lt;&lt; iface-&gt;localName() &lt;&lt; "::descriptor(\"" &lt;&lt; iface-&gt;fqName().string() &lt;&lt; "\");\n\n"; out &lt;&lt; "__attribute__((constructor))"; out &lt;&lt; "static void static_constructor() &#123;\n"; out.indent([&amp;] &#123; out &lt;&lt; "::android::hardware::details::gBnConstructorMap.set(" &lt;&lt; iface-&gt;localName() &lt;&lt; "::descriptor,\n"; out.indent(2, [&amp;] &#123; out &lt;&lt; "[](void *iIntf) -&gt; ::android::sp&lt;::android::hardware::IBinder&gt; &#123;\n"; out.indent([&amp;] &#123; out &lt;&lt; "return new " &lt;&lt; iface-&gt;getStubName() &lt;&lt; "(static_cast&lt;" &lt;&lt; iface-&gt;localName() &lt;&lt; " *&gt;(iIntf));\n"; &#125;); out &lt;&lt; "&#125;);\n"; &#125;); out &lt;&lt; "::android::hardware::details::gBsConstructorMap.set(" &lt;&lt; iface-&gt;localName() &lt;&lt; "::descriptor,\n"; out.indent(2, [&amp;] &#123; out &lt;&lt; "[](void *iIntf) -&gt; ::android::sp&lt;" &lt;&lt; gIBaseFqName.cppName() &lt;&lt; "&gt; &#123;\n"; out.indent([&amp;] &#123; out &lt;&lt; "return new " &lt;&lt; iface-&gt;getPassthroughName() &lt;&lt; "(static_cast&lt;" &lt;&lt; iface-&gt;localName() &lt;&lt; " *&gt;(iIntf));\n"; &#125;); out &lt;&lt; "&#125;);\n"; &#125;); &#125;); out &lt;&lt; "&#125;;\n\n"; out &lt;&lt; "__attribute__((destructor))"; out &lt;&lt; "static void static_destructor() &#123;\n"; out.indent([&amp;] &#123; out &lt;&lt; "::android::hardware::details::gBnConstructorMap.erase(" &lt;&lt; iface-&gt;localName() &lt;&lt; "::descriptor);\n"; out &lt;&lt; "::android::hardware::details::gBsConstructorMap.erase(" &lt;&lt; iface-&gt;localName() &lt;&lt; "::descriptor);\n"; &#125;); out &lt;&lt; "&#125;;\n\n"; err = generateInterfaceSource(out); &#125; if (err == OK &amp;&amp; isInterface) &#123; err = generateProxySource(out, iface-&gt;fqName()); &#125; if (err == OK &amp;&amp; isInterface) &#123; err = generateStubSource(out, iface); &#125; if (err == OK &amp;&amp; isInterface) &#123; err = generatePassthroughSource(out); &#125; if (err == OK &amp;&amp; isInterface) &#123; const Interface *iface = mRootScope-&gt;getInterface(); if (isIBase()) &#123; out &lt;&lt; "// skipped getService, registerAsService, registerForNotifications\n"; &#125; else &#123; std::string package = iface-&gt;fqName().package() + iface-&gt;fqName().atVersion(); implementServiceManagerInteractions(out, iface-&gt;fqName(), package); &#125;&#125; 正是在implementServiceManagerInteractions这个函数里，对于IRadio.hal接口生成了获取服务getService以及注册服务的registerAsService的接口。可以看到，registerAsService利用了defaultServiceManager()来调用IServiceManager进行服务注册。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152static void implementServiceManagerInteractions(Formatter &amp;out, const FQName &amp;fqName, const std::string &amp;package) &#123; const std::string interfaceName = fqName.getInterfaceName(); implementGetService(out, fqName, true /* isTry */); implementGetService(out, fqName, false /* isTry */); out &lt;&lt; "::android::status_t " &lt;&lt; interfaceName &lt;&lt; "::registerAsService(" &lt;&lt; "const std::string &amp;serviceName) "; out.block([&amp;] &#123; out &lt;&lt; "::android::hardware::details::onRegistration(\"" &lt;&lt; fqName.getPackageAndVersion().string() &lt;&lt; "\", \"" &lt;&lt; interfaceName &lt;&lt; "\", serviceName);\n\n"; out &lt;&lt; "const ::android::sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm\n"; out.indent(2, [&amp;] &#123; out &lt;&lt; "= ::android::hardware::defaultServiceManager();\n"; &#125;); out.sIf("sm == nullptr", [&amp;] &#123; out &lt;&lt; "return ::android::INVALID_OPERATION;\n"; &#125;).endl(); out &lt;&lt; "::android::hardware::Return&lt;bool&gt; ret = " &lt;&lt; "sm-&gt;add(serviceName.c_str(), this);\n" &lt;&lt; "return ret.isOk() &amp;&amp; ret ? ::android::OK : ::android::UNKNOWN_ERROR;\n"; &#125;).endl().endl(); out &lt;&lt; "bool " &lt;&lt; interfaceName &lt;&lt; "::registerForNotifications(\n"; out.indent(2, [&amp;] &#123; out &lt;&lt; "const std::string &amp;serviceName,\n" &lt;&lt; "const ::android::sp&lt;::android::hidl::manager::V1_0::IServiceNotification&gt; " &lt;&lt; "&amp;notification) "; &#125;); out.block([&amp;] &#123; out &lt;&lt; "const ::android::sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm\n"; out.indent(2, [&amp;] &#123; out &lt;&lt; "= ::android::hardware::defaultServiceManager();\n"; &#125;); out.sIf("sm == nullptr", [&amp;] &#123; out &lt;&lt; "return false;\n"; &#125;).endl(); out &lt;&lt; "::android::hardware::Return&lt;bool&gt; success =\n"; out.indent(2, [&amp;] &#123; out &lt;&lt; "sm-&gt;registerForNotifications(\"" &lt;&lt; package &lt;&lt; "::" &lt;&lt; interfaceName &lt;&lt; "\",\n"; out.indent(2, [&amp;] &#123; out &lt;&lt; "serviceName, notification);\n"; &#125;); &#125;); out &lt;&lt; "return success.isOk() &amp;&amp; success;\n"; &#125;).endl().endl();&#125; defaultServiceManager在ServiceManagement.cpp中定义,HAL服务管家HwServiceManager初始化完成后，会设置属性值hwservicemanager.ready;这样defaultServiceManager实际返回的是一个强引用的变量gDefaultServiceManager: 代码路径/android/system/libhidl/transport/ServiceManagement.cpp 1234567891011121314151617181920212223242526272829303132333435363738sp&lt;IServiceManager&gt; defaultServiceManager() &#123; &#123; AutoMutex _l(details::gDefaultServiceManagerLock); if (details::gDefaultServiceManager != NULL) &#123; return details::gDefaultServiceManager; &#125; if (access("/dev/hwbinder", F_OK|R_OK|W_OK) != 0) &#123; // HwBinder not available on this device or not accessible to // this process. return nullptr; &#125; waitForHwServiceManager(); while (details::gDefaultServiceManager == NULL) &#123; details::gDefaultServiceManager = fromBinder&lt;IServiceManager, BpHwServiceManager, BnHwServiceManager&gt;( ProcessState::self()-&gt;getContextObject(NULL)); if (details::gDefaultServiceManager == NULL) &#123; LOG(ERROR) &lt;&lt; "Waited for hwservicemanager, but got nullptr."; sleep(1); &#125; &#125; &#125; return details::gDefaultServiceManager;&#125;//等待hwservicemanager启动完成void waitForHwServiceManager() &#123; using std::literals::chrono_literals::operator""s; while (!WaitForProperty(kHwServicemanagerReadyProperty, "true", 1s)) &#123; LOG(WARNING) &lt;&lt; "Waited for hwservicemanager.ready for a second, waiting another..."; &#125;&#125; 那么，gDefaultServiceManager又是什么东东了？先来看看ProcessState::self()-&gt;getContextObject(NULL)得到的是一个什么对象: 1234567891011121314151617181920212223242526272829303132sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/)&#123; return getStrongProxyForHandle(0);&#125;sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)&#123; sp&lt;IBinder&gt; result; AutoMutex _l(mLock); handle_entry* e = lookupHandleLocked(handle); if (e != NULL) &#123; // We need to create a new BpHwBinder if there isn't currently one, OR we // are unable to acquire a weak reference on this current one. See comment // in getWeakProxyForHandle() for more info about this. IBinder* b = e-&gt;binder; if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123; b = new BpHwBinder(handle); e-&gt;binder = b; if (b) e-&gt;refs = b-&gt;getWeakRefs(); result = b; &#125; else &#123; result.force_set(b); e-&gt;refs-&gt;decWeak(this); &#125; &#125; return result;&#125; 从上面的代码不难看出，ProcessState::self()-&gt;getContextObject(NULL)实际返回的是一个BpHwBinder(0)的Binder代理对象，函数fromBinder会根据这个Binder对象转换成相应的IServiceManager: BpHwServerceManager(BpHwBinder(0)),BpHwServerceManager实际上也是根据接口IServiceManager.hal通过generatedCpp.cpp中的函数生成的代理对象， 123456789101112131415161718192021template &lt;typename IType, typename ProxyType, typename StubType&gt;sp&lt;IType&gt; fromBinder(const sp&lt;IBinder&gt;&amp; binderIface) &#123; using ::android::hidl::base::V1_0::IBase; using ::android::hidl::base::V1_0::BnHwBase; if (binderIface.get() == nullptr) &#123; return nullptr; &#125; // 代理对象，本地binder为空 if (binderIface-&gt;localBinder() == nullptr) &#123; return new ProxyType(binderIface); &#125; sp&lt;IBase&gt; base = static_cast&lt;BnHwBase*&gt;(binderIface.get())-&gt;getImpl(); if (details::canCastInterface(base.get(), IType::descriptor)) &#123; StubType* stub = static_cast&lt;StubType*&gt;(binderIface.get()); return stub-&gt;getImpl(); &#125; else &#123; return nullptr; &#125;&#125; 这样HwServiceManager的在客户端的代理对象BpHwServerceManager将客户端请求发送给HAL Binder驱动；HAL Binder驱动则将请求发送给HAL服务管家的stub对象BnHwServiceManager（BnHwServiceManager在何时成为HAL服务上下文管家的，可以看看上一篇文章“Android HAL binder详解”)来完成服务的注册。 获取RILD服务RILD HAL服务注册完成之后，RILJ是如何获取到服务的了？Phone进程启动后，对RILJ进行初始化，这时RILJ会去获取RILD服务， 123456789101112131415161718192021222324252627282930public RIL(Context context, int preferredNetworkType, int cdmaSubscription) &#123; this(context, preferredNetworkType, cdmaSubscription, null);&#125; public RIL(Context context, int preferredNetworkType, int cdmaSubscription, Integer instanceId) &#123; super(context); mContext = context; mPreferredNetworkType = preferredNetworkType; mPhoneType = RILConstants.NO_PHONE; mPhoneId = instanceId; ConnectivityManager cm = (ConnectivityManager)context.getSystemService( Context.CONNECTIVITY_SERVICE); mIsMobileNetworkSupported = cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE); // 新建response,indication，用于接收RILD的消息 mRadioResponse = new RadioResponse(this); mRadioIndication = new RadioIndication(this); mOemHookResponse = new OemHookResponse(this); mOemHookIndication = new OemHookIndication(this); mRilHandler = new RilHandler(); mRadioProxyDeathRecipient = new RadioProxyDeathRecipient(); .... // 获取RILD HAL服务 getRadioProxy(null); getOemHookProxy(null);&#125; getRadioProxy首先判断终端是否支持移动数据，如果没有移动数据（没有modem），则直接返回空；如果已经获取到了，则返回之前获取到的代理对象mRadioProxy。如果都不是，通过IRadio.getService来获取RILD服务的代理对象，接着向RILD注册回调函数mRadioResponse以及mRadioIndication,同时还需要注册RILD服务的死亡注册通知接收器，以便RILD异常退出后，RILJ能够收到该信息做相应的处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private IRadio getRadioProxy(Message result) &#123; if (!mIsMobileNetworkSupported) &#123; if (RILJ_LOGV) riljLog("getRadioProxy: Not calling getService(): wifi-only"); if (result != null) &#123; AsyncResult.forMessage(result, null, CommandException.fromRilErrno(RADIO_NOT_AVAILABLE)); result.sendToTarget(); &#125; return null; &#125; if (mRadioProxy != null) &#123; return mRadioProxy; &#125; try &#123; mRadioProxy = IRadio.getService(HIDL_SERVICE_NAME[mPhoneId == null ? 0 : mPhoneId]); if (mRadioProxy != null) &#123; mRadioProxy.linkToDeath(mRadioProxyDeathRecipient, mRadioProxyCookie.incrementAndGet()); mRadioProxy.setResponseFunctions(mRadioResponse, mRadioIndication); &#125; else &#123; riljLoge("getRadioProxy: mRadioProxy == null"); &#125; &#125; catch (RemoteException | RuntimeException e) &#123; mRadioProxy = null; riljLoge("RadioProxy getService/setResponseFunctions: " + e); &#125; if (mRadioProxy == null) &#123; if (result != null) &#123; AsyncResult.forMessage(result, null, CommandException.fromRilErrno(RADIO_NOT_AVAILABLE)); result.sendToTarget(); &#125; // 此时RILD服务还无法获取到，则延迟几秒再次获取 mRilHandler.sendMessageDelayed( mRilHandler.obtainMessage(EVENT_RADIO_PROXY_DEAD, mRadioProxyCookie.incrementAndGet()), IRADIO_GET_SERVICE_DELAY_MILLIS); &#125; return mRadioProxy;&#125; 这里有一个问题，搜索Android源码并没有IRadio.java类，那么只能说同之前HwServiceMananger一样，这个类也是通过hidl-gen来产生的。看下IRadio.hal对应目录的Android.bp并没有定义生成规则，是不是在Android.mk里边了？搜了下，果然在： 12345678910111213141516171819202122232425## Build IRadio.hal#GEN := $(intermediates)/android/hardware/radio/V1_0/IRadio.java$(GEN): $(HIDL)$(GEN): PRIVATE_HIDL := $(HIDL)$(GEN): PRIVATE_DEPS := $(LOCAL_PATH)/IRadio.hal$(GEN): PRIVATE_DEPS += $(LOCAL_PATH)/IRadioIndication.hal$(GEN): $(LOCAL_PATH)/IRadioIndication.hal$(GEN): PRIVATE_DEPS += $(LOCAL_PATH)/IRadioResponse.hal$(GEN): $(LOCAL_PATH)/IRadioResponse.hal$(GEN): PRIVATE_DEPS += $(LOCAL_PATH)/types.hal$(GEN): $(LOCAL_PATH)/types.hal$(GEN): PRIVATE_OUTPUT_DIR := $(intermediates)$(GEN): PRIVATE_CUSTOM_TOOL = \ $(PRIVATE_HIDL) -o $(PRIVATE_OUTPUT_DIR) \ -Ljava \ -randroid.hardware:hardware/interfaces \ -randroid.hidl:system/libhidl/transport \ android.hardware.radio@1.0::IRadio$(GEN): $(LOCAL_PATH)/IRadio.hal $(transform-generated-source)LOCAL_GENERATED_SOURCES += $(GEN) 可以简单的写成如下这个指令，其作用是生成一个Java层的类用于获取RILD的服务。 hidl-gen利用generateJava.cpp中的函数generateJava来自动生成对应的类 12hidl-gen -o $(PRIVATE_OUTPUT_DIR) -LJava -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport ` generateJava.cpp生成的IRadio.java大致结构如下（只写了几个关键函数）。绕来绕去，IRadio.getService(&quot;slot1&quot;)实际返回的是一个由HwBinder.getService返回的IHwBinder对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package android.hardware.radio;public interface IRaio extends android.os.IHwInterface &#123; public static final String kInterfaceName = "android.hardware.radio::IRadio"; static asInterface(android.os.IHwBinder binder) &#123; if (binder == null) &#123; return null; &#125; android.os.IHwInterface iface = binder.queryLocalInterface(kInterfaceName); if (iface != null &amp;&amp; iface instanceof IRaio) &#123; return (IRadio)iface; &#125; IRadio proxy = new IRadio.Proxy(binder); try &#123; for (String descriptor : proxy.interfaceChain()) &#123; if (descriptor.equals(kInterfaceName)) &#123; return proxy; &#125; &#125; &#125; catch (android.os.RemoteException e) &#123; &#125; return null; ... public static getService(String serviceName) throws android.os.RemoteException &#123; return IRadio.asInterface(android.os.HwBinder.getService( android.hardware.radio@1.0::IRadio, serviceName)); &#125; ... public static final class Proxy implements IRadio &#123; private android.os.IHwBinder mRemote; public Proxy(android.os.IHwBinder remote) &#123; mRemote = java.util.Objects.requireNonNull(remote); &#125; @Override public android.os.IHwBinder asBinder() &#123; return mRemote; &#125; &#125; ... &#125;&#125; 继续看看HwBinder.getService返回的是什么东东？原来是一个native函数调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public abstract class HwBinder implements IHwBinder &#123; private static final String TAG = "HwBinder"; private static final NativeAllocationRegistry sNativeRegistry; public HwBinder() &#123; native_setup(); sNativeRegistry.registerNativeAllocation( this, mNativeContext); &#125; @Override public final native void transact( int code, HwParcel request, HwParcel reply, int flags) throws RemoteException; public abstract void onTransact( int code, HwParcel request, HwParcel reply, int flags) throws RemoteException; public native final void registerService(String serviceName) throws RemoteException; // native接口 public static native final IHwBinder getService( String iface, String serviceName) throws RemoteException, NoSuchElementException; // Returns address of the "freeFunction". private static native final long native_init(); private native final void native_setup(); static &#123; long freeFunction = native_init(); sNativeRegistry = new NativeAllocationRegistry( HwBinder.class.getClassLoader(), freeFunction, 128 /* size */); &#125; private long mNativeContext;&#125; native层获取HAL服务，仍然是通过defaultServiceManager来获取服务的代理对象，从上面获取上下文服务ServiceManager的过程不难看出hardware::defaultServiceManager()-&gt;get(&quot;android.hardware.radio@1.0::IRadio&quot;, &quot;slot1&quot;)返回的实际上是一个与RILD服务binder代理对象BpHwBinder(handle)（handle由注册服务时binder驱动自动生成）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899static jobject JHwBinder_native_getService( JNIEnv *env, jclass /* clazzObj */, jstring ifaceNameObj, jstring serviceNameObj) &#123; using ::android::hidl::base::V1_0::IBase; using ::android::hidl::manager::V1_0::IServiceManager; if (ifaceNameObj == NULL) &#123; jniThrowException(env, "java/lang/NullPointerException", NULL); return NULL; &#125; if (serviceNameObj == NULL) &#123; jniThrowException(env, "java/lang/NullPointerException", NULL); return NULL; &#125; auto manager = hardware::defaultServiceManager(); if (manager == nullptr) &#123; LOG(ERROR) &lt;&lt; "Could not get hwservicemanager."; signalExceptionForError(env, UNKNOWN_ERROR, true /* canThrowRemoteException */); return NULL; &#125; const char *ifaceNameCStr = env-&gt;GetStringUTFChars(ifaceNameObj, NULL); if (ifaceNameCStr == NULL) &#123; return NULL; // XXX exception already pending? &#125; std::string ifaceName(ifaceNameCStr); env-&gt;ReleaseStringUTFChars(ifaceNameObj, ifaceNameCStr); ::android::hardware::hidl_string ifaceNameHStr; ifaceNameHStr.setToExternal(ifaceName.c_str(), ifaceName.size()); const char *serviceNameCStr = env-&gt;GetStringUTFChars(serviceNameObj, NULL); if (serviceNameCStr == NULL) &#123; return NULL; // XXX exception already pending? &#125; std::string serviceName(serviceNameCStr); env-&gt;ReleaseStringUTFChars(serviceNameObj, serviceNameCStr); ::android::hardware::hidl_string serviceNameHStr; serviceNameHStr.setToExternal(serviceName.c_str(), serviceName.size()); // 判断当前service是直通式（C/S在同一进程）还是跨进程的binder类型 Return&lt;IServiceManager::Transport&gt; transportRet = manager-&gt;getTransport(ifaceNameHStr, serviceNameHStr); .... IServiceManager::Transport transport = transportRet; if (transport != IServiceManager::Transport::HWBINDER &amp;&amp; !vintfLegacy) &#123; LOG(ERROR) &lt;&lt; "service " &lt;&lt; ifaceName &lt;&lt; " declares transport method " &lt;&lt; toString(transport) &lt;&lt; " but framework expects hwbinder."; signalExceptionForError(env, UNKNOWN_ERROR, true /* canThrowRemoteException */); return NULL; &#125; // 返回一个BpHwBinder(handle)对象 Return&lt;sp&lt;hidl::base::V1_0::IBase&gt;&gt; ret = manager-&gt;get(ifaceNameHStr, serviceNameHStr); if (!ret.isOk()) &#123; signalExceptionForError(env, UNKNOWN_ERROR, true /* canThrowRemoteException */); return NULL; &#125; //对于远程代理对象，toBinder返回的是一个downcast后的`IBinder`对象（BpHwBinder) sp&lt;hardware::IBinder&gt; service = hardware::toBinder&lt; hidl::base::V1_0::IBase, hidl::base::V1_0::BpHwBase&gt;(ret); if (service == NULL) &#123; signalExceptionForError(env, NAME_NOT_FOUND); return NULL; &#125; LOG(INFO) &lt;&lt; "Starting thread pool."; ::android::hardware::ProcessState::self()-&gt;startThreadPool(); // 返回一个HwRemoteBinder(BpHwBinder(handle)) return JHwRemoteBinder::NewObject(env, service);&#125;// staticjobject JHwRemoteBinder::NewObject( JNIEnv *env, const sp&lt;hardware::IBinder&gt; &amp;binder) &#123; ScopedLocalRef&lt;jclass&gt; clazz(env, FindClassOrDie(env, CLASS_PATH)); // XXX Have to look up the constructor here because otherwise that static // class initializer isn't called and gProxyOffsets.constructID is undefined :( jmethodID constructID = GetMethodIDOrDie(env, clazz.get(), "&lt;init&gt;", "()V"); jobject obj = env-&gt;NewObject(clazz.get(), constructID); JHwRemoteBinder::GetNativeContext(env, obj)-&gt;setBinder(binder); return obj;&#125; native层得到RILD服务的IBinder对象后，将其保存到native对象JHwRemoteBinder(其对应的Java对象是HwRemoteBinder.java)，这样Java层代码binder就可以通过native接口来实现binder通信了。回到最开始调用的地方，至此我们知道，实际RILJ通过调用IRadio.getService得到的是一个私有变量mRemote=HwRemoteBinder的Proxy代理对象。这样RILJ就可以通过该代理对象与RILD进行通信了。大功告成。RILJ跟RILD的通信还差最后一步：RILJ向RILD注册回调。 HAL服务的类型（直通或者binder类型）是由各个厂商定义的，配置文件manifest.xml放在/android/device/目录下，其基本结构如下: 12345678910111213141516171819202122232425262728&lt;manifest version="1.0" type="device"&gt; &lt;hal format="hidl"&gt; &lt;name&gt;android.hardware.radio&lt;/name&gt; &lt;transport&gt;hwbinder&lt;/transport&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;interface&gt; &lt;name&gt;IRadio&lt;/name&gt; &lt;instance&gt;slot1&lt;/instance&gt; &lt;instance&gt;slot2&lt;/instance&gt; &lt;/interface&gt; &lt;interface&gt; &lt;name&gt;ISap&lt;/name&gt; &lt;instance&gt;slot1&lt;/instance&gt; &lt;instance&gt;slot2&lt;/instance&gt; &lt;/interface&gt; &lt;/hal&gt; &lt;hal format="hidl"&gt; &lt;name&gt;android.hardware.radio.deprecated&lt;/name&gt; &lt;transport&gt;hwbinder&lt;/transport&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;interface&gt; &lt;name&gt;IOemHook&lt;/name&gt; &lt;instance&gt;slot1&lt;/instance&gt; &lt;instance&gt;slot2&lt;/instance&gt; &lt;/interface&gt; &lt;/hal&gt;&lt;/manifest&gt; RILJ注册回调，通信建立完成RILJ获取到RILD的代理对象后，就可以通过远程调用向RILD发送请求了。但在建立最后的通信，还需要做三件事情： RILJ向RILD注册一个死亡通知: 当RILD异常退出后，通过该接收者来接受死亡消息 12 mRadioProxy.linkToDeath(mRadioProxyDeathReceipent, mRadioProxyCookie.incrementAndGet()); RILJ向RILD注册回调，RILD可通过该回调向RILJ发送消息： 12345678910111213141516171819202122232425262728Return&lt;void&gt; RadioImpl::setResponseFunctions( const ::android::sp&lt;IRadioResponse&gt;&amp; radioResponseParam, const ::android::sp&lt;IRadioIndication&gt;&amp; radioIndicationParam) &#123; RLOGD("setResponseFunctions"); pthread_rwlock_t *radioServiceRwlockPtr = radio::getRadioServiceRwlock(mSlotId); int ret = pthread_rwlock_wrlock(radioServiceRwlockPtr); assert(ret == 0); mRadioResponse = radioResponseParam; mRadioIndication = radioIndicationParam;//&lt; RNTFIX:: mSecRadioResponse = NULL; mSecRadioIndication = NULL;//&gt; RNTFIX mCounterRadio[mSlotId]++; ret = pthread_rwlock_unlock(radioServiceRwlockPtr); assert(ret == 0); // client is connected. Send initial indications. android::onNewCommandConnect((RIL_SOCKET_ID) mSlotId); return Void();&#125; RILD发送消息告知RILJ通信建立成功： 123456789101112131415161718192021222324252627282930 void onNewCommandConnect(RIL_SOCKET_ID socket_id) &#123; // Inform we are connected and the ril version int rilVer = s_callbacks.version; RIL_UNSOL_RESPONSE(RIL_UNSOL_RIL_CONNECTED, &amp;rilVer, sizeof(rilVer), socket_id); // implicit radio state changed RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED, NULL, 0, socket_id); // Send last NITZ time data, in case it was missed if (s_lastNITZTimeData != NULL) &#123; resendLastNITZTimeData(socket_id); &#125; // Get version string if (s_callbacks.getVersion != NULL) &#123; const char *version; version = s_callbacks.getVersion(); RLOGI("RIL Daemon version: %s\n", version); property_set(PROPERTY_RIL_IMPL, version); &#125; else &#123; RLOGI("RIL Daemon version: unavailable\n"); property_set(PROPERTY_RIL_IMPL, "unavailable"); &#125;&#125; 参考资料 http://sniffer.site/2016/11/29/Android-RILD详解/ http://sniffer.site/2016/11/29/Android-RIL概述/]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RILD</tag>
        <tag>Binder</tag>
        <tag>HAL</tag>
        <tag>RILJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入Android HAL binder]]></title>
    <url>%2F2018%2F06%2F06%2F%E6%B7%B1%E5%85%A5Android-HAL-binder%2F</url>
    <content type="text"><![CDATA[HAL binder是Android O(8.0)专门用于HAL（Hardware Abstract Layer)层（native）进程与其clients之间的通信机制（clients可以是native进程，也可以是Java Framework进程)。 HAL binder替代了早先使用的socket通信，其kernel层实际是基于原有的binder驱动，但为了配合Client与Server之间的数据传输，需要使用特定的中间层HIDL来进行接口与数据的转换。那么，相对之前的HAL通信方式（socket），基于HIDL的HAL通信有什么优势了？从系统架构的角度，HIDL为客户端与服务端提供了清晰的接口；从效率的角度，binder IPC实际在传输数据上只有一次拷贝，而socket实际传输需要两次数据拷贝。 目前Android有两种类型的HAL： binder化的HAL： 利用HIDL(HAL interface Definition Language)来描述HAL接口，Framework层与HAL层通过binder IPC的方式进行通信；如下的HAL模块都是利用binder IPC来进行通信的: `android.hardware.biometrics.fingerprint@2.1` `android.hardware.configstore@1.0` `android.hardware.dumpstate@1.0` `android.hardware.graphics.allocator@2.0` `android.hardware.radio@1.0` `android.hardware.usb@1.0` `android.hardware.wifi@1.0` `android.hardware.wifi.supplicant@1.0` 直通式HAL： 基于HIDL或者传统HAL方式来实现，在这种模式下，Framework层与HAL层的通信可以通过IPC的方式进行，也可以使用共享内存的方式在同一个进程内进行（passthrough,直通）。目前有如下两个HAL模块使用直通式方式进行通信： `android.hardware.graphics.mapper@1.0` `android.hardware.renderscript@1.0` 相关代码 /android/system/tools/hidl/： 根据HAL接口 .hal来产生相应的Proxy(client端接口）以及stub(server端接口）。 /android/system/libhwbinder/： 初始化binder线程，负责与binder驱动交互，读写数据； /android/system/libhidl： HIDL状态与HAL服务管理接口； /android/os/HwBinder： Java层Hardware binder代码，获取server端接口以及向server发起IPC调用； android_os_HwBinder.cpp (JNI)：Java层HAL binder的JNI代码，负责将Java层的请求传递给相应的server进程； /android/hardware/interfaces/： 各个模块HAL层接口，每个模块都包含了一个Android.bp的脚步来生成对应的代理(Proxy)与存根对象(stub)，如radio接口IRadio.hal,sensors接口ISensors.hal； /android/kernel/drivers/staging/android/： binder驱动； 下图是HAL binder的结构简图, 了解Binder的同学应该很快能看出，这个结构跟binder的C/S IPC架构很相似，区别的地方在对于HAL binder来说，server进程是Android的native进程而已。在接下来的两篇文章里，我将以Telephony Framwork(RILJ)与native进程RILD是如何通过hardware binder来进行通信为例，从以下两个方面来说明HAL Binder的实现机制与工作原理： HAL服务管家HwServiceMananger是如何启动以及如何注册、获取系统服务； RILJ如何通过HAL binder与RILD进行通信？ 关于Android.bp脚本可以参考https://android.googlesource.com/platform/build/soong/ 这篇文章，主要来看下第一个问题，HAL binder是如何启动以及管理所有HAL服务的。跟常规的binder通信（AMS，PMS等使用的binder）一样，HAL binder也需要有一个专门的服务管家，来统一管理系统的服务，同时为客户端提供诸如注册、获取服务等API。 HwServiceMananger的启动在/android/system/hwservicemanager/hwservicemanager.rc目录下，有个启动脚本hwservicemanager.rc，init进程在启动之后会对该脚本进行解析： 1234567891011service hwservicemanager /system/bin/hwservicemanager user system disabled group system readproc critical onrestart setprop hwservicemanager.ready false onrestart class_restart hal onrestart class_restart early_hal writepid /dev/cpuset/system-background/tasks class animation 在/android/system/core/rootdir/init.rc文件中，有个控制指令，专门来启动hwservicemananger这个系统服务： 12345678910111213on post-fs # Load properties from # /system/build.prop, # /odm/build.prop, # /vendor/build.prop and # /factory/factory.prop load_system_props # start essential services start logd start servicemanager start hwservicemanager start vndservicemanager 这样，系统加载hwservicemanager，进入main函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class BinderCallback : public LooperCallback &#123;public: BinderCallback() &#123;&#125; ~BinderCallback() override &#123;&#125; int handleEvent(int /* fd */, int /* events */, void* /* data */) override &#123; IPCThreadState::self()-&gt;handlePolledCommands(); return 1; // Continue receiving callbacks. &#125;&#125;;int main() &#123; // 初始化hwbinder驱动，设置线程池 configureRpcThreadpool(1, true /* callerWillJoin */); ServiceManager *manager = new ServiceManager(); if (!manager-&gt;add(serviceName, manager)) &#123; ALOGE("Failed to register hwservicemanager with itself."); &#125; // TokenManager有何作用？ TokenManager *tokenManager = new TokenManager(); if (!manager-&gt;add(serviceName, tokenManager)) &#123; ALOGE("Failed to register ITokenManager with hwservicemanager."); &#125; sp&lt;Looper&gt; looper(Looper::prepare(0 /* opts */)); int binder_fd = -1; // 设置线程进入等待状态，准备处理IPC请求 IPCThreadState::self()-&gt;setupPolling(&amp;binder_fd); if (binder_fd &lt; 0) &#123; ALOGE("Failed to aquire binder FD. Aborting..."); return -1; &#125; // Flush after setupPolling(), to make sure the binder driver // knows about this thread handling commands. IPCThreadState::self()-&gt;flushCommands(); // IPC请求回调，有数据时会调用该回调进行处理 sp&lt;BinderCallback&gt; cb(new BinderCallback); if (looper-&gt;addFd(binder_fd, Looper::POLL_CALLBACK, Looper::EVENT_INPUT, cb, nullptr) != 1) &#123; ALOGE("Failed to add hwbinder FD to Looper. Aborting..."); return -1; &#125; // Tell IPCThreadState we're the service manager sp&lt;BnHwServiceManager&gt; service = new BnHwServiceManager(manager); IPCThreadState::self()-&gt;setTheContextObject(service); ioctl(binder_fd, BINDER_SET_CONTEXT_MGR, 0); ... rc = property_set("hwservicemanager.ready", "true"); while (true) &#123; looper-&gt;pollAll(-1 /* timeoutMillis */); &#125; return 0;&#125; ServiceManager启动主要需要做以下几件事情： 初始化/dev/hwbinder驱动，为其分配一块虚拟内存用于IPC数据交换； 向hwbinder注册HAL服务管家(IPC上下文管理者）； 监听/dev/hwbinder是否有数据可读，如有则调用回调执行指令； hwbinder驱动初始化HwServiceManager启动的第一件事情，就是配置binder线程池，告知驱动当前需要启动多少个线程处理IPC指令：对于HwServiceManager而言，只需要一个binder线程，即调用者线程即可（调用者线程何时加入binder线程池下面会讲到），而无需启动新的线程。 12345// HidlBinderSupport.cppvoid configureBinderRpcThreadpool(size_t maxThreads, bool callerWillJoin) &#123; ProcessState::self()-&gt;setThreadPoolConfiguration(maxThreads, callerWillJoin /*callerJoinsPool*/);&#125; ProcessState只有一个实例（ProcessState可以看成是hwbinder用户空间进程状态管理者），因此在调用ProcessState():self的时候，如果当前ProcessState没有创建全局实例，则会创建一个实例： 12345678910sp&lt;ProcessState&gt; ProcessState::self()&#123; Mutex::Autolock _l(gProcessMutex); if (gProcess != NULL) &#123; return gProcess; &#125; gProcess = new ProcessState; return gProcess;&#125; 创建ProcessState的时候，主要做两件事： 打开/dev/hwbinder驱动，验证binder版本以及协议版本，并配置最大的binder线程数量（对于hwbinder，默认的最大线程数量为0）； 将/dev/hwbinder映射到一块大小约为1M的虚拟内存上用于交换IPC数据； 123456789101112131415161718192021222324252627282930ProcessState::ProcessState() : mDriverFD(open_driver()) // 配置最大线程数 , mVMStart(MAP_FAILED) , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER) , mThreadCountDecrement(PTHREAD_COND_INITIALIZER) , mExecutingThreadsCount(0) , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) , mStarvationStartTimeMs(0) , mManagesContexts(false) , mBinderContextCheckFunc(NULL) , mBinderContextUserData(NULL) , mThreadPoolStarted(false) , mSpawnThreadOnStart(true) , mThreadPoolSeq(1)&#123; if (mDriverFD &gt;= 0) &#123; // mmap the binder, providing a chunk of virtual address space to receive transactions. mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); if (mVMStart == MAP_FAILED) &#123; // *sigh* ALOGE("Using /dev/hwbinder failed: unable to mmap transaction memory.\n"); close(mDriverFD); mDriverFD = -1; &#125; &#125; else &#123; ALOGE("Binder driver could not be opened. Terminating."); &#125;&#125; ProcessState初始化完成后，获取到相应实例，配置线程池(对于每个HAL服务来是，一般线程池只有一个线程，就是服务进行注册时所在的主线程），告知线程当前所需的最大线程数目： 1234567891011status_t ProcessState::setThreadPoolMaxThreadCount(size_t maxThreads) &#123; status_t result = NO_ERROR; if (ioctl(mDriverFD, BINDER_SET_MAX_THREADS, &amp;maxThreads) != -1) &#123; mMaxThreads = maxThreads; &#125; else &#123; result = -errno; ALOGE("Binder ioctl to set max threads failed: %s", strerror(-result)); &#125; return result;&#125; 注册HAL服务管家线程池配置完成后，获取当前线程的Looper（对的，就是Framework层常用的Handler消息循环在native的对应），并告知HwBinder驱动由当前线程来处理HAL服务上下文相关的指令， 设置Looper消息回调。接着，就是注册HAL服务的管家ServiceManager了。 ServiceManager继承了IServiceManager接口，负责管理系统中所有的HAL服务，为其他进程提供服务注册、查找等功能： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Manages all the hidl hals on a device. * * Terminology: * Package: "android.hidl.manager" * Major version: "1" * Minor version: "0" * Version: "1.0" * Interface name: "IServiceManager" * Fully-qualified interface name: "android.hidl.manager@1.0::IServiceManager" * Instance name: "manager" * Fully-qualified instance name: "android.hidl.manager@1.0::IServiceManager/manager" */interface IServiceManager &#123; // Retrieve an existing service that supports the requested version. get(string fqName, string name) generates (interface service); /** * Register a service. The service manager must retrieve the (inherited) * interfaces that this service implements, and register them along with * the service. * */ add(string name, interface service) generates (bool success); enum Transport : uint8_t &#123; EMPTY, HWBINDER, PASSTHROUGH, &#125;; // Get the transport of a service. getTransport(string fqName, string name) generates (Transport transport); // List all registered services. Must be sorted. list() generates (vec&lt;string&gt; fqInstanceNames); // List all instances of a particular service. Must be sorted. listByInterface(string fqName) generates (vec&lt;string&gt; instanceNames); /** * Register for service notifications for a particular service. Must support * multiple registrations. */ registerForNotifications(string fqName, string name, IServiceNotification callback) generates (bool success); ... /** * When the passthrough service manager returns a service via * get(string, string), it must dispatch a registerPassthroughClient call * to the binderized service manager to indicate the current process has * called get(). Binderized service manager must record this PID, which can * be retrieved via debugDump. */ // 注册直通式客户端 registerPassthroughClient(string fqName, string name);&#125;; 接着， 让BnHwServiceManager成为HAL服务的上下文管家，需要做两件事：一是告知IPCThreadState负责上下文管理的对象，用于接收来自其他进程的IPC请求；一是告知kernel上下文管理者的是一个handle为0的IBinder对象，kernel会为其保存一个节点，以便IPC时使用。 123456// Tell IPCThreadState we're the service managersp&lt;BnHwServiceManager&gt; service = new BnHwServiceManager(manager);IPCThreadState::self()-&gt;setTheContextObject(service);// Then tell binder kernelioctl(binder_fd, BINDER_SET_CONTEXT_MGR, 0); BnHwServiceManager是ServiceManager服务端的stub对象，与客户端代理ProxyBpHwServiceManager相对应，具体怎么来的，在下一篇文章中再详细讲述 最后，设置hwservicemanager.ready，表面当前hwservicemanager已经处于可用状态；pollAll则表示hwservicemanager进入消息循环等待的过程，一旦/dev/hwbinder有数据可读，就会调用之前注册的BinderCallback进行处理。 123456rc = property_set("hwservicemanager.ready", "true");while (true) &#123; looper-&gt;pollAll(-1 /* timeoutMillis */);&#125; 在接下来的一篇文章，基于Telephony与RILD的通信来讲述HAL服务的具体工作流程。 参考文献 https://source.android.com/devices/architecture/hal]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Binder</tag>
        <tag>HAL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从HTTP到HTTPS]]></title>
    <url>%2F2018%2F05%2F05%2F%E4%BB%8EHTTP%E5%88%B0HTTPS%2F</url>
    <content type="text"><![CDATA[HTTP 自从上世纪90年代随着WEB的诞生而出现的，是所有WEB应用的基础。随着网络购物、电子商务、网上银行等逐渐普及，HTTP本身存在信息窃听与身份伪装等问题，已很难满足人们对于可信安全的通信环境的需求了。如何确保用户隐私与数据不被非法获取，这是HTTPS（HTTP Secure )需要解决的问题。使用HTTPS协议的网站，一般都以https开头而不是http，如:https://tools.ietf.org/html/rfc2246 。 那么，从数据安全的角度来看，HTTP有哪些不足了？ HTTP本身不具备加密功能，因此请求与响应都没有经过加密，而使用的是不加密的明文，因此内容可能会被窃听； 通信时不会验证通信方（client/server)的身份，任何人都可以发送请求，而服务器对于所有请求也照单全收，因此客户端与服务端都有可能被伪装； 在传输数据时，报文可能被篡改或者攻击，无法保证报文的完整性(integrity);这种在请求与数据传输过程中，被攻击者拦截并篡改的攻击方式被称为中间人攻击(Man-in-the-middle attack ); 为了解决上述安全问题，HTTPS通过在HTTP之下添加一个安全层SSL/TLS(Transport Layer Security , RFC2246)来实现数据的加密、身份验证以及数据完整性校验： 就是说，HTTPS实际是在TCP/IP的基础上加上了TLS协议，而TLS协议是独立于HTTP协议的，因此除了HTTP之外，其他的应用层协议SMTP，TELNET，EMAIL也同样可以使用TLS来实现安全加密的通信。 HTTPS需要解决的问题HTTPS需要解决的首要问题是，通信过程请求与响应的加密。我们知道，目前世界上常用的加密方式有两种：一个是对称密钥加密(Symmetric-key algorithm ，加密与解密都使用同一个密钥，因此要确保加密信息的安全，通信双方交换密钥时需要保证密钥不被窃取；另一种是非对称加密（也称为公开密钥加密 ), 加密与解密使用两个不同的密钥，一把公钥（对外公开），一把私钥（需要保存），使用非对称加密，发送方只需使用公钥对数据加密，而接收方则利用自己的私钥对密文进行解密，这样通信双方不用交换密钥，不用担心通信过程中密钥被窃取。 HTTPS实际上同时使用了这两种加密方式来实现安全通信。在通信开始交换密钥时使用的是非对称加密的方式来交换对称加密的密钥；等到密钥交换完毕后，发送通信数据时则利用交换后的密钥来对数据进行加密。 但采用这种混合加密的方式通信还存在一个问题：无法确保非对称加密公开密钥的真实性。比如，某个客户端与服务器建立链接时，如何要证明所接收到的公钥就是服务器发送过来的密钥了，有可能在密钥传递的过程中，公钥已经被攻击者替换成完全不同的一个密钥了。 为了解决上述公钥真实性的问题，需要使用第三方数字认证机构（Certificate Authority )颁布的公钥数字证书 。数字证书是一种身份标识，表明持有者是一个可信的实体。但即便有一个颁发数字证书的CA，也不能完全确保数字证书的持有着就是可信的（CA机构的数字证书有可能被攻击者篡改或者攻破），这样就产生了类似“先有蛋，还是先有鸡”的问题了 。这是另一个需要解决的信任问题了（（查看信任链））。回到HTTPS那个公钥问题。HTTPS是如何利用公钥证书进行安全通信的？ 服务器的运营人员向CA提出公开密钥（公钥）的申请； CA在确认申请人的身份之后，利用非对称加密算法，产生公钥与私钥。私钥做数字签名 ，公钥放入公钥证书一起发送给申请者； 服务器拿到公钥证书后，在通信时，发送给客户端，以利用公钥进行通信； 客户端接受到服务器发过来的公钥证书后，会利用保存在本地的数字证书（CA除了需要将数字证书发给服务器之外，还需要发给客户端，为了确保安全，一般浏览器会内置CA的公钥证书）中的公钥验证服务器的数字签名，一旦验证通过，客户端便认为： 一公钥证书的颁发机构是真实合法的；二是服务的身份是可信的。 确保了密钥交换的公钥的真实性后，HTTPS就可以放心的通信了。 HTTPS通信流程下图HTTPS的通信流程，相比HTTP通信，其主要多了客户端与服务端的握手流程（握手流程也可以参考TLS标准RFC2246 ）： 客户端发送ClientHello报文开始SSL通信；报文包含了客户端支持的SSL版本号、加密组件(Cipher suite)列表（包括了加密算法以及密钥长度等）； 服务端可进行SSL通信，则发送ServerHello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件（是从接收的客户端中筛选出来的）； 服务端发送包含数字证书的certificate报文; 最后服务器发送ServerHelloDone告知客户端SSL握手协商结束； SSL第一次握手结束后，客户端以ClientKeyExchange报文作为回应，报文中包含通信加密中使用的Premaster secret的随机密码串。报文本身会利用公开密钥进行加密处理； 客户端继续发送ChangeCipherSpec报文，提示服务器，在此报文后的通信会采用Pre-master secret密钥加密； 客户端发送Finished报文，该报文包含了建立链接至此全部报文的整体校验值。握手协商是否成功，要以服务器是否能正确的机密该报文为判定条件； 服务器同样发送ChangeCipherSpec报文； 服务器发送Finished报文； 服务器和客户端的Finished报文交换完毕后，SSL通信链接就算建立完成了。此后，客户端就会发送HTTP请求； 应用层协议通信开始，发送HTTP响应； 最后由客户端断开链接。断开链接时，发送close notify报文（上图做了简化，实际到这一步还需要发送TCP FIN报文关闭TCP链接）。 在上述通信过程中，应用层HTTP发送的数据都会附加一个利用MAC（Message Authentication Code 的报文摘要，MAC用来验证通信数据的完整性。 参考资料 https://access.redhat.com/documentation/en-US/Red_Hat_Certificate_System/8.0/html/Deployment_Guide/Introduction_to_Public_Key_Cryptography-Digital_Signatures.html https://sites.google.com/site/ddmwsst/digital-certificates#TOC-What-is-a-Digital-Certificate https://tools.ietf.org/html/rfc2246 《图解HTTP》 SSL协议握手详尽的介绍]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
        <tag>TLS</tag>
        <tag>SSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人类简史》札记]]></title>
    <url>%2F2018%2F04%2F30%2F%E3%80%8A%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E3%80%8B%E6%9C%AD%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[作为文化的中国，其实已经灭亡了。。。为什么中国人在这一百多年，老是把传统和现代，把西方文化和中国文化对立起来，为什么我们不能像欧洲那样把传统和现代的关系处理的那么好？ 粟宪庭 《人类简史》之前也听说过，但一直没有时间去看。一个朋友极力推荐之下，从他那借了过来，前后断断续续看了一个月，快看完了。作者的视野广阔，从宏观上来描述人类的发展历史，但描述起历史细节也是娓娓道来，总之可读性极好。推荐指数五星。以前，看书都是翻了就算看了，没有留下多少笔记，这次看《人类简史》有些心得感悟，都写了下来，算是一个总结。 人类社会的观念都是主体间共同想象出来的产物，比如国家，政府，自由以及权利。因此想改变一个国家或者民族的对待某种事物的态度与看法，首先是要为其构造出新的“想象”，这种“想象”可以称之为思想。一旦这种新思想在主体间传播开来，植入越来越多人的头脑，旧秩序就面临瓦解与崩塌。从这里也可以看到，新思想对于那些独裁者来说是难以接受的毒药。因此，纵观古今，无一例外的，独裁者都要想法设法控制垄断人民的思想，一看到有任何“不合时宜”的言论或行为都会严加禁止，竭力把星星之火扼杀在尚未燎原之前。 人类社会的诸多观念都是基于想象而构建出来的，并没有相应的实体对象，如平等，人权，国家，财富，金钱。一旦人不再相信这些概念，人类的社会秩序就面临崩塌。人类能从自然的演化中占据绝对优势，依靠的也是这样的想象力。这种想象力利用得当，对社会与个人都是极有利的事情，而利用不当，成为统治阶层的工具，则只会压制人性，让社会走向不公，降低社会效率。 书开篇就说，135亿年前，宇宙大爆炸形成了能量、时间与空间；在这以后大约30万年，开始有了复杂的物质结构，有了“原子”、“分子”。这简短的几句，看似平常，可要是追问起来，对人而言，却是终极的谜题：宇宙爆炸之前是怎么样的状态？原子与分子形成之前是什么状态？ 人类经过上百万年的进化演变，从前那种残酷的生存环境已经不再，人类也不用像往昔那样为了获取食物而焦虑，为了与各种大型的野兽争夺食物而感到恐惧。这种对生存的焦虑与恐惧随着人类的强大而渐渐转移到其他方面，比如创造，比如政府，比如商品等等。直到今天，人类依然在某种程度上被这些进化的烙印所影响、左右。 做任何事都是有成本的，看的见的是时间成本，而看不见的却是机会成本，更多的时候是难以预料的偶然事件叠加导致机会成本陡增。这就是所谓的学费。怎么减少交学费的次数？这个需要不断的思考总结。 人从神崇拜到个人崇拜，是种倒退。人类漫长的历史过程，就是不断探索世界，理解自然规则，认识自我的过程。人历经过自然灾害，在残酷的战争中挣扎撕裂过，到今天，应该意识到，要解放自己，活的洒脱，让生命不在痛苦与沉闷中度过，关键还是在发挥个体的个性，把个体的潜能挖掘出来，寻找自我的价值。 数万年年前，人类还在荒野奔跑，与野兽做斗争，辛苦劳累一天只是够养活一家人而已。随着人类认知开始跳跃，生产效率不断提升，历经工业革命、信息技术革命，到现在的人工智能，如今人再不用像网昔那样为了吃饱穿暖而愁眉苦脸，担惊受怕了。人们在忙完自己一天的工作后，可以吃喝玩乐，可以逛街散步；可以开着车到处溜达，也可以到公园里漫步。但在某种程度上，人类的生活变得更加无趣了，人与人之间也更加疏离。信息爆炸性的增长看似丰富了人的生活，却在一定程度上让人类自身变得茫然与焦虑。而在另一方面，大部分人虽然远离了历史上残酷的战争以及制度性的压迫，但由于自然资源的过度开发，经济快速发展，环境污染、资源枯竭、生态失衡、人口过多等种种问题开始困扰着人类社会。如果说在过去几万年间人类的进化是与自然的斗争，那么现在却是一场人与自身的斗争。面对这些问题，人类若不懂得克制，不懂得保持对自然与宇宙的敬畏，那么人类面临的终将是痛苦，将付出沉重的代价。 进化心理学认为现在人类社会和心理特征早在农业时代之前就开始形成。即便到了今天，我们的大脑和心灵还是以狩猎和采集的生活方式在思考。。。在现代城市环境下，我们比前人拥有更多物质资源，拥有更长寿命，但又觉得疏离、沮丧而压力重重。 人类从智人时代，就开始了对生态环境的大规模破坏，放火烧林、屠戮动物，所到之处物种开始大范围灭绝。几万前，人类尚处在享受美食、享受占有与掠夺的快感之中，对自然的理解也处于比较单一粗糙的阶段，并不会反思这种行为对自然的摧毁，对人类自身的生存环境带来的影响。直到今天，工业化与城市化的快速发展，人类人口膨胀，人不仅破坏了自然的平衡，也把自身的生存环境弄得乌烟瘴气。青山绿水也只是存在于远古的想象了。 远古时代，人类与自然对斗争，与身边的老虎狮子争夺生存空间；进入农业时代，人类开始大规模改造自然，不再过着担惊受怕的生活。由于人口的大福增加，人与人之间对于资源的竞争加剧，民族之间的摩擦也不断增加，战争、疾病威胁着人类自身的生存；进入工业社会到今天，人类对自然资源的利用已经到了无以复加的地步，煤矿、铁矿、铜矿、金矿；石油、天然气；饮用水、森林等资源都被过度开发，而工厂集中生产带来了环境污染，人类的生存环境日益堪忧：水污染，空气污染，噪声污染，生活空间被极度压缩，四处奔波再也看不得青山绿水。人类贪婪无节制的发展，不仅造成了自然的破坏，也导致了自身生存环境不断恶化。若再这样下去，人类能够得到的只是生态毁灭后的地球。未来，人类面临更大的挑战的是如何协调自身发展与自然环境的保护。 “历史从无正义“，第一次看到这句话以及书中的陈述，心里压抑了好一阵。这是否就意味着个人只能听任命运的摆布，意味着历史就是强者的天下，而弱者只能接受被压制与奴役的残酷？若是这样，努力还有什么意义？从已有的知识来看，历史从来都没有什么必然的规律，而是充满着偶然性。从地球的诞生，到细胞的存在，再到生命的出现、智人的存在，都只是自然中各种偶然因素作用的结果。而人类短暂的历史，为何总上演着一幕又一幕的悲剧： 疾病、饥荒、战争导致大规模的人口死亡；黑人被奴役，当作动物一般贩卖；女性被认为比男性虚弱，因此总是被压制与剥夺的一方？个体无法掌控自己的命运，正义总是缺位，就如古人说的，”兴，百姓苦；亡，百姓苦“。可到了今天，我们有机会来审视人自身命运的时候，比对现实，或许可以看的更为清晰些：正义是一种选择，一种社会制度的安排，正义并不是天然的，而是根植于社会与文化的构建。就像今天，欧美等国家走的是民主与法制，法律保障了每个个体的自由与权利，保证了每个个体依靠自身努力获取到的财富所享有的权益，在这样的社会里，正义蕴涵在国家的制度与法律条文中；而朝鲜、伊朗等国家则选择了专制与独裁，每个人都得服从集体与国家的安排，个人自由的空间被压缩到极致，个体难以控制自身的命运，只有被现实所裹挟，那么，正义又从何谈起？ 为什么是欧洲成为了近代历史科学的摇篮，而不是中国或者中东地区了？作者赫拉利认为，帝国主义、资本主义与科学的结合造成了这样的结果。15世纪，葡萄牙、西班牙的航海冒险家，跨越浩瀚的大海，是为了生存，为了财富与土地，为了征服与探索；而彼时，中国明朝的郑和也七次扬帆去到大西洋沿岸，但目的却不是为了财富，而是为了宣扬天朝上国的威严与强盛。西欧国家为了保持自己对占有财富的控制权，会产生诸如绘制地图、征税等需要科学家来解决的实际问题，因此会大力去培育自己的科学队伍，科学因此得以进步。财富的积累与资本的扩展是无疑是科学获得快速发展的动因。但除此之外，科学的持续发展也离不开欧洲国家政治与社会制度的保障。若没有法制来保护科学家的发明创造，没有法律来确保科学家的权益，个体的创造才能怎么会被激发出来？在强大的野心与征服、探索欲望推动下，在法制的保障下，欧洲成为近代世界的中心也就不难理解了。 近百年来，人类拥有的物质财富增加了成千上百倍，每个个体的财富也大幅攀升。住房，汽车，冰箱，洗衣机，电视，电脑，手机等等，这些让人类的生活变得更加方便快捷，舒适安逸了。但与此同时却也让人产生了依赖感。试想，今天的人是否能够离开手里的智能设备了？恐怕一小时都做不到。人类的物质财富翻了好几个数量级，但人类的快乐与幸福是否也跟着在增长了？结论恐怕不容乐观。今天的人们为了工作整天忙碌奔波，生活看似有了更多的选择，但内心却更为孤独而焦虑。选择太多了，欲望刺激太多了，人们的时间精力被四处打散。匆忙盲目之中，人们恐怕都不会问问自己，究竟什么是快乐幸福？什么能够带来快乐与幸福？ 为什么人能够体验到快乐与幸福了？现代科学已经揭开了谜底：在快乐幸福时，身体里会产生多巴胺、血清素、催产素等“快乐”激素，从而刺激人的大脑，让人感到一阵阵愉悦。这些激素在人运动、做爱或者体验到某种巅峰时刻的时候都会产生。不禁要问，是否可以利用什么手段让大脑细胞感到类似多巴胺刺激的快感了？有，酒精或者毒品。从已有的现实来看，这些外来刺激虽然延长了人的快感（是不是快乐不得而知），但其带来的却是灾难性后果，为了短暂的快感体验而牺牲了一生的快乐幸福恐怕并不值得。快乐与幸福从大的方面来说，有两个部分：一个是外在的，比如财富，家庭，爱情婚姻，以及社会环境；一个是内在的，比如身体，能力，性格。外在的因素往往难以控制，它很难随着个人的意志而发生变化。从这个角度来说，为实现个人福祉，为了避免陷入愤世嫉俗的歇斯底里，人只有努力适应外在的条件，努力调整自己的态度与看法，而不是期待去控制与改变。个人能把握的，实际是这些内在的因素，比如的身体（也可以包括相貌，虽然长相是天生的，但是锻炼身体这件事至少会改善个人的气质），你可以通过不断的体育锻炼来让它更为健壮，让自己变得更有活力；比如能力，只要愿意，你可以通过持续的学习与思考总结来提升自己的技能；比如性格，你可以通过不断的阅读，让自己变得更为渊博，开朗睿智。这些事情，短期来看可能不能让你有所收获，但长期来看确会是巨额的回报。不论是锻炼身体，还是学习新的东西，掌握新的技能，这些都是通往自我认知、发掘自身潜能的必经之路。其目标是认识自己，找到内心所爱，找到生命的价值与意义。不断的发掘自身潜能，也是一个不断拓宽生命边界，探索人生各种可能的一种超凡体验。这个过程会让人感到满足与幸福。对罗素的一句话印象深刻，他说：“参差多态乃人生幸福的源泉“， 我想持续不断的为自己的目标与追寻的价值努力，就是探索参差多态的人生之路吧。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>人类简史</tag>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的垃圾回收机制]]></title>
    <url>%2F2018%2F02%2F23%2FGarbage-Collection-in-Java%2F</url>
    <content type="text"><![CDATA[Java将所有运行时的分配的对象保存到堆(heap)中，虚拟机通过诸如new,newarray,anewarray以及multianewarray等指令来分配对象，但并不会在代码中显式的释放这些内存区域，而是由虚拟机中自带的内存回收器(Garbage Collection)，以下简称GC）来负责内存分配、压缩以及回收。GC的主要任务就是找到堆中那些不再被引用的内存对象，将其回收用于分配新的对象；同时，GC还要负责压缩堆内存分片，减少内存碎片，确保新的对象有足够的连续空间可以使用。GC让开发人员不用再担心内存释放的问题，提升了开发效率； 在另外一个方面，GC使开发人员不用再担心错误的释放了某个对象，确保了程序的完整性。但使用GC的一个潜在弊端是，GC在收集内存时会增加程序负担，减低程序运行效率。 接下来，就来看看Java虚拟机中常用的垃圾回收算法。 垃圾收集算法任何垃圾收集算法都需要做如下几件事情： 检测需要回收的对象； 回收“垃圾”对象所占用的内存，将这些内存提供给程序使用； 对内存进行去碎片化处理； 那么，怎么确定哪些对象是需要回收的了？首先，GC需要确定一个“根对象＂集合，如果某个对象可以通过“根集合”中的元素访问到，则称该对象是可达的（任何根对象都是可达的），因此就可以认为该对象是“存活的”，而对于不可达的对象则被认为是“待回收”的对象，因为他们对程序的执行不会产生影响。那么，一般根集合中的对象要如何选择了？这个跟具体的JVM实现有关系，一般有如下四种： 在线程中使用的本地变量； 正在运行的线程； 被类引用的静态变量 通过JNI调用在本地代码引用的对象 确定了根集合元素之后，JVM是怎么来区分存活对象与需要回收的对象的了？主要有两种方式，一种是引用计数(Reference counting);一种是跟踪(tracing)。引用计数回收器保存了每个对象的引用次数，如果发现该对象的引用次数为零，则认为该对象可被回收；跟踪回收器基于根集合中的节点建立对象引用图，跟踪每个对象的引用关系，跟踪过程完成后，没有标记的对象即是不可达的，因此会被回收。 引用计数回收器引用计数是在JVM初期使用的垃圾回收策略。JVM在分配对象时，会保存一个该对象的引用计数，并且该引用计数被初始化为1，当其他变量引用该对象时，对象的引用计数会加一，而该引用不再使用或者被赋予新值时，则将该对象的引用减一。当对象引用计数为零时，就将该对象回收，一旦对象回收，所有该对象引用的对象的引用计数都需要减一。 引用计数回收器的一个优点在于，回收时间短，不会过多占用程序执行时间，这也使得这种回收方式特别适合程序执行不能中断过久的实时性环境；不足之处时，引用计数不能检测循环引用：多个对象相互引用。即使这些对象对于执行程序的根集合来讲是不可达的，它们的引用计数永远不可能为零。 正是因为这个原因，引用计数回收已经很少在实际中使用了，如今的JVM大都使用跟踪算法来实现垃圾回收。 跟踪回收器跟踪算法从根对象开始，计算出整个对象引用图，将图中被引用的对象进行标记。跟踪回收算法一般分为三个步骤： 标记(mark)： 从根对象开始，遍历所有可达对象，并作相应的标记； 清理(sweep)：对于未被标记的不可达对象，回收其内存区域，确保可以被下一次内存分配使用；在JVM中，清理阶段必须包含对象的finalization。 压缩（compact)：在删除“垃圾”对象后，通常需要将存活的对象移动到一起，清除堆内存中的碎片，从而提高新对象分配的效率。 虽然跟踪回收器解决了引用计数回收器中存在的循环引用问题，但是在清理之前，通常需要执行”stop the world（STW)”,暂停运行程序，这在一定程度上降低了程序运行的效率。因此，如何减少STW对程序运行的影响，是各个GC算法需要考虑的重点。 JVM中的垃圾回收器当前，JVM主要提供了四种垃圾回收器：the serial collector; the throughput(parallel) collector; the concurrent(CMS) collector以及G1 collector。尽管这四种回收器在细节上有所区别，但所有的GC都将堆内存划分成不同的“代（generations)”：新生代(young generation)以及老一代(old or tenured generation)。新生代又进一步划分为伊甸区(eden space)和两个幸存区(survivor space)。为什么要把堆内存划分成不同的代了？这样做有何益处？这种划分是基于经验的分析：应用中大部分对象都具有比较短的生命周期。将堆内存根据生命周期划分成更小的空间，可以减少内存回收的时间。 新生代用于新对象的分配、当新生代空间耗尽后，会进行一次垃圾回收。这种在新生代上进行的GC通常被称为Minor GC;老一代空间包含了生命周期较长以及在多次Minor GC之后存活的对象，通常老一代空间填满后，会进行一次垃圾回收，被称为Major GC（也称为full GC),与Minor GC相比，Major GC通常需要耗费更长的时间。以下是关于新生代空间的几个要点： 绝大多数的新创建对象都位于Eden空间； 当eden被填满后，进行Minor GC，所有存活下来的对象都会移动到一个survivor空间； Minor GC也会检查survivor空间，将其中存活的对象移动到另外一个survivor空间。因此，在任何时候，总有一个survivor空间是空的； 多次Minor GC后，依然存活的对象会被移动到老一代空间中去。 在JVM内存中，除了堆空间外，还有一个永生代（permanent generation),该内存空间用于存放程序中需要使用的元数据(metadata),同时还保存着Java标准库的类与方法。永生代空间的垃圾回收一般在full GC中进行。 接下来看看各个回收器算法的具体差异以及使用方式： seriral collector: 串行回收器是最简单的一种，其使用单个线程来处理堆内存，主要用于单核CPU以及堆空间较小的执行环境。在回收垃圾时，串行回收器会暂停所有程序，这使得它并不适用于服务器场景。JVM中可通过-XX:+UseSerialGC来使用串行回收器； parallel/throughput collector: 并行回收器，对于服务器（多个CPU以及64-bit JVM）这是JVM默认使用的回收器。并行回收器使用多个线程并行的对堆内存进行扫描、标记以及去碎片，在最低程度上减少垃圾回收时程序暂停的时间。但并行回收器在执行minor/major(full) GC时，会暂停所有程序线程。因此，并行回收器比较适合于能够容忍一定时间暂停的场景。并行回收器对应的JVM参数为-XX:+UseParallelGC/-XX:+UseParallelOldGC(JDK 7之前的JVM使用）; CMS collector:Concurrent mark sweep旨在减少full GC引起的长时间暂停，其使用多个线程标记、清理未被引用的对象。在Minor GC时，CMS依然会stop the world,但对于full GC，CMS会使用多个线程定时的扫描老一代内存空间，丢弃那些未被使用的对象。相比并行回收器，CMS大幅减少了程序暂停的时间，但在一定程度上增加了CPU负担，而且CMS并不会对堆空间进行压缩，这会导致大量内存碎片。开启CMS对应的参数为-XX:+UseConcMarkSweepGC`。如果系统的堆内存在4G以下，并且为了避免程序暂停允许GC分配更多的系统资源，可以考虑使用CMS回收器； G1 collector:The Garbage first Collector(G1)在JDK7中引入，是为了更好的支持堆空间在4G以上的系统。G1回收器使用多个后台进程扫描堆空间，并把堆空间分割成1MB～32MB大小的区域。G1回收器会优先扫描包含了最多待回收对象的区域。这样能够减少GC后台线程完成扫描未被引用的对象之前将对象删除的几率，从而避免了GC进入”stop the world”,降低程序运行的效率。G1清理老一代空间对象时，将对象从一个区域复制到另一个区域，这样使得G1在正常情况下也可以进行内存的去碎片化处理。因此相比CMS来说，G1具有更少的碎片。G1对于的JVM参数为-XX:+UseG1GC； 参考资料 Java Performance: the Definitive Guide https://plumbr.io/handbook/what-is-garbage-collection https://www.cs.cmu.edu/~fp/courses/15411-f14/lectures/21-gc.pdf https://betsol.com/2017/06/java-memory-management-for-java-virtual-machine-jvm/ https://www.cs.princeton.edu/picasso/mats/HotspotOverview.pdf https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java Virtual Machine</tag>
        <tag>Garbage Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机入门]]></title>
    <url>%2F2018%2F01%2F07%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Java诞生于互联网兴盛的上世纪90年代，为了在不同终端设备上运行Java程序，其在设计之初，就考虑到了语言的可移植性，确保编写完后，可以在任何平台上运行。随着互联网时代的来临，Java因其平台无关性（platform independence), 安全性(security)、网络可移动性(network mobility)以及内存自动管理(Garbage Collection)等特征而得到了广泛的应用。那么， Java的这些特性究竟是如何实现的？相比早前的C/C++等编译型语言，Java程序首先被编译成一个个包含了字节码(bytecode)的.class文件，运行时，.class文件被加载Java虚拟机（Java Virtual Machine)上执行。实际上，任何其他语言只要能够编译成JVM能够识别的bytecode， JVM都可以执行。从这个角度来看，JVM封装了平台的硬件细节，使得Java程序在编译完后可以在任何有Java运行环境的（Java Runtime Enviroment, JRE)平台上运行，无需再关心不同平台的差异。接下来，就来看下，JVM的具体结构以及各个组成部分的功能。 下图是JVM的结构图, 其主要由如下三个部分组成： 类加载系统(class loader subsystem）：负责加载class文件； 运行时数据区: (Runtime data areas）： 运行程序运行时的内存区域，保存如类实例、类名、方法参数、方法代码以及局部变量等，主要分为方法区(method area)、堆（heap)、栈（Java Stacks)等几个区域，对于不同的虚拟机实现运行时数据区可能并不一样。 执行系统(Execution Engine）：负责执行JVM指令 类文件Java类文件.class是由.java文件编译过来的二进制文件，其中每个字符都只有8-bit，因此类文件字节流也叫做bytecode，每个数据项都是依次相邻存储，不会有任何填充位，如果一个数据项有多个字节，则将其分成多个连续的字节存放（采用高位在前的bit-endian编码）。这中连续存放的格式使得类文件更加紧凑，方便在网络中传输。 类文件的定义确保了不管在何种系统下编译产生，JVM都能够正确的加载、解析执行；因此，其他语言通过编译产生同样的.class文件，JVM同样能够解析执行。 那么，类文件具体包含哪些信息了？Java文件中的变量、方法名以及方法中的代码又是如何存储的？JVM虚拟机规范给出了类文件的结构： 这其中，u1,u2,u4分别表示一个字节、两个字节以及四个字节长的无符号整数，可以看出，类文件实际上是一个由不同长度的数据项组成，每个数据项都有一个类型(type)，名称(name)以及数量（count），比如类文件魔数magic是一个类型为u2、数量为1的数据项。类文件就是按照上述顺序存储的，我们来看看各个数据项的具体信息： 魔数(magic)类文件的开头四个字节总是它的魔数(magic number)0xCAFEBABE，魔数用于识别某个文件是否是类文件；如果一个文件的魔术不是0xCAFEBABE，则肯定不是类文件。 minor_version/major_version第二个四个字节分别是次版本号与主版本号，用于表示Java对应的版本，如果版本号不再有效的范围内，JVM会直接拒绝加载该类文件。 常量池(constant pool)顾名思义，常量池包含了类或者接口中的常量，如字符串、final变量、类名以及方法名等。常量池是由一个个常量项组成的表，该表大小为constant_pool_count，表索引的位置是从1到constant_pool_count-1,索引位置0是预留位置，一般不使用。 每个常量项都是由一个字节的tag与一个字节数组构成： 12345cp_info &#123; u1 tag; u1 info[]&#125; info数组的大小是根据不同tag对应的数据项所占空间大小决定的，常量池有如下几种tag类型： 例如，标签CONSTANT_Class，用于表示一个类或者接口名称，其主要有两部分组成： 长度为u1的标签值； 长度为u2的名称索引（指向常量表中的某个位置） 12345CONSTANT_Class_info &#123; u1 tag; u2 name_index;&#125; 从这里也可以看到， 对于Java语言来说，类名或者接口名的最大长度为255个字符。 access_flags类型标志，占有2个字节，用于表示这个类或者接口的类型： this_class在类型标志之后的两个字节，是this_class数据项，用于表示类名，该数据项实际是一个constant pool的索引，其指向一个CONSTANT_Class类。 super_classsuper_class占两个字节，跟this_class一样，也是一个常量池的索引，用于表示一个类的父类的全限定名（例如java.lang.object对应的全限定名为java/lang/object)。在Java中，所有类的基类都是java.lang.object，因此对于所有类，该索引都指向一个java.lang.object的CONSTANT_Class_info常量项，但是对于Object类本身来说，该值为0。 interfaces_count and interfacessuper_class之后是interfaces_count，表示类所实现的接口或者在类中定义的接口数。接着interfaces_count是接口数据索引数组interfaces，该数组包含了所有指向常量池中接口描述信息CONTANT_Class_info的索引。 在接口信息之后还包含了类似的数据项fields_count/fields、methods_count/methods、attributes_count/attributes。 运行时数据区类文件加载完成后， JVM需要为程序新建内存区域，保存诸如方法名、类名、类实例、方法参数、返回值以及局部变量等。JVM将这些运行时的内存主要分为几个区域(需要注意的是，不同的虚拟机实现运行时数据区可能并不相同）： 方法区(method area）：方法区在JVM启动时候创建，用于存储每个类的运行时常量池（constant pool),变量以及方法信息以及相应的代码。方法区为所有线程共享。如果方法区内存不足，不能满足分配请求时，JVM会抛出一个OutOfMemoryError异常； 堆区(Heap）：JVM启动时创建，所有引用类对象的创建都是在堆区进行的，该区的内存分配与释放都是由GC(Gabage Collector)来负责管理的。与方法区一样，堆区也是为所有线程共享的。当JVM的内存管理系统无法分配所需内存时，则抛出OutOfMemoryError异常； 栈(Java Stacks）：新的进程创建时，JVM为其创建一个栈区，用于保存线程的本地变量以及运行结果，返回值等。Java栈是由栈帧(Stack frames)组成的，一个栈帧包含了Java方法调用的状态，当一个线程调用某个方法时，JVM将一个新的栈帧压入栈区；当调用方法完成后，则将该栈帧从栈中弹出。如果一个线程所需的栈内存超过了JVM栈最大能够提供的大小，则会抛出StackOverflowError; 程序计数器寄存器(PC registers）：每个线程都有自己的程序计数器，用于保存当前线程所运行方法的地址，如果该方法不是native的，程序计数器保存的是线程当前正在执行的方法地址；而对于native方法，程序计数器的值是不定的； 本地方法栈(Native Method Stacks）:一个线程调用其他语言如C/C++的方法时， JVM会为其创建一个本地方法栈，用于保存临时变量以及返回值等； 运行时常量池(run-time constant pool): 每个类与接口在类文件中都有一个constant_pool的表，用于存放数值或者方法的引用。每个常量池所需内存都是从JVM的方法区中分配的，JVM会在类或者接口创建的时候为其构造一个运行时常量池。当常量池内存分配不足时，JVM会抛出一个OutOfMemoryError的异常。 执行系统执行系统(Execution Engine)是JVM的核心部分，主要负责执行虚拟机指令。对于每个线程，都有自己的执行系统实例。执行系统可能直接执行字节码指令，或者执行本地代码，也可以通过JIT执行编译后的本地代码。JVM规范对具体如何执行指令并没有做明确的规定，只是提供了指令的定义。 JVM中的指令都有一个助记符，一般都是由一个单字节操作码(opcode)，跟着零个或者多个操作数(operands)，多数的指令都有操作码，没有操作数。大部分指令的操作码都在首个字母标识了该指令对应的动作，例如，iload指令加载局部变量值的操作栈上，这个局部变量的值必须是int,与此类似的指令还有fload, dload等： int型指令对应开头为*i*; float型指令对应为*f*; double型指令对应为**d**; long型指令对应为l; short型指令对应s; byte型指令对应b; char型指令对应c; 引用类型指令对应a; 来看一个JVM指令的具体实例，有如下一个类SayHello.java: 1234567891011121314package com.examples.jason.javecore;public class SayHello &#123; private static void sayHello() &#123; System.out.print("hello, world!\n"); &#125; public static void main(String[] args) &#123; SayHello.sayHello(); &#125;&#125; 在对应文件目录输入指令javac SayHello.java，得到一个SayHello.class的文件，接着利用反编译工具javap,输入指令javap -c SayHello.class,得到反汇编后的字节码： 1234567891011121314Compiled from "SayHello.java"public class com.examples.jason.javecore.SayHello &#123; public com.examples.jason.javecore.SayHello(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return public static void main(java.lang.String[]); Code: 0: invokestatic #5 // Method sayHello:()V 3: return&#125; 参考资料 http://www.onjava.com/pub/a/onjava/2003/11/12/classloader.html https://www.javaworld.com/article/2077260/learn-java/learn-java-the-basics-of-java-class-loaders.html https://www.artima.com/insidejvm/ed2/introarch.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java Virtual Machine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用JobScheduler进行任务调度]]></title>
    <url>%2F2017%2F12%2F23%2F%E5%A6%82%E4%BD%95%E7%94%A8JobScheduler%E8%BF%9B%E8%A1%8C%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[Android从5.0开始添加了一个任何调度服务JobSchedulerService,APP可以通过该服务进行各种任务的调度，如定时任务，与服务器同步资源，下载特定信息等。由于JobScheduler通过收集各个应用的调度任务，采用批处理的方式，允许多个任务同时运行，可以让设备具有更长的睡眠时间， 从而延长了电池使用。这篇文章，主要从应用与原理两个方面讲述分析JobScheduler。 如何使用JobScheduler这里假定我们有一个定时任务，需要每隔一段时间就同步本地与服务器的数据。通过JobScheduelr发起任务调度，第一步是要创建一个JobService用于处理定时同步服务器的任务请求： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * data sync job service */public class DataSyncJobService extends JobService &#123; private static final String TAG = "DataSyncJobService"; @Override public boolean onStartJob(JobParameters jobParameters) &#123; Log.v(TAG,"onStartJob()"); startSyncData(); return false; &#125; @Override public boolean onStopJob(JobParameters jobParameters) &#123; Log.v(TAG,"onStopJob()"); showMessage(getString(R.string.stop_job_scheduler)); return false; &#125; private void startSyncData() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // data sync done showMessage(getString(R.string.data_sync_complete)); &#125; &#125;).start(); &#125; private void showMessage(String message) &#123; Intent intent = new Intent(getBaseContext(), MessageActivity.class); intent.putExtra("message" , message); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); &#125;&#125; 同时需要在AndroidManifest.xml中声明该servce， 并且该service必须添加一个权限android:permission=&quot;android.permission.BIND_JOB_SERVICE， 这样当定时时间到后，系统会主动绑定该服务，从而发起任务调度： 123&lt;service android:name=".DataSyncJobService" android:permission="android.permission.BIND_JOB_SERVICE"/&gt; 建立了任务处理的service之后，就可以通过JobScheduler来发起任务调度的请求了， Android提供了如下几个接口供用户调度任务： int schedule(in JobInfo job) ： 发起一个任务job，如成功则返回1,失败则返回0; enqueue(JobInfo job, JobWorkItem worker)： 与schedule类似，但允许将一个新的任务放入job的队列； void cancel(int jobId) ： 取消一个任务； void cancelAll()： 取消所有任务； List&lt;JobInfo&gt; getAllPendingJobs()：获取当前未处理的任务列表； JobInfo getPendingJob(int jobId)： 根据jobId来获取对应未处理任务的信息； 1234567891011121314151617public abstract class JobScheduler &#123; public static final int RESULT_FAILURE = 0; public static final int RESULT_SUCCESS = 1; public abstract int schedule(JobInfo var1); public abstract int enqueue(JobInfo job, JobWorkItem worker); public abstract void cancel(int jobId); public abstract void cancelAll(); public abstract List&lt;JobInfo&gt; getAllPendingJobs(); public abstract JobInfo getPendingJob(int jobId);&#125; JobScheduler无法实例化，只能通过getSystemService接口来获取实例，在下面这个函数中， 首先构建一个任务用于定时同步服务器数据： setPeriordic： 设置定时任务的时间间隔，如果没有设置则不是一个定时任务； setPersisted： 持久化任务数据，下次开机时该任务会自动启动，如果设置了该选项，则需要在AndroidManifest.xml中添加一个用户权限声明： &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;，这样任务在开机启动后，立刻启动任务调度； setRequiredNetworkType： 是否需要设置调度所需要的网络模式，比如可以设置是否在收费或者漫游情况下发起任务调度； 1234567891011private void startDataSyncJobScheduler() &#123; ComponentName jobService = new ComponentName(this, DataSyncJobService.class); JobInfo.Builder builder = new JobInfo.Builder(DATA_SYNC_JOB_ID, jobService); builder.setPeriodic(DATA_SYNC_INTERVAL) .setPersisted(true) .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY); JobScheduler js = (JobScheduler)getSystemService(JOB_SCHEDULER_SERVICE); js.schedule(builder.build());&#125; 这样系统就会定时向DataSyncJobService发起任务请求，这里需要注意的是，当Android系统进入低电量的睡眠模式时，JobScheuduler是不允许执行的，详细可以参考休眠与待机 。 JobScheduler的原理JobSchedulerService初始化JobSchedulerService属于系统服务，因此在手机启动时，SystemServer进程会主动加载该服务。创建时，JobSchedulerService会依次初始化: JobHandler： 用于处理请求的Handler; JobSchedulerStub:服务端stub类，用于处理客户端请求； JobStore: 持久化客户端请求数据 StateController: 监听系统状态，以此触发任务调度 123456789101112131415161718public JobSchedulerService(Context context) &#123; super(context); mHandler = new JobHandler(context.getMainLooper()); mConstants = new Constants(mHandler); mJobSchedulerStub = new JobSchedulerStub(); mJobs = JobStore.initAndGet(this); // Create the controllers. mControllers = new ArrayList&lt;StateController&gt;(); mControllers.add(ConnectivityController.get(this)); mControllers.add(TimeController.get(this)); mControllers.add(IdleController.get(this)); mControllers.add(BatteryController.get(this)); mControllers.add(AppIdleController.get(this)); mControllers.add(ContentObserverController.get(this)); mControllers.add(DeviceIdleJobsController.get(this));&#125; 系统启动阶段，JobSchedulerService需要注册应用程序安装包监听器（监听APP是否被卸载、重启），同时需要将持久化的任务数据从存储中加载，重新启动这些任务： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Overridepublic void onBootPhase(int phase) &#123; if (PHASE_SYSTEM_SERVICES_READY == phase) &#123; mConstants.start(getContext().getContentResolver()); // Register br for package removals and user removals. final IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_PACKAGE_REMOVED); filter.addAction(Intent.ACTION_PACKAGE_CHANGED); filter.addAction(Intent.ACTION_PACKAGE_RESTARTED); filter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART); filter.addDataScheme("package"); getContext().registerReceiverAsUser( mBroadcastReceiver, UserHandle.ALL, filter, null, null); final IntentFilter userFilter = new IntentFilter(Intent.ACTION_USER_REMOVED); getContext().registerReceiverAsUser( mBroadcastReceiver, UserHandle.ALL, userFilter, null, null); mPowerManager = (PowerManager)getContext().getSystemService(Context.POWER_SERVICE); try &#123; ActivityManagerNative.getDefault().registerUidObserver(mUidObserver, ActivityManager.UID_OBSERVER_PROCSTATE | ActivityManager.UID_OBSERVER_GONE | ActivityManager.UID_OBSERVER_IDLE); &#125; catch (RemoteException e) &#123; // ignored; both services live in system_server &#125; &#125; else if (phase == PHASE_THIRD_PARTY_APPS_CAN_START) &#123; synchronized (mLock) &#123; // Let's go! mReadyToRock = true; mBatteryStats = IBatteryStats.Stub.asInterface(ServiceManager.getService( BatteryStats.SERVICE_NAME)); mLocalDeviceIdleController = LocalServices.getService(DeviceIdleController.LocalService.class); // Create the "runners". for (int i = 0; i &lt; MAX_JOB_CONTEXTS_COUNT; i++) &#123; mActiveServices.add( new JobServiceContext(this, mBatteryStats, mJobPackageTracker, getContext().getMainLooper())); &#125; // Attach jobs to their controllers. mJobs.forEachJob(new JobStatusFunctor() &#123; @Override public void process(JobStatus job) &#123; for (int controller = 0; controller &lt; mControllers.size(); controller++) &#123; final StateController sc = mControllers.get(controller); sc.maybeStartTrackingJobLocked(job, null); &#125; &#125; &#125;); // GO GO GO! mHandler.obtainMessage(MSG_CHECK_JOB).sendToTarget(); &#125; &#125;&#125; JobSchedulerService中共启动了16个JobServiceContext服务负责处理任务请求。接下来，就来看下JobSchedulerService是如何进行工作调度的。 工作调度目前JobSchedulerService支持的任务调度主要有如下几个属性： 周期性：给定时间间隔触发一次任务调度； 设备充电：是否需要设备当前正在充电； 设备空闲：要求任务调度时设备处于空闲状态； 数据库内容更改： 监听数据库内容状态，如有改变则触发任务调度； 网络连接： 指定网络链接时触发任务调度 通过指定任务属性，我们可以发起一个定时任务，也可以指定某个网络条件下触发任务调度： 123456789101112131415161718192021222324252627282930313233343536public class JobInfo implements Parcelable &#123; .... /** Builder class for constructing &#123;@link JobInfo&#125; objects. */ public static final class Builder &#123; private final int mJobId; private final ComponentName mJobService; private PersistableBundle mExtras = PersistableBundle.EMPTY; private int mPriority = PRIORITY_DEFAULT; private int mFlags; // Requirements. private boolean mRequiresCharging; private boolean mRequiresDeviceIdle; private int mNetworkType; private ArrayList&lt;TriggerContentUri&gt; mTriggerContentUris; private long mTriggerContentUpdateDelay = -1; private long mTriggerContentMaxDelay = -1; private boolean mIsPersisted; // One-off parameters. private long mMinLatencyMillis; private long mMaxExecutionDelayMillis; // Periodic parameters. private boolean mIsPeriodic; private boolean mHasEarlyConstraint; private boolean mHasLateConstraint; private long mIntervalMillis; private long mFlexMillis; // Back-off parameters. private long mInitialBackoffMillis = DEFAULT_INITIAL_BACKOFF_MILLIS; private int mBackoffPolicy = DEFAULT_BACKOFF_POLICY; /** Easy way to track whether the client has tried to set a back-off policy. */ private boolean mBackoffPolicySet = false; .... &#125;&#125; 参考文献 ASOP源代码路径： /android/frameworks/base/services/core/java/com/android/server/job/ https://developer.android.com/training/monitoring-device-state/doze-standby.html 示例代码： https://github.com/runningforlife/AndroidExamples/tree/master/JobScheduler]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>JobScheduler</tag>
        <tag>AlarmManager</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Circuit Switching & Packet Switching]]></title>
    <url>%2F2017%2F11%2F20%2FCircuit-Switching-Packet-Switching%2F</url>
    <content type="text"><![CDATA[通信网络中的两个节点需要交换数据,通常有两种数据传输方式: Circuit Switching (CS, 链路交换)以及Packet Switching (PS, 分组交换)。链路交换早在19世纪便在电讯行业中使用了。对于CS网络，呼叫方（caller）首先需要与被被叫方（callee）建立一个专用的链接，通信才可能进行，双方通信期间，需要占用一定的频带或者时间资源，通信结束，资源才会释放，如果网络出现拥塞，无法分配资源，则通信失败 。下图是链路交换网络通信示意图： 分组交换（PS）是由于计算机网络的出现而开始广泛应用的。其目的是解决CS交换时出现的资源分配问题：需要预先分配资源，即使没有数据传输，资源依然被占用。PS网络，把所要传输的数据分割成一个个“数据包”，然后将其发送到网络，由网络来决定数据的传输路径。与CS交换方式不同的是，PS无需预先建立通信链接，分配资源，也无需在通信结束后断开链路，但在“数据包”传输过程中，需要通过查找路由表（routing table，路由表）将数据在网络节点之间传递，因此不同的“数据包”使用的并不是同一个物理链接，每个“数据包”的路径是由路由算法来决定的。 通常来说，由于CS在通信节点之间建立了专门的通信链路，因此可以保证通信质量，常见的如PSTN ，移动通信GSM中语音通话都采用了CS来传输数据；而PS通常用于对实时性要求不高的服务，如MMS/VoIP等。 参考文献 https://www.ietf.org/rfc/rfc3439.txt https://en.wikipedia.org/wiki/PSTN_network_topology http://www.cs.virginia.edu/~mngroup/projects/mpls/documents/thesis/node8.html https://en.wikipedia.org/wiki/Switching_circuit_theory http://www.rfwireless-world.com/Terminology/circuit-switching-vs-packet-switching.html https://en.wikipedia.org/wiki/Circuit_switching A symbolic analysis of relay and switching circuits]]></content>
      <categories>
        <category>Network Architecture</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>PS</tag>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 动画]]></title>
    <url>%2F2017%2F11%2F18%2FAndroid-%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[Android为开发者提供了强大的动画功能，常见的有属性动画(property animation)、视觉动画（view anmiation)以及可绘制对象动画(Drawable Animation)，属性动画可以用于任何对象（视图对象或者非视图对象）的任何属性，而视觉动画则只能用于可视对象的某些属性，如颜色，大小，以及旋转等;可绘制对象动画利用一系列Drawable资源创建连续的帧动画。 Property Animation（属性动画）什么是属性动画属性动画更改某个视图对象的属性值，如背景颜色或者alpha值，使其在某个时间段内变化，其主要由几个参数决定： 持续时间：动画持续变化的时间； 时间插值器： 决定了对象属性值如何随着时间变化； 重复次数： 动画结束后是否重复 下图表示了属性动画是如何构成的。ValueAnimator由一个时间插值器（TimeInterpolator)、类型估值器(TypeEvaluator)以及参数持续时间、起始值和终值决定。调用start开始动画，ValueAnimator通过插值器来计算消逝的时间比率；接着调用估值器来计算动画对象属性对应的值。最后，通过接口AnimatorUpdateListener来获取更新后当前的属性值。 Android提供了三种类型的属性动画，其都有一个共同的父类android.animation.Animator: ValueAnimator: 该类已经计算出对象属性随时间变化的值，实际使用时需要通过监听器AnimatorUpdateListener来获取对应的值，然后将其应用到对象上； ObjectAnimator: 继承自ValueAnimator,允许指定目标对象以及对象属性来创建动画； AnimatorSet: 将多个Animator放在一起构成一个动画集，该动画集的动画可以一起播放也可以指定先后顺序； 来看看插值器与估值器源码实现。插值器确定了对象值是怎么跟随时间变化的。以下是一个加速减速插值器示例（以下代码均来自Android7.0)，使用该插值器时，对象属性值先加速变化而后减速变化： 1234567891011121314151617181920212223242526/** * An interpolator where the rate of change starts and ends slowly but * accelerates through the middle. */@HasNativeInterpolatorpublic class AccelerateDecelerateInterpolator extends BaseInterpolator implements NativeInterpolatorFactory &#123; public AccelerateDecelerateInterpolator() &#123; &#125; @SuppressWarnings(&#123;"UnusedDeclaration"&#125;) public AccelerateDecelerateInterpolator(Context context, AttributeSet attrs) &#123; &#125; public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f; &#125; /** @hide */ @Override public long createNativeInterpolator() &#123; return NativeInterpolatorFactoryHelper.createAccelerateDecelerateInterpolator(); &#125;&#125; Android还提供了诸如AccelerateInterpolator,AnticipateInterpolator,BounceInterpolator,CycleInterpolator,LinearInterpolator等多种插值器。通过实现TimeInterpolator接口，用户可以自定义自己的插值函数。 由于目标对象存在多种类型的属性值，因此需要类型估值器来计算对应的属性值，常见的有IntEvaluator,FloatEvaluator,ArgbEvaluator。如下是一个整型估值器示例: 12345678910111213141516171819/** * This evaluator can be used to perform type interpolation between &lt;code&gt;int&lt;/code&gt; values. */public class IntEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; /** * This function returns the result of linearly interpolating the start and end values, with * &lt;code&gt;fraction&lt;/code&gt; representing the proportion between the start and end values. The * calculation is a simple parametric calculation: &lt;code&gt;result = x0 + t * (v1 - v0)&lt;/code&gt;, * where &lt;code&gt;x0&lt;/code&gt; is &lt;code&gt;startValue&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt; is &lt;code&gt;endValue&lt;/code&gt;, * and &lt;code&gt;t&lt;/code&gt; is &lt;code&gt;fraction&lt;/code&gt;. */ public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(startInt + fraction * (endValue - startInt)); &#125;&#125; 同样，通过实现TypeEvaluator&lt;T&gt;接口，可以定义非int，float，color类型的估值器。 对于视图对象，可以创建动画的属性主要有： translationX,translationY: 平移坐标 rotation,rotationX,rotationY： 旋转坐标 scaleX,scaleY: 缩放坐标 pivotX,pivotY: 中心点坐标 x,y: 坐标 alpha: 透明度 利用ObjectAnimator可以创建一个旋转摸个视图的动画: 123ObjectAnimator rotate = ObjectAnimator.ofFloat(myView, "rotation", 0.0f, 360f);rotate.start(); 使用属性动画那么，在实际应用中，如何创建一个属性动画？Android提供了两种方式，一种是通过XML资源，一个是通过代码。首先来看看第一种。 在XML资源中声明动画属性动画位于animator的资源文件夹内： 12res/animator/filename.xml Android Studio中默认是没有该文件夹的，因此需要手动创建一个animator的资源文件夹。接着，在该文件夹新建一个名为my_anim.xml的XML文件： 属性动画资源对应的标签是&lt;set&gt;,表示一个动画资源集，可以包含多个属性动画， 属性动画中，标签&lt;animator&gt;表示ValueAnimator,&lt;objectAnimator&gt;表示ObjectAnimator,&lt;set&gt;表示AnimatornSet 1234567891011121314151617&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;animator android:duration="@android:integer/config_mediumAnimTime" android:valueTo="1.0" android:valueFrom="0.0" android:valueType="floatType" android:interpolator="@android:interpolator/accelerate_decelerate"/&gt; &lt;objectAnimator android:duration="@android:integer/config_mediumAnimTime" android:interpolator="@android:interpolator/anticipate" android:valueType="floatType" android:propertyName="rotation" android:valueTo="360" android:valueFrom="0"/&gt;&lt;/set&gt; 接着使用在代码中将动画资源加载到对象上即可： 1234AnimatorSet as = (AnimatorSet)AnimatorInflater.loadAnimator(getApplicationContext(), R.animator.fade_in);as.setTarget(myView);as.start(); 使用代码创建动画创建一个改变视图对象透明度的动画: 123456789ValueAnimator animator = ValueAnimator.ofFloat(0.0f, 1.0f);animator.setDuration(500);animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; myView.setAlpha((float) animation.getAnimatedValue()); &#125;&#125;); 在给定对象上创建一个旋转动画: 1234ObjectAnimator rotate = ObjectAnimator.ofFloat(mTxt, "rotation", 0.0f, 360f);rotate.setDuration(500);rotate.start(); View Animation（视觉动画）视图动画通过计算View的起点/终点，尺寸以及旋转等属性，产生一个补间动画(Tween Animation),其主要类型有： AlphaAnimation(&lt;alpha&gt;): 透明度动画； ScaleAnimation（&lt;scale&gt;）:缩放动画; TranslateAnimation(&lt;translate&gt;):平移动画； RotateAnimation(&lt;rotate&gt;): 旋转动画； AnimationSet(&lt;set&gt;): 包含了上述几种动画的集合; 与属性动画一样，视觉动画也有两种使用方式，一种是通过XML资源（位于res/anim/filename.xml），一种是通过代码加载。这里使用XML资源声明来看下如何使用视觉动画。 首先，声明所需动画资源： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;scale android:interpolator="@android:anim/accelerate_decelerate_interpolator" android:fromXScale="1.0" android:toXScale="1.4" android:fromYScale="1.0" android:toYScale="0.6" android:pivotX="50%" android:pivotY="50%" android:fillAfter="false" android:duration="700" /&gt; &lt;set android:interpolator="@android:anim/decelerate_interpolator"&gt; &lt;scale android:fromXScale="1.4" android:toXScale="0.0" android:fromYScale="0.6" android:toYScale="0.0" android:pivotX="50%" android:pivotY="50%" android:startOffset="700" android:duration="400" android:fillBefore="false" /&gt; &lt;rotate android:fromDegrees="0" android:toDegrees="-45" android:toYScale="0.0" android:pivotX="50%" android:pivotY="50%" android:startOffset="700" android:duration="400" /&gt; &lt;/set&gt;&lt;/set&gt; 通过代码加载到指定对象： 123AnimationSet scaleIn = (AnimationSet) AnimationUtils.loadAnimation(getApplicationContext(), R.anim.scale_in);myView.startAnimation(scaleIn); Drawable Animation可绘制对象动画通过加载一连串可绘制对象资源像电影一样将资源连续的播放出来，因此也称为帧动画(Frame Animation)。可绘制对象动画的使用方式与上述两种动画无异，首先在 res/drawable/filename.xml中添加一个动画资源文件heart_fill_in,对应的标签为&lt;animation-list&gt;： 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="true"&gt; &lt;item android:drawable="@mipmap/ic_heart_0" android:duration="@android:integer/config_longAnimTime"/&gt; &lt;item android:drawable="@mipmap/ic_heart_25" android:duration="@android:integer/config_longAnimTime"/&gt; &lt;item android:drawable="@mipmap/ic_heart_75" android:duration="@android:integer/config_longAnimTime"/&gt; &lt;item android:drawable="@mipmap/ic_heart_100" android:duration="@android:integer/config_longAnimTime"/&gt;&lt;/animation-list&gt; 使用时，将其添加到ImageView: 1234myImageView.setBackgroundResource(R.drawable.heart_fill_in);AnimationDrawable ad = (AnimationDrawable)mHeart.getBackground();ad.start(); 这样就可以看到一个心被填充的动画。 参考文献 http://easings.net/en https://developer.android.com/guide/topics/graphics/overview.html http://gizma.com/easing/]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Animation</tag>
        <tag>Property Animation</tag>
        <tag>Frame Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSM短信的发送与接收]]></title>
    <url>%2F2017%2F10%2F15%2FGSM%E7%9F%AD%E4%BF%A1%E7%9A%84%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6%2F</url>
    <content type="text"><![CDATA[在GSM中，短消息(SMS,Short Message Service)有两种发送模式，一个是文本模式（所有字符都以可读的字符发送），一种是PDU模式。文本模式下，SMS字符都依照GSM 03.38标准中的默认的7-bit字符表进行编码（表格如下): 在PDU(Protocol Data Unit)模式下，SMS通过编码成特定的二进制串发送出去，在该模式下，PDU数据不仅包含了消息字符，还包括很多元数据，比如短信中心地址(SMSC),字符编码格式以及时间戳等。根据ETSI标准(GSM 03.40 &amp; GSM 03.38), 单条短信采用7-bit编码时最长可达160个字符，若采用8-bit字符编码则最多包含140个字符，而对于中文、韩文以及日文等东亚文字通常需要16-bit编码，则实际上能发送的文本长度只有70个字符，因此发送长短信时，需要将长短信分割成多个单一的短信（每条短信的长度不超过160个字符)。 那么，如何区分长短信与普通的单条短信了？对于长短信，设置TP-UDHIbit位，用于标识信息包含了头信息；头信息UDH（User Data Header)中包含了长短信的引用编号（分割后对应的序列号)，这样SMS接收端就可以根据该序列号将分割前的短信恢复过来。 下面来看下PDU模式下，GSM如何接受与发送短信？ 参考文章： http://www.gsm-modem.de/sms-pdu-mode.html 接收短信PDU字符串除了文本数据外，还包含了短信中心地址(SMSC)以及时间戳等信息，所有数据均以十六进制/十进制八位字节或者半个八位字节(4-bit)。以下字符串是Nokia 6110中接收到来自http://www.mtn.co.za/的一条内容为hellohello的短信： 1207 917238010010F 5 040BC87238880900F100009930925161958003C160 10 这条短信包含了三个部分：（1）标识SMSC长度的八位字节(07);(2) SMSC(917283010010F5); (3) SMS_DELIVER部分。 Octets Description Format Meaning 07 SMSC长度 hex-octet 7个八位字节 91 SMSC地址类型 hex-octet 国际号码 7283010010F5 SMSC号码 semi-octet +27381000015 04 SMS_DELIVER首个八位字节 hex-octet TP-MMS,参考GSM 03.40 0B 地址长度 hex-octet 发送方地址长度为11 C8 TOA,发送方地址类型 hex-octet 参考GSM 03.40 TypeofAddress 7238880900F1 发送方号码 semi-octets 发送方号码 00 TP-PID, Protocol Identifier hex-octet 参考GSM 03.40 00 TP-DCS, Data Coding Scheme hex-octet 参考GSM 03.38 99309251619580 TP-SCTS, time-stamp semi-octets 29/03/99 15:16:59 0A TP-UDL, User Data Length hex-octets 长度为10 E8329BFD4697D9EC37 TP-UD, User Data 8-bit octets表示7-bit数据 hellohello 发送短信以下是用Nokia 6110在PDU模式下发送“hellohello”消息的PDU字符串： 1200 11 00 0B 91 6407281553F8 00 00 AA 0A E8329BFD4697D9EC37 与接收短信PDU格式相似，发送的短信也由3个部分组成: (1)SMSC的长度， 这里实际长度00表示使用保存在手机里的SMSC地址； (2) SMSC号码， 由于长度为0， 因此该部分不存在； (3) SMS_SUBMIT消息。 Octets Description 00 SMSC长度， 该字段是可选的， SMSC可以从手机读取 11 首个八位字节, 各个bit位的含义见GSM 03.40 00 SMS_SUBMIT计数， 基站每收到一个SMS_SUBMIT都相应的加1， 参考GSM 03.40 0B 地址长度， 11位的号码 91 地址类型(TOA), 91表示国际号码 6407281553F8 semi-octet字符串（46708251358）， 由于号码长度为奇数，因此会在尾部添加一个F，实际编码的号码为46708251358 00 TP-PID, protocol identifier 00 TP-DCS, 短信文本编码方案，这里00表示采用的7-bit GSM默认的字符编码 AA TP-Validaty-Period, 该字段可选 0A TP-UDL, 短信文本长度，就是说这个短信数据长度为10*7个bit E8329BFD4697D9EC37 TP-UD, 短信文本 参考文献 http://www.gsm-modem.de/sms-pdu-mode.html http://read.pudn.com/downloads122/doc/520173/SMS_PDU-mode.PDF http://read.pudn.com/downloads150/sourcecode/embed/646395/Short%20Message%20in%20PDU%20Encoding.pdf http://www.smartposition.nl/resources/sms_pdu.html]]></content>
      <categories>
        <category>Mobile Communication</category>
      </categories>
      <tags>
        <tag>GSM</tag>
        <tag>SMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Annotation]]></title>
    <url>%2F2017%2F10%2F08%2FJava-Annotation%2F</url>
    <content type="text"><![CDATA[在Java中，Annotation(注解）是一种可添加到源码中的句法元数据(Java annotation)，类、方法、变量、参数以及包都可以进行注解。 注解主要有如下几个用途: 为编译器提供信息： 编译器使用annotation来检测错误或者消除警告； 编译或者部署时处理： 可以利用注解信息产生代码，XML文件等； 运行时处理： 可在运行时检查注解，产生相应的代码； Java预定义注解类型Java中java.lang内置有@Deprecated, @Override,以及@SuppressWarnings三个常用的注解： @Deprecated： 用于标识一个元素弃用了，不再使用； 12345 @Documented@Retention(value=RUNTIME)@Target(value=&#123;CONSTRUCTOR,FIELD,LOCAL_VARIABLE,METHOD,PACKAGE,PARAMETER,TYPE&#125;)public @interface Deprecated&#123;&#125; @Override： 该注解用于标识当前方法重载了父类中的方法,如果一个标识了@Override的方法没有重载父类中的方法，编译器会产生错误； 1234@Target(value=METHOD)@Retention(value=SOURCE)public @interface Override&#123;&#125; @SuppressWarnings：告知编译器忽略特定的警告，例如@SuppressWarnings(&quot;unchecked&quot;)让编译器忽略unchecked警告；@SuppressWarnings(&quot;deprecation&quot;)则用于忽略某个元素已经废弃的警告。 1234567 @Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123; String[] value();&#125; 除了上述注解外， Java还提供了应用于其他注解的注解，被称之为元注解(meta-annotations)，如@Rentention, @Documented, @Target,@Inherited: Annotation interface Applicable to Purpose Target annotations 指定注解使用的元素类型(见下) Retention annotations 指定注解使用的方式，需要保留的时间，RetentionPolicy.SOURCE，RetentionPolicy.CLASS， RetentionPolicy.RUNTIME Documented annotations 使用了该注解的注解，都会用Javadoc工具进行处理，然后输出相应的文档 Inherited annotations 标识某个注解是否能被子类锁继承 Resource class or interface 声明单个资源 Resources class or interface 声明多个资源 Target中指定了注解的目标类型，java.lang.annotation中定义了枚举类型ElementType用于表示注解所使用的元素类型: 1234567891011121314151617181920212223242526272829303132333435363738 public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE&#125; 如何自定义注解类型Java Annotation使用关键字@interface来声明，自定义时需要注意几点： 只允许使用public，default修饰符； 对于注解的属性值，只能使用public或者default修饰符； 注解的属性值类型，只能使用基本类型，String，Class,Enum，Annotation以及上述类型的一维数组； 可以为属性值定义默认值； 这里，来看下Android中的一个注解示例@RequestPermission,当某个元素需要请求系统权限时，可以使用该注解标识：从定义可以看到，@RequestPermission只是在源码（不是运行时或者class文件中）中使用，可用于方法、构造函数、变量、参数以及注解等几种类型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Retention(SOURCE)@Target(&#123;ANNOTATION_TYPE,METHOD,CONSTRUCTOR,FIELD,PARAMETER&#125;)public @interface RequiresPermission &#123; /** * The name of the permission that is required, if precisely one permission * is required. If more than one permission is required, specify either * &#123;@link #allOf()&#125; or &#123;@link #anyOf()&#125; instead. */ String value() default ""; /** * Specifies a list of permission names that are all required. */ String[] allOf() default &#123;&#125;; /** * Specifies a list of permission names where at least one is required */ String[] anyOf() default &#123;&#125;; /** * If true, the permission may not be required in all cases (e.g. it may only be * enforced on certain platforms, or for certain call parameters, etc. */ boolean conditional() default false; /** * Specifies that the given permission is required for read operations. * * When specified on a parameter, the annotation indicates that the method requires * a permission which depends on the value of the parameter (and typically * the corresponding field passed in will be one of a set of constants which have * been annotated with a &lt;code&gt;@RequiresPermission&lt;/code&gt; annotation.) */ @Target(&#123;FIELD, METHOD, PARAMETER&#125;) @interface Read &#123; RequiresPermission value() default @RequiresPermission; &#125; /** * Specifies that the given permission is required for write operations. * * When specified on a parameter, the annotation indicates that the method requires * a permission which depends on the value of the parameter (and typically * the corresponding field passed in will be one of a set of constants which have been annotated with a &lt;code&gt;@RequiresPermission&lt;/code&gt; annotation.) */ @Target(&#123;FIELD, METHOD, PARAMETER&#125;) @interface Write &#123; RequiresPermission value() default @RequiresPermission; &#125;&#125; 源码: /android/frameworks/base/core/java/android/annotation/RequiresPermission.java 应用示例那么，如何使用annotation？使用过JUnit测试框架的应该了解，JUnit就是使用注解来创建测试用例，并执行这些用例的。现在，我们就来模仿JUnit来写一个自定义的测试注解@Test。假定有一个类MathsOperation, 该类支持add以及divide两个数学操作，对于除法操作，如果除数为零，则抛出一个自定义的InvalidParamterException的异常， 因此如果任何除数为零的操作，都会抛出异常，此时可通过检测该异常来判断测试用例是否通过。 定义@Test注解Test.java 1234567891011121314151617181920212223package com.examples.jason.javecore.annotation;import java.lang.annotation.Documented;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import static java.lang.annotation.ElementType.METHOD;@Documented@Inherited@Target (value=METHOD)@Retention (RetentionPolicy.RUNTIME)public @interface Test &#123; /** * This annotation attribute is used whether method throw assigned custom *exception * or not. If it throws custom exception, it means test case pass * @return */ public Class&lt;? extends Exception&gt; expected() default java.lang.Exception.class;&#125; InvalidParameterException.java 123456789101112131415161718192021222324252627282930313233343536package com.examples.jason.javecore.annotation;/** * The class &lt;code&gt;InvalidParameterException&lt;/code&gt; is a subclass of &lt;code&gt;Exception&lt;/code&gt; class; * This class is used to throw exception when method arguments are invalid * @author Jason * */@SuppressWarnings("serial")public class InvalidParameterException extends Exception&#123; private String message = null; public InvalidParameterException()&#123; super(); &#125; public InvalidParameterException(String msg)&#123; this.message = msg; &#125; public InvalidParameterException(Throwable t)&#123; super(t); &#125; @Override public String toString()&#123; return this.message; &#125; @Override public String getMessage()&#123; return this.message; &#125;&#125; MathsOperation.java 1234567891011121314151617181920212223package com.examples.jason.javecore.annotation;/** * math operation class, which support two math operations * @author Jason * */public class MathsOperation &#123; public int sum(int a, int b)&#123; return a + b; &#125; public float divide(int a, int b) throws InvalidParameterException&#123; if(b == 0)&#123; throw new InvalidParameterException(); &#125; return (float)(a/b); &#125;&#125; MathUnitTests.java 123456789101112131415161718192021222324package com.examples.jason.javecore.annotation;/** * All test cases are written here with @Test annotation * */public class MathUnitTests &#123; @Test(expected = InvalidParameterException.class) public void testDivide() throws InvalidParameterException&#123; MathsOperation mp = new MathsOperation(); mp.divide(10, 0); &#125; @Test public void testSum()&#123; MathsOperation mp = new MathsOperation(); int s = mp.sum(10, 3); if(s == 13)&#123; System.out.println("Sum Test Case Pass, output value is " + s); &#125; &#125;&#125; UnitTestRunner.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.examples.jason.javecore.annotation;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * This class is test suite runner, which will runs all test cases * provided in given test class. This class particularly check custom exception thrown by method. * If thrown exception match with expected exception mentioned on attributes of @Test annotation, that means * test case is pass. This same scenario is used in JUnit as well. * */public class UnitTestRunner &#123; public void runUnitTests(String className)&#123; try&#123; Class&lt;?&gt; testClass = Class.forName(className); Object obj = testClass.newInstance(); Method[] methods = testClass.getMethods(); for(Method method : methods)&#123; if(method.isAnnotationPresent(com.examples.jason.javecore.annotation.Test.class))&#123; Test annotation = method.getAnnotation(Test.class); Class&lt;? extends Exception&gt; expectedClass = annotation.expected(); if(expectedClass != null)&#123; try&#123; method.invoke(obj); &#125; catch(InvocationTargetException e)&#123; if(e.getTargetException().getClass() == expectedClass)&#123; System.out.println("Test Case Pass with InvalidParameterException"); &#125; else&#123; System.out.println("Test Case Fail with an exception: " + e.getMessage()); &#125; &#125; catch(Exception e)&#123; System.out.println("Test Case Fail with an exception: " + e.getMessage()); &#125; &#125; &#125; &#125; &#125; catch (ClassNotFoundException cnfe)&#123; cnfe.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args)&#123; UnitTestRunner utRunner = new UnitTestRunner(); utRunner.runUnitTests("com.examples.jason.javecore.annotation.MathUnitTests"); &#125;&#125; 参考文献 https://stablekernel.com/the-10-step-guide-to-annotation-processing-in-android-studio/ https://medium.com/@aitorvs/annotation-processing-in-android-studio-7042ccb83024 https://medium.com/@iammert/annotation-processing-dont-repeat-yourself-generate-your-code-8425e60c6657 https://web.archive.org/web/20140223113106/http://www.somanyword.com/2014/02/how-to-create-and-implement-custom-annotations-in-java/ http://hannesdorfmann.com/annotation-processing/annotationprocessing101]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Annotation</tag>
        <tag>Annotation Processor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Android中查看进程状态]]></title>
    <url>%2F2017%2F09%2F22%2F%E5%A6%82%E4%BD%95%E5%9C%A8Android%E4%B8%AD%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[在Android开发调试过程中，常需要使用ps指令用于获取当前系统进程的快照信息（如果想要获取进程动态信息，则需要使用top命令)。通过ADB SHELL连接上手机后，输入adb shell命令进入shell控制台, 输入ps即可查看当前系统所有进程信息： Android的PS指令在Linux的基础上做了很大的简化，使用ps查看一个进程的信息，大概有两种方式，一个是根据进程全名，一个是根据进程ID。比如，这里要获取Phone进程的信息: 进程名 进程ID 有关PS指令的具体代码可参考: /android/system/core/toolbox/ps.c 另外，通过ps指令，指定参数-T还可以查看进程内所有线程的状态： 上述ps指令输出各个参数有何含义？ FIELD Description USER 进程持有者名称 PID 进程ID PPID 父进程ID VSIZE 进程在虚拟内存所占的空间大小(KB) RSS 进程实际所使用的物理内存大小（KB) WCHAN Waiting Channel, 进程等待正在等待的某个事件，如果为空，则表示进程处于运行状态 PC Program Counter, 程序计数器所保存的地址 NAME 进程名 除了列表中的参数之外，输出的参数中还有一列用于表示进程状态，这里看到进程状态是S(sleeping)。通常进程可能有以下几个状态: 缩写代号 进程状态 含义 D TASK_UNINTERRUPTABLE uninterruptible sleeping, cannot be woken up S TASK_INTERRUPTABLE sleeping, can be woken up R TASK_RUNNING task currently running T TASK_STOPPED traced or stopped Z TASK_ZOMBIE zombie process, terminated and parent not waiting 参考文献 https://www.cyberciti.biz/faq/show-all-running-processes-in-linux/ https://ss64.com/bash/ps.html http://www.unix.com/man-page/All/1b/ps/ http://www.petefreitag.com/tools/man-pages/ps.html https://events.linuxfoundation.org/images/stories/pdf/lf_abs12_kobayashi.pdf https://access.redhat.com/sites/default/files/attachments/processstates_20120831.pdf]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>进程状态，Shell指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP简介]]></title>
    <url>%2F2017%2F08%2F23%2FHTTP%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[HTTP(Hypertext Transfer Protocol)即超文本传输协议，是一种用于传输文本、音视频等超媒体(hypermedia)的应用层协议。HTTP从1990年开始就应用于WWW(World Wide Web)服务中,其发展变化与WEB服务紧密相连。这篇文章，就来看看HTTP协议的基本概念。 基本概念HTTP协议允许不同类型的客户端与服务端进行通讯，支持不同的网络配置，并不依赖于特定的系统。在消息交换过程中，不保存任何状态（state-less,状态无关)。HTTP协议请求基于Request/Response，一个客户端向服务端发送request，该请求包含了Request Method, URL，协议版本以及请求的资源类型；服务端得到请求后，返回一个response,包括状态信息（协议版本，状态码)以及请求的资源。这样一次Request/Response的过程我们称为一次HTTP会话(session)，大致有三个阶段： 客户端与服务端建立一个TCP链接； 客户端发送数据请求，等待回应； 服务端处理请求，返回结果并提供一个状态码与资源； 了解TCP/IP的人应该知道，网络协议是一个分层的结构，由物理层、链路层、网络层、传输层以及应用层组成。物理层与链路层负责处理不同网络底层通信细节，如网络接口，网络速率等；网络层主要负责数据的路由，传输层主要负责数据分包、数据重传、拥塞控制，而应用层协议则通常与某个业务需求紧密相关，在某些特定的场景下使用，如HTTP用于WEB应用，而DNS则用于域名解析，FTP协议用于文件传输，EMAIL协议则用于电子邮件的发送与接收。HTTP协议一般通过TCP协议来进行会话，对应的TCP端口为80(有时也会用8080),而对于加密版HTTP协议HTTPS，则使用443端口。 既然HTTP是用于Web中获取资源（这个资源可以是一个文档，一张图片或者一个视频），那么HTTP是如何知道资源所在的位置了？在HTTP，对每个资源都有一个唯一的识别符URI(Uniform Resource Identifier),常见的URI有两种:一种是URL(Uniform Resource Locator),就是我们通常所说的WEB地址；一种是URN(Uniform Resource Name: URL示例 1234https://developer.mozilla.orghttps://developer.mozilla.org/en-US/docs/Learn/https://developer.mozilla.org/en-US/search?q=URL URN示例 123urn:isbn:9780141036144urn:ietf:rfc:7230 接下来，我们来看下URI是怎么构成的。 URI如下图是一个URI的结构示意图： schemehttps://属于URI的协议部分，用来标识浏览器所使用的协议，对WEB服务来说，通常使用HTTP或者HTTPS协议。常用的scheme有如下几种： scheme Description data Data URI file host-specific file names ftp File transfer protocol http/https hyper text transfer protocol(secure) mailto electronic mail address ssh secure shell tel telephone urn Uniform Resource Names view-source source code of the resource ws/wss (encrypted) websocket connections Authoritytools.ietf.org又称为域名，该域名标识了一个WEB服务器的地址。通常，我们也可以直接使用该WEB服务器的IP地址来访问，但是在WEB中比较少用。 Port:443是HTTP进行数据交换的TCP端口，如果一个WEB服务器使用的是HTTP的标准端口(HTTP:80; HTTPS: 44),则在URI中可以忽略，否则需要特别指出。 Path/html/rfc7320表示某个资源在WEB服务器中的路径，通过该路径WEB服务器查找到用户请求的资源。 Query?query部分是提供给WEB服务器的额外参数，其通常是如下形式的&lt;key,value&gt;对：?k1=v1&amp;k2=v2，例如在使用搜索引擎时，关键词就会以这样的形式呈现给WEB服务器。如下是在Google输入Android后浏览器地址栏显示的部分结果： 12https://www.google.co.kr/search?newwindow=1&amp;site=&amp;source=hp&amp;q=Android Fragment#section-2.7可以看做是一个资源某个部分的一个索引或者书签，通过该字段，我们可以直接访问到某个WEB页面的某一部分。需要注意的时，HTTP发送资源请求时，#Fragment部分并不会发送到服务器，这个部分是由浏览器来处理的， 浏览器会根据这个标签将页面滑动到相应的位置。 HTTP消息HTTP消息定义了客户端与服务端如何进行数据的交换，这里有两种类型的消息：一种是客户端发送的请求(request)，一种是服务端发送的响应(responses)。接下来，就来详细的看下HTTP两类消息的构成。 HTTP请求跟响应总体上结构很相似，主要由四个部分组成(下图所示）： 一个单一的起始行(start-line):起始行描述的是请求的类型（获取数据还是写入数据）或者服务端响应的状态是成功或者失败。 HTTP头(headers): 描述请求类型或者消息的主体部分（body); 一个空白行用于表示所有元数据(meta-information)已经发送完毕； 可选的消息主体(body),如请求的内容或者服务端相应的数据。一般，消息主体的存在以及大小需要在起始行和HTTP头中指定。 HTTP Request一个HTTP请求由三个部分组成： start line; http headers; body start lineHTTP的start line用于标识客户端想要服务器执行的某个动作，例如是GET某个数据，还是上传某个数据，其有三个要素组成： HTTP method:该HTTP请求所要执行的动作，主要有以下几类： GET(需要大写）： 从服务端获取指定的资源，可以是一个文档，一张图片，一个视频等； PUT:创建一个新的资源或者用新的数据取代目标资源； POST: 提交某个资源，例如对已存在的资源进行注释；提交一个表单；发布消息到新闻组，邮件列表等；通过附加操作扩展一个数据库； DELETE: 删除某个特定的资源； TRACE: 用于发起一个远端的回环(loop-back)的消息请求； CONNECT: 用于建立一个到服务端的网络隧道(tunnel)； HEAD: 请求一个与GET命令请求相同的response,但是不包含消息主体(body); OPTIONS: 为目标资源描述会话的可选项 请求资源的URL, URL在不同的情况下可以是： 绝对路径，通常后面会有一个?以及一个查询字符串，一般与GET,POST，HEAD以及OPTIONS搭配使用： POST / HTTP/1.1, GET /background.png HTTP/1.1; 完整的URL，通常连接一个代理服务器时与GET方法一起使用：GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1 一个URL的authority部分，包含了域名跟端口号： CONNECT developer.mozilla.org:80 HTTP/1.1 与OPTIONS方法一起使用的星号(*): OPTIONS * HTTP/1.1 HTTP版本号，用于告知服务端接收请求响应时所期望的HTTP版本； HTTP HeadersHTTP头用于客户端向服务端发送关于请求或者响应的额外信息，比如字符的编码方式，语言等，这些信息可以分成如下三个部分： 一般性头信息(General Header): 对于请求与响应都适用; 请求头信息(Request Header): 关于HTTP请求的附加信息 实体头信息(Entity Header): 适用于请求主体(body)的附加信息 有关HTTP头的详细信息可以参考:https://en.wikipedia.org/wiki/List_of_HTTP_header_fields Request Body通常情况下，HTTP请求不包主体，除非客户端有数据需要更新到服务器上，此时一般由HTTP头Content-Length,Content-Type来确定消息体的数据类型以及长度。 HTTP Response与HTTP请求相类似，HTTP响应也有三部分组成： status line: 状态行主要包括HTTP协议版本、状态码以及状态码描述字符串组成。例如HTTP/1.1 404 NOT FOUND； Headers: 响应的头跟请求的头信息有相同的结构（可参考上节关于请求头信息的描述），也包含了三个类型的头信息 General Headers: 适用于整个消息； Response Headers: 描述有关服务端的信息； Entity Headers: 适用于消息主体部分； body： 并不是所有的HTTP响应都有主体部分，像204，201状态码对应的响应就不需要。 最后一部分，我们来看下服务端响应客户端请求后返回的状态码以及具体的含义。 status codeHTTP的状态码是一个3位数表示，其作用是告知客户端如何解析服务端的响应，共有5种类型的状态码： 1xx: informational服务端告知客户端继续或者执行某个操作： 100： continue, 表示客户端可以继续发送HTTP请求； 101： switching protocols, 切换协议； 2xx: Successful这类状态码用于告知客户端，服务端已经成功收到并处理了HTTP请求： 200： OK, 请求成功； 202： Accepted, 请求已经被接收到，但是尚未完成处理； 3xx: Redirection重定向：需要用户的做进一步的操作，通常需要跳至一个不同的URL去获取资源 301： moved permanently, 资源已经更换到一个新的URL； 303: see other, 需要通过另外一个URL来获取资源； 4xx: Client error服务端认为客户端出错时发送此状态码，如访问一个无效的资源或者请求有误： 400： bad reqeust, 请求有误； 401: unauthorized, 请求需要验证； 403： forbidden, 服务器拒绝访问资源； 404: Not found, 请求的资源不存在 5xx: Server error此类状态码表示服务器处理请求时出现了错误： 500： internal server error, 服务器自身出错； 501： not implemented, 服务器尚未实现该请求； 503： service unavailable, 服务不用，如服务故障或者过载 参考文献 https://code.tutsplus.com/tutorials/http-the-protocol-every-web-developer-must-know-part-1–net-31177 https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP https://inst.eecs.berkeley.edu/~ee233/sp06/student_presentations/EE233_TCPIP.pdf https://tools.ietf.org/html/rfc2616]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用哈希函数C实现]]></title>
    <url>%2F2017%2F08%2F06%2F%E5%B8%B8%E7%94%A8%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0C%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[哈希函数（hash function)是一个将某个集合内的元素映射到一个大小固定的元素集合的函数，其在数据查找、数据去重等方面有着许多的应用。这里，就来看看常用的一些哈希函数是如何来实现的。 0. RsHash最简单的一种Hash函数实现方法，来自于Rober Sedgwicks的C语言算法书: 12345678910111213unsigned int RsHash(const char* str, unsigned int len)&#123; unsigned int b = 378551; unsigned int a = 63689; unsigned int hash = 0; for(int i = 0; i &lt; len; ++i)&#123; hash = hash * a + (*str++); a *= b; &#125; return hash;&#125; 1. JsHash由Justin Sobel提出的Hash函数： 12345678910unsigned int JsHash(const char* str, unsigned int len)&#123; unsigned int hash = 1315423911; for(int i = 0; i &lt; len; ++i)&#123; hash ^= ((hash &lt;&lt; 5) + (*str++) + (hash &gt;&gt; 2)); &#125; return hash;&#125; 2. PjwHashPwjHash是由AT&amp;T的Peter J.Wenberger提出的Hash算法: 1234567891011121314151617181920unsigned int PjwHash(const char* str, unsigned int len)&#123; const unsigned int bitsOfUnsignedInt = (unsigned int)(sizeof(unsigned int) * 8); const unsigned int threeQuarters = (unsigned int)((bitsOfUnsignedInt * 3)/4); const unsigned int halfQuarter = (unsigned int)(bitsOfUnsignedInt/8); const unsigned int highBits = (unsigned int)(0xFFFFFFFF &lt;&lt;(bitsOfUnsignedInt - halfQuarter)); unsigned int hash = 0; unsigned int test = 0; for(int i = 0; i &lt; len; ++i)&#123; hash = (hash &lt;&lt; halfQuarter) + (*str++); if((test = hash &amp; highBits) != 0)&#123; hash = ((hash^(test &gt;&gt; threeQuarters)) &amp; (~highBits)); &#125; &#125; return hash;&#125; 3. ElfHash该Hash函数在UNIX系统中有着广泛的应用： 1234567891011121314151617unsigned int ElfHash(const char* str, unsigned int len)&#123; unsigned int hash = 0; unsigned int x = 0; for(int i = 0; i &lt; len; ++i)&#123; hash = (hash &lt;&lt; 4) + (*str++); if((x = hash &amp; 0xF0000000L) != 0)&#123; hash ^= (x &gt;&gt; 24); &#125; hash &amp;= ~x; &#125; return hash;&#125; 4. BkdrHash由Brian Kernighan和Dennis Ritchie在《C Programming Language》中提出的Hash算法: Java中的hashCode()函数通常使用该方法实现 1234567891011unsigned int BkdrHash(const char* str, unsigned int len)&#123; unsigned int seed = 131; /*31 131 1313 13131 131313 etc*/ unsigned int hash = 0; for(int i = 0; i &lt; len; ++i)&#123; hash = (hash * seed) + (*str++); &#125; return hash;&#125; 5. SdbmHash在开源项目SDBM中使用的一个Hash算法: 12345678910unsigned int SdbmHash(const char* str, unsigned int len)&#123; unsigned int hash = 0; for(int i = 0; i &lt; len; ++i)&#123; hash = (*str++) + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash; &#125; return hash;&#125; 6. DjbHash由Daniel J.Bernstein教授提出的一个Hash算法: 12345678910unsigned int DjbHash(const char* str, unsigned int len)&#123; unsigned int hash = 5381; for(int i = 0; i &lt; len; ++i)&#123; hash = (hash &lt;&lt; 5 + hash) + (*str++); &#125; return hash;&#125; 7. DekHashDonald E.Knuth提出的一个hash函数: 12345678910unsigned int DekHash(const char* str, unsigned int len)&#123; unsigned int hash = len; for(int i = 0; i &lt; len; ++i)&#123; hash = ((hash &lt;&lt; 5)^(hash &gt;&gt; 27))^(*str++); &#125; return hash;&#125; 8. ApHash由Arash Partow提出的一种Hash算法: 123456789101112unsigned int ApHash(const char* str, unsigned int len)&#123; unsigned int hash = 0xAAAAAAAA; for(unsigned int i = 0; i &lt; len; ++i)&#123; hash ^= ((i &amp; 1 == 0) ? (((hash &lt;&lt; 7)^(*str)) * (hash &gt;&gt; 3)) : (~((hash &lt;&lt; 11) + (*str)^(hash &gt;&gt; 5)))); ++str; &#125; return hash;&#125; 参考文献 http://www.partow.net/programming/hashfunctions/]]></content>
      <categories>
        <category>算法/数据结构</category>
      </categories>
      <tags>
        <tag>Hash Function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cache揭秘]]></title>
    <url>%2F2017%2F07%2F16%2Fcache%E6%8F%AD%E7%A7%98%2F</url>
    <content type="text"><![CDATA[缓存(Memory Cache)在一般意义上是指一种用于存储当前或者历史数据的硬件或者软件结构，其目的是加速数据的存取，提升系统效率。这里，将要讨论的cache是指CPU与主内存之间的一种基于SRAM(Static Random Access Memory)存储结构。 自计算机诞生以来，CPU的性能大致都按照摩尔定律以每年50%的速度递增，而主内存RAM(Random Access Memory)的性能增速却只有7%，因此在CPU性能与主内存性能之间渐渐形成了一个鸿沟： 1980年CPU中尚无cache; 到1995年CPU开始有两级cache 从主内存中读取数据通常需要花费50~200个CPU周期，利用cache来保存CPU最近使用的数据或者指令，如果cache中存在所需数据（指令），则直接返回给CPU；如果不存在相应的数据，则从主内存中获取，从而提升CPU效率。这样Cache, Main Memory以及Disk（磁盘）之间就形成了通常被称为”Memory Hierarchy“的存储层次化的结构： 那么，为什么cache能够提升CPU的运行效率？这里边依靠的是程序运行时的一个基本原理：引用的局部性(Locality of reference):相近的或者最近被访问的内存区域通常就是下一次需要访问的内存区域。最常见的是两种局部性： 时间局部性（Temporal locality) : 最近被访问的内存区域，很可能在稍后的时间里被引用； 空间局部性(Spatial locality): 某个内存区域被访问，很可能稍后其临近的区域也会被访问； 接下来就来看下cache是怎么构成的。 缓存架构下图是一个有256 (2^8) 个缓存行,4KB（2^10)大小的cache架构框图，可以看到，cache由两部分组成：cache controller，以及cache memory； cache memory是由一内存单元阵列组成的专用存储结构，其中每一个存储单元被称为cache lines（缓存行）;而cache controller负责将CPU发送过来的地址映射到cache memory，选取相应的cache memory： 图片来自《ARM System Develop’s Guide - Designing and Optimizting System Software》 一个cache line由三个部分组成：目录项，数据区以及状态。目录项也叫作cache tag,用于标识一个cache line是主内存中的来源（地址）；而从主内存中拷贝过来的数据则保持在数据区,而状态位则用于保持cache line的状态信息，通常有valid(有效）跟dirty（脏数据）两种状态。有效则意味着缓存数据保持的是最新的主内存数据，而脏数据则表示一个缓存行中的数据跟主内存不同。 CPU有数据或者指令请求时，首先被cache controller截取，controller会把内存地址分为三个部分：tag标签域，set index集合索引域，data index数据索引域。利用set index来定位可能包含内存数据的缓存行。刚才我们说道，每个缓存行都有个一个cache tag，controller正是通过这个标签域与状态位来确定数据是否存在。如果一个缓存行的状态为是valid，并且内存地址的tag与缓存行的tag相同，则命中缓存（cache hit)，否则出现缓存缺失(cache miss)。 cache miss: 出现缓存缺失，cache controller需要将主内存中的数据拷贝到缓存中，并将其提供给CPU； cache hit: 缓存命中，直接将命中缓存数据发送给CPU（利用data index确定数据所在位置）； 那么，主内存是如何映射到cache当中的了？学过中学数学的都知道，两个集合的映射一般有一对一，多对一、一对多、多对多等几种形式。与此相类似，主内存与cache直接的物理映射（通过硬件设计实现）大致有三种形式： Directed Mapping(直接映射）： 对于主内存中的任一地址仅有一个可能的cache地址。这种映射方式最为简单，其存在的不足之处容易出现“缓存抖动”(cache thrashing)) - 不断出现缓存缺失，从而降低系统性能； Full-associative cache（全关联）： 对每个主内存中的地址可以映射到任何一个cache位置。全关联虽然为主内存数据的存储带来了更多的灵活性，但是由于其实现方式复杂，成本高，因而通常只在cache空间很小的CPU中使用； K-way assocative cache(多路关联）:是直接映射与全关联两种方式的折中策略，通过将cache memory划分为更小的单位（ways)，使得主内存中的位置可能有多个cache位置与之相对应。比如下图是一个4-way 4KB大小的cache示意图： 图片来自《ARM System Develop’s Guide - Designing and Optimizting System Software》 与前文中的示意图不同的是，这里cache memory共包含了4路，每路都包含了64(2^6)个缓存行，但cache总的大小仍然是4KB（4*4*64*4 bytes),但现在对于每个set index都对应了4个cache line,这4个缓存行可以看成是一个set，这也是set index这个名字的由来。 缓存策略这里就来看下缓存的两种策略： 写内存以及缓存替换策略。写内存策略用于确定何时将数据写入内存；但出现cache miss时，使用替换策略将某个缓存行换出。 首先来看下写策略。 write policy当CPU需要将数据写回主内存时，cache controller有两种写策略可选择：一种是同时更新缓存行数据和主内存数据，这种方法被称为writethrough;另一种策略writeback则只更新缓存行数据，而不更新主内存数据。 Writethrough: 如果缓存命中，则同时更新主内存与缓存行数据，确保主内存与缓存数据始终保持一致，由于需要将数据写回内存，因此Writethrough会比Writeback慢； Writeback: 使用该写策略，只更新有效(缓存行标记为valid)的缓存数据，而不更新主内存，这样就可能出现缓存与主内存数据不一致，那么，何时将缓存数据写入内存了？当cache controller写数据到缓存时，将该缓存行中的数据标记为dirty，等到下一次访问时，controller知道这个缓存行数据并不在内存中，因此换出该缓存行时，则自动将其写回主内存； replacement policy出现cache miss时，cache controller需要从缓存中选择一个缓存行用于保存从主内存中加载的新数据。如果被替换的缓存行包含了有效或者脏数据，则需要将其写回内存。那么，如何从缓存中选择可能被替换的缓存行了？这就是缓存的替换策略。一般有以下几种： Least Recently Used(LRU): 将最少使用的缓存行换出； Roud-robin(RR): 轮盘随机选择一个缓存行换出； 更多关于缓存替换策略可以参考WIKIPEDIA文章：https://en.wikipedia.org/wiki/Cache_replacement_policies。 参考文献 http://service.scs.carleton.ca/sivarama/org_book/org_book_web/slides/chap_1_versions/ch17_1.pdf https://www.cs.umd.edu/class/fall2001/cmsc411/proj01/cache/cache.pdf http://www.ece.northwestern.edu/~kcoloma/ece361/lectures/Lec14-cache.pdf https://cseweb.ucsd.edu/classes/fa14/cse240A-a/pdf/08/CSE240A-MBT-L15-Cache.ppt.pdf http://people.cs.pitt.edu/~cho/cs1541/current/handouts/lect-memh_4up.pdf 《ARM System Develop’s Guide - Designing and Optimizting System Software》]]></content>
      <categories>
        <category>Computer Architecture</category>
      </categories>
      <tags>
        <tag>Memory Cache</tag>
        <tag>CPU Architecture</tag>
        <tag>Memory Hierarchy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android进程Crash处理流程]]></title>
    <url>%2F2017%2F07%2F09%2FAndroid%E8%BF%9B%E7%A8%8BCrash%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[之前的一篇文章，讲到了应用程序无响应(ANR)时Android的处理逻辑。这篇文章，就来分析下应用进程发生崩溃(Crash)时，Android是如何处理的？总的说来，Android主要有两大类Crash： Java(JVM)层： 应用程序发生运行时错误（如空指针，浮点运算错误，数据索引超出界限)或者系统进程崩溃(长时间无响应)； Native层： native进程或者kernel发生运行时错误； APP层Crash处理对Java层，Android需要处理两种情况的Crash： 对于APP中未捕获的异常，捕捉到后，进行处理； 监控UI线程（主线程）、前台服务线程、IO线程、显示线程（IMS/WMS,DMS中使用）以及Binder进程通信线程是否挂起（10s内无响应则视为挂起); 主线程(main thread）是指应用启动时创建的进程中的第一个线程，而UI线程则是负责输入、绘制等前台交互，大部分情况下主线程就是UI线程，参考： https://developer.android.com/guide/components/processes-and-threads.html https://developer.android.com/studio/write/annotations.html#thread-annotations 下面就从这两种情况来分析APP出现的Crash。 未捕获异常Crash对于每个进程，在启动过程初始化运行时执行环境时，都会设置一个未捕获异常处理函数，用于捕获APP中未捕获到的异常情况： 1234567891011121314151617private static final void commonInit() &#123; if (DEBUG) Slog.d(TAG, "Entered RuntimeInit!"); /* set default handler; this applies to all threads in the VM */ Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler()); TimezoneGetter.setInstance(new TimezoneGetter() &#123; @Override public String getId() &#123; return SystemProperties.get("persist.sys.timezone"); &#125; &#125;); TimeZone.setDefault(null); .... initialized = true;&#125; 捕获到应用Crash后，向AMS发送Crash信息，最后将进程杀死： 123456789101112131415161718192021222324252627282930313233private static class UncaughtHandler implements Thread.UncaughtExceptionHandler &#123; public void uncaughtException(Thread t, Throwable e) &#123; try &#123; // Don't re-enter -- avoid infinite loops if crash-reporting crashes. if (mCrashing) return; mCrashing = true; if (mApplicationObject == null) &#123; // 进程启动时设置了mApplicationObject = ApplicationThread &#125; else &#123; StringBuilder message = new StringBuilder(); message.append("FATAL EXCEPTION: ").append(t.getName()).append("\n"); final String processName = ActivityThread.currentProcessName(); if (processName != null) &#123; message.append("Process: ").append(processName).append(", "); &#125; message.append("PID: ").append(Process.myPid()); Clog_e(TAG, message.toString(), e); &#125; .... // Bring up crash dialog, wait for it to be dismissed ActivityManagerNative.getDefault().handleApplicationCrash( mApplicationObject, new ApplicationErrorReport.CrashInfo(e)); &#125; catch (Throwable t2) &#123; .... &#125; finally &#123; // Try everything to make sure this process goes away. Process.killProcess(Process.myPid()); System.exit(10); &#125; &#125;&#125; 参考源码：/android/frameworks/base/core/java/com/android/internal/os/RuntimeInit.java AMS接收到Crash后，找到应用的进程记录，做下一步处理： 1234567891011public void handleApplicationCrash(IBinder app, ApplicationErrorReport.CrashInfo crashInfo) &#123; ProcessRecord r = findAppProcess(app, "Crash"); final String processName = app == null ? "system_server" : (r == null ? "unknown" : r.processName); final int userId = r == null ? UserHandle.USER_OWNER : r.userId; .... // 处理应用Crash handleApplicationCrashInner("crash", r, processName, crashInfo); &#125; AMS处理APP的Crash主要做了两件事情： 保存Crash的当时的现场到Dropbox; 如果发现该APP频繁Crash，记录信息，强制其停止，不提示用户；否则需要弹出APP出错的对话框告知用户，由用户自己选择处理的方式（重启或者强制停止）； 12345678910111213141516void handleApplicationCrashInner(String eventType, ProcessRecord r, String processName, ApplicationErrorReport.CrashInfo crashInfo) &#123; EventLog.writeEvent(EventLogTags.AM_CRASH, Binder.getCallingPid(), UserHandle.getUserId(Binder.getCallingUid()), processName, r == null ? -1 : r.info.flags, crashInfo.exceptionClassName, crashInfo.exceptionMessage, crashInfo.throwFileName, crashInfo.throwLineNumber); addErrorToDropBox(eventType, r, processName, null, null, null, null, null, crashInfo); mAppErrors.crashApplication(r, crashInfo);&#125; 系统挂起在应用层， Android有一个专门的监控者Watchdog线程来负责监控应用层是否出现系统挂起（在给定时间10s无响应则视为挂起），比如系统服务IMS(AMS,WMS)无响应，UI线程、IO线程无响应，Binder IPC线程无响应等各种异常情况： 1234567891011121314151617181920212223242526private Watchdog() &#123; super("watchdog"); // The shared foreground thread is the main checker. It is where we // will also dispatch monitor checks and do other work. mMonitorChecker = new HandlerChecker(FgThread.getHandler(), "foreground thread", DEFAULT_TIMEOUT); mHandlerCheckers.add(mMonitorChecker); // Add checker for main thread. We only do a quick check since there // can be UI running on the thread. mHandlerCheckers.add(new HandlerChecker(new Handler(Looper.getMainLooper()), "main thread", DEFAULT_TIMEOUT)); // Add checker for shared UI thread. mHandlerCheckers.add(new HandlerChecker(UiThread.getHandler(), "ui thread", DEFAULT_TIMEOUT)); // And also check IO thread. mHandlerCheckers.add(new HandlerChecker(IoThread.getHandler(), "i/o thread", DEFAULT_TIMEOUT)); // And the display thread. mHandlerCheckers.add(new HandlerChecker(DisplayThread.getHandler(), "display thread", DEFAULT_TIMEOUT)); // Initialize monitor for Binder threads. addMonitor(new BinderThreadMonitor());&#125; Watchdog线程是在system_server进程启动时启动起来的： 12345678private void startOtherServices() &#123; .... final Watchdog watchdog = Watchdog.getInstance(); watchdog.init(context, mActivityManagerService); .... Watchdog.getInstance().start();&#125; Watchdog线程启动后，开始监测各个线程有无响应（通过在线程消息队列的头部添加一个可执行对象，对于Binder线程则通过BlockUtilThreadAvailable来检测是否有Binder线程可用），一旦发现系统某个线程无响应，则抓取相应APP的堆栈LOG，同时保存kernel的堆栈信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public void run() &#123; boolean waitedHalf = false; File traceFile = new File("/data/anr/traces.txt"); try &#123; if (!traceFile.exists()) &#123; traceFile.createNewFile(); &#125; traceFile.setReadable(true, false); traceFile.setWritable(true, false); &#125; catch(IOException e) &#123; Slog.e(TAG, "Failed to create /data/anr/traces.txt"); &#125; while (true) &#123; final ArrayList&lt;HandlerChecker&gt; blockedCheckers; final String subject; final boolean allowRestart; synchronized (this) &#123; long timeout = CHECK_INTERVAL; for (int i=0; i&lt;mHandlerCheckers.size(); i++) &#123; HandlerChecker hc = mHandlerCheckers.get(i); hc.scheduleCheckLocked(); &#125; .... final int waitState = evaluateCheckerCompletionLocked(); if (waitState == COMPLETED) &#123; // The monitors have returned; reset waitedHalf = false; continue; &#125; else if (waitState == WAITING) &#123; // still waiting but within their configured intervals; back off and recheck continue; &#125; else if (waitState == WAITED_HALF) &#123; .... continue; &#125; // something is overdue! blockedCheckers = getBlockedCheckersLocked(); subject = describeCheckersLocked(blockedCheckers); allowRestart = mAllowRestart; &#125; &#125; // 系统处于挂起状态，保存APP堆栈信息 final File stack = ActivityManagerService.dumpStackTraces( !waitedHalf, pids, null, null, NATIVE_STACKS_OF_INTEREST); .... // 保存kernel堆栈信息 if (RECORD_KERNEL_THREADS) &#123; dumpKernelStackTraces(); &#125; .... &#125; 参考源码：/android/frameworks/base/services/core/java/com/android/server/Watchdog.java 接下来，就来看一看Android是如何处理native进程crash的。 Native层Crash处理在native层，Android的Crash处理主要由三个部分组成： kernel捕捉到进程的异常信号(SIGABRT,SIGBUS,SIGFPE)时,调用信号处理函数；信号处理函数负责收集Crash进程的错误信息，并将错误信息通过socket发送给debugger守护进程； debugger守护进程接收到crash信息后，一方面告知AMS有进程发生Crash，一方面通过tomestone保存完整的现场信息； AMS收到Crash信息后，弹出对话框告知用户Crash信息，同时保存该crash进程的相关LOG； 接下来，我们分步骤来看下native层Crash的处理流程。 Crash信号处理函数Native进程发生崩溃（Crash)时，kernel会向其发送一个信号(signal),此时当前进程被中断，kernel接着调用事先注册在系统中的信号处理函数(Signal Handler)。Android在启动时专门注册了一个signal handler用于处理Native进程由于运行错误而出现的信号。 那么，Android的signal handler是在哪里注册到系统中的了？在Android库bionic中有一个动态链接库linker（文件目录/android/bionic/）,linker启动时会初始化通过系统调用signal向系统注册信号处理函数； Android主要处理SIGABRT、SIGBUS等几种Crash信号（linux signal)： SIGABRT(6): abort, 异常终止； SIGBUS(10): bus error, 总线错误； SIGFPE(8): Floating Point Exception, 浮点运算异常； SIGILL(4): Illegal Instruction, 非法指令； SIGSEGV(11): Invalid memory Segmentation Fault, 无效内存访问； SIGSTKFLT(16): stack fault, 堆栈错误； SIGTRAP(5): Trace Trap, 跟踪陷阱； debugger.cpp12345678910111213141516171819202122__LIBC_HIDDEN__ void debuggerd_init() &#123; struct sigaction action; memset(&amp;action, 0, sizeof(action)); sigemptyset(&amp;action.sa_mask); // 信号处理函数 action.sa_sigaction = debuggerd_signal_handler; action.sa_flags = SA_RESTART | SA_SIGINFO; // Use the alternate signal stack if available so we can catch stack overflows. action.sa_flags |= SA_ONSTACK; // 需要捕捉的信号 sigaction(SIGABRT, &amp;action, nullptr); sigaction(SIGBUS, &amp;action, nullptr); sigaction(SIGFPE, &amp;action, nullptr); sigaction(SIGILL, &amp;action, nullptr); sigaction(SIGSEGV, &amp;action, nullptr); #if defined(SIGSTKFLT) sigaction(SIGSTKFLT, &amp;action, nullptr); #endif sigaction(SIGTRAP, &amp;action, nullptr);&#125; 注册完信号处理函数后，一旦kernel检测到有进程出现上述信号，则会调用debuggerd_signal_handler函数进行处理：此时会通过socket接口android:debuggerd32（对于64位系统，socket名为android:debuggerd）发送错误信息， 123456789101112131415161718/* * Catches fatal signals so we can ask debuggerd to ptrace us before * we crash. */static void debuggerd_signal_handler(int signal_number, siginfo_t* info, void*) &#123; // It's possible somebody cleared the SA_SIGINFO flag, which would mean // our "info" arg holds an undefined value. if (!have_siginfo(signal_number)) &#123; info = nullptr; &#125; log_signal_summary(signal_number, info); // 向debuggered发送错误信息 send_debuggerd_packet(info); ....&#125; 调用send_debuggerd_packet，首先连接debuggerd的服务端socket；接着不断尝试向该socket写入数据，直至成功： 123456789101112131415161718192021222324252627282930313233343536373839static void send_debuggerd_packet(siginfo_t* info) &#123; // Mutex to prevent multiple crashing threads from trying to talk // to debuggerd at the same time. static pthread_mutex_t crash_mutex = PTHREAD_MUTEX_INITIALIZER; int ret = pthread_mutex_trylock(&amp;crash_mutex); ... // 连接debuggerd int s = socket_abstract_client(DEBUGGER_SOCKET_NAME, SOCK_STREAM | SOCK_CLOEXEC); if (s == -1) &#123; __libc_format_log(ANDROID_LOG_FATAL, "libc", "Unable to open connection to debuggerd: %s", strerror(errno)); return; &#125; // debuggerd knows our pid from the credentials on the // local socket but we need to tell it the tid of the crashing thread. // debuggerd will be paranoid and verify that we sent a tid // that's actually in our process. debugger_msg_t msg; // crash msg.action = DEBUGGER_ACTION_CRASH; msg.tid = gettid(); msg.abort_msg_address = reinterpret_cast&lt;uintptr_t&gt;(g_abort_message); msg.original_si_code = (info != nullptr) ? info-&gt;si_code : 0; // 向socket写入数据 ret = TEMP_FAILURE_RETRY(write(s, &amp;msg, sizeof(msg))); if (ret == sizeof(msg)) &#123; char debuggerd_ack; ret = TEMP_FAILURE_RETRY(read(s, &amp;debuggerd_ack, 1)); int saved_errno = errno; notify_gdb_of_libraries(); errno = saved_errno; &#125; else &#123; // read or write failed -- broken connection? __libc_format_log(ANDROID_LOG_FATAL, "libc", "Failed while talking to debuggerd: %s", strerror(errno)); &#125; // 关闭socket close(s);&#125; 参考源码： /android/bionic/linker/debugger.cpp debuggerd.cpp在服务端进程debuggerd启动时，会不断监听客户端的连接请求，一旦发现有连接，就会读取其中的数据进行处理： 123456789101112131415161718192021222324252627282930313233343536373839404142static int do_server() &#123; // debuggerd crashes can't be reported to debuggerd. // Reset all of the crash handlers. signal(SIGABRT, SIG_DFL); signal(SIGBUS, SIG_DFL); signal(SIGFPE, SIG_DFL); signal(SIGILL, SIG_DFL); signal(SIGSEGV, SIG_DFL);#ifdef SIGSTKFLT signal(SIGSTKFLT, SIG_DFL);#endif signal(SIGTRAP, SIG_DFL); // Ignore failed writes to closed sockets signal(SIGPIPE, SIG_IGN); .... // 创建服务端socket int s = socket_local_server(SOCKET_NAME, ANDROID_SOCKET_NAMESPACE_ABSTRACT, SOCK_STREAM | SOCK_CLOEXEC); // Fork a process that stays root, and listens on a pipe to pause and resume the target.（具体什么作用，没看明白） if (!start_signal_sender()) &#123; ALOGE("debuggerd: failed to fork signal sender"); return 1; &#125; // 监听并处理客户端进程请求 for (;;) &#123; sockaddr_storage ss; sockaddr* addrp = reinterpret_cast&lt;sockaddr*&gt;(&amp;ss); socklen_t alen = sizeof(ss); ALOGV("waiting for connection\n"); int fd = accept4(s, addrp, &amp;alen, SOCK_CLOEXEC); if (fd == -1) &#123; continue; &#125; handle_request(fd); &#125; return 0;&#125; 现在debuggerd与客户端进程已经建立好连接了，读取其中的数据并fork一个新的进程处理之： 12345678910111213141516171819202122static void handle_request(int fd) &#123; ScopedFd closer(fd); debugger_request_t request; memset(&amp;request, 0, sizeof(request)); // 读取数据 int status = read_request(fd, &amp;request); if (status != 0) &#123; return; &#125; .... // Fork a child to handle the rest of the request. pid_t fork_pid = fork(); if (fork_pid == -1) &#123; ALOGE("debuggerd: failed to fork: %s\n", strerror(errno)); // 在子进程中处理请求 &#125; else if (fork_pid == 0) &#123; worker_process(fd, request); &#125; else &#123; monitor_worker_process(fork_pid, request); &#125;&#125; 在子进程中处理Crash：首先尝试连接AMS，接着会保存Crash进程的DUMP LOG，最后通过socket发送消息告知AMS有Crash发生， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static void worker_process(int fd, debugger_request_t&amp; request) &#123; // Open the tombstone file if we need it. std::string tombstone_path; int tombstone_fd = -1; switch (request.action) &#123; case DEBUGGER_ACTION_DUMP_TOMBSTONE: case DEBUGGER_ACTION_CRASH: tombstone_fd = open_tombstone(&amp;tombstone_path); if (tombstone_fd == -1) &#123; ALOGE("debuggerd: failed to open tombstone file: %s\n", strerror(errno)); exit(1); &#125; break; .... &#125; // Don't attach to the sibling threads if we want to attach gdb. // Supposedly, it makes the process less reliable. bool attach_gdb = should_attach_gdb(request); .... std::set&lt;pid_t&gt; siblings; if (!attach_gdb) &#123; ptrace_siblings(request.pid, request.tid, siblings); &#125; int amfd = -1; std::unique_ptr&lt;std::string&gt; amfd_data; if (request.action == DEBUGGER_ACTION_CRASH) &#123; // 连接AMS amfd = activity_manager_connect(); amfd_data.reset(new std::string); &#125; bool succeeded = false; .... int crash_signal = SIGKILL; // 保存DUMP LOG succeeded = perform_dump(request, fd, tombstone_fd, backtrace_map.get(), siblings, &amp;crash_signal, amfd_data.get()); if (succeeded) &#123; if (request.action == DEBUGGER_ACTION_DUMP_TOMBSTONE) &#123; if (!tombstone_path.empty()) &#123; android::base::WriteFully(fd, tombstone_path.c_str(), tombstone_path.length()); &#125; &#125; &#125; .... if (!attach_gdb) &#123; // Tell the Activity Manager about the crashing process. If we are // waiting for gdb to attach, do not send this or Activity Manager // might kill the process before anyone can attach. activity_manager_write(request.pid, crash_signal, amfd, *amfd_data.get()); &#125; .... close(amfd); exit(!succeeded);&#125; 连接AMS用来监听native crash的socket， 从这里我们也可以看到，debuggerd进程实际连接的是在NativeCrashListener.java中创建的socket： 12345678910111213141516171819202122232425262728293031static int activity_manager_connect() &#123; android::base::unique_fd amfd(socket(PF_UNIX, SOCK_STREAM, 0)); struct sockaddr_un address; memset(&amp;address, 0, sizeof(address)); address.sun_family = AF_UNIX; // The path used here must match the value defined in NativeCrashListener.java. strncpy(address.sun_path, "/data/system/ndebugsocket", sizeof(address.sun_path)); if (TEMP_FAILURE_RETRY(connect(amfd.get(), reinterpret_cast&lt;struct sockaddr*&gt;(&amp;address), sizeof(address))) == -1) &#123; return -1; &#125; struct timeval tv; memset(&amp;tv, 0, sizeof(tv)); tv.tv_sec = 1; // tight leash if (setsockopt(amfd.get(), SOL_SOCKET, SO_SNDTIMEO, &amp;tv, sizeof(tv)) == -1) &#123; ALOGE("debuggerd: Unable to connect to activity manager (setsockopt SO_SNDTIMEO failed: %s)", strerror(errno)); return -1; &#125; tv.tv_sec = 3; // 3 seconds on handshake read if (setsockopt(amfd.get(), SOL_SOCKET, SO_RCVTIMEO, &amp;tv, sizeof(tv)) == -1) &#123; ALOGE("debuggerd: Unable to connect to activity manager (setsockopt SO_RCVTIMEO failed: %s)", strerror(errno)); return -1; &#125; return amfd.release();&#125; 参考源码： /android/system/core/debuggerd/debuggerd.cpp ActivityManagerService.java进程debuggerd跟AMS是通过一个叫/data/system/ndebugsocket的socket进行通信的，该socket在NativeCrashListener.java中创建的; NativeCrashListener实际是一个线程，它是在AMS初始化时创建的，其作用是一直在监听来自debuggerd进程的请求，如果有则处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445NativeCrashListener(ActivityManagerService am) &#123; mAm = am; &#125; @Override public void run() &#123; final byte[] ackSignal = new byte[1]; // The file system entity for this socket is created with 0700 perms, owned // by system:system. debuggerd runs as root, so is capable of connecting to // it, but 3rd party apps cannot. .... try &#123; FileDescriptor serverFd = Os.socket(AF_UNIX, SOCK_STREAM, 0); final UnixSocketAddress sockAddr = UnixSocketAddress.createFileSystem( DEBUGGERD_SOCKET_PATH); Os.bind(serverFd, sockAddr); Os.listen(serverFd, 1); while (true) &#123; FileDescriptor peerFd = null; try &#123; // 等待客户端连接 peerFd = Os.accept(serverFd, null /* peerAddress */); if (MORE_DEBUG) Slog.v(TAG, "Got debuggerd socket " + peerFd); if (peerFd != null) &#123; // Only the superuser is allowed to talk to us over this socket StructUcred credentials = Os.getsockoptUcred(peerFd, SOL_SOCKET, SO_PEERCRED); if (credentials.uid == 0) &#123; // 处理Crash数据 consumeNativeCrashData(peerFd); &#125; &#125; &#125; catch (Exception e) &#123; Slog.w(TAG, "Error handling connection", e); &#125; finally &#123; .... &#125; &#125; &#125; catch (Exception e) &#123; Slog.e(TAG, "Unable to init native debug socket!", e); &#125; &#125; 读取socket中的Crash数据，并将其报告给AMS： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void consumeNativeCrashData(FileDescriptor fd) &#123; final byte[] buf = new byte[4096]; final ByteArrayOutputStream os = new ByteArrayOutputStream(4096); try &#123; StructTimeval timeout = StructTimeval.fromMillis(SOCKET_TIMEOUT_MILLIS); Os.setsockoptTimeval(fd, SOL_SOCKET, SO_RCVTIMEO, timeout); Os.setsockoptTimeval(fd, SOL_SOCKET, SO_SNDTIMEO, timeout); // first, the pid and signal number int headerBytes = readExactly(fd, buf, 0, 8); if (headerBytes != 8) &#123; // protocol failure; give up Slog.e(TAG, "Unable to read from debuggerd"); return; &#125; int pid = unpackInt(buf, 0); int signal = unpackInt(buf, 4); // now the text of the dump if (pid &gt; 0) &#123; final ProcessRecord pr; synchronized (mAm.mPidsSelfLocked) &#123; pr = mAm.mPidsSelfLocked.get(pid); &#125; if (pr != null) &#123; // Don't attempt crash reporting for persistent apps if (pr.persistent) &#123; return; &#125; int bytes; do &#123; // get some data bytes = Os.read(fd, buf, 0, buf.length); if (bytes &gt; 0) &#123; // did we just get the EOD null byte? if (buf[bytes-1] == 0) &#123; os.write(buf, 0, bytes-1); // exclude the EOD token break; &#125; // no EOD, so collect it and read more os.write(buf, 0, bytes); &#125; &#125; while (bytes &gt; 0); .... // 启动另一个线程NativeCrashReporter通知AMS final String reportString = new String(os.toByteArray(), "UTF-8"); (new NativeCrashReporter(pr, signal, reportString)).start(); &#125; else &#123; Slog.w(TAG, "Couldn't find ProcessRecord for pid " + pid); &#125; &#125; else &#123; Slog.e(TAG, "Bogus pid!"); &#125; &#125; catch (Exception e) &#123; Slog.e(TAG, "Exception dealing with report", e); // ugh, fail. &#125; &#125; 通过NativeCrashReporter线程告知AMS有native crash发生： 123456789101112131415161718192021222324252627282930class NativeCrashReporter extends Thread &#123; ProcessRecord mApp; int mSignal; String mCrashReport; NativeCrashReporter(ProcessRecord app, int signal, String report) &#123; super("NativeCrashReport"); mApp = app; mSignal = signal; mCrashReport = report; &#125; @Override public void run() &#123; try &#123; CrashInfo ci = new CrashInfo(); ci.exceptionClassName = "Native crash"; ci.exceptionMessage = Os.strsignal(mSignal); ci.throwFileName = "unknown"; ci.throwClassName = "unknown"; ci.throwMethodName = "unknown"; ci.stackTrace = mCrashReport; mAm.handleApplicationCrashInner("native_crash", mApp, mApp.processName, ci); &#125; catch (Exception e) &#123; Slog.e(TAG, "Unable to report native crash", e); &#125; &#125;&#125; 之后的处理流程，跟在第一节关于未捕获异常的时候，就基本一样了。详细可以参考上节内容。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Crash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的任务管理]]></title>
    <url>%2F2017%2F07%2F01%2FAndroid%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Activity是Android负责与用户交互的实体。一个应用一般由多个Activity组成;一个Activity不仅可以打开应用内的Activity，也可以打开其他应用内的Activity，比如通过一个名为android.intent.action.VIEW的Intent事件可以打开浏览器；通过android.intent.action.DIAL可以向CALL发送拨号请求。一系列的Activity组合在一起（完成某个特定的“任务“）构成了一个任务（一个后进先出的队列，被称为back stack），而多个任务又构成了一个任务栈（后台可以有多个任务栈，但系统如需恢复内存，则会杀死部分应用，清空部分任务，以释放内存，因此长时间后应用状态会丢失）。以下图为例，图中的back stack一开始只有一个Activity1；接着在Activity1中启动Activity2，此时Activity2位于队列的顶部，而Activity1位于栈底（Activity1处于Stop状态），而Activity2又启动一个Activity3，同样，Activity3压入栈顶。如果此时通过回退键（Back）用户离开Activity3,则Activity3从栈中清除，被系统销毁，而Activity2则恢复到可见状态(resume)。 总的说来，Activity与任务栈之间的关系有如下几种情况： 当Activity A启动ActivityB时，A处于停止（stop）状态，但是系统会保留其状态（如当前滑动位置以及输入的文本等）；如果在B中用户按下回退键，此时A恢复原来的状态，而B被销毁； 当用户按下HOME键离开一个任务时，当前Activity会被停止，相应的任务进入后台，系统会保留任务中所有Activity的状态。如果用户稍后通过启动界面（Launcher）的图标启动该任务，则任务恢复到前台运行，使任务顶部的Activity处于可见状态(resume); 用户按下回退（back)键时，当前Activity从栈中弹出，销毁（系统不再保留次Activity状态），此时之前的Activity恢复运行； 一个Activity可被实例化多次，该实例可以来自不同的任务（back stack）； 那么，Android是如何来管理这些任务的了？这里有这么几个问题： 刚讲到，一个Activity可能在一个任务中被实例化多次，那么如何避免这样多次实例化的开销了？ 怎么来控制一个Activity所属的任务(back stack)? 怎么启动一个新的任务？ 任务管理Android通过启动模式(Launch Mode)来控制Activity的启动方式，也可以通过控制Activity中的某些属性来控制Activity在任务中的行为。启动模式主要有两种控制方式，一个是在manifest文件的&lt;activity&gt;标签来指定，一种是通过Intent中的标志位。接下来就来看下这两种控制方式。 使用manifest文件&lt;activity&gt;中有一个launchMode的属性来指定Activity启动的模式： “standard”: 默认的启动模式，系统创建一个新的Activity实例，并放入启动该Activity的任务中。在这种模式下，一个Activity可能被实例化多次，每个实例可能属于不同的任务，而且有可能一个任务里存在多个实例； “singleTop”： 如果当前任务的顶部已存在该Activity实例，则将intent通过onNewIntent方法传给该Activity，不会再创建一个新的Activity实例； “singleTask”: 创建一个新的任务，并将该Activity放入任务(back stack)的底部；但是如果其他任务栈中已存在该Activity实例，则不会创建新的任务，而是将该Activity实例所在任务放置到前台运行，intent则通过onNewIntent()方法传给该Activity。该启动模式确保任务栈中始终只有一个Activity实例存在； “singleInstance”: 与singleTask相同，唯一的区别在于该模式下系统不会将其他Activity放入到该Activity所在的任务中，并且任何通过该Activity启动的Activity都会在另一个任务当中，就是说，当前Activity始终是其任务中唯一的一个成员； 使用Intent标志位当通过startActivity()来启动Activity时，可以通过Intent的标志位来控制Activity的启动方式： FLAG_ACTIVITY_NEW_TASK： 行为与launchMode中的singleTask一样； FLAG_ACTIVITY_SINGLE_TOP： 行为与launchMode中的singleTop一样； FLAG_ACTIVITY_CLEAR_TOP： 这个标志在launchMode中没有对应的值。如果当前任务中已存在该Activity的实例，则将所有在该Activity之上的其他Activity都销毁，该Activity置于任务的栈顶，并通过onNewIntent()方法将intent传给该实例。 处理亲和标志affinity(亲和性）表示一个activity属于哪个任务（back stack)。Android默认在同一个进程中，所有的Activity相互之间都有同样的affinity，就是说在同一个任务中。但是，通过taskAffinity属性值我们可以修改一个Activity属于的任务，这样不同应用之前的Activity可以共有一个affinity，而同一个应用之间的Activity也可以有不同的affinity： 对于Activity来说，可通过标签&lt;activity&gt;中的属性taskAffinity来指定affinity； 对于一个应用来说，&lt;application&gt;中的taskAffinity属性默认为&lt;manifest&gt;中指定的程序包名； 一般有两种情况会影响到Activity的affinity： 启动Activity时，设置了标志位FLAG_ACTIVITY_NEW_TASK,此时如果系统没有包含该Activity实例的任务，则启动新的任务；否则该Activity从已有任务中启动； &lt;activity&gt;中的属性值allowTaskReparenting设为true，在这种情况下，如果Activity所属affinity的任务到前台运行，则该Activity可能从启动它的任务(back stack)中移动到它所属affinity的任务当中。 清除任务如果用户长时间离开一个任务，系统会清理除根Activity以外的所有Activity。当用户返回应用后，仅有根Activity被恢复。但可以通过如下几个&lt;activiyt&gt;的属性值来更改系统的这一行为： alwaysRetainTaskState：如果在一个任务中的根Activity中的将其设为true，则不会任务中的任何Activity，即使长时间后，依然保留所有Activity在任务中； clearTaskOnLaunch：其作用恰好与alwaysRetainTaskState相反；如果在根Activity中将该属性值设为true，则只要用户离开任务，则会将除根Activity之外的Activity都清除，就是说，每次用户返回任务时，都是一个最开始初始化的状态； finishOnTaskLaunch：与clearTaskOnLaunch作用类似，但其只局限于单个Activity，而不是整个任务（back stack），它可以使任何一个Activity被清除，包括根Activity。该属性设为true时，应用只是为当前会话而保留在任务中，一旦用户离开，稍后返回任务，则不能再看到该Activity。 参考文献 https://developer.android.com/guide/components/activities/tasks-and-back-stack.html#ManagingTasks]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>任务管理</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ANR处理流程]]></title>
    <url>%2F2017%2F06%2F25%2FAndroid-ANR%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ANR即Application Not Responding, 应用无响应：当应用在某一个时间内无法及时响应用户请求时，系统会弹出一个对话框，告知用户应用无法响应。此时，用户可以选择关闭应用。对于Android应用来说，有一个UI线程(主线程）专门负责与用户交互，如果在此线程中进行耗时的操作，比如读取磁盘数据、从网络下载资源等IO操作，通常会导致UI线程阻塞，从而无法及时处理用户的输入请求，发生ANR。 Android是通过AMS跟WMS来监控应用响应状态的，一般有如下两种ANR情况： 应用在给定时间内没有对用户输入(按键或者触屏操作）做出响应，通常是5s; 广播接收者(BroadcastReceiver)没有在10s内处理完成； 对于输入无响应的情况，native监控到输入无响应时，则告知WMS，最后由WMS发送消息告诉AMS，某个应用发送了ANR，最后AMS会弹出Application Not Responding的对话框，请求用户关闭应用；对于广播无响应的情况是由AMS负责处理的，AMS对于每个发送出去给广播接收者的广播都有一个10s的定时，如果广播接收者在10s内尚未处理完，则视为无响应，因此也会弹出Application Not Responding。 首先来看下第一种情况。 输入无响应输入无响应是指用户长时间（5s内）无法响应用户的输入操作，如触摸，按键等，此时AMS会弹出对话框提示用户应用出现ANR(Application Not Responding)。 Android由InputManagerService（IMS）负责处理用户的输入事件，IMS会将输入转交给对应的应用窗口，最后由应用本身做出相应的操作；在native层，IMS有一个对应的InputManager来管理来自Kernel的输入事件（有关Android输入系统，请参考罗升阳Android应用程序键盘消息处理机制分析），InputReader负责读取输入事件，而InputDispatcher则负责将读取的事件分发出去。这里，就来看下InputDispatcher是如何检测应用输入无响应以及将其分发出去的。 以下是输入ANR处理流程图(图片来自http://gityuan.com/images/input/input_reader_seq.jpg)： native的InputManager初始化时启动一个InputDispatcherThread用于输入事件的分发: 123456789101112131415161718192021222324InputManager::InputManager( const sp&lt;EventHubInterface&gt;&amp; eventHub, const sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy, const sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123; mDispatcher = new InputDispatcher(dispatcherPolicy); mReader = new InputReader(eventHub, readerPolicy, mDispatcher); initialize();&#125;....void InputManager::initialize() &#123; mReaderThread = new InputReaderThread(mReader); mDispatcherThread = new InputDispatcherThread(mDispatcher);&#125;status_t InputManager::start() &#123; // 分发线程 status_t result = mDispatcherThread-&gt;run("InputDispatcher", PRIORITY_URGENT_DISPLAY); // 读线程 result = mReaderThread-&gt;run("InputReader", PRIORITY_URGENT_DISPLAY); return OK;&#125; InputDispatcherThread启动时，进入一个线程循环： 12345678910InputDispatcherThread::InputDispatcherThread(const sp&lt;InputDispatcherInterface&gt;&amp; dispatcher) : Thread(/*canCallJava*/ true), mDispatcher(dispatcher) &#123;&#125;//启动后，进入线程循环bool InputDispatcherThread::threadLoop() &#123; mDispatcher-&gt;dispatchOnce(); return true;&#125; InputDispatcher开始事件处理： 123456789101112131415161718192021222324void InputDispatcher::dispatchOnce() &#123; nsecs_t nextWakeupTime = LONG_LONG_MAX; &#123; // acquire lock AutoMutex _l(mLock); mDispatcherIsAliveCondition.broadcast(); // 指令请求队列为空，则开始分发输入事件 if (!haveCommandsLocked()) &#123; dispatchOnceInnerLocked(&amp;nextWakeupTime); &#125; // Run all pending commands if there are any. if (runCommandsLockedInterruptible()) &#123; nextWakeupTime = LONG_LONG_MIN; &#125; &#125; // release lock // Wait for callback or timeout or wake. (make sure we round up, not down) nsecs_t currentTime = now(); int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime); // 查看线程消息队列是否有新的消息 mLooper-&gt;pollOnce(timeoutMillis);&#125; 根据输入事件的类型将事件分发出去，按键输入事件类型是TYPE_KEY，触屏输入事件TYPE_MOTION，这里假定应用处理的是一个按键事件: 123456789101112131415161718192021222324void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) &#123; ... switch (mPendingEvent-&gt;type) &#123; .... // 按键事件 case EventEntry::TYPE_KEY: &#123; ... //分发按键事件 done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime); break; &#125; // 触屏事件 case EventEntry::TYPE_MOTION: &#123; .... done = dispatchMotionLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime); break; &#125; &#125;&#125; 分发键盘事件之前，首先需要找到当前响应输入的焦点窗口： 1234567891011121314bool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, KeyEntry* entry, DropReason* dropReason, nsecs_t* nextWakeupTime) &#123; .... // 找到当前输入焦点窗口 Vector&lt;InputTarget&gt; inputTargets; int32_t injectionResult = findFocusedWindowTargetsLocked(currentTime, entry, inputTargets, nextWakeupTime); .... // Dispatch the key. dispatchEventLocked(currentTime, entry, inputTargets); return true;&#125; 在查找目标焦点窗口之前，会检查是否有应用程序的窗口处于无响应状态： 1234567891011121314151617181920212223int32_t InputDispatcher::findFocusedWindowTargetsLocked(nsecs_t currentTime, EventEntry* entry, Vector&lt;InputTarget&gt;&amp; inputTargets, nsecs_t* nextWakeupTime) &#123; .... // Check whether the window is ready for more input reason = checkWindowReadyForMoreInputLocked(currentTime, focusedWindowHandle, entry, "focused"); // 输入无响应 if (!reason.isEmpty()) &#123; injectionResult = handleTargetsNotReadyLocked(currentTime, entry, //mFocusedApplicationHandle, mFocusedWindowHandle, nextWakeupTime, reason.string()); mFocusedApplicationHandle, focusedWindowHandle, nextWakeupTime, reason.string()); goto Unresponsive; &#125; // Done. Failed: Unresponsive: nsecs_t timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime); updateDispatchStatisticsLocked(currentTime, entry, injectionResult, timeSpentWaitingForApplication); return injectionResult;&#125; 如果发现焦点窗口无法对用户事件作出响应，并且超过了给定的时间(Android设定的超时为5s)，则 123456789101112131415161718192021int32_t InputDispatcher::handleTargetsNotReadyLocked(nsecs_t currentTime, const EventEntry* entry, const sp&lt;InputApplicationHandle&gt;&amp; applicationHandle, const sp&lt;InputWindowHandle&gt;&amp; windowHandle, nsecs_t* nextWakeupTime, const char* reason) &#123; .... //应用无响应超时 if (currentTime &gt;= mInputTargetWaitTimeoutTime) &#123; onANRLocked(currentTime, applicationHandle, windowHandle, entry-&gt;eventTime, mInputTargetWaitStartTime, reason); *nextWakeupTime = LONG_LONG_MIN; return INPUT_EVENT_INJECTION_PENDING; &#125; else &#123; // Force poll loop to wake up when timeout is due. if (mInputTargetWaitTimeoutTime &lt; *nextWakeupTime) &#123; *nextWakeupTime = mInputTargetWaitTimeoutTime; &#125; return INPUT_EVENT_INJECTION_PENDING; &#125;&#125; 将ANR事件以CommandEntry的形式加入到命令队列中，等到下一次输入处理周期时在处理，处理时会调用函数doNotifyANRLockedInterruptible(见dispatchOnce()）: 12345678910111213void InputDispatcher::onANRLocked( nsecs_t currentTime, const sp&lt;InputApplicationHandle&gt;&amp; applicationHandle, const sp&lt;InputWindowHandle&gt;&amp; windowHandle, nsecs_t eventTime, nsecs_t waitStartTime, const char* reason) &#123; ... // 将ANR事件添加到命令队列 CommandEntry* commandEntry = postCommandLocked( &amp; InputDispatcher::doNotifyANRLockedInterruptible); commandEntry-&gt;inputApplicationHandle = applicationHandle; commandEntry-&gt;inputWindowHandle = windowHandle; commandEntry-&gt;reason = reason;&#125; 通过InputDispatcherPolicyInterface接口通知NativeInputMananger有ANR事件发生： 123456789101112131415void InputDispatcher::doNotifyANRLockedInterruptible( CommandEntry* commandEntry) &#123; mLock.unlock(); nsecs_t newTimeout = mPolicy-&gt;notifyANR( commandEntry-&gt;inputApplicationHandle, commandEntry-&gt;inputWindowHandle, commandEntry-&gt;reason); mLock.lock(); resumeAfterTargetsNotReadyTimeoutLocked(newTimeout, commandEntry-&gt;inputWindowHandle != NULL ? commandEntry-&gt;inputWindowHandle-&gt;getInputChannel() : NULL);&#125; 到这里，准备通知InputManagerService.java（IMS）ANR事件了，mServiceObj实际是一个Java类InputManagerService的一个全局引用，通过CallLongMethod来调用IMS中的notifyANR方法： 12345678910111213141516171819202122nsecs_t NativeInputManager::notifyANR(const sp&lt;InputApplicationHandle&gt;&amp; inputApplicationHandle, const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, const String8&amp; reason) &#123; JNIEnv* env = jniEnv(); jobject inputApplicationHandleObj = getInputApplicationHandleObjLocalRef(env, inputApplicationHandle); jobject inputWindowHandleObj = getInputWindowHandleObjLocalRef(env, inputWindowHandle); jstring reasonObj = env-&gt;NewStringUTF(reason.string()); //调用IMS的notifyANR方法 jlong newTimeout = env-&gt;CallLongMethod(mServiceObj, gServiceClassInfo.notifyANR, inputApplicationHandleObj, inputWindowHandleObj, reasonObj); env-&gt;DeleteLocalRef(reasonObj); env-&gt;DeleteLocalRef(inputWindowHandleObj); env-&gt;DeleteLocalRef(inputApplicationHandleObj); return newTimeout;&#125; NativeInputManager位于com_android_server_input_InputManagerService.cpp,是InputManagerService.java对应的Native文件中的类，其负责初始化输入系统的native框架 IMS收到ANR事件后，通过一个回调接口WindowManagerCallbacks通知WMS(WindowManagerService)， WindowManagerCallbacks接口实际是一个InputMonitor.java对象，在SystemServer进程启动时，将WMS中的InputMonitor设置为IMS的回调: 1234567private long notifyANR(InputApplicationHandle inputApplicationHandle, InputWindowHandle inputWindowHandle, String reason) &#123; // mWindowMangerCallbacks是InputMonitor实现的回调接口 return mWindowManagerCallbacks.notifyANR( inputApplicationHandle, inputWindowHandle, reason);&#125; 向AMS发起inputDispatchingTimedOut的Binder请求，告知其ANR事件： 1234567891011121314151617181920212223@Overridepublic long notifyANR(InputApplicationHandle inputApplicationHandle, InputWindowHandle inputWindowHandle, String reason) &#123; .... if (appWindowToken != null &amp;&amp; appWindowToken.appToken != null) &#123; // 告知AMS有ANR事件 &#125; else if (windowState != null) &#123; try &#123; // Notify the activity manager about the timeout and let it decide whether // to abort dispatching or keep waiting. long timeout = ActivityManagerNative.getDefault().inputDispatchingTimedOut( windowState.mSession.mPid, aboveSystem, reason); if (timeout &gt;= 0) &#123; // The activity manager declined to abort dispatching. // Wait a bit longer and timeout again later. return timeout * 1000000L; // nanoseconds &#125; &#125; catch (RemoteException ex) &#123; &#125; &#125; return 0; // abort dispatching&#125; AMS处理输入响应超时： 12345678910111213141516171819@Overridepublic long inputDispatchingTimedOut(int pid, final boolean aboveSystem, String reason) &#123; ProcessRecord proc; long timeout; synchronized (this) &#123; synchronized (mPidsSelfLocked) &#123; proc = mPidsSelfLocked.get(pid); &#125; timeout = getInputDispatchingTimeoutLocked(proc); &#125; if (!inputDispatchingTimedOut(proc, null, null, aboveSystem, reason)) &#123; return -1; &#125; return timeout;&#125; 发现有应用进程ANR，AMS向主线程发送一个可执行对象，执行ANR操作，最后AppErrors会向当前应用程序的UI线程发送一个ANR的对话框： 123456789101112131415161718public boolean inputDispatchingTimedOut(final ProcessRecord proc, final ActivityRecord activity, final ActivityRecord parent, final boolean aboveSystem, String reason) &#123; .... if (proc != null) &#123; // mHandler.post(new Runnable() &#123; @Override public void run() &#123; mAppErrors.appNotResponding(proc, activity, parent, aboveSystem, annotation); &#125; &#125;); &#125; return true;&#125; 接下来，再来看下广播处理超时的情况。 广播处理超时广播的运行机制很像“内容发布者-订阅者”这样的信息传递方式：新闻报纸就是典型的例子，订阅者首先得到新闻通讯社注册成为用户才能接收到报纸；而新闻媒体则负责将报纸发送给各个合法的注册者。与此类似，广播的发送者通过Context中的接口sendBroadcast(Intent)向系统发送广播；而接收者则需要通过Context中提供的接口registerReceiver来监听广播，对于有系统权限限制的广播，需要相应的用户权限才允许接收。 Android系统广播由AMS(ActivityManagerService)负责管理，AMS中有两个广播队列，一个是前台广播(Intent中对应的标志位FLAG_RECEIVER_FOREGROUND),具有在前台运行的优先级；一个是后台广播，不指定前台标志位的广播都默认为后台广播。对于前台广播，接收者如果在10s内为完成，则视为超时；后台广播如果接收后60s内为完成，则超时。此时，AMS会向当前UI线程发送一个ANR的对话框。 AMS中接收到广播后，将广播放入一个队列,根据广播接收者注册机制的不同，广播队列分为并行与串行两种处理方式，并行处理广播不用等待其他广播完成，主要用于处理用Context接口注册的广播接收者；串行方式则必须按照严格广播入队列的先后次序来处理. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) &#123; .... // 从Context中注册的广播接收 int NR = registeredReceivers != null ? registeredReceivers.size() : 0; if (!ordered &amp;&amp; NR &gt; 0) &#123; // If we are not serializing this broadcast, then send the // registered receivers separately so they don't wait for the // components to be launched. if (isCallerSystem) &#123; checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid, isProtectedBroadcast, registeredReceivers); &#125; final BroadcastQueue queue = broadcastQueueForIntent(intent); BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId); final boolean replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r); // 放入广播队列，并开始处理广播 if (!replaced) &#123; queue.enqueueParallelBroadcastLocked(r); queue.scheduleBroadcastsLocked(); &#125; registeredReceivers = null; NR = 0; &#125; // AndroidManifest.xml文件中声明的广播接收者 if ((receivers != null &amp;&amp; receivers.size() &gt; 0) || resultTo != null) &#123; BroadcastQueue queue = broadcastQueueForIntent(intent); BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r); if (!replaced) &#123; queue.enqueueOrderedBroadcastLocked(r); queue.scheduleBroadcastsLocked(); &#125; &#125; else &#123; .... &#125; &#125; return ActivityManager.BROADCAST_SUCCESS;&#125; 发送消息BROADCAST_INTENT_MSG请求处理广播： 123456789public void scheduleBroadcastsLocked() &#123; //当前有广播在处理，返回 if (mBroadcastsScheduled) &#123; return; &#125; mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this)); mBroadcastsScheduled = true;&#125; Handler接受到消息，开始处理队列中的广播： 1234567891011121314151617181920212223private final class BroadcastHandler extends Handler &#123; public BroadcastHandler(Looper looper) &#123; super(looper, null, true); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case BROADCAST_INTENT_MSG: &#123; //处理广播 processNextBroadcast(true); &#125; break; // 广播超时消息 case BROADCAST_TIMEOUT_MSG: &#123; synchronized (mService) &#123; broadcastTimeoutLocked(true); &#125; &#125; break; &#125; &#125;&#125; 处理下一个广播，简单起见，这里只分析串行分发广播的方式：首先记录下广播分发的时间dispatchTime,接着设置广播超时时间；最后开始处理广播，将其发送给广播接收者： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556final void processNextBroadcast(boolean fromMsg) &#123; synchronized(mService) &#123; do &#123; r = mOrderedBroadcasts.get(0); // 取消广播超时设置 cancelBroadcastTimeoutLocked(); &#125; while (r == null); ... r.receiverTime = SystemClock.uptimeMillis(); if (recIdx == 0) &#123; // 广播分发时间 r.dispatchTime = r.receiverTime; r.dispatchClockTime = System.currentTimeMillis(); &#125; if (! mPendingBroadcastTimeoutMessage) &#123; long timeoutTime = r.receiverTime + mTimeoutPeriod; //设置广播超时消息 setBroadcastTimeoutLocked(timeoutTime); &#125; .... // Is this receiver's application already running? if (app != null &amp;&amp; app.thread != null) &#123; try &#123; app.addPackage(info.activityInfo.packageName, info.activityInfo.applicationInfo.versionCode, mService.mProcessStats); processCurBroadcastLocked(r, app); return; &#125; catch (RemoteException e) &#123; &#125; catch (RuntimeException e) &#123; logBroadcastReceiverDiscardLocked(r); finishReceiverLocked(r, r.resultCode, r.resultData, r.resultExtras, r.resultAbort, false); scheduleBroadcastsLocked(); // We need to reset the state if we failed to start the receiver. r.state = BroadcastRecord.IDLE; return; &#125; &#125; //广播接收者进程不存在，启动之 if ((r.curApp=mService.startProcessLocked(targetProcess, info.activityInfo.applicationInfo, true, r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND, "broadcast", r.curComponent, (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, false, false, false)) == null) &#123; //启动应用失败 finishReceiverLocked(r, r.resultCode, r.resultData, r.resultExtras, r.resultAbort, false); scheduleBroadcastsLocked(); r.state = BroadcastRecord.IDLE; return; &#125; &#125; 如果广播处理在10s内未完成，则出发TIME_OUT的消息: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152final void broadcastTimeoutLocked(boolean fromMsg) &#123; if (fromMsg) &#123; mPendingBroadcastTimeoutMessage = false; &#125; if (mOrderedBroadcasts.size() == 0) &#123; return; &#125; long now = SystemClock.uptimeMillis(); BroadcastRecord r = mOrderedBroadcasts.get(0); if (fromMsg) &#123; long timeoutTime = r.receiverTime + mTimeoutPeriod; if (timeoutTime &gt; now) &#123; // 处理成功，重新设置TIMEOUT时间，返回 setBroadcastTimeoutLocked(timeoutTime); return; &#125; &#125; .... r.receiverTime = now; r.anrCount++; ProcessRecord app = null; String anrMessage = null; Object curReceiver = r.receivers.get(r.nextReceiver-1); r.delivery[r.nextReceiver-1] = BroadcastRecord.DELIVERY_TIMEOUT; if (curReceiver instanceof BroadcastFilter) &#123; BroadcastFilter bf = (BroadcastFilter)curReceiver; if (bf.receiverList.pid != 0 &amp;&amp; bf.receiverList.pid != ActivityManagerService.MY_PID) &#123; synchronized (mService.mPidsSelfLocked) &#123; app = mService.mPidsSelfLocked.get( bf.receiverList.pid); &#125; &#125; &#125; else &#123; app = r.curApp; &#125; // Move on to the next receiver. finishReceiverLocked(r, r.resultCode, r.resultData, r.resultExtras, r.resultAbort, false); scheduleBroadcastsLocked(); // 向超时应用发送ANR消息 if (anrMessage != null) &#123; mHandler.post(new AppNotResponding(app, anrMessage)); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ANR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程之锁]]></title>
    <url>%2F2017%2F06%2F18%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%94%81%2F</url>
    <content type="text"><![CDATA[Java语言synchronized关键字自带了一个内置的隐性锁(implicit lock),使用起来方便简单，但是内置锁一旦使用，则会强制将某个代码块加锁或者解锁，而且内置锁并不支持可中断的获取锁。从Java5.0开始，提供了一个并发工具包java.util.concurrent.*，实现了显性锁(explicit lock)ReentrantLock（可重入锁，可多次获取同一个锁）;ReentrantLock实现了与synchronized一样的功能，确保并发过程中数据的互斥访问与可见性。获取ReentrantLock相当于进入一个synchronized代码块，而释放ReentrantLock则相当于从一个synchronized代码块退出。ReentrantLock实现了如下Lock.java接口： 1234567891011121314151617181920public interface Lock &#123; //获取锁 void lock(); //获取锁，可响应中断 void lockInterruptibly() throws InterruptedException; //尝试获取锁，如果可用则返回TRUE，否则返回FALSE boolean tryLock(); //尝试在给定时间内获取锁，如果超时或者发生中断，则返回FALSE boolean tryLock(long time, TimeUnit unit) throws InterruptedException; //释放锁 void unlock(); //创建与该锁绑定的Conidition变量 Condition newCondition();&#125; ReentrantLock支持中断地获取锁，也可以给定超时时间获取锁，从而为并发编程提供了更大的灵活性。如下代码是ReentrantLock使用的一个示例： 1234567891011Lock lock = new ReentrantLock();...lock.lock();try&#123; doSomething();&#125; finally&#123; lock.unlock();&#125; 可重入锁ReentrantLock有两种获取模式：一种是公平(fair)，就是说锁按照请求的顺序获取的，而非公平(non-fair)模式则并不管等待队列中是否有线程，只要请求锁时可用，则直接获取锁。非公平锁是默认的实现方式。从表面上看，公平模式性能似乎要更好。但实际上，大多数情况非公平模式的性能都要优于公平模式（见 Doug Lea《Java Concurrency in Practice》)。 除了ReentrantLock，还有一种常用的锁ReentrantReadWriteLock(可重入读写锁)。在并发编程的情况下使用ReentrantLock虽然确保了任何时候都只有一个线程操作，保证了数据的一致性，但实际上大部分情况，共享数据往往是只需要读，而不会被修改，这样ReentrantLock对于多个读线程(Reader）的情况就显得有点过于谨慎了。那么，能否让多个读线程同时运行，而任何时刻都只有一个写线程(Writer)了？这就是ReadWriteLock需要做的事情。ReentrantReadWriteLock实现了如下ReadWriteLock接口: 123456789public interface ReadWriteLock &#123; //读锁 Lock readLock(); //写锁 Lock writeLock();&#125; 读写锁确保可同时有多个Reader而任何时刻都只有一个Writer,从而提升了读写的并发程度。这种特性使得ReentrantReadWriteLock尤其适合读操作执行时间长而很少有写操作的情况。与ReentrantLock类似，读写锁也提供了Fair与Non-fair两种获取模式。在公平模式下，锁总是给那些请求等待时间最长的线程，如果读锁被一个线程持有，此时另一个线程请求写锁，则其他请求读锁的线程一直会阻塞直到获取到写锁的线程完成任务；对于非公平模式，锁获取的顺序是不定的。另外，读写锁还支持锁降级（downgrading)，如果一个线程持有写锁，但需要请求读锁，此时无需释放写锁就可以直接获取读锁（其他写锁请求被阻塞），但不支持锁升级(upgrading，可能导致死锁)：持有读锁的线程请求写锁。 这里我们来看一个具体的实例：利用读写锁来实现一个可支持多个Reader,单个Writer的Map对象， 1234567891011121314151617181920212223242526272829303132333435363738394041public class ReadWriteMap&lt;K,V&gt; &#123; private final Map&lt;K,V&gt; map; private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(); private final Lock rl = rwLock.readLock(); private final Lock wl = rwLock.writeLock(); public ReadWriteMap(Map&lt;K,V&gt; map)&#123; this.map = map; &#125; public void put(K key, V value)&#123; wl.lock(); try&#123; map.put(key, value); &#125; finally&#123; wl.unlock(); &#125; &#125; // do same for putAll(), clear() public void remove(Object key)&#123; wl.lock(); try&#123; map.remove(key); &#125; finally&#123; wl.unlock(); &#125; &#125; public V get(Object key)&#123; rl.lock(); try&#123; return map.get(key); &#125; finally&#123; rl.unlock(); &#125; &#125;&#125; 了解了两种基本的锁，接下来这一节就来着重分析下ReentrantLock的具体实现原理。 ReentrantLock的实现原理在分析ReentrantLock的具体原理之前，先来看下java.util.concurrent包同步器实现的基础类AbstractQueueSynchronizer(AQS)的实现机制。除了ReentrantLock，ReentrantReadWriteLock之外，AQS是同步类如Semaphore,CountDownLatch,FutureTask的实现基础。与内置同步synchronized不同的是，AQS支持： 非阻塞的同步（Lock.tryLock())以及阻塞同步; 锁获取超时，防止线程饥饿； 可通过中断取消锁的获取； AQS主要提供了两类方法：acquire操作（可能阻塞或者不阻塞当前线程）和release操作。AQS对于每个阻塞线程都维护了一个同步状态，这个状态可以是互斥的（exclusive,只有一个线程可访问）也可以是共享的(shared,多个线程可访问）。互斥模式一般用于实现锁，如ReentrantLock；而信号量Semaphore,计数门栓CountDownLatch则通过共享模式实现。 AQS实现原理实现AQS的基本原理比较简单，一个获取操作可以按如下方式处理： 1234567while(*synchronization state does not allow acquire*)&#123; *enqueue current thread if not already queued;* *possibly block current thread;*&#125;*dequeue current thread if it was queued;* 而释放操作可以这么处理： 12345*update synchronization state*if(*state may permit a blocked thread to acquire*) *unblock one or more queued threads;* 要实现上述操作，需要三个基本组件的通力协作： 原子地更新同步状态（通过对一个volatile变量进行CAS操作实现）； 阻塞线程以及解阻线程（通过LockSupport.park/unpark方法实现）； 维护阻塞线程队列； 这里，主要来看下AQS是如何实现阻塞线程队列的。AQS中阻塞线程队列是由一个个Node节点组成的双端链表，每个节点包含了阻塞线程，队列的头节点、尾节点、前驱节点，后驱节点以及线程同步状态、线程等待状态等信息。获取时，AQS首先通过tryAcquire（由每个同步类自己实现）尝试获取，如果获取失败，则需要将其添加到等待队列中： 123456789101112131415161718192021222324public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; // 尝试获取 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;// 添加等待节点private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; // 入队列 enq(node); return node;&#125; 入队后，不断尝试获取： 1234567891011121314151617181920212223final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); // 前驱节点为头节点，并且设置状态成功 if (p == head &amp;&amp; tryAcquire(arg)) &#123; //出队列 setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; .... &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 释放时，调用tryRelease()释放，接着解阻头节点的前驱节点线程： 12345678910public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 接下来看看可重入锁ReentrantLock是如何利用AQS来实现锁的获取与释放的。 ReentrantLock的实现ReentrantLock提供了两个构造函数：默认构造函数利用非公平模式实现；如果需要公平模式，则可通过指定模式来构造。这里NonfairSync跟FairSync都是ReentrantLock的内部类。 123456789public ReentrantLock() &#123; sync = new NonfairSync(); &#125; // 指定实现模式：nonfair public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125; 获取锁， 123456789101112131415161718192021222324252627public void lock() &#123; sync.lock();&#125;static final class FairSync extends Sync &#123; .... protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125;&#125; 非公平方式获取时，首先不管阻塞线程队列是否有线程，直接通过CAS操作来设置状态，直至成功： 123456789101112131415161718192021222324252627282930313233343536373839static final class NonfairSync extends Sync &#123; final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else // AQS实现 acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125;abstract static class Sync extends AbstractQueuedSynchronizer &#123; .... // 非公平方式获取锁 final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125; &#125; 而对于公平方式，则首先会检查AQS等待队列中是否有线程比当前线程更早的进行获取锁的操作，如果没有才让当前线程成为锁持有者，否则当前线程需要进入等待队列： 123456789101112131415161718192021222324252627282930static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; // AQS的实现 acquire(1); &#125; // 公平方式获取锁，检查是否有更早的等待线程 protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125;&#125; 有关ReentrantLock以及AQS的实现源码可参考OpenJDK 。 参考文献 http://gee.cs.oswego.edu/dl/papers/aqs.pdf http://gee.cs.oswego.edu/dl/concurrency-interest/jsr166-slides.pdf]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程之原子操作]]></title>
    <url>%2F2017%2F06%2F11%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[在古希腊时代，哲学家Democritus（德谟克利特）提出了关于物质构成的理论：所有物质都由不可分割的元素组成，这种元素被称之为原子（atom）。编程中所说的原子性(atomic)借用了这个概念, 用于表示某个代码指令动作的不可中断性。在之前的一篇文章（Java Memory Model)时，提到多线程并发访问共享数据时，会出现数据竞争，从而导致数据不一致的情况。比如对一个整型变量进行加一的操作： ++counter，表面上看，这是一个单一原子操作，但实际上这个操作有三个步骤：首先，需要从内存中（有可能是cache中）加载到寄存器；接着，将该值加一；最后需要将寄存器中的值写入内存。这样，在多个线程访问的情况，上述几个步骤出现交织执行，就可能出现各个线程读写数据不一致的情形。 Atomic Theory: http://www.softschools.com/timelines/atomic_theory_timeline/95/ 于是，有了原子操作。原子操作确保了执行的不可中断，因而能避免数据冲突。Java从5.0开始有一个atomic的工具包专门支持int，long以及引用变量的原子操作，而在硬件层面，目前大部分处理器都支持诸如CAS(CompareAndSet/CompareAndSwap)，FAA(FetchAndAdd)等原子指令。在介绍Java中的原子操作类之前，先来了解下硬件层面的原子指令。 一个执行操作的原子性，是说该操作不可中断，除非其他线程在执行原子操作（此时当前线程进行原子操作出现错误)，否则当前线程需要占用CPU，直到执行完该操作为止，从而确保数据的互斥访问与可见性。 处理器原子指令相比锁(lock)，原子操作由于暂时禁止了中断，确保当前线程不会进行上下文切换，不会阻塞当前线程，效率通常要更高。因此，支持原子操作的处理器通常可以用来实现无锁算法(Non-blocking_algorithm)。常见的几个原子指令有: atomic swap: 原子的交换数据，x86对应的指令为XCHG (X86_instruction_listings); test and set: 向内存写入1，并返回旧值； fetch and add: 从内存中读取变量，并增加其值； compare and swap: CAS, 将一个变量的值与某个期望值比较，如果相等，则将新的值写入到内存;否则直接返回原值，不做任何操作（对应X86指令CMPXCHG）； 这里主要看下CAS的具体原理。CAS操作涉及的参数有内存区域V，期望的旧值A，以及新值B；如果V中的当前值与期望的值相等（表示当前没有其他线程修改过V），则更新V为新值B。当多个线程同时访问V时，一个线程成功修改了变量值，其他线程则直接失败了，但CAS不会阻塞这些线程。 以下是模拟实际CAS操作的一个代码片段: 12345678910111213141516171819202122// samples from Ch15 of &lt;&lt;Java Concurrency in Practice&gt;&gt;public class SimulatedCAS &#123; private int value; public synchronized int get()&#123; return value; &#125; public synchronized int compareAndSwap(int expectedV, int newV)&#123; int oldV = value; if(oldV == expectedV)&#123; value = newV; &#125; return oldV; &#125; public synchronized boolean compareAndSet(int expectedV, int newV)&#123; return (expectedV == compareAndSwap(expectedV,newV)); &#125;&#125; Atomic工具包Java5.0开始提供了一个Atomic的工具包，支持对int (AtomicInteger) ,long （AtomicLong）,boolean(AtomicBoolean)以及整型数组(AtomicIntegerArray)、引用类型(AtomicReference)、引用类型成员(AtomicReferenceFieldUpdater）的原子操作。如果使用其他基本类型数据如float,double，可以通过floatToIntBits()和doubleToLongBit()将long跟double转换成一个int，long再使用相应的原子类。 如下是AtomicInteger的一个代码片段，其内部整型成员value是一个volatile变量，这样可以确保多线程访问时数据的可见性；而底层封装类Unsafe提供的CAS操作则保证了AtomicInteger成员变量访问的互斥性。可以这么说，AtomicInteger是volatile的一般化实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; // 确保变量的可见性 private volatile int value; public AtomicInteger(int initialValue) &#123; value = initialValue; &#125; public AtomicInteger() &#123; &#125; public final int get() &#123; return value; &#125; public final void set(int newValue) &#123; value = newValue; &#125; /** * Eventually sets to the given value. */ public final void lazySet(int newValue) &#123; unsafe.putOrderedInt(this, valueOffset, newValue); &#125; public final int getAndSet(int newValue) &#123; return unsafe.getAndSetInt(this, valueOffset, newValue); &#125; public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1); &#125; ....&#125; 最后，以AtomicInteger为例来看下Atomic包具体的使用。假定，我们想要统计一个类某个接口的调用次数： 12345678910111213141516171819202122232425262728public class AtomicExamples &#123; private static AtomicInteger sCalledCount = new AtomicInteger(0); public static void main(String[] args)&#123; final AtomicExamples atomic = new AtomicExamples(); for(int i = 0; i &lt;= 10; ++i)&#123; Thread t = new Thread(new Runnable()&#123; @Override public void run() &#123; System.out.println("currently called " + atomic.callMe() + " times"); &#125; &#125;,"thread-" + i); t.start(); &#125; &#125; public int callMe()&#123; return sCalledCount.incrementAndGet(); &#125;&#125; 参考文献 http://cs.brown.edu/~mph/Herlihy91/p124-herlihy.pdf https://courses.cs.washington.edu/courses/cse378/07au/lectures/L25-Atomic-Operations.pdf]]></content>
      <categories>
        <category>Java</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
        <tag>Atomicity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide详解之图片加载过程分析]]></title>
    <url>%2F2017%2F05%2F30%2FGlide%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在之前的一篇文章(Glide架构分析 )中介绍了Glide的具体原理。这篇文章，用一个下载图片的示例来说明Glide加载图片的整个过程。以下是用Glide从网络上加载一个图片的代码片段： 12345678 Glide .with(activity) // Activity .load(url) .centerCrop() .placeholder(R.drawable.loading_spinner) .crossFade() .into(myImageView); 大致说来，在Glide中图片的加载有如下几个过程： 产生一个图片加载的请求GenericRequest&lt;T&gt;; 将图片加载请求发送给资源引擎中心Engine,由其负责资源的加载以及数据解码任务的管理； EngineRunnable首先尝试从DISK加载资源，完成后进行回调，将数据加载到ImageView中； 磁盘中没有请求对应的资源，则尝试从网络端下载，并解码完成后回调，将数据加载到Target对象； 现在就来详细的看下Glide加载图片的整个过程。 产生图片加载请求调用Glide.with(activity)产生一个RequestManager，用来负责管理和启动数据加载请求。 12345public static RequestManager with(Activity activity) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(activity);&#125; 在RequestManagerRetriever产生RequestMananger时，会启动一个没有视图对象的Fragment用以自动管理Glide中加载请求的生命周期： 12345678910111213141516171819202122232425RequestManager fragmentGet(Context context, android.app.FragmentManager fm) &#123; RequestManagerFragment current = getRequestManagerFragment(fm); RequestManager requestManager = current.getRequestManager(); if (requestManager == null) &#123; requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode()); current.setRequestManager(requestManager); &#125; return requestManager;&#125;@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)RequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) &#123; RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG); if (current == null) &#123; current = pendingRequestManagerFragments.get(fm); if (current == null) &#123; current = new RequestManagerFragment(); pendingRequestManagerFragments.put(fm, current); fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss(); handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget(); &#125; &#125; return current;&#125; 继续调用RequestManager.load(url),RequestMananger开始着手创建新的图片加载请求DrawableTypeRequest&lt;String&gt;： 123456789101112131415161718192021public DrawableTypeRequest&lt;String&gt; load(String string) &#123; return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);&#125;public DrawableTypeRequest&lt;String&gt; fromString() &#123; return loadGeneric(String.class);&#125;private &lt;T&gt; DrawableTypeRequest&lt;T&gt; loadGeneric(Class&lt;T&gt; modelClass) &#123; // 数据加载器，Glide默认的是HttpUrlGlideUrlLoader ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context); ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader = Glide.buildFileDescriptorModelLoader(modelClass, context); .... return optionsApplier.apply( new DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context, glide, requestTracker, lifecycle, optionsApplier));&#125; 通过DrawableTypeRequest，可以配置图片加载时的参数，如图片显示位置(fitCenter;centerCrop),图片加载的优先级priority,设置下载之前的占位符图片placeholder()，以及图片下载失败时的图片error(): 这些参数配置功能均在DrawableRequestBuilder 123456789101112131415161718192021222324252627@Overridepublic DrawableRequestBuilder&lt;ModelType&gt; priority(Priority priority) &#123; super.priority(priority); return this;&#125;@SuppressWarnings("unchecked")public DrawableRequestBuilder&lt;ModelType&gt; centerCrop() &#123; return transform(glide.getDrawableCenterCrop());&#125;@SuppressWarnings("unchecked")public DrawableRequestBuilder&lt;ModelType&gt; fitCenter() &#123; return transform(glide.getDrawableFitCenter());&#125;public final DrawableRequestBuilder&lt;ModelType&gt; crossFade() &#123; super.animate(new DrawableCrossFadeFactory&lt;GlideDrawable&gt;()); return this;&#125;@Overridepublic DrawableRequestBuilder&lt;ModelType&gt; error(int resourceId) &#123; super.error(resourceId); return this;&#125; 至此，图片加载请求就完成了。此时调用into(ImageView)，Glide就可以准备加载图片了。在GenericRequestBuilder中，调用into(ImageView)时首先会将ImageView包装成一个Target&lt;R&gt;,这里的资源类型R是GlideDrawable: 12345678910111213141516171819202122232425public Target&lt;TranscodeType&gt; into(ImageView view) &#123; Util.assertMainThread(); if (view == null) &#123; throw new IllegalArgumentException("You must pass in a non null View"); &#125; if (!isTransformationSet &amp;&amp; view.getScaleType() != null) &#123; switch (view.getScaleType()) &#123; case CENTER_CROP: applyCenterCrop(); break; case FIT_CENTER: case FIT_START: case FIT_END: applyFitCenter(); break; //$CASES-OMITTED$ default: // Do nothing. &#125; &#125; return into(glide.buildImageViewTarget(view, transcodeClass));&#125; Glide调用ImageViewTargetFactory来生成一个Target对象，这里实际创建的是一个GlideDrawableImageViewTarget对象： 1234567891011121314151617public class ImageViewTargetFactory &#123; @SuppressWarnings("unchecked") public &lt;Z&gt; Target&lt;Z&gt; buildTarget(ImageView view, Class&lt;Z&gt; clazz) &#123; if (GlideDrawable.class.isAssignableFrom(clazz)) &#123; return (Target&lt;Z&gt;) new GlideDrawableImageViewTarget(view); &#125; else if (Bitmap.class.equals(clazz)) &#123; return (Target&lt;Z&gt;) new BitmapImageViewTarget(view); &#125; else if (Drawable.class.isAssignableFrom(clazz)) &#123; return (Target&lt;Z&gt;) new DrawableImageViewTarget(view); &#125; else &#123; throw new IllegalArgumentException("Unhandled class: " + clazz + ", try .as*(Class).transcode(ResourceTranscoder)"); &#125; &#125;&#125; 调用into(Target)，在这里生成一个Request,并将其传递给RequestTracker执行。 12345678910111213141516171819public &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(Y target) &#123; Util.assertMainThread(); .... Request previous = target.getRequest(); if (previous != null) &#123; previous.clear(); requestTracker.removeRequest(previous); previous.recycle(); &#125; // 产生图片加载请求 Request request = buildRequest(target); target.setRequest(request); lifecycle.addListener(target); requestTracker.runRequest(request); return target;&#125; 启动图片加载调用RequestTracker.runRequest，保存该Request到队列中，如果当前状态没有处于paused，则直接调用Request.begin,启动Request: 12345678910public void runRequest(Request request) &#123; requests.add(request); if (!isPaused) &#123; request.begin(); &#125; else &#123; pendingRequests.add(request); &#125;&#125; 1234567891011121314151617181920@Overridepublic void begin() &#123; startTime = LogTime.getLogTime(); if (model == null) &#123; onException(null); return; &#125; status = Status.WAITING_FOR_SIZE; if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123; onSizeReady(overrideWidth, overrideHeight); &#125; else &#123; target.getSize(this); &#125; if (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123; target.onLoadStarted(getPlaceholderDrawable()); &#125;&#125; 如果图片给定的尺寸大小有效，则从FixedLoadProvider中获取一个数据加载器（在构造DrawableTypeRequest时由Glide创建），并将其作为参数传入Engine进行图片加载： 123456789101112131415161718192021@Overridepublic void onSizeReady(int width, int height) &#123; .... status = Status.RUNNING; width = Math.round(sizeMultiplier * width); height = Math.round(sizeMultiplier * height); ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader(); final DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height); .... ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder(); .... loadedFromMemoryCache = true; // 调用load进行图片加载 loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder, priority, isMemoryCacheable, diskCacheStrategy, this); loadedFromMemoryCache = resource != null; &#125; 加载图片，如果缓存中有，则直接回调返回该资源；或者Engine中有保存的活跃资源（之前提交了Request但尚未被释放的资源）也会直接返回该资源。否则需要从DISK或者网络端进行加载： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public &lt;T, Z, R&gt; LoadStatus load(Key signature, int width, int height, DataFetcher&lt;T&gt; fetcher, DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder, Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) &#123; Util.assertMainThread(); final String id = fetcher.getId(); EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(), loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(), transcoder, loadProvider.getSourceEncoder()); // cache中已经包含 EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable); if (cached != null) &#123; cb.onResourceReady(cached); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey("Loaded resource from cache", startTime, key); &#125; return null; &#125; // 活跃资源中包含该请求所需资源 EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable); if (active != null) &#123; cb.onResourceReady(active); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey("Loaded resource from active resources", startTime, key); &#125; return null; &#125; EngineJob current = jobs.get(key); .... EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable); DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation, transcoder, diskCacheProvider, diskCacheStrategy, priority); // EngineRunnable负责图片下载，解码 EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority); jobs.put(key, engineJob); engineJob.addCallback(cb); // 开始执行图片加载 engineJob.start(runnable); return new LoadStatus(cb, engineJob);&#125; 将EngineRunnable可执行对象放入一个优先级线程池FifoPriorityThreadPoolExecutor中执行： 两个线程池均在GlideBuilder创建，然后传给Engine的构造函数 12345public void start(EngineRunnable engineRunnable) &#123; this.engineRunnable = engineRunnable; future = diskCacheService.submit(engineRunnable);&#125; 由于EngineRunnable的初始状态为CACHE,因此首先会尝试从DISK的缓存中加载资源，如果加载成功，则直接回调返回该资源给上层调用者： 1234567891011121314151617181920212223242526272829@Overridepublic void run() &#123; .... Exception exception = null; Resource&lt;?&gt; resource = null; try &#123; // 从DISK或者NETWORK加载图片 resource = decode(); &#125; catch (Exception e) &#123; exception = e; &#125; // 资源加载结束，回调返回结果 if (resource == null) &#123; onLoadFailed(exception); &#125; else &#123; onLoadComplete(resource); &#125;&#125;private Resource&lt;?&gt; decode() throws Exception &#123; // stage为cache,直接从cache中获取资源 if (isDecodingFromCache()) &#123; return decodeFromCache(); &#125; else &#123; return decodeFromSource(); &#125;&#125; 调用DecodeJob.decodeFromCache()尝试从CACHE中获取资源： 12345678910111213141516private Resource&lt;?&gt; decodeFromCache() throws Exception &#123; Resource&lt;?&gt; result = null; try &#123; result = decodeJob.decodeResultFromCache(); &#125; catch (Exception e) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, "Exception decoding result from cache: " + e); &#125; &#125; if (result == null) &#123; result = decodeJob.decodeSourceFromCache(); &#125; return result;&#125; 如果CACHE中并没有发现可用的资源，EngineRunnable进入SOURCE状态： 12345678910111213141516private void onLoadFailed(Exception e) &#123; if (isDecodingFromCache()) &#123; stage = Stage.SOURCE; // 通过EngineJob将该执行对象再次执行 manager.submitForSource(this); &#125; else &#123; manager.onException(e); &#125;&#125;// EngineJob: 这一次提交到网络端线程池加载资源@Overridepublic void submitForSource(EngineRunnable runnable) &#123; future = sourceService.submit(runnable);&#125; 从网络端下载图片，回调返回结果调用DecodeJob.decodeFromSource(),从网络端下载图片,并将数据解码成对应格式: 12345public Resource&lt;Z&gt; decodeFromSource() throws Exception &#123; Resource&lt;T&gt; decoded = decodeSource(); return transformEncodeAndTranscode(decoded);&#125; 调用Resource&lt;T&gt;对应的DataFetcher&lt;A&gt;来从网络端加载数据，这里T是一个Bitmap， 而A是一个InputStream数据流；接着讲该输入流转换成相应的Resource&lt;Bitmap&gt;类： 12345678910111213141516171819private Resource&lt;T&gt; decodeSource() throws Exception &#123; Resource&lt;T&gt; decoded = null; try &#123; long startTime = LogTime.getLogTime(); // 这里的DataFetcher实际上是OkHttpStreamFetcher final A data = fetcher.loadData(priority); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey("Fetched data", startTime); &#125; if (isCancelled) &#123; return null; &#125; decoded = decodeFromSourceData(data); &#125; finally &#123; fetcher.cleanup(); &#125; return decoded;&#125; 调用OkHttpStreamFetcher.loadData()加载数据： 1234567891011121314151617181920212223@Overridepublic InputStream loadData(Priority priority) throws Exception &#123; Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl()); for (Map.Entry&lt;String, String&gt; headerEntry : url.getHeaders().entrySet()) &#123; String key = headerEntry.getKey(); requestBuilder.addHeader(key, headerEntry.getValue()); &#125; Request request = requestBuilder.build(); Response response; call = client.newCall(request); response = call.execute(); responseBody = response.body(); if (!response.isSuccessful()) &#123; throw new IOException("Request failed with code: " + response.code()); &#125; long contentLength = responseBody.contentLength(); stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength); return stream;&#125; 这里loadProvider是StreamBitmapDataLoadProvider，而用于资源解码的是StreamBitmapDecoder： 12345678910111213141516171819private Resource&lt;T&gt; decodeFromSourceData(A data) throws IOException &#123; final Resource&lt;T&gt; decoded; // 默认的磁盘缓存策略是(source,result) = (false, true) if (diskCacheStrategy.cacheSource()) &#123; decoded = cacheAndDecodeSourceData(data); &#125; else &#123; // 调用InputStream对应的资源解码器对InputStream进行解密 decoded = loadProvider.getSourceDecoder().decode(data, width, height); &#125; return decoded;&#125;//StreamBitmapDecoder: 输入流数据进行解码，按照给定的图片尺寸对图片进行比例采样@Overridepublic Resource&lt;Bitmap&gt; decode(InputStream source, int width, int height) &#123; Bitmap bitmap = downsampler.decode(source, bitmapPool, width, height, decodeFormat); return BitmapResource.obtain(bitmap, bitmapPool);&#125; 至此图片解码完成了，接着要讲Resource&lt;Bitmap&gt;转换成另一种包装类格式GlideBitmapDrawable，因而此时实际返回的是一个GlideBitmapDrawableResource: 1234567891011121314151617181920public Resource&lt;Z&gt; decodeFromSource() throws Exception &#123; Resource&lt;T&gt; decoded = decodeSource(); // 大小变换以及转换成另一个类Z return transformEncodeAndTranscode(decoded);&#125;private Resource&lt;Z&gt; transformEncodeAndTranscode(Resource&lt;T&gt; decoded) &#123; long startTime = LogTime.getLogTime(); Resource&lt;T&gt; transformed = transform(decoded); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey("Transformed resource from source", startTime); &#125; // 将变换后的结果保存到缓存 writeTransformedToCache(transformed); // 转换成GlideBitmapDrawable Resource&lt;Z&gt; result = transcode(transformed); return result;&#125; 回调onLoadComplete(),告知EngineJob资源加载完成了: 1234private void onLoadComplete(Resource resource) &#123; manager.onResourceReady(resource);&#125; 回调EngineJob.onResourceReady(),在主线程上处理回调结果： 123456789101112131415161718192021222324252627282930class EngineJob implements EngineRunnable.EngineRunnableManager &#123; // 用于向主线程发送消息 private static final Handler MAIN_THREAD_HANDLER = new Handler(Looper.getMainLooper(), new MainThreadCallback()); @Override public void onResourceReady(final Resource&lt;?&gt; resource) &#123; this.resource = resource; MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget(); &#125; private static class MainThreadCallback implements Handler.Callback &#123; @Override public boolean handleMessage(Message message) &#123; if (MSG_COMPLETE == message.what || MSG_EXCEPTION == message.what) &#123; EngineJob job = (EngineJob) message.obj; if (MSG_COMPLETE == message.what) &#123; // 资源加载成功 job.handleResultOnMainThread(); &#125; else &#123; job.handleExceptionOnMainThread(); &#125; return true; &#125; return false; &#125; &#125;&#125; 在主线程上处理结果：首先告知Engine资源加载完毕，接着告知所有ResourceCallback，并返回一个含有资源的包装类EngineResource: 1234567891011121314151617181920private void handleResultOnMainThread() &#123; engineResource = engineResourceFactory.build(resource, isCacheable); hasResource = true; // Hold on to resource for duration of request so we don't recycle it in the middle of notifying if it // synchronously released by one of the callbacks. engineResource.acquire(); listener.onEngineJobComplete(key, engineResource); // 回调接口在Engine中添加 for (ResourceCallback cb : cbs) &#123; if (!isInIgnoredCallbacks(cb)) &#123; engineResource.acquire(); cb.onResourceReady(engineResource); &#125; &#125; // Our request is complete, so we can release the resource. engineResource.release();&#125; 回忆下最开始调用Engine.decode()的地方GenericRequest，可以看到，ResourceCallback的源头在GenericRequest： 12345678910111213141516171819202122232425262728@SuppressWarnings("unchecked")@Overridepublic void onResourceReady(Resource&lt;?&gt; resource) &#123; if (resource == null) &#123; onException(new Exception("Expected to receive a Resource&lt;R&gt; with an object of " + transcodeClass + " inside, but instead got null.")); return; &#125; .... onResourceReady(resource, (R) received);&#125;private void onResourceReady(Resource&lt;?&gt; resource, R result) &#123; // We must call isFirstReadyResource before setting status. boolean isFirstResource = isFirstReadyResource(); status = Status.COMPLETE; this.resource = resource; // RequestListener是用户自己定义的监听接口 if (requestListener == null || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache, isFirstResource)) &#123; GlideAnimation&lt;R&gt; animation = animationFactory.build(loadedFromMemoryCache, isFirstResource); // 告知Target资源加载完毕 target.onResourceReady(result, animation); &#125; notifyLoadSuccess();&#125; 调用ImageViewTarget.onResourceReady,将资源加载到ImageView: 1234567@Overridepublic void onResourceReady(Z resource, GlideAnimation&lt;? super Z&gt; glideAnimation) &#123; if (glideAnimation == null || !glideAnimation.animate(resource, this)) &#123; setResource(resource); &#125;&#125; 至此这个图片就加载完成了。相比Piccasso,Glide大量使用了泛型，所以看代码可能比较费力，但是只要搞清楚各个泛型之间的关系，代码之间的逻辑就容易理清了。]]></content>
      <categories>
        <category>Open Source</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Glide</tag>
        <tag>图片加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近来二三事]]></title>
    <url>%2F2017%2F05%2F29%2F%E8%BF%91%E6%9D%A5%E4%BA%8C%E4%B8%89%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[如何专注你的聪明才智，比你有多聪明更重要 上周跟妹子去看了阿米尔-汗主演的《摔跤吧，爸爸》。电影剧情比较简单，讲述的是一个全国摔跤冠军一直梦想着在有生之年拿到一块国际金牌，为国争光。他把希望寄托在自己尚未降生的儿子身上，但天不随人愿，老婆连续生了几个小孩，无例外都是女孩。他渐渐放弃了通过儿子来实现自己梦想的想法。自己也一天天衰老。一次意外，他发现两个女儿吉塔与巴比塔是天生的摔跤手，于是萌生了让女儿接受摔跤训练，将其培养成世界冠军的想法。但这个想法遭到了家人的反对，邻里的嘲笑，几乎所有人都不看好他。但是，他的坚持获得了回报：大女儿吉塔先后获得了州冠军，全国摔跤冠军，并进入国家体育学院接受专业训练，而二女儿巴比塔也开始崭露头脚。最后吉塔在英联邦运动会上，夺得了摔跤金牌，终于圆了他的梦想。看到他女儿亲自将金牌递到他手里时，我还是忍不住留下了眼泪…他的那份坚持与勇气让我感动。有时，心怀梦想，做那些别人不敢做的事情的人注定孤单，但有梦想的陪伴，人至少能过得充实，能让生命发挥出不一样的光彩，而不是在沉默之中度过一生。发挥你的光与热，不要跟随大众，不要随大流，而是要勇敢追求自己真正期待的梦想。 近来学习新东西感觉要比以前快了。想想，可能是之前读书学习都没有掌握一个好的系统性的方法，只是埋头在看，花时间在学习而已，并没有深入的思考背后的概念。现在想来，要想对自己不熟悉的领域有一个深入的学习与认知，光有热情与时间精力远远不够，还需要正确的学习方法。正确的学习方法，是指学习时不再被动接受，而是主动去思考，思考概念背后所要解决的问题，思考概念背后所隐藏的原理；实在迷惑不解时，可能需要利用类比与联想的方式将概念与其他已知或者熟悉的概念联系起来帮助自己理解与把握。对于那些很大的“概念”，则需要将其进行分解，采用divide and conquer，各个击破，然后再综合起来，这样以来，头脑对概念的理解就会渐渐清晰起来。更重要的是要培养一种思维习惯，碰到一个概念，首先就问自己几个问题：(1) 这个概念是用来解决什么问题；（2） 有类似的概念吗？ （3）为什么需要这样一个概念，是否有现有的可以替代了？ 与一同事聊起中国的世俗人情。他说，他家一年到头光各种人情往来就要好几万块，每年回去光给家里每个侄子侄女的红包都要在千元以上。关于这种压岁钱、婚礼礼金以及各种人情消费，也听过见过，但这种攀比虚荣的人情往来竟会到了这种地步，也是让人感概。我们常说，中国是个人情社会，人们之前靠着“你帮我，我帮你”的社会伦理准则进行交往，但为何这种人情竟发展到了虚荣攀比以及炫富式的消费，进而形成一种社会风气，却是值得深思。在这样的人情社会，人们往往有一种用钱来衡量彼此之间的密程度，你给我送礼“重”，你对我的情谊就深。人们期待通过金钱来巩固彼此的感情，来维系人与人之间的信任与忠诚，但这往往会让人大失所望。因为金钱并不可靠，真正可靠的是规则，是制度保障下的规则。这种用钱来维持人情的做法，跟中国历史上法治的缺乏不无关系。当人们做什么事情都想着靠钱来解决时，当人们想到一个问题时总是想到通过挣钱来解决时，何尝不能说这是一个社会缺乏法治与法制的表现了？在另一方面来说，这种在金钱上的攀比也跟国人“好面子”有着不可分割的联系。世界上每个民族都多少会为了装饰门面而维护“脸面”，但像中国这样从普通百姓到政府首脑都爱慕虚荣这一点来看，却是少见的，可以说，“好面子”已经成了中国人内在的一部分。从慈禧“量中华之物力，结与国之欢心”，到政府各种集体式的炫耀，中国在某些方面依然原地踏步。”好面子“式的炫耀说到底是一种自卑，一种不自信，一种期待用表演来获取他人关注的爱慕虚荣。]]></content>
      <categories>
        <category>社会万象</category>
      </categories>
      <tags>
        <tag>摔跤吧，爸爸</tag>
        <tag>电影</tag>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程之Java Memory Model]]></title>
    <url>%2F2017%2F05%2F29%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BJava-Memory-Model%2F</url>
    <content type="text"><![CDATA[在之前一篇文章里，讲到了利用synchronized关键字来进行同步，从而避免多线程并发执行时可能出现的竞争条件，那么JVM又是如何实现线程之间的通信的？换句话说，线程A写共享数据的结果怎么确保被其他线程可见，使得线程之间共享的数据对每个线程而言都是一致的？Java从5.0开始定义了一个新的Memory Model(Java Specification Request 133, JSR133)，在多线程情况下，为Java程序提供了一个最少程度的保证：正确同步的情况下，一个线程写共享变量对于其他线程是可见的。Java Memory Model(JMM)抽象了不同计算机平台底层内存读写细节（Register; Cache; Main Memory)，为程序员提供了一个访问内存的统一的模型与视角，从而确保在不同平台上程序能有同样的结果，实现Java“编写一次，可以在任何平台上执行”的目标。 为什么需要JMM现代计算机的内存是一个层级的结构(memory hierarchy),最上层是寄存器(register),接下来是缓存(cache),最后才是主内存(main memory),因此一个变量的读总是需要经过cache，如果cache数据无效，才会从main meory中获取;写变量同样如此，先将数据写入对应cache,等到某个时间才将cache中的数据与main memory进行同步(见下图）。这样，在硬件层面就存在一个如何确保各个CPU之间数据可见性的问题。不同的硬件平台可能有不同的memory model来处理CPU之间的数据可见性。最简单的memory model就是一个CPU对内存中某个变量的写操作立即对其他CPU可见，这种强内存模型要求数据之间存在严格的顺序一致性,也被称为sequential consistency。虽然sequential consistency为线程之间的数据同步提供了强有力的保证，但是（1）顺序一致性要求所有的内存操作对所有线程可见；（2）禁止了编译器与CPU对于代码的优化，这无疑会降低系统运行的性能。因此，为在性能与数据可见性之间取得平衡，大部分平台都提供了一个更弱的meomory model,在需要进行数据同步时，通过一个内存屏障(Memory Barrier )来同步CPU缓存与主内存之间的数据。 每个CPU有自己独立的Register,Cache,但是共享Main Memory,各个不同的CPU之间通过总线（bus)来访问内存 Memory Hierarchy https://www.cs.auckland.ac.nz/~jmor159/363/html/mem_hierarchy.html 除了上述硬件平台memory model之间的差异，JMM还需要考虑编译器以及CPU执行指令时对代码执行顺序进行重排(reordering)导致的共享数据不一致问题。 Reordering在单线程情况下，Java语言本身要求JVM满足as-if-serial语义（只要在单线程情况下程序的执行结果不被改变，任何其他的重排都是允许的)。但对于多线程问题就复杂起来了。考虑如下两个线程,两个线程共享变量a，b，各自有一个局部变量r1，r2,假定初始状态时a = 0, b = 0： 12345678// Thread A1: r2 = a;2: b = 1;// Thread B3: r1 = b;4: a = 2; 直觉上来看，r1 = 1,r2 = 2似乎不可能。对线程A或者B来说，执行动作1与3都执行在前，如果1在前，则r2 = a不应该看到动作4执行的结果；如果3在前，同样r1 = b不应该看到2执行的结果。但是，分开来看，只要不影响当前线程的执行结果，编译器是可以对两个线程的指令进行重排的，因此，实际上代码可能按照如下顺序执行： 12345678// Thread Ab = 1;r2 = a;// Thread Br1 = b;a = 2; 不难看出，这样就有可能出现r1 = 1,r2 = 2难以预料的结果了。为了解决上述问题（编译器或者CPU优化时导致的指令重排)，Java定义了自己的一个memory model，由JVM来负责处理数据同步的底层实现细节（通过在适当的位置插入内存屏障来实现共享内存的可见性；通过CAS操作来实现原子操作)，开发者只要通过正确的调用synchronized,final,volatile等语言本身提供的同步语义即可实现共享数据的一致性与可见性。 什么是JMM总的说来，JMM定义了线程与主内存之间的一种抽象关系，其定义的规则在于解决多线程情况下可能出现的三个问题： Atomicity(原子性）: 那些指令必须是不可分割的(原子操作）； Visibility（可见性）： 在什么情况下，一个线程的写操作结果对另一个线程可见； Ordering（重排）: 在什么情况下，对任何线程而言，执行操作是可重排的 JMM确保读写内存区域（除了long/double之外）是原子的；volatile long/double读写是原子的; 一个线程执行的动作可被另一个线程检测到或者被直接影响到，则将该动作称为线程之间的动作(inter-thread action)，主要有以下几种： Read(non-volatile): 读一个变量； Write(non-volatile): 写一个变量； 同步动作： 读取一个volatile变量； 写一个volatile变量； Lock/unlock 线程的启动与终止 这样，一个线程间的执行动作可由一个由线程(t),执行的动作(k),变量或者monitor(v)以及任意的动作标识符（u）这样一个&lt;t,k,v,u&gt;四元组来确定了。在多线程情况下，最简单的内存模型就是所有动作总的顺序（由单个执行动作组成）跟程序的执行顺序（Program Order)保持一致，且所有的单个动作都具有原子性，操作的结果能够立刻对所有其他线程可见(Sequential Consistency)。这种强一致性虽然能够保证动作的可见性与执行顺序的可预测性，但是由于其禁止了编译器以及CPU指令优化，因此会降低系统的性能。 Sequential Consistency: http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf https://en.wikipedia.org/wiki/Sequential_consistency JMM提供了另一种选择，在不同平台上的执行性能与程序可预测性之间取得了平衡：JMM保证，在正确同步的情况下，JVM必须确保写变量对其他各个线程是可见的。通过对Java中的各种执行动作定义一种偏序关系(partial ordering),JMM确保程序执行结果的一致性。这种偏序关系通常被称为happens-before。JMM中主要有如下happens-before规则： Lock Rule: 在一个monitor上释放锁happens-before每一个在该monitor上的锁获取； Volatile Rule: 写一个volatile变量happens-before每一个volatile变量的读操作； Thread Start Rule: 线程的启动start()happens-before每一个其他该线程的动作； Thread Termination Rule: 任何在一个线程上的动作 happens-before其他线程得知该线程终止之前的动作 （从Thread.join 成功返回或者 Thread.isAlive返回false); All actions in a thread happens-before any other thread successfully returns from a join on that thread(与上条类似）； Interruption Rule: 一个线程中断另一个线程happens-before 被中断线程检测到该中断(either by having InterruptedException thrown or invoking Thread.isInterrupted or Thread.interrupted); Initialization Rule: 对象的默认初始化happens-before其他任何执行动作（除默认的写动作之外)（the defaul initialization of any object happens-before any other actions(other than default-writes) of a program); 什么是Partial Ordering Partially_ordered_set 下面就来看下，volatile以及final在happens-before规则下的语义。 volatile关键词volatile在不用同步的情况下，通过内存屏障的方式来禁止变量读写操作的重排序，从而确保一个线程的写操作对其他线程是可见的（volatile变量不会缓存到对其他处理器比可见的register或者cache，因此其他线程的读操作得到的总是其他任何线程最新写的结果）。在JSR133之前，只是不允许volatile变量之间的重排序，但不会禁止volatile变量与普通变量之间的重排序，而新的JSR133模型则严格限制了volatile变量读写与普通变量读写之间的重排序：写一个volatile变量在内存效果上等同于释放monitor锁; 读volatile变量则等同于获取monitor锁。 volatile只是保证了变量读写的可见性，但并没有确保互斥性。因此，使用volatile变量需要慎重。以下两点可以作为volatile使用的参考： 将一个类的引用声明为volatile并不能保证该类中非volatile的成员的可见性； 在单个写线程、多个读线程一个变量时使用volatile； 示例: 12345678910111213141516class VolatileExample&#123; int x = 0; volatile boolean v = false; public void writer()&#123; x = 30; v = true; // JMM确保上述普通变量与volatile变量之间的操作不被重排序 &#125; public void reader()&#123; if(v == true)&#123; int y = 2*x; // x = 30对其他任何读线程都是可见的 &#125; &#125;&#125; | 有关更多volatile变量的使用方法，请参考Managing Volatility final关键词final确保变量是不可变的（尽管该变量所引用的对象可变），一旦一个变量声明为final,并被初始化一次，之后就不会被更改。因此，final变量无需做同步即可在多线程情况下使用：一个在对象构造完成之后，可见该对象的引用的线程保证可以看到该对象的final变量。 示例：一个线程调用write(),另一个调用read(),根据Happens-before Rule,由于变量f的写动作总是在对象构造完成之后，因此读线程总是可以看到f.x = 3,而由于f.y并非final变量，因此JMM并不保证读线程可以看到f.y = 4。 1234567891011121314151617181920212223class FinalFieldExample&#123; final int x; int y; static FinalFiledExample f; public FinalFieldExample()&#123; x = 3; y = 2; &#125; static void write()&#123; f = new FinalFieldExample(); &#125; static void read()&#123; if(f != null)&#123; int i = f.x; // guaranteed to see 3 int j = f.y; // could see 0 &#125; &#125;&#125; 参考文献 [JMM refers] http://www.cs.umd.edu/~pugh/java/memoryModel/ [Reordering] https://mortoray.com/2010/11/18/cpu-reordering-what-is-actually-being-reordered/ [Fixing JMM] https://www.ibm.com/developerworks/library/j-jtp02244/index.html [Doug Lee] http://gee.cs.oswego.edu/dl/cpj/jmm.html?cm_mc_uid=64655373050114725223524&amp;cm_mc_sid_50200000=1494921172 https://www.ibm.com/developerworks/library/j-jtp03304/ https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html http://download.oracle.com/otndocs/jcp/memory_model-1.0-pfd-spec-oth-JSpec/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
        <tag>Java Memory Model</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zygote进程启动过程详解]]></title>
    <url>%2F2017%2F05%2F27%2FZygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[与Java程序类似，Android应用程序框架层(Application Framework)以及APP运行在一个Dalvik Virtual Machine之上，那么，Android启动时框架层是如何初始化的，从何处初始化的？为此，Android在启动时会首先初始化一个专门的系统进程zygote来负责启动与初始化Java代码，比如系统服务进程system_server的启动，系统启动时各种Java服务的初始化，APP资源文件的加载，APP进程的创建与启动。这篇文章，主要讲zygote进程的两个问题： zygote进程如何初始化的； APP进程是如何通过zygote创建的？ 本文基于Android NN7.0 zygote进程的初始化kernel初始化完成后，Android启动的第一个进程是init(pid = 0)，此后启动的进程都是init进程的子进程；init进程在启动时，会解析init.rc脚本中的语句，以此来启动某个进程或者执行某个动作。 脚本init.zygotexx.rc(xx是不同平台的字长，有32/64两种）负责启动系统服务zygote： 1234567891011service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks 这里： service表示该进程是一个系统服务进程； zygote是该进程的名字； /system/bin/app_process是进程代码所在的文件路径； -Xzygote /system/bin --zygote --start-system-server： 是进程启动参数，单杠-是符号参数 socket zygote stream 660 root system： 创建一个/dev/socket/zygote的socket，zygote会监听该socket，一旦有APP进程启动请求即fork一个进程; onrestart: 表示只要该service重启，就执行后面的动作。就是说，zygote服务重启的话，会重启audioserver,cameraserver等系统服务； writepid: 属于服务所需要执行的函数，zygote进程fork完成后，将其PID写入该参数对应的文件； init进程解析该脚本语句，通过Service.cpp中的函数start来启动zygote进程: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960bool Service::Start() &#123; if (flags_ &amp; SVC_RUNNING) &#123; return false; &#125; .... NOTICE("Starting service '%s'...\n", name_.c_str()); pid_t pid = fork(); // 进程创建成功 if (pid == 0) &#123; umask(077); // 创建socket for (const auto&amp; si : sockets_) &#123; int socket_type = ((si.type == "stream" ? SOCK_STREAM : (si.type == "dgram" ? SOCK_DGRAM : SOCK_SEQPACKET))); const char* socketcon = !si.socketcon.empty() ? si.socketcon.c_str() : scon.c_str(); int s = create_socket(si.name.c_str(), socket_type, si.perm, si.uid, si.gid, socketcon); if (s &gt;= 0) &#123; PublishSocket(si.name, s); &#125; &#125; // 保存PID到文件 std::string pid_str = StringPrintf("%d", getpid()); for (const auto&amp; file : writepid_files_) &#123; if (!WriteStringToFile(pid_str, file)) &#123; ERROR("couldn't write %s to %s: %s\n", pid_str.c_str(), file.c_str(), strerror(errno)); &#125; &#125; setpgid(0, getpid()); .... // 执行app_process二进制代码中的main函数 if (execve(strs[0], (char**) &amp;strs[0], (char**) ENV) &lt; 0) &#123; ERROR("cannot execve('%s'): %s\n", strs[0], strerror(errno)); &#125; _exit(127); &#125; if (pid &lt; 0) &#123; ERROR("failed to start '%s'\n", name_.c_str()); pid_ = 0; return false; &#125; time_started_ = gettime(); pid_ = pid; flags_ |= SVC_RUNNING; NotifyStateChange("running"); return true;&#125; 执行app_main.cpp中的main函数，其中的argv[]是一个{-Xzygote,/system/bin,--zygote,--start-system-server}的字符串指针数组； 解析参数后，通过AppRuntime加载ZygoteInit类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182int main(int argc, char* const argv[])&#123; // 运行时执行环境，加载JAVA代码 AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); // Process command line arguments； ignore argv[0] argc--; argv++; int i; for (i = 0; i &lt; argc; i++) &#123; if (argv[i][0] != '-') &#123; break; &#125; if (argv[i][1] == '-' &amp;&amp; argv[i][2] == 0) &#123; ++i; // Skip --. break; &#125; // 保存-Xzygote参数 runtime.addOption(strdup(argv[i])); &#125; // Parse runtime arguments. Stop at first unrecognized option. bool zygote = false; bool startSystemServer = false; bool application = false; String8 niceName; String8 className; ++i; // Skip unused "parent dir" argument. while (i &lt; argc) &#123; const char* arg = argv[i++]; if (strcmp(arg, "--zygote") == 0) &#123; zygote = true; niceName = ZYGOTE_NICE_NAME; &#125; else if (strcmp(arg, "--start-system-server") == 0) &#123; startSystemServer = true; .... &#125; else if (strcmp(arg, "--application") == 0) &#123; application = true; &#125; else if (strncmp(arg, "--nice-name=", 12) == 0) &#123; niceName.setTo(arg + 12); .... &#125; else &#123; --i; break; &#125; &#125; Vector&lt;String8&gt; args; if (!className.isEmpty()) &#123; runtime.setClassNameAndArgs(className, argc - i, argv + i); &#125; else &#123; // We're in zygote mode. if (startSystemServer) &#123; args.add(String8("start-system-server")); &#125; .... // In zygote mode, pass all remaining arguments to the zygote // main() method. for (; i &lt; argc; ++i) &#123; args.add(String8(argv[i])); &#125; &#125; //设置进程名称 if (!niceName.isEmpty()) &#123; runtime.setArgv0(niceName.string()); set_process_name(niceName.string()); &#125; // zygote模式，加载ZygoteInit类，这里的args为"start-system-server" if (zygote) &#123; runtime.start("com.android.internal.os.ZygoteInit", args, zygote); &#125; else if (className) &#123; runtime.start("com.android.internal.os.RuntimeInit", args, zygote); &#125; else &#123; fprintf(stderr, "Error: no class name or --zygote supplied.\n"); app_usage(); LOG_ALWAYS_FATAL("app_process: no class name or --zygote supplied."); return 10; &#125;&#125; 代码： /android/frameworks/base/cmds/app_process/app_main.cpp 由于AppRuntime继承了AndroidRuntime，调用AndroidRuntime.start():创建一个VM实例，并注册系统JNI，然后调用ZygoteInit的main方法， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; .... /* start the virtual machine */ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; // 创建一个VM实例 if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123; return; &#125; onVmCreated(env); /* * Register android functions. */ if (startReg(env) &lt; 0) &#123; ALOGE("Unable to register all android natives\n"); return; &#125; jclass stringClass; jobjectArray strArray; jstring classNameStr; stringClass = env-&gt;FindClass("java/lang/String"); assert(stringClass != NULL); strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL); assert(strArray != NULL); classNameStr = env-&gt;NewStringUTF(className); assert(classNameStr != NULL); env-&gt;SetObjectArrayElement(strArray, 0, classNameStr); for (size_t i = 0; i &lt; options.size(); ++i) &#123; jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string()); assert(optionsStr != NULL); env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr); &#125; /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ char* slashClassName = toSlashClassName(className); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE("JavaVM unable to locate class '%s'\n", slashClassName); &#125; else &#123; // 获取main函数ID jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, "main", "([Ljava/lang/String;)V"); if (startMeth == NULL) &#123; ALOGE("JavaVM unable to find main() in '%s'\n", className); /* keep going */ &#125; else &#123; // 调用main函数 env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); &#125; &#125; free(slashClassName); ALOGD("Shutting down VM\n"); if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK) ALOGW("Warning: unable to detach main thread\n"); if (mJavaVM-&gt;DestroyJavaVM() != 0) ALOGW("Warning: VM did not shut down cleanly\n");&#125; 调用ZygoteInit.main, 监听来自客户端的请求；在子进程中，runSelectLoop会抛出一个MethodAndArgsCaller异常，该异常被捕获后，会去调用应用的入口方法ActivityThread.main。 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String argv[]) &#123; /* set default handler; this applies to all threads in the VM */ RuntimeInit.__init__UncaughtHandler(); try &#123; //启动Android调试工具DDMS(Dalvik Debug Monitor Server) RuntimeInit.enableDdms(); boolean startSystemServer = false; String socketName = "zygote"; String abiList = null; for (int i = 1; i &lt; argv.length; i++) &#123; if ("start-system-server".equals(argv[i])) &#123; startSystemServer = true; primaryZygoteThreadRunning=true; &#125; .... &#125; Log.i(TAG, "!@Zygote : primaryZygoteThreadRunning = " + primaryZygoteThreadRunning + " ZygoteAgentRunning = " + zygoteAgentRunning); // 注册一个/dev/sockete/zyogote的socket，将其与一个FileDescriptor进行绑定 registerZygoteSocket(socketName); // 预加载资源、共享库 preload(); // 启动system_server进程 if (startSystemServer) &#123; startSystemServer(abiList, socketName); &#125; // 不断监听socket接口连接请求，子进程创建完成后，会抛出MethodAndArgsCaller异常 runSelectLoop(abiList); // 如果进程退出，需要关闭zygote的socket closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); &#125; catch (Throwable ex) &#123; Log.e(TAG, "Zygote died with exception", ex); closeServerSocket(); throw ex; &#125;&#125; runSelectLoop不断监听来自客户端的请求，如果有，则创建一个ZygoteConnection用于处理来自客户端的请求，负责解析应用启动的参数，调用fork启动一个新的进程，然后加载应用代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123; ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); fds.add(sServerSocket.getFileDescriptor()); peers.add(null); while (true) &#123; StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i &lt; pollFds.length; ++i) &#123; pollFds[i] = new StructPollfd(); pollFds[i].fd = fds.get(i); pollFds[i].events = (short) POLLIN; &#125; // 监听socket端口,如果有请求则返回 try &#123; Os.poll(pollFds, -1); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException("poll failed", ex); &#125; // 初始状态，pollFds只有一个服务端socket对应的fd for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (i == 0) &#123; // acceptCommandPeer阻塞调用，直到有来自客户端的请求 ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); &#125; else &#123; // 第一个元素为空，其他的都是来自客户端的请求 boolean done = peers.get(i).runOnce(); if (done) &#123; peers.remove(i); fds.remove(i); &#125; &#125; &#125; &#125; &#125;// acceptCommandPeer返回一个请求对应的ZygoteConnection用于读取socket中的数据private static ZygoteConnection acceptCommandPeer(String abiList) &#123; try &#123; return new ZygoteConnection(sServerSocket.accept(), abiList); &#125; catch (IOException ex) &#123; throw new RuntimeException( "IOException during accept()", ex); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; String args[]; Arguments parsedArgs = null; FileDescriptor[] descriptors; try &#123; args = readArgumentList(); descriptors = mSocket.getAncillaryFileDescriptors(); &#125; catch (IOException ex) &#123; Log.w(TAG, "IOException on command socket " + ex.getMessage()); closeSocket(); return true; &#125; if (args == null) &#123; // EOF reached. closeSocket(); return true; &#125; .... /** * In order to avoid leaking descriptors to the Zygote child, * the native code must close the two Zygote socket descriptors * in the child process before it switches from Zygote-root to * the UID and privileges of the application being launched. * * In order to avoid "bad file descriptor" errors when the * two LocalSocket objects are closed, the Posix file * descriptors are released via a dup2() call which closes * the socket and substitutes an open descriptor to /dev/null. */ int [] fdsToClose = &#123; -1, -1 &#125;; FileDescriptor fd = mSocket.getFileDescriptor(); if (fd != null) &#123; fdsToClose[0] = fd.getInt$(); &#125; fd = ZygoteInit.getServerSocketFileDescriptor(); if (fd != null) &#123; fdsToClose[1] = fd.getInt$(); &#125; fd = null; // 调用本地方法fork一个新的进程 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.category, parsedArgs.accessInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir, parsedArgs.mountKnoxPoint); &#125; catch (ErrnoException ex) &#123; logAndPrintError(newStderr, "Exception creating pipe", ex); &#125; catch (IllegalArgumentException ex) &#123; logAndPrintError(newStderr, "Invalid zygote arguments", ex); &#125; catch (ZygoteSecurityException ex) &#123; logAndPrintError(newStderr, "Zygote security policy prevents request: ", ex); &#125; try &#123; if (pid == 0) &#123; // in child IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; // 在子进程中，会加载应用代码 handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); // should never get here, the child is expected to either // throw ZygoteInit.MethodAndArgsCaller or exec(). return true; &#125; else &#123; // in parent...pid of &lt; 0 means failure IoUtils.closeQuietly(childPipeFd); childPipeFd = null; return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs); &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125;&#125; 至此Zygote进程就启动完成了。接下来我们就来看一看，有APP启动时，zygote进程如何创建新的应用进程的？ zygote创建新的应用进程在Activity启动过程中，如果当前应用尚未启动过，进程不存在，AMS(Activity Manager Service)会为应用启动一个新的进程： 123456789101112131415161718192021222324252627282930313233private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123; .... try &#123; final int userId = UserHandle.getUserId(app.uid); .... // Start the process. It will either succeed and return a result containing // the PID of the new process, or else throw a RuntimeException. Process.ProcessStartResult startResult = null; if(userid&gt;0 &amp;&amp; (bbcId&gt;0 &amp;&amp; userid == bbcId) &amp;&amp; app.info.bbcseinfo!=null)&#123; startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.bbcseinfo, app.info.bbccategory, app.info.accessInfo, requiredAbi, instructionSet, app.info.dataDir, mountKnoxPoint, entryPointArgs); &#125;else &#123; startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, aasaSeInfo != null ? new String(aasaSeInfo) : app.info.seinfo, //AASA--4 : changed orginal : only "app.info.seinfo" app.info.category, app.info.accessInfo, requiredAbi, instructionSet, app.info.dataDir, mountKnoxPoint, entryPointArgs); &#125; &#125; catch(RemoteException re)&#123; // &#125;&#125; 调用Process.start()启动一个新的进程： 1234567891011121314151617181920212223242526public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, int category, int accessInfo, String abi, String instructionSet, String appDataDir, boolean mountKnoxPoint, String[] zygoteArgs) &#123; try &#123; return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, category, accessInfo, abi, instructionSet, appDataDir, mountKnoxPoint, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; Log.e(LOG_TAG, "Starting VM process through Zygote failed"); throw new RuntimeException( "Starting VM process through Zygote failed", ex); &#125;&#125; 通过zygote创建一个新的进程： 1234567891011121314151617181920212223242526272829303132333435363738394041private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, int category, int accessInfo, String abi, String instructionSet, String appDataDir, boolean mountKnoxPoint, String[] extraArgs) throws ZygoteStartFailedEx &#123; synchronized(Process.class) &#123; ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;(); // 添加启动参数 argsForZygote.add("--runtime-args"); argsForZygote.add("--setuid=" + uid); argsForZygote.add("--setgid=" + gid); .... // 进程名 if (niceName != null) &#123; argsForZygote.add("--nice-name=" + niceName); &#125; .... argsForZygote.add(processClass); if (extraArgs != null) &#123; for (String arg : extraArgs) &#123; argsForZygote.add(arg); &#125; &#125; // openZygoteSocketIfNeeded 连接socket return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); &#125; &#125; 将启动进程所需的参数通过/dev/socket/zygote发送给zygote进程,并将创建的PID返回： 123456789101112131415161718192021222324252627282930313233343536373839404142434445private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; try &#123; /** * See com.android.internal.os.ZygoteInit.readArgumentList() * Presently the wire format to the zygote process is: * a) a count of arguments (argc, in essence) * b) a number of newline-separated argument strings equal to count */ final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; writer.write(Integer.toString(args.size())); writer.newLine(); for (int i = 0; i &lt; sz; i++) &#123; String arg = args.get(i); writer.write(arg); writer.newLine(); &#125; // 写入socket writer.flush(); // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); // Always read the entire result from the input stream to avoid leaving // bytes in the stream for future process starts to accidentally stumble // upon. result.pid = inputStream.readInt(); result.usingWrapper = inputStream.readBoolean(); if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx("fork() failed"); &#125; return result; &#125; catch (IOException ex) &#123; zygoteState.close(); throw new ZygoteStartFailedEx(ex); &#125;&#125; 在之前分析zygote启动时，我们了解到，每当有进程创建请求时，都会通过runSelectLoop函数创建一个ZygoteConnection； ZygoteConnecton中的runOnce()函数负责将进程启动的参数写入到socket，并着手创建新的进程，创建完成后将子进程PID写回到socket： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; String args[]; Arguments parsedArgs = null; FileDescriptor[] descriptors; try &#123; // 从Socket中读取数据 args = readArgumentList(); descriptors = mSocket.getAncillaryFileDescriptors(); &#125; catch (IOException ex) &#123; closeSocket(); return true; &#125; .... int pid = -1; FileDescriptor childPipeFd = null; FileDescriptor serverPipeFd = null; try &#123; parsedArgs = new Arguments(args); if (parsedArgs.abiListQuery) &#123; return handleAbiListQuery(); &#125; .... /** * In order to avoid leaking descriptors to the Zygote child, * the native code must close the two Zygote socket descriptors * in the child process before it switches from Zygote-root to * the UID and privileges of the application being launched. * * In order to avoid "bad file descriptor" errors when the * two LocalSocket objects are closed, the Posix file * descriptors are released via a dup2() call which closes * the socket and substitutes an open descriptor to /dev/null. */ int [] fdsToClose = &#123; -1, -1 &#125;; FileDescriptor fd = mSocket.getFileDescriptor(); if (fd != null) &#123; fdsToClose[0] = fd.getInt$(); &#125; fd = ZygoteInit.getServerSocketFileDescriptor(); if (fd != null) &#123; fdsToClose[1] = fd.getInt$(); &#125; fd = null; // 创建进程，并返回 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.category, parsedArgs.accessInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir, parsedArgs.mountKnoxPoint); &#125; catch (ErrnoException ex) &#123; logAndPrintError(newStderr, "Exception creating pipe", ex); &#125; catch (IllegalArgumentException ex) &#123; logAndPrintError(newStderr, "Invalid zygote arguments", ex); &#125; catch (ZygoteSecurityException ex) &#123; logAndPrintError(newStderr, "Zygote security policy prevents request: ", ex); &#125; try &#123; if (pid == 0) &#123; // 子进程继承了zygote进程的FD，需要关闭 IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; // 继续子进程启动后的一些准备工作 handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); // should never get here, the child is expected to either // throw ZygoteInit.MethodAndArgsCaller or exec(). return true; &#125; else &#123; // in parent...pid of &lt; 0 means failure IoUtils.closeQuietly(childPipeFd); childPipeFd = null; // 将子进程PID写入socket return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs); &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125;&#125; 调用zygote.forkAndSpecialize创建进程： 123456789101112131415161718public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags, int[][] rlimits, int mountExternal, String seInfo, int category, int accessInfo, String niceName, int[] fdsToClose,String instructionSet, String appDataDir, int mountKnoxPoint) &#123; VM_HOOKS.preFork(); // 调用native方法创建进程 int pid = nativeForkAndSpecialize( uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, category, accessInfo, niceName, fdsToClose, instructionSet, appDataDir, mountKnoxPoint); // Enable tracing as soon as possible for the child process. if (pid == 0) &#123; Trace.setTracingEnabled(true); // Note that this event ends at the end of handleChildProc, Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "PostFork"); &#125; VM_HOOKS.postForkCommon(); return pid;&#125; 找到forkAndSpecialize对应的native方法,实际是创建一个Linux进程，子进程与父进程拥有共同的内存空间，至此一个应用的进程就创建完成了。但此时应用本身的代码还没有加载。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids, jint debug_flags, jobjectArray javaRlimits, jlong permittedCapabilities, jlong effectiveCapabilities, jint mount_external, jstring java_se_info, jint category, jint accessInfo, jstring java_se_name, bool is_system_server, jintArray fdsToClose, jstring instructionSet, jstring dataDir, jint mountKnoxPoint) &#123; SetSigChldHandler(); .... sigset_t sigchld; sigemptyset(&amp;sigchld); sigaddset(&amp;sigchld, SIGCHLD); .... // 创建进程 pid_t pid = fork(); if (pid == 0) &#123; // The child process. gMallocLeakZygoteChild = 1; // Clean up any descriptors which must be closed immediately DetachDescriptors(env, fdsToClose); .... if (!is_system_server) &#123; int rc = createProcessGroup(uid, getpid()); if (rc != 0) &#123; if (rc == -EROFS) &#123; ALOGW("createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?"); &#125; else &#123; ALOGE("createProcessGroup(%d, %d) failed: %s", uid, pid, strerror(-rc)); &#125; &#125; &#125; .... // VM post fork for child process env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags, is_system_server, instructionSet); if (env-&gt;ExceptionCheck()) &#123; RuntimeAbort(env, __LINE__, "Error calling post fork hooks."); &#125; &#125; else if (pid &gt; 0) &#123; // the parent process .... &#125; return pid;&#125; Android中的native方法所在文件命名是由Java包名基础上加上Java文件名组成，例如nativeForkAndSpecialize所在类zygote.java对应的包名为com.android.internal.os,那么其该native方法对应的文件为com_android_internal_os_zygote.cpp 最后在新的子进程中，需要对APP进程的执行环境进行初始化，调用RuntimeInit.zygoteInit对APP进行初始化： 123456789101112131415161718192021private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller &#123; .... if (parsedArgs.niceName != null) &#123; Process.setArgV0(parsedArgs.niceName); &#125; // End of the postFork event. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); if (parsedArgs.invokeWith != null) &#123; WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), pipeFd, parsedArgs.remainingArgs); &#125; else &#123; //初始化运行时执行环境, 这里的remainingArgs实际是每个APP的入口`android.app.ActivityThread` RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); &#125;&#125; zygoteInit主要负责如下几件事情： 通用初始化commonInit(): 设置未捕获异常的处理函数；设置默认时区; VM本地初始化nativeZygoteInit()； 应用初始化applicationInit(): 这里正是APP代码加载的地方; 123456789101112public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, "RuntimeInit: Starting application from zygote"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "RuntimeInit"); redirectLogStreams(); commonInit(); nativeZygoteInit(); applicationInit(targetSdkVersion, argv, classLoader);&#125; 方法applicationInit在设置完堆内存的使用率（可能引发GC）和应用目标SDK后；通过invokeStaticMain抛出一个MethodAndArgsCaller异常的方式调用ActivityThread.main，这样这个应用就算加载完成了。这篇文章旨在梳理zygote进程的一些逻辑，有关某个具体应用的加载流程请参考:Android Phone进程启动过程分析。 12345678910111213141516171819202122232425262728293031private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; // If the application calls System.exit(), terminate the process // immediately without running any shutdown hooks. It is not possible to // shutdown an Android application gracefully. Among other things, the // Android runtime shutdown hooks close the Binder driver, which can cause // leftover running threads to crash before the process actually exits. nativeSetExitWithoutCleanup(true); // We want to be fairly aggressive about heap utilization, to avoid // holding on to a lot of memory that isn't needed. VMRuntime.getRuntime().setTargetHeapUtilization(0.75f); VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); final Arguments args; try &#123; args = new Arguments(argv); &#125; catch (IllegalArgumentException ex) &#123; Slog.e(TAG, ex.getMessage()); // let the process exit return; &#125; // The end of of the RuntimeInit event (see #zygoteInit). Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); // Remaining arguments are passed to the start class's static main invokeStaticMain(args.startClass, args.startArgs, classLoader);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Zygote</tag>
        <tag>Android应用启动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程综述]]></title>
    <url>%2F2017%2F05%2F24%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%BB%BC%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[在计算机诞生初期，由于其高昂的计算成本，只能允许一个用户运行一个任务或者一批任务（Batch processing)。随着技术的发展，人们开始思考一个问题，如何在计算机上实现多个任务“同时”运行？一开始，采用的是分时策略（Time sharing），就是允许多个用户共享一台计算机，但每个用户占用计算机的一个时间片，在这个时间后，由另一个用户接着运行使用。分时系统在一定程度上提高了计算效率，实现了资源的共享。但其实际上并没有真正实现任务的“同时”（并发,concurrency）运行。 现代并发编程(Concurrent Pragramming)概念的出现一方面是受到操作系统中如进程、中断以及抢占的影响；一方面由于计算机硬件技术的发展而出现的多核处理器。 进程，是程序执行的一个实体，是操作系统对CPU，寄存器，堆栈，内存，文件系统等计算资源的一种执行时的抽象；有了进程，计算机就可以通过调度系统来实现多个任务“同时”运行了，这里所谓的“同时”并不是多个程序真的在一个CPU中同时运行，而是说调度程序快速的在多个进程之间切换，交替执行不同程序，从而更有效的利用了计算机资源； 多核CPU的出现，为并发、并行计算提供了另一种可能。以前程序只能在一个CPU上运行，现在单个程序可以同时在多个CPU上同时运行了（Parallel Computing）；或者多个进程同时在多个CPU上运行。 进程虽然提高了计算机系统的利用效率，实现了多个任务的并发执行，但是由于进程上下文切换Context Switch需要耗费CPU时间，频繁的进程切换势必导致计算机性能的下降。还有一个问题是，单个进程的程序在进行I/O操作时会阻塞，这样一方面会导致程序无响应，一方面也会浪费宝贵的CPU资源。于是，人们提出了线程(Thread)。一个进程中的线程共享进程的内存空间、全局变量、文件等资源，但会有独立的程序计数器(Program Counter),寄存器，栈空间（调用参数，本地变量等）以及线程状态。相比较而言，由于资源共享，线程创建比进程创建要快很多，上下文切换的时间更短，因而常被称为轻量级进程(Light-weight Process,LWP)。 那么，多线程并发到底有哪些好处？ 充分利用处理器资源： 多线程可以让程序的线程同时在多个CPU上同时执行，这样能充分利用CPU，提高系统的性能，让程序本身运行更快； 更好的程序响应能力:程序在由I/O事件时，无需等待，可以让一个线程等待I/O，另一个线程处理其他事情，从而提供程序运行的效率； 更好的用户体验: 对有UI的程序来说，在多线程执行情况下，可以让一个线程来专门处理与UI的交互，其他线程则处理后台任务，这样既保证了良好的UI响应，也能保证程序的正常运行。 多线程并发执行虽然好处多多，但是在线程模型下，由于有资源的共享，多个线程同时操作共享数据/内存时，会出现数据一致性问题，导致程序运行出错。因此引来了一个难以忽视的线程安全问题：数据竞争(data race)与死锁(dead lock)。如果两个线程之间并没有共享数据（或者共享数据是不可变的，immutable)，那么根本就不用考虑同步问题，因为线程之间执行时独立的，互不干涉。一旦有了共享数据，如果其中有一个线程修改，而其他线程需要读取该数据，则两个线程同时操作的情况下，可能出现竞争条件(race condition )或者变质(stale)数据。另一个可能的问题就是死锁。比如一个线程A试图获取某个资源X，而该资源被线程B持有，因此A需要等待B释放资源X；线程B需要获取某个资源Y，但是该资源被A所持有，B需要等待A释放资源Y，这样就可能出现死锁(Dead Lock)。另一方面，线程同步需要额外的计算来实现加锁与释放锁，在一定程度上降低了程序运行的效率,而频繁的上下文切换也会带来性能的损耗。为了减少线程上下文切换，人们又提出了协程,coroutine。 存在数据/内存共享的代码区域, 通常被称为临界区(critical section), 为了避免上述可能存在的数据竞争与死锁问题的出现，需要确保线程的访问是原子(atomic)的, 不可中断的, 这种确保临界区数据的序列化访问方式即我们常说的同步(synchronization).Java在语言层面实现了同步机制。这些同步机制主要考虑两个关键问题： 共享数据的互斥访问(mutual exclusion)：对于共享数据，任何时刻都只有一个线程在操作（竞争）; 共享数据的可见性（visibility):一个线程修改数据后对其他线程可见（协作）； 在接下来的几篇文章里，我将围绕上述两个为题重点介绍Java并发编程的基本概念以及具体的实现机制,争取在这几篇文章里把Java并发编程的基本概念与核心要点都讲明白： Java并发编程之线程类的实现 Java并发编程之同步 ； Java并发编程之Java Memory Model ; Java并发编程之原子操作 ； Java并发编程之锁 ； 对于并发编程，本人也处于学习总结阶段，有不正确的地方，欢迎指正。 参考文献 http://www.oberon2005.oberoncore.ru/paper/bh2002.pdf http://www.enseignement.polytechnique.fr/informatique/INF431/X09-2010-2011/AmphiTHC/SynchronizationPrimitives.pdf]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide详解之架构分析]]></title>
    <url>%2F2017%2F05%2F20%2FGlide%E8%AF%A6%E8%A7%A3%E4%B9%8B%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Glide是BumpTech开发的一个同时可支持图片、GIF以及视频加载的Android开源库，同时Glide支持任何用户自定义的网络栈，其主要有以下几个特点： 支持GIF格式动画的解码； 支持本地视频加载解码； 加载大图之前，可预先加载一个小图片 自动管理资源加载请求的生命周期； 给定图片尺寸，可以对资源进行自由转换 Github：https://github.com/bumptech/glide 这里就来分析下Glide的具体架构以及介绍其主要特点，分如下几个方面： Glide代码架构及工作原理； Glide如何自动管理资源加载请求的生命周期的？ Glide是如何进行图片的加载与转换的？ 架构及工作原理先来看一下Glide的代码结构，这里主要看下几个核心的包： com.bumptech.glide： 主要负责Glide的初始化，参数配置，Request的创建； com.bumptech.glide.load： 主要负责资源的加载，解码与格式转换； com.bumptech.glide.manager： 负责Glide请求生命周期的自动管理； com.bumptech.glide.module： 用于加载解析用户自定义的网络模块； com.bumptech.glide.provider： 管理Glide中图片、GIF等资源的加载与转换器； com.bumptech.glide.request ： 资源加载请求相关以及动画； com.bumptech.glide.util ： 常用工具类； 下图是Glide的原理简图。可以看到，Glide大致可以分为五个部分： Glide： 初始化系统，负责管理系统其他模块如数据加载器、网络栈等初始化管理； RequestManager: 创建、初始化以及管理系统所有的Request； Engine: 将资源加载请求放入执行线程池，加载完后返回给主线程； ExecutorService: 线程池执行服务，负责分发调度EngineRunnable可执行对象； DataFetcher: 从磁盘或者网络端加载数据 关于Glide资源加载的详细过程请参考我的另一篇文章：Glide图片加载过程分析 接下来就来看一看，Glide的两个特征：请求生命周期的自动化管理以及系统的泛型化。 如何自动进行生命周期管理Glide从3.0开始支持Request生命周期的自动管理，即随着Activity或者Fragment的生命周期自动启动、恢复或者停止Request。Glide提供了两种生命周期管理策略：ApplicationLifecycle和ActivityFragmentLifecycle，前者确保Request的生命周期与APP的Application的生命周期保持一致；而后者则使Request的生命周期与Activity或者Fragment保持一致。 那么，ActivityFragmentLifecycle是如何实现的？ 123456789101112131415161718192021222324252627282930313233343536373839class ActivityFragmentLifecycle implements Lifecycle &#123; @Override public void addListener(LifecycleListener listener) &#123; lifecycleListeners.add(listener); if (isDestroyed) &#123; listener.onDestroy(); &#125; else if (isStarted) &#123; listener.onStart(); &#125; else &#123; listener.onStop(); &#125; &#125; &#125; void onStart() &#123; isStarted = true; for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123; lifecycleListener.onStart(); &#125; &#125; void onStop() &#123; isStarted = false; for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123; lifecycleListener.onStop(); &#125; &#125; void onDestroy() &#123; isDestroyed = true; for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123; lifecycleListener.onDestroy(); &#125; &#125;&#125; 在初始化RequestManager时，会根据传入的Context来构造RequestManager(这里假定这里是一个FragmentActivity)： 12345678910111213141516public RequestManager get(Context context) &#123; if (context == null) &#123; throw new IllegalArgumentException("You cannot start a load on a null Context"); &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123; if (context instanceof FragmentActivity) &#123; return get((FragmentActivity) context); &#125; else if (context instanceof Activity) &#123; return get((Activity) context); &#125; else if (context instanceof ContextWrapper) &#123; return get(((ContextWrapper) context).getBaseContext()); &#125; &#125; // 返回一个与`ApplicationLifeCycle`对应的RequestManager return getApplicationManager(context);&#125; 生成一个无UI的SupportRequestManagerFragment，并将其中的ActivityFragmentLifecycle作为构造函数的参数传递给RequestManager: 123456789101112131415161718192021public RequestManager get(FragmentActivity activity) &#123; if (Util.isOnBackgroundThread()) &#123; return get(activity.getApplicationContext()); &#125; else &#123; assertNotDestroyed(activity); FragmentManager fm = activity.getSupportFragmentManager(); return supportFragmentGet(activity, fm); &#125;&#125;// SupportRequestManagerFragment是一个无UI的Fragment,用于控制Request的生命周期RequestManager supportFragmentGet(Context context, FragmentManager fm) &#123; SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm); RequestManager requestManager = current.getRequestManager(); if (requestManager == null) &#123; requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode()); current.setRequestManager(requestManager); &#125; return requestManager;&#125; 在RequestManager构造时，会将RequestManager作为上述Fragment生命周期的监听者，从而使得RequsetManager中的Request生命周期始终与Fragment保持一致： 12345678910111213141516171819202122232425262728RequestManager(Context context, final Lifecycle lifecycle, RequestManagerTreeNode treeNode, RequestTracker requestTracker, ConnectivityMonitorFactory factory) &#123; this.context = context.getApplicationContext(); this.lifecycle = lifecycle; this.treeNode = treeNode; this.requestTracker = requestTracker; this.glide = Glide.get(context); this.optionsApplier = new OptionsApplier(); ConnectivityMonitor connectivityMonitor = factory.build(context, new RequestManagerConnectivityListener(requestTracker)); // If we're the application level request manager, we may be created on a background thread. In that case we // cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding // ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe. if (Util.isOnBackgroundThread()) &#123; new Handler(Looper.getMainLooper()).post(new Runnable() &#123; @Override public void run() &#123; lifecycle.addListener(RequestManager.this); &#125; &#125;); &#125; else &#123; lifecycle.addListener(this); &#125; lifecycle.addListener(connectivityMonitor);&#125; 这样，不难看出这样一个生命周期事件的通知链： 12SupportRequestManagerFragment --&gt; ActivityFragmentLifecycle --&gt; RequestMananger 系统的泛型化Glide在设计上尽可能保持抽象与泛型化，从最大程度上保持了系统的可扩展性与可维护性。这些泛型化主要体现在如下几个方面： 用户加载资源的来源可能是一个包含了URI路径的字符串，可能是一个文件，可能是一个URL，因此需要对资源加载的类型泛型化成一个类ModelLoader&lt;T,Y&gt;（称之为ModelType); 资源的数据类型可能是InputStream,也可以是字节流数组byte[],还可以是一个文件File，因此需要对数据类型进行泛型化成一个类DataFetcher&lt;Y&gt;(称之为DataType); 加载完的资源类型可能是一个drawable，也可能是一个gif文件；可能是一个bitmap,也可能是一个byte[]字节数组，同样将其泛型化成一个类Resource&lt;Z&gt;(称之为ResourceType,实际上是对加载完后的资源的一个包装类型）； 不同资源类型可能需要进行转换，比如讲bitmap转换成字节数组byte[];将drawable变换成bitmap，因此可以将这种转换的关系泛化成一个类ResourceTranscoder&lt;Z,R&gt;（TranscodeType); 接下来就来看下这几个泛型类的实现。 ModelLoaderModelLoader的功能是将资源加载到一个具体的数据类型，比如InputStream中,实际是利用DataFetcher来实现资源的加载。Glide提供了多种类型的ModelLoader将不同资源的文件加载到一个InputStream中去： HttpUrlGlideUrlLoader：将一个GlideUrl加载后到一个Inpustream中； StreamByteArrayLoader： 将一个字节流加载到一个InputStream; StreamFileLoader： 将文件加载到一个InputStream; StreamUrlLoader： 将一个URL资源加载到InputStream; StreamResourceLoader：讲一个Android资源文件加载到InputStream； DataFetcherDataFetcher用于从文件或者网络上加载资源，将其变成一个特定的数据类型： HttpUrlFetcher: 获取一个URL资源的InputStream; ByteArrayFetcher: 将一个字节流数据变成InputStream输入流； StreamLocalUriFetcher： 获取本地URI资源的InputStream; 12345public final class GenericRequest&lt;A, T, Z, R&gt; implements Request, SizeReadyCallback, ResourceCallback &#123; ....&#125; ResourceTranscoder将一种资源类型Resource&lt;Z&gt;转换成另一种类型Resource&lt;R&gt;，比如Bitmap转换成Drawable： BitmapBytesTranscoder: 将bitmap转码成一个字节数组； BitmapToGlideDrawableTranscoder： 将一个bitmap转码成一个GlideDrawable; GifDrawableBytesTranscoder: 将GIF文件转码成字节数组； 有关Glide加载图片的过程以及泛型参数的擦除请参考另一篇文章Glide图片加载过程分析 。 Glide源码地址 Glide源码地址：https://github.com/bumptech/glide]]></content>
      <categories>
        <category>Open Source</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Glide</tag>
        <tag>Image Loading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程之同步]]></title>
    <url>%2F2017%2F05%2F17%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[在单一线程执行的情况下，并不用考虑任何数据一致性与同步等问题，但到了多个线程执行的情况下，共享数据的同步就显得至关重要了。比如有一个银行账户的操作问题(例子来自Wikipedia),现在有两个线程A与B共享一个账户变量balance,这个提款的操作有两个部分，首先需要判定提款数目是否小于当前账户存款，记为s1;如果该条件满足，则从账户中提取资金，记为s2。假定开始时账户balance=600，现在A调用withdraw(200),B调用withdraw(500)，如果两个线程A与B调用时，s1都发生在s2之前，则两个线程都可以进入判定条件，提取相应的资金，而实际的存款是小于两个线程需要提取的资金的。 123456789101112bool withdraw(int withdrawal)&#123; if (balance &gt;= withdrawal) // --&gt; s1 &#123; balance -= withdrawal; // --&gt; s2 return true; &#125; return false;&#125; 这种线程之间共享资源的一致性同步问题在并发编程中十分常见，通常被称为Data Race。根据官网上的定义(what is data race)，Data Race出现是由以下原因导致： 多个线程同时访问共享内存； 至少有一个线程写该共享内存区域； 线程访问共享内存并没有利用锁进行同步； 除了上述Data Race之外，多个线程之间并发执行的情况下，若不正确进行同步还可能出现： 竞争条件(race conditions): 多个线程同时修改一个共享数据，从而导致数据不一致（Data Race就是一种） 死锁(dead lock): 多个线程之间相互等待某个或者多个线程释放某个资源，从而导致死循环（参考： Deadlock） 饿死(Starvation): 某个线程获取某个资源时总是被阻塞（资源被其他线程占有，未被释放），而无法获得CPU 那么，Java是如何来解决上述并发编程中出现的问题？Java主要有两种方法来避免上述问题： 线程之间的同步（使用synchronized或者lock) Java内存模型(Java Memory Model)中的执行偏序关系,确保某些特定的代码依照特定的顺序执行，从而确保数据的可见性 这篇文章里，主要来看一看线程之间的同步(synchronized)。Java中内置了一个同步关键字synchronized，synchronized实际上是通过monitor)(监视器）来实现的。在Java中，每个对象跟一个monitor关联在一起，线程通过获取monitor锁互斥访问某个资源；通过释放monitor上的锁释放占用的资源。因此，Java中任何一个对象都可以成为一个锁来实现同步。在锁住或者解锁monitor时，有如下约定： 任何时刻只有一个线程占有一个monitor的一个锁，此时其他尝试获取该monitor锁的其他线程都会被阻塞直到获取锁成功为止； 一个线程可多次获取某个monitor的锁；需要同样次数的解锁，线程才算完全释放monitor锁； 总的说来，monitor提供了两种同步功能： Mutual Exclusion: 互斥访问，确保多个线程访问共享资源时不会造成冲突，任何时刻只有一个线程占用资源； Cooperation: 合作，让多个线程协同工作完成某个特定的任务。资源不可用，线程进入睡眠等待队列；资源可用时，会从等待队列中唤醒队列中的某个线程执行； Mutual Exclusion互斥访问是通过synchronized来实现的。synchronized在Java中有两种使用方式：一种是在某个代码块前使用，一个是在放在方法名前面使用。例如，上述银行提款的示例,在代码提款的代码块中加上同步（以下简称块同步）： 1234567891011121314bool withdraw(int withdrawal)&#123; synchronized(this)&#123; if (balance &gt;= withdrawal) // --&gt; s1 &#123; balance -= withdrawal; // --&gt; s2 return true; &#125; &#125; return false;&#125; 对整个方法进行同步（以下简称方法同步）： 1234567891011bool synchronized withdraw(int withdrawal)&#123; if (balance &gt;= withdrawal) // --&gt; s1 &#123; balance -= withdrawal; // --&gt; s2 return true; &#125; return false;&#125; 从效果上来说，两种方法都能达到避免balance出现竞争的目的。但块同步锁住的是其表达式内的对象monitor；而方法同步则锁住的是该方法所属类上的monitor，这里有两种情况： 非静态方法，锁住当前类实例this对应的monitor; static静态方法，锁住类的Class对象的monitor; 当块代码或者方法执行完毕之后，锁会被自动释放。除了语言本身提供的同步之外，Java还提供了volatile用于确保变量读写的可见性；java.util.concurrent中针对不同的应用需求，提供了诸如ReentrantLock,ReadWriteLock,Condition等同步方法，接下来的一篇文章会详细介绍这些类的原理与使用。 Cooperation线程在访问共享变量时需要确保互斥访问，而在诸如将计算任务细分成多个子任务的多线程运行的情况下，就需要考虑线程之间的协作（Cooperation），就是说，某个线程执行完某个动作后，怎么让另一个线程知道该完成事件了？ 在Java中，每个对象（Object)除了有自己的monitor之外，还有一个关联的wait set(等待集),就是一个线程的集合，表示当前有多少个线程在该对象上等待某个事件的发生。一个对象初次创建时，wait set是空的，当有线程调用Object.wait()时，就将该线程加入到该wait set中，而当其他线程调用Object.notify()或者Object.notifyAll()时，该线程从wait set中释放。 Object提供了三种wait方法： 不超时：wait() 超时等待： wait(long millisecs)； 超时等待：wait(long millisecs, int naos)，更精确的等待时间； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Object &#123; private static native void registerNatives(); static &#123; registerNatives(); &#125; public final native Class&lt;?&gt; getClass(); public native int hashCode(); public boolean equals(Object obj) &#123; return (this == obj); &#125; protected native Object clone() throws CloneNotSupportedException; public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125; /** * Wakes up a single thread that is waiting on this object's * monitor. If any threads are waiting on this object, one of them * is chosen to be awakened. The choice is arbitrary and occurs at * the discretion of the implementation. A thread waits on an object's * monitor by calling one of the &#123;@code wait&#125; methods. */ public final native void notify(); public final native void notifyAll(); /** * Causes the current thread to wait until either another thread invokes the * &#123;@link java.lang.Object#notify()&#125; method or the * &#123;@link java.lang.Object#notifyAll()&#125; method for this object, or a * specified amount of time has elapsed. */ public final native void wait(long timeout) throws InterruptedException; public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; timeout == 0)) &#123; timeout++; &#125; wait(timeout); &#125; public final void wait() throws InterruptedException &#123; wait(0); &#125; /** * Called by the garbage collector on an object when garbage collection * determines that there are no more references to the object. * / protected void finalize() throws Throwable &#123; &#125;&#125; wait一个线程调用Object.wait时可能有如下几种情况出现： 首先线程需要获取对象Object的锁；如果获取到锁，则会抛出IllegalMonitorStateException异常； 如果是超时等待，且参数nanos的大小不在[0-999999]之间的话或者timeout小于0，则抛出IllegalArgumentException; 线程被中断，抛出中断异常InterruptException,中断状态置为false; 接着，线程加入到对象的wait set,并释放对象锁； 此后线程处于等待状态直到从对象的wait set移除之后，以下动作会导致线程从wait set中移除： 调用了Object.notfiy()或者Object.notifyAll(); 线程被中断（从wait set移除后，线程中断状态设置为false，并抛出InterruptException异常）； 等待超时； 线程重新获取了对象锁； notification通知动作是通过调用Object.notify()和Object.notifyAll()来实现的，调用时可能出现以下几种情况： 如果当前线程没有获取到对象锁，则抛出IllegalMonitorStateException异常； 有锁，执行notify，若对象的wait set不为空，则选择一个线程，并移除之（注意，如果当前线程多次获取了对象锁，notify后，其他线程只能等到当前线程完全释放锁后才能成功）； 有锁，执行notifyAll，对象wait set不为空，将所有线程从中移除； 有关wait/notify机制的具体使用，可参考示例代码：ConcurrencyExamples 参考文献 https://en.wikipedia.org/wiki/Monitor_(synchronization)) http://www.artima.com/insidejvm/ed2/threadsynch.html http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5-110 Java Language Specification SE8 Edition]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程之线程]]></title>
    <url>%2F2017%2F05%2F07%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程作为操作系统的最小调度单位。一个进程里可以有多个线程，这些线程有各自的程序计数器、堆栈空间和局部变量，而且可以共享进程的内存空间，因而在上下文切换时时间更短，效率更高，也常被成为轻量级进程(Light Weight Process)。接下来，将从三个方面来介绍Java线程类Thread的具体用法： 线程构造与初始化; 线程状态切换; 线程变量ThreadLocal的使用 Thread: https://en.wikipedia.org/wiki/Thread_(computing) 线程的构造与初始化Thread类提供了多个构造函数，初始化时有四个主要的参数： ThreadGroup 线程所在的线程组; Runnable目标可执行对象; String 线程名称; long stackSize,线程栈空间大小，不指定（为0)时由JVM确定; 123456789101112131415 public Thread() &#123; init(null, null, "Thread-" + nextThreadNum(), 0); &#125; public Thread(Runnable target) &#123; init(null, target, "Thread-" + nextThreadNum(), 0); &#125; .... public Thread(ThreadGroup group, Runnable target, String name, long stackSize) &#123; init(group, target, name, stackSize); &#125; 线程的构造函数最后通过一个init函数来进行初始化，初始化主要完成完成几个事情: 如果用户没有指定ThreadGroup,则首先需要确定该线程的ThreadGroup; 设置守护进程属性以及线程优先级; 创建ThreadLocal变量对应的ThreadLocalMap对象; 产生线程ID 1234567891011121314151617181920212223242526272829303132333435363738394041424344 private void init(ThreadGroup g, Runnable target, String name, long stackSize) &#123; Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); // 确定ThreadGroup if (g == null) &#123; /* Determine if it's an applet or not */ /* If there is a security manager, ask the security manager what to do. */ if (security != null) &#123; g = security.getThreadGroup(); &#125; /* If the security doesn't have a strong opinion of the matter use the parent thread group. */ if (g == null) &#123; g = parent.getThreadGroup(); &#125; &#125; // 增加该线程组中未启动线程的数目 g.addUnstarted(); this.group = g; // 是否为守护线程/优先级都由父亲线程确定 this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); this.name = name.toCharArray(); this.target = target; setPriority(priority); // 创建ThreadLocal变量对应的ThreadLocalMap if (parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* 设置线程ID */ tid = nextThreadID(); // 初始化完成 this.me = this; &#125; 线程构造完成后，调用start()即可启动了。 线程状态看Thread.java源码，线程在JVM中有6种不同的状态： NEW： 线程刚创建，还未启动; RUNNABLE: 线程在JVM中开始执行 BLOCKED: 线程在等待某个锁时被阻塞 WAITING： 线程处于无限期等待另一个线程完成某个动作 TIMED_WAITING: 线程等待另一个线程完成某个动作，超时后返回执行; TERMINATED： 线程处于终止状体(执行完成或者推出) 下图是一个线程状态之间的切换图： 线程创建完成后，调用start开始执行。当线程调用wait方法之后，开始进入等待状态，这是需要在其他线程调用notify/notifyAll进行通知才能返回的运行状态，如果使用了超时等待，线程在等待指定时间长度之后，仍未受到通知，则直接返回运行。若线程尝试通过synchronized获取同步锁，则会进入阻塞状态;在执行完run方法中的代码之后，则会进入终止状态。 线程变量ThreadLocal的使用线程本地变量ThreadLocal允许每个线程都有关于某个变量自己的一份唯一拷贝，线程可通过get/set方法来获取或者设置本地变量的值。通常，一个本地变量是一个static型、跟线程状态相关的变量（如用户ID ,交易ID)。 先来看下如何使用ThreadLocal本地变量。例如，我们想要得到一个线程的执行时间，可以这样利用ThreadLocal： 12345678910111213141516171819202122public class ThreadProfiler &#123; private static final ThreadLocal&lt;Long&gt; TIME = new ThreadLocal&lt;Long&gt;()&#123; protected Long initialValue()&#123; return System.currentTimeMillis(); &#125; &#125;; public static final void start()&#123; TIME.set(System.currentTimeMillis()); &#125; public static final void end()&#123; TIME.set(System.currentTimeMillis()); &#125; public static final long getTime()&#123; return System.currentTimeMillis() - TIME.get(); &#125;&#125; 这样只要在线程开始执行时调用ThreadProfiler.start()，而线程结束时调用ThreadProfiler.getTime()就可以得到线程执行所耗费的时间了。 ThreadLocal通过一个以ThreadLocal为key,其他任何对象为value的ThreadLocalMap（一个HashMap)来保存线程相关的本地变量值，而每个线程都有自己的一个ThreadLocalMap，这样线程就可以通过ThreadLocal来获取该map对象以ThreadLocal为键值的对象值了。 线程调用ThreadLocal的set(T value)时，如果已存在一个map对象，则直接将该值以该ThreadLocal对象为键值保存下来；如果线程没有map对象，则需要创建一个新的ThreadLocalMap。 1234567891011121314151617public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 线程调用ThreadLocal.get(),返回线程的本地变量。如果当前线程已经有一个map对象，并且该map对象有ThreadLocal对应的值，则直接返回;否则对线程的ThreadLocalMap对象threadLocals进行初始化操作。 123456789101112131415161718192021222324public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue();&#125;private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 参考源码 http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/ThreadLocal.java#ThreadLocal]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式在Java中的应用]]></title>
    <url>%2F2017%2F04%2F29%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[单例模式（Singleton Pattern)用于确保系统中某个类只有一个实例存在，即该类被创建初始化一次后，之后都不会再被创建。这里就来看下单例模式在Java中常见的几种实现方式： 双重检查锁 类初始化 enum类型实现 双重检查锁先来看下单例模式的简单实现: 123456789101112131415161718192021/* * a very simple singleton * * this is not thread safe */public class SimpleSingletonUnsafe &#123; private static SimpleSingletonUnsafe sInstance = null; private SimpleSingletonUnsafe()&#123;&#125; public static SimpleSingletonUnsafe getInstance()&#123; if(sInstance == null)&#123; sInstance = new SimpleSingletonUnsafe(); &#125; return sInstance; &#125;&#125; 由于没有对代码进行同步保护，上述实现在多个线程并发访问时可能出现sInstance被初始化多次的情况。为避免这种情况，可以直接在声明静态变量时进行类的初始化，从而保证始终只有一次初始化动作（JVM在初始化类时会获取一个锁，确保类初始化是线程安全的）: 123456789101112131415/* * a singleton which is thread safe */public class SimpleSingletonSafe &#123; private static SimpleSingletonSafe INSTANCE = new SimpleSingletonSafe(); private SimpleSingletonSafe()&#123;&#125; public static SimpleSingletonSafe getInstance()&#123; return INSTANCE; &#125;&#125; 现在有了一个线程安全的单例模式了(Eager Initialization)，但是这里还存在一个问题： 不管是否有线程使用该类，它都会初始化一次。这对于那些占有很多资源的类来说，可能并不合适。能不能只是在需要使用的时候才会类进行初始化了？采用双重检查锁（double checking lock)技术即可避免这个问题： 12345678910111213141516171819202122232425/* * a lazy singleton to prevent object creation earlier * * this is not thread safe */public class LazySingletonUnsafe &#123; private static LazySingletonUnsafe sInstance = null; private LazySingletonUnsafe()&#123;&#125; public static LazySingletonUnsafe getInstance()&#123; if(sInstance == null)&#123; //B: 1 synchronized(LazySingletonUnsafe.class)&#123; if(sInstance == null)&#123; sInstance = new LazySingletonUnsafe(); // A: 2 &#125; &#125; &#125; return sInstance; // B: 可能返回一个尚未初始化完成的对象 &#125;&#125; 表面看起来，这个方案似乎已经大功告成了。但在多线程的情况下，可能返回一个未初始化完成的对象。比如，有两个线程A、B，线程A先获取到同步锁，进入初始化代码，此时类LazySingletonUnsafe开始初始化，此时sInstance已经指向类分配的内存空间，不为空，当线程B调用getInstance时，判断条件不成立，因此直接准备返回，而实际上返回的是sInstance的一个引用对象，而可能此时类的初始化并没有完成，B得到的类实例就与A得到的不一致了。通过在限定变量sInstance为volatile(禁止JVM进行指令重排序,确保引用sInstance在多线程情况下是可见的），即可解决该问题： | 有关volatile在JVM中的实现原理可参考:Java并发编程之Java Memory Model 1234567891011121314151617181920212223/* * a thread-safe singleton */public class LazySingletonSafe &#123; private volatile static LazySingletonSafe sInstance = null; private LazySingletonSafe()&#123;&#125; public static LazySingletonSafe getInstance()&#123; if(sInstance == null)&#123; synchronized(LazySingletonUnsafe.class)&#123; if(sInstance == null)&#123; sInstance = new LazySingletonUnsafe(); &#125; &#125; &#125; return sInstance; &#125;&#125; Java类初始化的详细过程： http://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4.2 类初始化与此前双重检查锁中方案2类似，通过一个静态的私有类，类的对象变量作为该私有类的静态成员，该静态成员变量初始化时即创建新的对象，这样即能确保线程安全，也能保证类始终只初始化一次: 123456789101112131415161718/* * a static nested holder to be singleton * * JVM will acquire a lock when initializing a class, so it is thread-safe */public class SingletonHolder &#123; private static class InstanceHolder&#123; public static final SingletonHolder INSTANCE = new SingletonHolder(); &#125; public static SingletonHolder getInstance()&#123; return InstanceHolder.INSTANCE; &#125;&#125; enum类型实现在《Effective Java 2nd edition》第二章里推荐一种利用enum来实现单例模式的方法，看起来似乎更为简单： 123456789public enum EnumSingleton &#123; INSTANCE; @Override public String toString()&#123; return "EnumSingleton"; &#125;&#125; 另外，其中还提到了单例模式下类序列化的问题：为了避免每次序列化时都创建一个新的对象，需要提供一个readResolve函数: 1234private void readResolve()&#123; return INSTANCE;&#125; 上述示例代码可参考：https://github.com/runningforlife/JavaExamples]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Picasso从使用到原理详解]]></title>
    <url>%2F2017%2F04%2F20%2FPicasso%E4%BB%8E%E4%BD%BF%E7%94%A8%E5%88%B0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Picasso是SquareUp公司开源的专门为Android平台量身制作的图片加载库。通过Picasso，用户可以方便的将图片加载到特定的ImageView中，而不用关心图片是在一个文件夹里，还是在一个服务器上。那么，Picasso是如何何实现图片的快速加载了？ 利用两级缓存机制对图片进行缓存: 加载一个图片时，首先从内存中查看是否存在；如果不存在，则查看外部存储是否有该图片。这时，如果还没有找到，则通过网络端下载图片； 利用OkHttp库进行图片下载，下载后保存到缓存，下次请求时无需从网络端下载；如果出现网络错误，会自动重试下载； 使用示例Picasso提供了好几个调用接口,可以从文件或资源文件,也可以从网络下载图片.比如,现在要从网络上下载一张图片,并将其加载到一个ImageView上去,可以这么来调用接口: 1234567891011public static void load(Context context, String url, ImageView target, @DrawableRes int placeholder)&#123; Picasso.with(context) .load(url) .placeholder(placeholder) // 未下载完之前显示的占位图片 .centerCrop() // 保持图片尺寸与屏幕长宽比一致 .resize(512,(int)(512*DisplayUtil.getScreenRatio(context))) .into(target);&#125; 那么,如果想要监听图片加载完成这一事件,则需要自己手动实现`Target这个接口: 1234567891011121314151617181920212223242526private class ImageTarget implements Target&#123; private ImageView image; public ImageTarget(ImageView view)&#123; this.image = view; &#125; @Override public void onBitmapLoaded(Bitmap bitmap, Picasso.LoadedFrom from) &#123; Log.v(TAG,"onBitmapLoaded(): bitmap size " + bitmap.getByteCount() + ",loaded from " + from); image.setImageBitmap(bitmap); &#125; @Override public void onBitmapFailed(Drawable errorDrawable) &#123; Log.v(TAG,"onBitmapFailed()"); image.setImageDrawable(errorDrawable); &#125; @Override public void onPrepareLoad(Drawable placeHolderDrawable) &#123; &#125;&#125; 然后将其作为参数传入: 1234567891011public static void load(Context context, String url, Target target, @DrawableRes int placeholder)&#123; Picasso.with(context) .load(url) .placeholder(placeholder) .centerCrop() .resize(512,(int)(512*DisplayUtil.getScreenRatio(context))) .into(target);&#125; 具体代码可参考: https://github.com/runningforlife/AndroidExamples 中ImageLoader部分代码 源码解析下图是Picasso的简单框图,用户调用into(ImageView iv)接口后，Picasso将其该下载图片的请求包装成一个ImageViewAction,接着由Picasso负责发送到Dispatcher中；Dispatcher接着会把该Action继续封装成一个可执行对象BitmapHunter，接着将其提交到线程池PicassoExecutorService中执行；如果此时发现内存中已经有图片，则直接返回，否则BitmapHunter将通过一个Downloader下载图片，下载图片完成后，BitmapHunter会将结果返回给Dispatcher,最后由Dispatcher告知Picasso图片加载完成。 这里就来看一看Picasso库的几个核心类: Picasso.java从构造函数来看，Picasso类构造时需要初始化整个库，通过RequestCreator来产生图片加载请求Request，发送到Dispatcher中准备执行； 等图片加载完成后，还需要通过主线程告知用户图片已经加载完成。 12345678910111213141516171819202122232425 Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener, RequestTransformer requestTransformer, List&lt;RequestHandler&gt; extraRequestHandlers, Stats stats, Bitmap.Config defaultBitmapConfig, boolean indicatorsEnabled, boolean loggingEnabled) &#123; ... // 请求分发 this.dispatcher = dispatcher; // 缓存 this.cache = cache; ... // 构造不同的RequestHandler对象，用以处理不同类型的Request allRequestHandlers.add(new ResourceRequestHandler(context)); if (extraRequestHandlers != null) &#123; allRequestHandlers.addAll(extraRequestHandlers); &#125; allRequestHandlers.add(new ContactsPhotoRequestHandler(context)); allRequestHandlers.add(new MediaStoreRequestHandler(context)); allRequestHandlers.add(new ContentStreamRequestHandler(context)); allRequestHandlers.add(new AssetRequestHandler(context)); allRequestHandlers.add(new FileRequestHandler(context)); allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats)); requestHandlers = Collections.unmodifiableList(allRequestHandlers); // 统计图片下载请求 this.stats = stats;&#125; 几个重要函数: load(...): 加载图片，资源可是一个URL,也可以是一个文件路径，可以是一个资源文件ID； cancelRequest(ImageView): 取消某个ImageView的图片加载请求； invalidate(...) : 清除缓存; shutdown: 关闭Picasso,取消所有已存在的Request; enqueueAnsSubmite(Action) : 将图片下载动作ImageViewAction保存到一个Map，并发送给Dispatcher处理； ImageViewAction.java 每一个图片下载请求都封装成一个ImageViewAction,当图片下载完成后，有错误，则调用error(Exception)接口，若用户设置了错误时对应的图片，则直接显示该图片；没有错误，则调用complete(Bitmap, LoadedFrom)，将下载完成的Bitmap显示出来。 complete(Bitmap,LoadedFrom): 图片加载完成 Dispatcher.java 接收来自Picasso.java的请求动作，产生一个BitmapHunter可执行对象用于下载图片；Dispatcher并不是在一个请求完成之后就发送给Picasso，而是采用批处理的方式，等到完成的动作达到4个时，才一起发送出去。同时，有错误发生网络错误时，需要重新尝试下载；网络状态变化（网络切换）时，Dispatcher会调整线程池中线程的个数，并且重新提交失败的下载请求。 performSubmit(Action): 将请求动作提交到线程执行服务PicassoExecutorService； performRetry(BitmapHunter): 重新执行BitmapHunter对象； BitmapHunter.java用于加载图片的可执行对象，其首先尝试从缓存中读取图片，如果没有则从外部存储或者网络中进行加载。加载完成后，解码生成一个Bitmap返回给Dispatcher。 hunt() : 加载图片，优先从cache中读取，若没有，则从网络端下载；完成后，返回一个Bitmap对象； getResult(): 返回加载的图片Bitmap; PicassoExecutorService.java继承自ThreadPoolExecutor,采用优先级阻塞队列PriorityBlockingQueue对执行请求BitmapHunter进行优先级排序，优先级高的始终位于队列的前端。另外，根据当前网络的状态来调整线程池的线程数目： 如果是WIFI连接，则线程数设置为4；4G网络下的线程数设置为3；而3G的线程数只有2个。 submit(Runnable) : 将可执行对象加入到线程池中，并返回一个FutureTask&lt;?&gt;对象； adjustThreadCount(NetworkInfo） ： 根据网络状态调整线程池线程数；]]></content>
      <categories>
        <category>Open Source</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Picasso,</tag>
        <tag>ImageLoader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP网络协议入门]]></title>
    <url>%2F2017%2F03%2F07%2FTCP-IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[互联网是由一个个电脑节点组成的网络，那么两个节点之间是如何进行数据通信的了？先来看一看一个最简单的通信模型：发送者通过一个媒介想一个接收者发送消息，同时接收者也可以向发送者发送消息。 这种通信模型与平时生活中的日常会话很是相似。A想与B交流，首先A与B要讲同样的方言，如果一个人讲湖南方言，而一个人讲粤语，则沟通无法进行, 除非请一个懂两种方言的翻译或者沟通双发统一使用某一种语言。抽象的来看，通信一般涉及到如下几个要素： 两个需要通信的节点（地址）； 通信的数据交换协议（协议）; 节点之间的物理连接（媒介）； 缺乏任何其中一个要素通信都不会发生。比如，身在天津的小明A要给远在北京的小芳B发送一封信，这虽然是最常见的通信方式，也要具备通信的三个要素才能顺利进行：小明与小芳就是两个通信节点，小明需要知道小芳的地址才能向她写信，而小芳如果要回信，也需要知道小明的地址；语言文字就是通信得以进行的信息交换协议了，国家的邮政系统与信纸就是通信的媒介。 同样，对于互联网中的任何两个节点，想要进行通信的话，也需要满足这三个要素。互联网的物理媒介可能是普通的网线，可能是电话线，也可能是光纤。在这篇文章里，我们重点关注通信中节点的寻址与数据交换协议TCP/IP协议族。首先，就来看一看，两个节点之间的通信模式有哪些？ 通信模式这里所谓的通信模式是指节点通信的通道是怎样的。对于网络中节点之间的通信通道，通常有三种模式，分别是单工(simplex),半双工(half duplex)以及全双工(duplex)。这三种通道之间的区别在于节点之间数据传输的方向与时间： 单工： 只存在单向通道，始终只能再一个方向上发送数据，常见的比如电视、音频广播电台； 半双工： 同时存在两个通道，每个通道都可以进行数据传输，但不能同时进行通信； 全双工： 同时存在两个通道，并且两个通道可同时交换数据，最常见的就是电话系统。 对于互联网中的通信一般都是全双工的，即可在上行与下行通道同时传输数据。接下来就来看一看，互联网之间的节点是如何进行寻址的，即节点A如何知道节点B的地址？ 寻址网络中的一个节点可以由两个地址来唯一的标识： 一个是网络接口卡（网卡）的物理地址(也叫MAC地址)，一个是IP地址。网卡的物理地址通常是由网卡制造商确定的，而IP地址则是IP(Internet Protocol)协议对应的一个地址，是由一个叫做IANA(Internet Assigned Numbers Authority)的机构管理的。对于IPv4来说，IP地址的长度是32位（4个字节），而IPv6的地址则达到了128位（16个字节）。 IP地址在互联网协议发展早期，一般将IP地址划分为两个部分：网络号和主机号。同时，为了区分不同用途的IP地址，IP地址的前3位用来区分IP地址的类，共有五类IP地址： 由上，A类地址范围为：128.0.0.0 ~ 191.255.255.255；B类地址范围为: 128.0.0.0 ~ 191.255.255.255;C类地址范围为: 192.0.0.0 ~ 223.255.255.255。以此类推。 如果按照接收端主机来看，可以将IP地址分为三类：单播地址（接收者为单个主机）、广播地址（接收端为给定网络上的所有主机）以及多播地址（接收端为同一组内的所有主机）。如果根据IP地址的用途划分, 有可以分成公有地址与私有地址, 私有地址一般用于局域网的通信, 常见的私有地址范围如下表所示(具体可以参考RFC1918): 对于IPv4主机，由于存在网络号与主机号，因而在寻址与路由时需要作出区分，这就需要用到子网掩码了（subnet mask):通过子网掩码，给定一个IP地址，就可以知道该IP地址的子网号以及主机号了。譬如，在配置网络环境时，就常常会用到子网掩码： 举个例子，来看一看子网掩码是如何工作的。我们有一个IP地址： 192.168.5.130，同时，我们知道子网掩码为255.255.255.0，转换成对应的二进制： 二进制 十进制 IP地址 11000000.10101000.00000101.10000010 192.168.5.130 子网掩码 11111111.11111111.11111111.00000000 255.255.255.0 子网号 11000000.10101000.00000101.00000000 192.168.5.0 主机号 00000000.00000000.00000000.10000010 0.0.0.130 就是说，子网号是IP地址二进制与子网掩码二进制位与的结果，而主机号则是IP地址与子网掩码取反后位与的结果。这样就可以通过子网掩码来对子网内的主机进行寻址了。 在上面讲到了网络节点有物理地址与IP地址，那么，是否可能通过节点的物理地址知道它的IP地址了，或者反过来通过IP地址知道它的物理地址？答案是可以的。在TCP/IP协议族中有一个地址解析协议ARP（Address Resolution Protocol)就是用于将IP地址转化成物理地址的，而逆地址解析协议RARP（Reverse Address Resolution Protocol)则是用于将物理地址转化为IP地址。 如今，RARP协议已经被更为灵活易用的DHCP(Dynamic Host Configuration Protocol)协议替代。对于内网或者区域性的网络，DHCP通过管理IP地址池来实现动态的分配IP地址，每当有节点接入网络时，DHCP就会为其动态的分配一个IP地址。 关于DHCP可参考: https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol 域名系统如果单纯依靠IP地址来识别网络上的节点的话，对于用户上网来说是很麻烦的事情。访问WEB服务器时，用户需要记忆一大堆IP地址，这无疑是件痛苦的事情。因此，人们想到用域名(Domain Name)来查找网络上的节点，比如，要使用Google搜索，只需要在浏览器中输入www.google.com而不是一串IP地址就可以了。但是实际的网络访问还是需要通过IP地址，这就需要将域名转化成相应的IP地址。这就是域名系统(DNS, Domain Name System)需要做的事情。 可以把域名系统看做是一个层次化的分布式数据库，通过域名服务器可以查看到对应域名的IP地址。域名有根域名、顶级域名以及二级域名之分,根域名下面分了很多顶级域名，而顶级域名下面则又分成很多二级域名，这样就组成了一个层级的结构： 比如网络地址www.google.com中 .com就是一个顶级域名； .google是一个二级域名； www则表示访问的是一个WEB服务器； 那么，在通过域名访问网络时，发送节点究竟是如何通过DNS来查找IP地址的了？这里用一个实际的例子来说明域名解析的过程。比如，现在需要访问www.wikipedia.org这个网站，首先会查找根域名服务器，根域名服务器会返回一个顶级域名服务器.org的IP地址；接着，通过该顶级域名服务器IP地址，继续查询,顶级域名服务器则返回一个二级域名.wikipedia的IP地址,这样根据这个IP地址，就可以顺利访问维基百科这个WEB服务了。 还有一个问题，需要访问网络的节点是如何知道根域名服务器的IP地址的？事实上，这些根域名服务器的IP地址是内置在电脑系统中的，这样通过事先预定的“根提示文件”(root hints file)就可以发起域名解析了。目前，在全球，共有13个根域名服务器，可以在 IANA 官网中查看这些根域名服务器的具体信息。 协议分层TCP/IP协议族是一个不同层次上多个协议的组合，每一个层都负责不一样的通信功能。实际使用的是一个五层的协议族： 链路层： 也被称为数据链路层或网络接口层，通常包括操作系统中的设备驱动和计算机中对应的网卡。链路层主要处理与物理接口相关的细节，接受来自网络端的数据或者发送数据到上层； 网络层： 有时也称为互联网层，处理分组在网络中的活动以及主机的寻址与识别，例如分组的选路。网络层协议主要包括了IP协议（网际协议）、ICMP（Internet Control Message Protocol，互联网控制报文协议)以及IGMP(Internet Group Management Protocol,Internet组管理协议）。 运输层： 为两台主机上的应用程序提供端到端的通信，有两个不相同的传输协议：TCP(Transmission Control Protocol)和UDP(User Datagram Protocol)。TCP为两台主机提供了高可靠性的数据通信，它所做的工作主要有（1）将应用层传过来的数据分成合适的小块发到网络层，确认接收到分组后，设置发送最后确认分组的超时时钟等；UDP则简单的多，它只是把数据报(Datagram)的分组发给另外一台主机，但不能确保数据报能到达另一端。 应用层处理特定应用程序细节。一般会提供如下几种应用程序: Telnet 远程登录； FTP 文件传输协议； SMTP 简单邮件传送协议； SNMP 简单网络管理系统 参考文献 https://en.wikipedia.org/wiki/Internet_protocol_suite http://www.ipprimer.com/#/overview http://www.eventhelix.com/RealtimeMantra/Networking/tcp/http://cn.linux.vbird.org/linux_server/0110network_basic.php]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>网络协议</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Maven]]></title>
    <url>%2F2017%2F03%2F06%2FMaven%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[什么是MavenMaven是一个自动化构建工具，最开始只适用于Java项目，后来逐渐支持C#,Ruby等项目的构建。Maven使用XML格式文件来描述一个项目的依赖，被称为Project Object Model(POM)。一个pom.xml描述了一个项目所有的配置，包括项目信息，项目所依赖的包等等。 Maven可以从一个或者多个代码仓库里（Maven 2 Central Repository)动态下载Java库文件以及插件,并将其保存到本地的仓库里（缓存），从而实现依赖的更新。 自动构建：https://en.wikipedia.org/wiki/Build_automation 通常，一个Maven项目的代码结构如下： 接下里主要介绍下Maven项目构建工具两个关键的概念:编译的生命周期与POM。 编译周期Maven提供了３种内置的编译周期：default(默认），clean(清除),site(位置)。默认周期用于项目的部署，clean周期则用于项目的清除工作，site周期主要处理项目相关的文档。 这里简要的列出default周期所包括的各个阶段以及具体作用： 阶段 任务 maven命令 validate 验证项目配置是否正确以及必要的信息是否可用 – generate-sources 产生用于编译的源代码 – compile 编译项目源代码 – test 用合适的测试框架测试代码,不应该需要代码打包或者部署 – package 以可分发的格式打包编译好的代码，比如JAR – verify 确认集合测试结果以确保质量达标 – install 安装包到本地库，用于其他项目的依赖 mvn install deploy 部署，将软件包拷贝到远程仓库，分享给其他开发者 – 关于项目编译各个生命周期更详细的文档，请参考: Maven编译周期: https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference POM什么是POM? POM,英文全称为Project Object Model,即项目对象模型，是Maven中最基本的组成部分（每个Maven项目都必须的一个文件)。POM是一个XML的文档，里边包含了Maven编译所需的项目信息及其配置。创建时，POM里边就包含了对大多数项目适用的默认值，比如编译目录’target’；源码目录’src/main/java’；测试代码目录,’src/test/java’。 POM文件主要包含了以下几个方面的信息: 项目依赖； 开发者与贡献者列表； 插件列表； 插件配置; 资源列表 一个最小的POM配置需要包括以下几项： 项目根目录‘’标签 modelVersion，应该被设为4.0.0 groudId,项目所在组的ID artifactId,项目ID version, 给定的组下项目的版本号 例如下面就是一个最小的POM文件： &lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1&lt;/version&gt; &lt;/project&gt; 稍微复杂一点，添加一个项目的依赖，如下这样一个pom.xml文件: &lt;project&gt; &lt;!-- model version is always 4.0.0 for Maven 2.x POMs --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- project coordinates, i.e. a group of values which uniquely identify this project --&gt; &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt; &lt;artifactId&gt;my-app&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;!-- library dependencies --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- coordinates of the required library --&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!-- this dependency is only used for running and compiling tests --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 更多关于POM的信息请参考官方文档：https://maven.apache.org/guides/introduction/introduction-to-the-pom.html]]></content>
      <categories>
        <category>项目构建</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
        <tag>构建工具</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[追寻真实的自我]]></title>
    <url>%2F2017%2F02%2F27%2F%E8%BF%BD%E5%AF%BB%E7%9C%9F%E5%AE%9E%E7%9A%84%E8%87%AA%E6%88%91%2F</url>
    <content type="text"><![CDATA[你对生活的理解程度决定了你有多幸福，有多自由 最近在看Bob Dylan的自传《编年史》，里边说到六十年代美国变革动荡时期，很多人要他做领袖，当个时代的开路人，希望他为社会的进步呐喊歌唱，但是他做不了。他只想要做真实的自己，做一个真正的民谣歌手，一个纯粹的艺术家。他渴求的只是探求真实的自我。由是，想到自己的经历，不免感慨，也就忍不住写下了这些文字，算是自我反省吧。 多少年前，你就开始思考自己的人生，想要探索自己的道路 可是，多少年过去了 你却依然摇摇晃晃，并没有坚定的意志与方向 你似乎并不懂得自己真正想要的东西，也未能理解人生真正值得追求的价值在哪里 你并没有找到一个自己真正热爱的东西 你大部分的努力都包含了别人的期待与关注 你内心有太多的负担与包袱，以至于你难以做到轻松愉快的投入到自己的探索之中 有时，你似乎理解了，你感觉到自己的进步 可，内心里你却依然被自卑与自傲所纠缠 过往的经历使你缺乏足够的信心，也让你变得有些自我怀疑 更确切的来说，是身边的人与环境让你总是不断的怀疑自己 总会有人抱着疑虑的心态来看待你，而这也让你染上了自我否定的毛病 你不断的自我怀疑，有时得过且过，浪费了很多时间与精力 在另一方面，你却始终在努力，在不断的改变自己 是的，如果没有那些努力 你或许要比现在还有平庸，比现在还要艰难 也是这些努力带来了一些所谓的成绩，而这点成绩竟然让你有了自傲的心态 现在想来，你只是要用自傲来补偿下内心的自卑 这或许是每个人内心的真实写照 在自卑的一面往往是自傲，而在自傲的一面也能看到自卑 现实生活的残酷与冷漠，不得不让我面对现实 让我放下内心所有可能的虚幻，坦然的面对一个真实的自己 那么，究竟什么才是一个真实的我 到底我该追寻一个怎样真实的自己 不要期待做他人的导师 不要好为人师，不要做任何人的王 不要想着努力赚取功名利禄，不要想攫取权力 努力找到自己喜欢、乐意做的事情吧 找到一件愿意一辈子付出的事情 找到自己的真爱，爱的人、爱的事、爱的物 然后坚持不懈，脚踏实地，一点一滴的去积累，去探寻 放下内心的自傲，也要放下自卑 你就是你，那个真实的存在，那个独一无二的存在 这一生，你要竭力做到把生命的光发的更亮一点，把生命的热散发的更温暖一些 这一生，你要矢志不渝的追寻一个真实的自我]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>Bob dylan</tag>
        <tag>追寻自我</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Effective Java》摘记]]></title>
    <url>%2F2017%2F02%2F25%2F%E3%80%8AEffective-Java%E3%80%8B%E6%91%98%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一遍看完感觉没有学到什么，又看了一遍，然后自己找了些实例对比着理解了书上的要点，算是对Java编程有了更多的认识。以下是 《Effective Java 2nd edition》的摘记。 Consider static factory methods instead of constructors相比构造函数，静态工厂方法有哪些优点了？首先，静态工厂方法有自己的名字，这可以增强程序的可读性；其次，静态工厂方法每次调用时，不用创建新的对象实例；第三，静态工厂方法可以返回其返回类型的任何子类型对象。 示例： 1234567891011121314151617public final class Boolean implements java.io.Serializable, Comparable&lt;Boolean&gt;&#123; public static final Boolean TRUE = new Boolean(true); public static final Boolean FALSE = new Boolean(false); .... //根据boolean值返回相应的Boolean对象 public static Boolean valueOf(boolean b) &#123; return (b ? TRUE : FALSE); &#125;&#125; Consider a builder when faced with many constructor parameters当存在多个参数时，静态工厂方法和构造函数都会遇到问题。以往的做法是，使用telescoping constructor,对外提供多个构造函数，每个构造函数有不同个数的参数。例如，Android中的View，共有四个构造函数，第一个构造函数有一个参数，一次类推，第四个构造函数则由四个参数： 1234567891011121314151617181920public View(Context context) &#123; mContext = context; ....&#125;public View(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0);&#125;public View(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; this(context, attrs, defStyleAttr, 0);&#125;public View(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; this(context); .....&#125; 但如果参数太多，telescoping constructor方法也会变得难以卒读。还有一种方式就是采用JavaBeans，但JavaBeans也有自身的不足:由于构造实例是通过多个接口进行的，一个JavaBean可能使实例处于不一致的状态，另一方面也会一个类处于可变状态(mutable)。 关于什么是JavaBeans: what-is-a-javabean-exactly；wikipedia：JavaBeans 结合上述两种方法的优点，builder模式很好的解决了上述问题：用户获取到一个builder对象，然后将设定的参数传递给该对象，最后通过buidler对象来产生一个不可变的目标对象。通常，builder对象是被构造类的静态成员类。在Android中，构造AlertDialog时，就用到了这种方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122public class AlertDialog extends Dialog implements DialogInterface &#123; public static class Builder &#123; private final AlertController.AlertParams P; private boolean mIsDeviceDefaultLight; private int mTheme; public Builder(Context context) &#123; this(context, resolveDialogTheme(context, 0)); &#125; public Builder(Context context, int themeResId) &#123; P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, themeResId))); mTheme = themeResId; .... &#125; ..... public Builder setTitle(CharSequence title) &#123; P.mTitle = title; return this; &#125; public Builder setCustomTitle(View customTitleView) &#123; P.mCustomTitleView = customTitleView; return this; &#125; public Builder setMessage(CharSequence message) &#123; P.mMessage = message; return this; &#125; public Builder setIcon(@DrawableRes int iconId) &#123; P.mIconId = iconId; return this; &#125; .... public Builder setPositiveButton(CharSequence text, final OnClickListener listener) &#123; P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this; &#125; public Builder setNegativeButton(@StringRes int textId, final OnClickListener listener) &#123; P.mNegativeButtonText = P.mContext.getText(textId); P.mNegativeButtonListener = listener; return this; &#125; public Builder setNeutralButton(@StringRes int textId, final OnClickListener listener) &#123; P.mNeutralButtonText = P.mContext.getText(textId); P.mNeutralButtonListener = listener; return this; &#125; public Builder setCancelable(boolean cancelable) &#123; P.mCancelable = cancelable; return this; &#125; public Builder setOnCancelListener(OnCancelListener onCancelListener) &#123; P.mOnCancelListener = onCancelListener; return this; &#125; public Builder setItems(@ArrayRes int itemsId, final OnClickListener listener) &#123; P.mItems = P.mContext.getResources().getTextArray(itemsId); P.mOnClickListener = listener; return this; &#125; public Builder setAdapter(final ListAdapter adapter, final OnClickListener listener) &#123; P.mAdapter = adapter; P.mOnClickListener = listener; return this; &#125; public Builder setCursor(final Cursor cursor, final OnClickListener listener, String labelColumn) &#123; P.mCursor = cursor; P.mLabelColumn = labelColumn; P.mOnClickListener = listener; return this; &#125; ..... public Builder setView(View view) &#123; P.mView = view; P.mViewLayoutResId = 0; P.mViewSpacingSpecified = false; return this; &#125; public AlertDialog create() &#123; AlertDialog dialog; if(mIsDeviceDefaultLight) &#123; dialog = new AlertDialog(P.mContext, mTheme , false); &#125; else &#123; dialog = new AlertDialog(P.mContext, 0, false); &#125; P.apply(dialog.mAlert); .... return dialog; &#125; public AlertDialog show() &#123; final AlertDialog dialog = create(); dialog.show(); return dialog; &#125; &#125;&#125; 总的说来，在所构造的对象有很多参数时，特别地，有些参数时可选的，builder模式是一个非常不错的选择。相比而言，使用builder模式，客户端代码更简洁易读(telescoping constructor)，也更安全（可构造一个不可变的对象,JavaBeans）。 Eliminate obsolete object referencesAn obsolete reference is simply a reference that will never be dereferenced again. Memory leaks in garbage-collected languages(known as unintentional object retentions) are insidious. If an object reference is unintentionally retained, not only is that object excluded from garbage collection, but so too are any objects referenced by that object, and so on. The fix for this sort of problem is simple: null out references once they become obsolete. So, when object references should be nulled? Nulling out object references should be the exception rather than the norm. The best way to eliminate an obsolete reference is to let the variable that contained the reference fall out of scope. This occurs naturally if you define each variable in the narrowest possible scope. Generally speaking, whenever a class manages its own memory, the programmer should be alert for memory leaks. Whenever an element is freed, any object references contained in the element should be nulled out. Another commmon source of memory leaks is caches: once you put an object reference into a cache, it’s easy to forget that it’s there and leave it in the cache long after it becomes irrelevant. A third common source of memory leaks is listeners and callbacks: if you implement an API where clients register callbacks but don’t deregister them explicitly, they will accumulate unless you take some action. Obey the general contract when overriding equals什么时候不需要重载object中的equals方法了？ 类的每个实例都是唯一的：例如像Thread这种活动实体类； 不用关心类是否提供了“逻辑相等”测试：比如java.util.Random类并不需要重载equals方法来检测两个实例是否相同； 父类已经重载了equals，而且该方法同样适用于这个类时，不用再重载； 类时私有的或者包私有的，并且可以确定equals方法不会被调用，则不用重载。 那么，在重载equals方法时，需要遵循那些原则了？ 反射性(reflexive): 对任何非NULL引用 x, x.equals(x)必须为真； 对称性(symmetric): 对任何非NULL引用 x,y: 当且仅当x.equals(y)返回真时，y.equals(x)才为真； 传递性(transitive): 对任何非NULL引用x,y,z,如果x.equals(y)和y.equals(z)均为真，则x.equals(z)也为真； 一致性(consisitency): 如果两个非NULL引用x,y相等，那么应该一直相等除非有一个被改变了； 空值行(Non-nullity): 对于任何非NULL引用 x，x.equals(NULL)为假； 示例： 12345678910111213141516171819202122232425262728293031public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; .... public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String) anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125;&#125; Always override hashCode when you override equals如果重载equals时，不重载hashCode的话，在使用基于hash值的集合类，如HashMap,HashSet,Hashtable时，可能出现异常情况。 那么，如何写好一个hashCode函数了？ 将一个int型变量 result 初始化为一个非零值，比如17； 对于类中不同类型的成员变量，其相应的hash值 c 如下： boolean: c = (f ? 0 : 1) byte, char,short, or int: c = (int) f long: c = (int) (f ^( f &gt;&gt;&gt; 32)) float: c = Float.floatToIntBits(f) double: long l = Double.doubleToLongBits(f);c = (int)(1^(l &gt;&gt;&gt; 32)) Object: c = f.hashCode() Array: 应用上述规则 将所得hash值计算存入result: result = 31 * result + c; 返回结果；并确保两个相等(equals)的对象是否有相同的hash值； 示例： 12345678910111213141516171819202122232425262728public class FileKey &#123; private long mDev; // ID of device private long mIno; // Inode number private FileKey() &#123; &#125; public int hashCode() &#123; return (int)(mDev ^ (mDev &gt;&gt;&gt; 32)) + (int)(mIno ^ (mIno &gt;&gt;&gt; 32)); &#125; public boolean equals(Object obj) &#123; if (obj == this) return true; if (!(obj instanceof FileKey)) return false; FileKey other = (FileKey)obj; if ((this.mDev != other.mDev) || (this.mIno != other.mIno)) &#123; return false; &#125; return true; &#125;&#125; Always override toString重载toString()函数可以让类使用起来更方便。 12345678910111213141516171819public static final class Mode implements Parcelable &#123; private final int mModeId; private final int mWidth; private final int mHeight; private final float mRefreshRate; @Override public String toString() &#123; return new StringBuilder("&#123;") .append("id=").append(mModeId) .append(", width=").append(mWidth) .append(", height=").append(mHeight) .append(", fps=").append(mRefreshRate) .append("&#125;") .toString(); &#125;&#125; Mininmize mutability一个不可变的类是指其对象不可修改。那么，怎么让一个类不可变了？有以下五个原则： 不要提供修改对象状态的任何接口(mutators); 确保类不可扩展(extend)：防止类被子类化的简单办法是将其声明为final;或者将其构造函数都声明为private，紧急只提供一个静态的工厂方法来产生类的对象； 将所有成员变量声明为final； 将所有成员声明为private； 有可变的成员变量时，确保其不可被外部修改； Favor composition over inheritance跟方法调用不同的是，继承（不是interface implementation)与封装原则是冲突的。在子类确实一个父类的一个子类型时，继承比较合适。换句话说，类B需要扩展类A，仅当两个类之间存在是一个的关系时。因此，在选择使用继承与组合时，应该问一问：类B是否是一个类A？如果不是，则考虑使用组合。 另外，在考虑使用继承时，还应该考虑下：被继承的类的API是否存在缺陷？如果有的话，使用继承方法则会将API的缺陷带入子类，而使用组合，则可以通过包装(wrapper)的方式隐藏这些缺陷。 Prefer interfaces to abstract classesIt is far easier to evolve an abstract class than an interface(once an interface is released and widely implemented, it is almost impossible to change); In summary, an interface is generally the best way to define a type that permits multiple implementations. An exception to this rule is the case where ease of evolution is deemed more important than flexibility and power. Favor static member classes over nonstaticIf you declare a member class that doesnot require access to an enclosing instance, always put the static modifier in its declaration. Do not use raw types in new codeUsing raw types can lead to exceptions at runtime, so don’t use them in new code. You must use raw types in class literals: List.class,String[].class,and int.class are all legal,but List&lt;String&gt;.class和List&lt;?&gt;.class are not Eliminate unchecked warnings每一个unchecked warnings都很重要，它表示了一个运行时可能出现的ClassCastException，尽可能的移除这些警告。如果无法消除这些警告，并且可以十分确定代码是typesafe的话，在尽可能小的范围内使用@SuppressWarnings(&quot;unchecked&quot;)注解将这些警告移除，并作出相应的comment。 User bouned wildcards to increase API flexibility参数化的类型(parameterized types)是不可变的，换句话说，对于任何两个不同的类型Type1,Type2,List&lt;Type1&gt;跟List&lt;Type2&gt;是不同的：List&lt;Type1&gt;既非List&lt;Type2&gt;的子类型，也非其父类型。 为了提升API的弹性，使用通用匹配符类型(wildcard types)作为表示生产者(producers)或者消费者(consumers)的输入参数。如果一个输入参数既是生产者又是消费者，通用匹配符类型并无多大帮助. 记住: Producer-extends, Consumer-super(PECS); all comparables and comparators are consumers 示例： 1234567891011121314// Producerpublic interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; .... boolean addAll(Collection&lt;? extends E&gt; c); ....&#125;// Consumerpublic void popAll(Collection&lt;? super E&gt; dst)&#123; while(!isEmpty()) dst.add(pop()); &#125; Use Enums instead of int constants 什么时候需要使用enum? 在需要固定数目的常量集合时都可以使用。 如果写一个可扩展的enum类型存在困难时，可以声明一个接口然后实现该接口，从而实现可扩展性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public interface Operation &#123; double apply(double x, double y);&#125;//BasicOperationspublic enum BasicOperations implements Operation&#123; ADD("+")&#123; public double apply(double x, double y) &#123; return x + y; &#125; &#125;, MINUS("-")&#123; public double apply(double x, double y)&#123; return x - y; &#125; &#125;, MULTIPLY("*")&#123; public double apply(double x, double y)&#123; return x * y; &#125; &#125;, DIVIDE("/")&#123; public double apply(double x, double y)&#123; if(Double.compare(y, 0.0) == 0)&#123; return Double.NaN; &#125; return x/y; &#125; &#125;; private final String mOpCode; BasicOperations(String op)&#123; mOpCode = op; &#125; @Override public String toString()&#123; return mOpCode; &#125;&#125;//ExtendOperationspublic enum ExtendOperations implements Operation&#123; POWER("^")&#123; public double apply(double x, double y)&#123; return Math.pow(x, y); &#125; &#125;, MOD("%")&#123; public double apply(double x, double y)&#123; return x % y; &#125; &#125;; private final String mOpCode; ExtendOperations(String op)&#123; mOpCode = op; &#125; @Override public String toString()&#123; return mOpCode; &#125;&#125; Prefer annotations to naming patterns在Java 1.5发布之前，一些工具或者框架采用命名模式对某些程序做特殊的处理，例如JUnit测试框架最开始要求使用者将每个测试方法以test开头。这种方法存在的不足是，万一使用者拼写有误，测试就无法通过；另外一个不足是，对于方法以外的程序部分如类，同样无法进行测试。同时，命名模式无法将参数值与程序元素无法关联，例如假如你想要设计一个测试集合，检查一个方法是否抛出特定的异常，这时本质上来说，异常类型是测试的一个参数。 上述问题都可以使用annotations(注解）来得到解决。这里，我们来定义一个注解类型用于设计用于自动运行并且在抛出异常时失败的测试（使用时只需在方法前面加上:@Test即可）： 1234567891011import java.lang.annotation.Target;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import static java.lang.annotation.ElementType.METHOD;@Retention(RetentionPolicy.RUNTIME)@Target(&#123;METHOD&#125;)public @interface Test &#123;&#125; 在Android的源码中，也可以看到很多注解用于对方法或者类做特殊的处理，例如@TargetApi()用于指定某个方法或者构造函数的API级别： 123456789101112/** Indicates that Lint should treat this type as targeting a given API level, no matter what the project target is. */@Target(&#123;TYPE, METHOD, CONSTRUCTOR&#125;)@Retention(RetentionPolicy.CLASS)public @interface TargetApi &#123; /** * This sets the target api level for the type.. */ int value();&#125; 参考源码: /android/frameworks/base/core/java/android/annotation/ Design Method signatures carefully怎么使得设计的API更容易被理解，更方便的被使用而不易产生错误了？ 谨慎的命名方法：命名始终遵循标准的命名约定，首要的目标应该是确保命名是可被理解，并且与包内其他命名保持一致； 不要提供太多的方法： 方法太多容易使类变得难以学习，使用，编写文档，测试跟维护，这个对于interface来说尤其如此。因此，当存疑时，应该直接忽略； 避免过长的参数列表：保持四个或者更少的参数。怎么减少参数？有三个办法：一个是将该方法分解为几个不同的方法，每个方法只包含一部分参数；第三个方法是使用Builder模式； 对于参数类型来说，使用interface而不是classes； 尽量使用两个元素的enum类型而非boolean参数，让程序变得更具可读性； Use overloading judiciouslyoverloaded(重载）方法是静态的，其在编译时就确定了如何调用，而overriden(覆盖）方法是动态的，具体如何调用是在运行时确定的。 Return emtpy arrays or collections, not nulls需要返回一个数组或者集合类值时，如果是空，不要返回null，而是返回一个空数组或者空集合。 12345678910111213141516171819202122// emtpy arrayprivate List&lt;Cheese&gt; allCheeses = new ArrayList&lt;&gt;();private static final Cheese[] EMPTY_ARRAY_CHEESE = new Cheese[0];public Cheese[] getCheeses()&#123; return allCheeses.toArray(EMPTY_ARRAY_CHEESE);&#125;// collectionsprivate List&lt;Cheese&gt; allCheeses = new ArrayList&lt;&gt;();public List&lt;Cheese&gt; getCheeseList()&#123; if(allCheeses.isEmpty())&#123; return Collections.emptyList(); &#125; return allCheeses;&#125; Write doc comments for all exposed API elements合适的描述API，需要将每个输出的类、接口、构造函数、方法以及成员变量写评述。同时，为了代码的可维护性，对于不输出的类、接口、构造函数、方法以及成员变量也应做出适当的说明。 Minimize the scope of local variables一个减少局部变量作用域的方法是在它第一次使用时才声明。另外一个办法是尽量让方法的变小，并且每个方法只做一件事。 Refer to objects by their interfaces如果存在合适的接口类型，那么参数，返回值，变量以及成员变量都应该声明为接口类型。 Optimize judiciously如果过早的进行优化，很可能带来更多的危害而不是好处。不要牺牲合理的架构原则来换取性能：努力写出好的代码而不是快的代码。 M.A.Jackson: we follow two rules in the matter of optimization: Rule 1. Don’t do it; Rule 2. (for experts only). Don’t do it yet - that is,not until you have a perfectly clear and unoptimized solution. Use checked exceptions fo recoverable conditions and runtime exceptions for programming errorsJava语言提供了三类可抛出对象(throwables):可检查的异常，运行时异常，以及错误。对于客户端需要从异常中恢复的情况，应该使用可检查的异常；而对于编程错误（如客户端调用接口有误）则使用运行时异常。 Synchronize access to shared mutable data适当的实用synchronize,可以确保对象在各个线程中的状态保持一致。在另一方面，同步不仅仅用于互斥访问（任何时候都只有一个线程可以读写），也可用于线程之间的通信。 记住，当有多个线程共享可变数据(mutable data)时，确保每个线程执行读或者写操作时都保持了同步。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Effective Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Phone进程启动过程分析]]></title>
    <url>%2F2017%2F02%2F21%2FAndroid-Phone%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[之前解决一个开机搜网慢的问题时，发现由于Phone进程起来以后才会主动连接RILD,因而在一定程度上Phone进程启动的时间会影响网络状态注册的快慢。适当的将Phone进程提前，可以将网络注册时间提前一点，让状态栏中信号显示的时间提前。那么，Android中作为系统的核心进程之一，Phone进程是如何启动的了？ 本文参考代码为Android NN7.0, RIL运行机制请参考: Android RIL概述 Telephony最开始创建的是PhoneFactory对象，直接搜索源码，可以看到在PhoneGlobals.java创建时，会调用PhoneFactory对Telephony进行初始化操作: 12345678910111213141516171819202122/** * Global state for the telephony subsystem when running in the primary * phone process. */public class PhoneGlobals extends ContextWrapper &#123; public void onCreate() &#123; Log.v(LOG_TAG, "!@Boot_SVC : PhoneApp OnCrate"); // CallManager为空 if (mCM == null) &#123; // Initialize the telephony framework PhoneFactory.makeDefaultPhones(this); // 创建CallManager实例 mCM = CallManager.getInstance(); for (Phone phone : PhoneFactory.getPhones()) &#123; mCM.registerPhone(phone); &#125; .... &#125;&#125; 那么，PhoneGlobals又是在哪里创建的了？再次搜索代码，可以看到在同一文件目录下，有一个PhoneApp.java文件: 1234567891011121314151617@Override public void onCreate() &#123; Log.d("PhoneApp", "onCreate"); if (UserHandle.myUserId() == 0) &#123; // 创建PhoneGlobals实例 mPhoneGlobals = new PhoneGlobals(this); mPhoneGlobals.onCreate(); mTelephonyGlobals = new TelephonyGlobals(this); mTelephonyGlobals.onCreate(); &#125; else &#123; Log.d("PhoneApp", "Phone app is created as userid not 0, there's no PhoneApp() Instance"); &#125; .... &#125; 那么，PhoneApp这个类又是什么时候创建的？我们知道，每一个Android应用都有一个Application与之对应，它是在应用启动过程中创建的，但是在这里搜索所有的源码，也无法看到PhoneApp创建的地方。联想到应用的启动过程，APP的启动的入口是ActivityThread,那么对于任何PhoneApp这样的系统应用来说，启动的入口也应该是ActivityThread。不妨继续看看代码。 打开Phone进程所在的源码路径: /android/applications/sources/services/Telephony/,查看应用对应的AndroidManefest.xml文件: 1234567891011121314151617181920212223&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:androidprv="http://schemas.android.com/apk/prv/res/android" package="com.android.phone" android:versionCode="1" android:versionName="1.0.0" coreApp="true" android:sharedUserId="android.uid.phone" android:sharedUserLabel="@string/phoneAppLabel" &gt; ..... &lt;application android:name="PhoneApp" android:persistent="true" android:hardwareAccelerated="true" android:label="@string/phoneAppLabel" android:icon="@mipmap/ic_launcher_phone" android:allowBackup="false" android:supportsRtl="true" android:usesCleartextTraffic="true" android:defaultToDeviceProtectedStorage="true" android:directBootAware="true"&gt; .... &lt;/application&gt;&lt;/manifest&gt; 在application标签下面，可以看到android:persistent=&quot;true&quot;这个属性值，看一看官方的文档怎么解释的： android:persistent Whether or not the application should remain running at all times — “true” if it should, and “false” if not. The default value is “false”. Applications should not normally set this flag; persistence mode is intended only for certain system applications. 由此可见，Phone应用是系统常驻进程，一旦起来后就会一直运行，不会被杀死（除非Phone进程自己发生了的运行时错误而崩溃）。对于这类常驻进程，ActivityManagerService(以下简称AMS)会在初始化完成后，主动启动。在SystemServer初始化完系统的核心服务后，会调用AMS的systemReady(Runnable r)函数。 ActivityManagerService.java12345678910111213141516171819202122232425262728public void systemReady(final Runnable goingCallback) &#123; synchronized (this) &#123; // Only start up encryption-aware persistent apps; once user is // unlocked we'll come back around and start unaware apps // 正是在这里，phone进程被创建 startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE); // Start up initial activity. mBooting = true; // Enable home activity for system user, so that the system can always boot if (UserManager.isSplitSystemUser()) &#123; ComponentName cName = new ComponentName(mContext, SystemUserHomeActivity.class); try &#123; AppGlobals.getPackageManager().setComponentEnabledSetting(cName, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, 0, UserHandle.USER_SYSTEM); &#125; catch (RemoteException e) &#123; throw e.rethrowAsRuntimeException(); &#125; &#125; startHomeActivityLocked(currentUserId, "systemReady"); &#125;&#125; 启动所有PackageManager.MATCH_DIRECT_BOOT_AWARE标志为true的应用: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void startPersistentApps(int matchFlags) &#123; synchronized (this) &#123; try &#123; //获取系统所有常驻应用程序信息 final List&lt;ApplicationInfo&gt; apps = AppGlobals.getPackageManager() .getPersistentApplications(STOCK_PM_FLAGS | matchFlags).getList(); for (ApplicationInfo app : apps) &#123; if (!"android".equals(app.packageName)) &#123; //加载应用 addAppLocked(app, false, null /* ABI override */); &#125; &#125; &#125; catch (RemoteException ex) &#123; &#125; &#125;&#125;//添加应用程序进程到LRU列表中，并创建进程final ProcessRecord addAppLocked(ApplicationInfo info, boolean isolated, String abiOverride) &#123; ProcessRecord app; if (!isolated) &#123; app = getProcessRecordLocked(info.processName, info.uid, true); &#125; else &#123; app = null; &#125; // 没有进程记录，因此创建一个进程记录 if (app == null) &#123; app = newProcessRecordLocked(info, null, isolated, 0); updateLruProcessLocked(app, false, null); updateOomAdjLocked(); &#125; .... if ((info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123; app.persistent = true; app.maxAdj = ProcessList.PERSISTENT_PROC_ADJ; &#125; // Start the process. It will either succeed and return a result containing // the PID of the new process, or else throw a RuntimeException. boolean isActivityProcess = (entryPoint == null); // 进程入口为ActivityThread if (entryPoint == null) entryPoint = "android.app.ActivityThread"; //启动应用进程 if (app.thread == null &amp;&amp; mPersistentStartingProcesses.indexOf(app) &lt; 0) &#123; mPersistentStartingProcesses.add(app); startProcessLocked(app, "added application", app.processName, abiOverride, null /* entryPoint */, null /* entryPointArgs */); &#125; return app;&#125; 准备创建应用进程: 12345678910111213141516private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123; Process.ProcessStartResult startResult = null; .... startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, aasaSeInfo != null ? new String(aasaSeInfo) : app.info.seinfo, //AASA--4 : changed orginal : only "app.info.seinfo" app.info.category, app.info.accessInfo, requiredAbi, instructionSet, app.info.dataDir, mountKnoxPoint, entryPointArgs); ....&#125; Process.java调用Process.start()，创建一个新的进程, Telephony服务以及RIL相关代码都运行在此进程中： 12345678910111213141516171819202122232425public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, int category, int accessInfo, String abi, String instructionSet, String appDataDir, boolean mountKnoxPoint, String[] zygoteArgs) &#123; try &#123; return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, category, accessInfo, abi, instructionSet, appDataDir, mountKnoxPoint, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; Log.e(LOG_TAG, "Starting VM process through Zygote failed"); throw new RuntimeException( "Starting VM process through Zygote failed", ex); &#125;&#125; 发送消息到zygote服务进程的socket端口，请求创建新的进程: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, int category, int accessInfo, String abi, String instructionSet, String appDataDir, boolean mountKnoxPoint, String[] extraArgs) throws ZygoteStartFailedEx &#123; synchronized(Process.class) &#123; ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;(); // --runtime-args, --setuid=, --setgid=, // and --setgroups= must go first argsForZygote.add("--runtime-args"); argsForZygote.add("--setuid=" + uid); argsForZygote.add("--setgid=" + gid); .... if (appDataDir != null) &#123; argsForZygote.add("--app-data-dir=" + appDataDir); &#125; .... argsForZygote.add(processClass); if (extraArgs != null) &#123; for (String arg : extraArgs) &#123; argsForZygote.add(arg); &#125; &#125; //发送消息到zygote的socket端口，请求创建新的进程 if (Zygote.isEnhancedZygoteASLREnabled) &#123; .... return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); // End of isEnhancedZygoteASLREnabled case &#125; else &#123; // Original case return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); &#125; &#125; &#125; ZygoteConnection.javazygote进程接收到AMS的请求后，由ZygoteConnection负责处理请求： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; String args[]; Arguments parsedArgs = null; FileDescriptor[] descriptors; try &#123; // 从socket中读取参数 args = readArgumentList(); descriptors = mSocket.getAncillaryFileDescriptors(); &#125; catch (IOException ex) &#123; Log.w(TAG, "IOException on command socket " + ex.getMessage()); closeSocket(); return true; &#125; if (args == null) &#123; // EOF reached. closeSocket(); return true; &#125; int pid = -1; FileDescriptor childPipeFd = null; FileDescriptor serverPipeFd = null; ... try &#123; parsedArgs = new Arguments(args); //Zygote调用本地方法创建进程 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.category, parsedArgs.accessInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir, parsedArgs.mountKnoxPoint); &#125; catch (ErrnoException ex) &#123; logAndPrintError(newStderr, "Exception creating pipe", ex); &#125; catch (IllegalArgumentException ex) &#123; logAndPrintError(newStderr, "Invalid zygote arguments", ex); &#125; catch (ZygoteSecurityException ex) &#123; logAndPrintError(newStderr, "Zygote security policy prevents request: ", ex); &#125; try &#123; if (pid == 0) &#123; // in child IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); // should never get here, the child is expected to either // throw ZygoteInit.MethodAndArgsCaller or exec(). return true; &#125; else &#123; // in parent...pid of &lt; 0 means failure IoUtils.closeQuietly(childPipeFd); childPipeFd = null; return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs); &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125;&#125; ZygoteInit.java至此phone进程已经创建完成了，但实际上PhoneApp的代码还没有加载。继续看，在启动的进程里，调用ZygoteInit.zygoteInit来加载phoneApp的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws Zygote.MethodAndArgsCaller &#123; /** * By the time we get here, the native code has closed the two actual Zygote * socket connections, and substituted /dev/null in their place. The LocalSocket * objects still need to be closed properly. */ closeSocket(); if (descriptors != null) &#123; try &#123; Os.dup2(descriptors[0], STDIN_FILENO); Os.dup2(descriptors[1], STDOUT_FILENO); Os.dup2(descriptors[2], STDERR_FILENO); for (FileDescriptor fd: descriptors) &#123; IoUtils.closeQuietly(fd); &#125; newStderr = System.err; &#125; catch (ErrnoException ex) &#123; Log.e(TAG, "Error reopening stdio", ex); &#125; &#125; if (parsedArgs.niceName != null) &#123; Process.setArgV0(parsedArgs.niceName); &#125; // End of the postFork event. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); // 这里没有指定invokewith参数 if (parsedArgs.invokeWith != null) &#123; WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), pipeFd, parsedArgs.remainingArgs); &#125; else &#123; // 这里remaingArgs的第一参数是android.app.ActivityThread, 就是之前的entrypoint RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); &#125; &#125; RuntimeInit.java通过RuntimeInit来加载phone APP的代码, zygoteInit函数主要做三件事： 做一些通用的初始化，比如设置虚拟机中线程的exception handler;设置默认时区； 完成VM本地的初始化操作； 加载APP代码，也就是调用ActivityThread.main函数来加载整个phone APP； 12345678910111213public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, "RuntimeInit: Starting application from zygote"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "RuntimeInit"); redirectLogStreams(); commonInit(); nativeZygoteInit(); // 初始化应用代码 applicationInit(targetSdkVersion, argv, classLoader);&#125; 函数applicationInit通过方法invokeStaticMain反射调用ActivityThread.main: 1234567891011121314151617181920212223242526protected static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws Zygote.MethodAndArgsCaller &#123; // If the application calls System.exit(), terminate the process // immediately without running any shutdown hooks. It is not possible to // shutdown an Android application gracefully. Among other things, the // Android runtime shutdown hooks close the Binder driver, which can cause // leftover running threads to crash before the process actually exits. nativeSetExitWithoutCleanup(true); // We want to be fairly aggressive about heap utilization, to avoid // holding on to a lot of memory that isn't needed. VMRuntime.getRuntime().setTargetHeapUtilization(0.75f); VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); final Arguments args; try &#123; args = new Arguments(argv); &#125; catch (IllegalArgumentException ex) &#123; Slog.e(TAG, ex.getMessage()); // let the process exit return; &#125; // Remaining arguments are passed to the start class's static main invokeStaticMain(args.startClass, args.startArgs, classLoader); &#125; invokeStaticMain通过抛出一个MethodAndArgsCaller的异常，被ZygoteInit.main方法捕获后，调用MethodAndArgsCaller.run，至此就调用了ActivityThread.main方法了，还真是有点绕。 | 有关zygote进程可以参考http://sniffer.site/2017/05/27/Zygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/ 1234567891011121314151617181920212223242526272829303132333435363738private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws Zygote.MethodAndArgsCaller &#123; Class&lt;?&gt; cl; try &#123; cl = Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( "Missing class when invoking static main " + className, ex); &#125; Method m; try &#123; m = cl.getMethod("main", new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException( "Missing static main on " + className, ex); &#125; catch (SecurityException ex) &#123; throw new RuntimeException( "Problem getting static main on " + className, ex); &#125; int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123; throw new RuntimeException( "Main method is not public and static on " + className); &#125; /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception's run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ throw new Zygote.MethodAndArgsCaller(m, argv); &#125; MethodAndArgsCaller异常的作用是清除父进程中的一些调用堆栈，这样子进程就从ActivityThread.main开始了自己的堆栈调用。 12345678910111213141516171819202122232425262728293031 public static class MethodAndArgsCaller extends Exception implements Runnable &#123; /** method to call */ private final Method mMethod; /** argument array */ private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) &#123; mMethod = method; mArgs = args; &#125; public void run() &#123; try &#123; mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; catch (InvocationTargetException ex) &#123; Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) &#123; throw (RuntimeException) cause; &#125; else if (cause instanceof Error) &#123; throw (Error) cause; &#125; throw new RuntimeException(ex); &#125; &#125;&#125; ActivityThread.java到这里，ActivityThread.main会启动一个主线程，接着创建一个ActivityThread用于Phone APP与AMS进行交互。最重要的是，接着在thread.attach(false);这个函数里，ActivityThread会去创建Phone进程入口类PhoneApp。后续就是Phone整个框架代码的加载与初始化了。 1234567891011121314151617181920212223242526272829303132333435363738394041public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0("&lt;pre-initialized&gt;"); // 启动主线程Looper Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited");&#125; 这样Phone进程就创建启动完成了。整个流程看下来，研究Android系统，源码是王道，但要深入理解系统背后的设计，还是需要从把基本的概念梳理清楚，才能更好的理解系统背后设计的逻辑。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Telephony</tag>
        <tag>Phone进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Launcher工作原理]]></title>
    <url>%2F2017%2F02%2F18%2FAndroid-Launcher%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Android系统启动完成后，第一个启动的Activity就是主界面应用程序Launcher，相当于电脑的桌面。Launcher界面可以看到系统中安装的所有APP,点击APP即可启动该APP应用了。那么，Launcher到底是如何启动的以及如何自定义自己的Launcher了？这篇文章我们就来讲讲这两个问题。 Launcher的启动系统进程SystemServer启动后，开始加载系统核心服务如 ActivityManagerService,WindowManagerService,PowerManagerService，同时加载系统的其他如VibratorService，ConnectivityService以及TelephonyRegistry等系统服务，最后着手启动HOME activity: 123456789101112131415161718192021222324252627282930313233private void startOtherServices() &#123; // 准备启动SystemUI以及HOME界面 mActivityManagerService.systemReady(new Runnable() &#123; @Override public void run() &#123; mSystemServiceManager.startBootPhase( SystemService.PHASE_ACTIVITY_MANAGER_READY); try &#123; mActivityManagerService.startObservingNativeCrashes(); &#125; catch (Throwable e) &#123; reportWtf("observing native crashes", e); &#125; Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartSystemUI"); try &#123; startSystemUi(context); &#125; catch (Throwable e) &#123; reportWtf("starting System UI", e); &#125; .... // 第三方应用可以启动了 mSystemServiceManager.startBootPhase( SystemService.PHASE_THIRD_PARTY_APPS_CAN_START); .... &#125;);&#125; AMS准备工作完毕，着手启动HOME： 12345678910111213141516171819202122232425262728293031323334public void systemReady(final Runnable goingCallback) &#123; .... //获取系统配置 retrieveSettings(); final int currentUserId; synchronized (this) &#123; currentUserId = mUserController.getCurrentUserIdLocked(); readGrantedUriPermissionsLocked(); &#125; // 执行回调 if (goingCallback != null) goingCallback.run(); synchronized (this) &#123; // Start up initial activity. mBooting = true; // Enable home activity for system user, so that the system can always boot if (UserManager.isSplitSystemUser()) &#123; ComponentName cName = new ComponentName(mContext, SystemUserHomeActivity.class); try &#123; AppGlobals.getPackageManager().setComponentEnabledSetting(cName, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, 0, UserHandle.USER_SYSTEM); &#125; catch (RemoteException e) &#123; throw e.rethrowAsRuntimeException(); &#125; &#125; // 启动HOME应用 startHomeActivityLocked(currentUserId, "systemReady"); &#125; 启动HOME界面: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 String mTopAction = Intent.ACTION_MAIN; Intent getHomeIntent() &#123; Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null); intent.setComponent(mTopComponent); intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING); if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; // intent的类别为HOME intent.addCategory(Intent.CATEGORY_HOME); &#125; return intent; &#125; boolean startHomeActivityLocked(int userId, String reason) &#123; Intent intent = getHomeIntent(); ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS | (needToCheckBbc ? PackageManager.GET_META_DATA : 0), userId); if (aInfo != null) &#123; intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name)); // Don't do this if the home app is currently being // instrumented. aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) &#123; intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); if (needToCheckBbc) &#123; aInfo = PersonaManagerService.changeInfoIfBBC(mContext, aInfo, intent); &#125; mActivityStarter.startHomeActivityLocked(intent, aInfo, reason); &#125; &#125; else &#123; Slog.wtf(TAG, "No home screen found for " + intent, new Throwable()); &#125; return true; &#125; 向AMS发送启动Activity的Binder请求： 1234567891011121314151617181920212223class ActivityStarter &#123; .... void startHomeActivityLocked(Intent intent, ActivityInfo aInfo, String reason) &#123; //将HOME activity放在任务栈的顶部 mSupervisor.moveHomeStackTaskToTop(HOME_ACTIVITY_TYPE, reason); //向AMS发送binder请求，启动activity startActivityLocked(null /*caller*/, intent, null /*ephemeralIntent*/, null /*resolvedType*/, aInfo, null /*rInfo*/, null /*voiceSession*/, null /*voiceInteractor*/, null /*resultTo*/, null /*resultWho*/, 0 /*requestCode*/, 0 /*callingPid*/, 0 /*callingUid*/, null /*callingPackage*/, 0 /*realCallingPid*/, 0 /*realCallingUid*/, 0 /*startFlags*/, null /*options*/, false /*ignoreTargetSecurity*/, false /*componentSpecified*/, null /*outActivity*/, null /*container*/, null /*inTask*/); if (mSupervisor.inResumeTopActivity) &#123; // If we are in resume section already, home activity will be initialized, but not // resumed (to avoid recursive resume) and will stay that way until something pokes it // again. We need to schedule another resume. mSupervisor.scheduleResumeTopActivities(); &#125; &#125;&#125; 至此HOME启动完成了。 自定义Launcher那么，如何来定义自己的Launcher了？这里，我们写一个简单的Launcher界面，上面列出了系统的应用程序，点击上面的图标即可启动应用。 首先，新建一个Activity: CustomHomeActivity：其中主要包含了一个GridView用于显示APP的图标跟名字，APP数据采用Loader进行异步加载，加载完后，数据跟GridView进行绑定。注意，在AndroidManifest.xml中声明activity，必须加上如下intent-filter: 12345678&lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;category android:name="android.intent.category.HOME"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt;&lt;/intent-filter&gt; 这样，每次用户点击Home按键时，系统就会弹出对话框让你选择启动哪一个Launcher。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class CustomHomeActivity extends AppCompatActivity implements LoaderManager.LoaderCallbacks&lt;List&lt;AppItem&gt;&gt;, AppItemAdapter.ItemClickListener&#123; private static final String TAG = "CustomHomeActivity"; private static final int APP_LOADER = 0x01; //FIXME: sometimes the gridview is empty; it seems tha data is lost private GridView mGvAppsList; private AppItemAdapter mAdapter; private List&lt;AppItem&gt; mAppList; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.v(TAG, "onCreate()"); setContentView(R.layout.activity_custom_home); mGvAppsList = (GridView)findViewById(R.id.gv_app_list); mAdapter = new AppItemAdapter(this); mGvAppsList.setAdapter(mAdapter); mAdapter.setListener(this); getSupportLoaderManager().initLoader(APP_LOADER,null,CustomHomeActivity.this); &#125; @Override protected void onResume()&#123; super.onResume(); Log.v(TAG,"onResume()"); Loader loader = getSupportLoaderManager().getLoader(APP_LOADER); if(mAppList == null || !loader.isStarted())&#123; loader.startLoading(); &#125; &#125; @Override public Loader&lt;List&lt;AppItem&gt;&gt; onCreateLoader(int id, Bundle args) &#123; Log.v(TAG,"onCreateLoader()"); return new AppLoader(getApplicationContext()); &#125; @Override public void onLoadFinished(Loader&lt;List&lt;AppItem&gt;&gt; loader, List&lt;AppItem&gt; data) &#123; Log.v(TAG, "onLoadFinished"); mAdapter.setData(data); mAdapter.notifyDataSetChanged(); //mGvAppsList.requestLayout(); mAppList = data; &#125; @Override public void onLoaderReset(Loader&lt;List&lt;AppItem&gt;&gt; loader) &#123; loader.forceLoad(); &#125; @Override public void onItemClick(int position) &#123; Log.v(TAG,"onItemClick(): pos = " + position); PackageManager pm = getPackageManager(); String pkgName = mAppList.get(position).getAppInfo().packageName; Intent intent = pm.getLaunchIntentForPackage(pkgName); if(intent != null)&#123; startActivity(intent); &#125; &#125;&#125; 现在，就要定义一个Loader用于APP数据的读取与加载，加载完后，把数据传给主线程;这里为了，提高加载的速度，利用DiskLruCache来做数据缓存(只是个示例,具体性能估计提高不大)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239public class AppLoader extends AsyncTaskLoader&lt;List&lt;AppItem&gt;&gt; &#123; private static final String TAG = "AppLoader"; private static final int DISK_CACHE_SIZE = 1024*1024*50; private static final String DISK_CACHE_NAME = "MyLauncher"; private static final int DISK_CACHE_INDEX = 0; private PackageManager mPackageMgr; private List&lt;AppItem&gt; mAppList; private HashSet&lt;String&gt; mAppsName; // disk file cache for app icon private DiskLruCache mDiskCache; public AppLoader(Context context) &#123; super(context); mPackageMgr = context.getPackageManager(); File cachePath = getDiskCachePath(context); if(!cachePath.exists())&#123; cachePath.mkdirs(); &#125; try &#123; if(getUsableSpace(cachePath) &gt; DISK_CACHE_SIZE) &#123; mDiskCache = DiskLruCache.open(cachePath, 1, 1, DISK_CACHE_SIZE); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; @Override public List&lt;AppItem&gt; loadInBackground() &#123; Log.v(TAG, "loadInBackground()"); List&lt;ApplicationInfo&gt; appInfoList = mPackageMgr.getInstalledApplications(PackageManager.MATCH_UNINSTALLED_PACKAGES); if(appInfoList == null)&#123; appInfoList = new ArrayList&lt;&gt;(); &#125; Log.v(TAG,"loadInBackground(): installed apps size = " + appInfoList.size()); mAppList = new ArrayList&lt;&gt;(appInfoList.size()); mAppsName = new HashSet&lt;&gt;(); for(ApplicationInfo info: appInfoList)&#123; String pkgName = info.packageName; String label = mPackageMgr.getApplicationLabel(info).toString(); // only launchable app is added if(!mAppsName.contains(label) &amp;&amp; mPackageMgr.getLaunchIntentForPackage(pkgName) != null)&#123; String key = getCacheKey(pkgName); Drawable d = loadFromDiskCache(key); AppItem item; if(d != null)&#123; item = new AppItem(mPackageMgr,d,label); saveIconToDiskCache(key,d); &#125;else &#123; item = new AppItem(mPackageMgr, info); saveIconToDiskCache(key,item.getAppIcon()); &#125; mAppList.add(item); mAppsName.add(label); Log.v(TAG,"application label : label " + label); &#125; &#125; Log.v(TAG, "loadInBackground(): app size = " + mAppList.size()); return mAppList; &#125; @Override public void deliverResult(List&lt;AppItem&gt; appList)&#123; Log.v(TAG,"deliverResult()"); if(isReset())&#123; if(appList != null)&#123; onReleaseResources(appList); &#125; &#125; List&lt;AppItem&gt; oldApps = mAppList; mAppList = appList; if(isStarted())&#123; super.deliverResult(appList); &#125; if(oldApps != null)&#123; onReleaseResources(oldApps); &#125; &#125; @Override protected void onStartLoading()&#123; Log.v(TAG,"onStartLoading()"); if(mAppList != null)&#123; deliverResult(mAppList); &#125; if(takeContentChanged() || mAppList == null)&#123; forceLoad(); &#125; &#125; @Override protected void onStopLoading()&#123; cancelLoad(); &#125; @Override public void onCanceled(List&lt;AppItem&gt; apps) &#123; super.onCanceled(apps); onReleaseResources(apps); &#125; @Override protected void onReset()&#123; super.onReset(); onStopLoading(); if(mAppList != null)&#123; onReleaseResources(mAppList); mAppList = null; mAppsName = null; &#125; &#125; // take care of releasing resources protected void onReleaseResources(List&lt;AppItem&gt; apps) &#123; // for cursor, we may want to close it &#125; private String getCacheKey(String pkgName)&#123; Log.v(TAG,"getCacheKey()"); String key; try &#123; MessageDigest digest = MessageDigest.getInstance("SHA"); digest.update(pkgName.getBytes()); key = bytesToHexString(digest.digest()); &#125;catch (NoSuchAlgorithmException e)&#123; key = pkgName; &#125; return key; &#125; private boolean saveIconToDiskCache(String key,Drawable icon)&#123; Log.v(TAG,"saveIconToDiskCache()"); if(mDiskCache == null)&#123; Log.e(TAG,"saveIconToDiskCache(): disk cache is not available"); return false; &#125; Bitmap bitmap = BitmapUtil.drawableToBitmap(icon); ByteArrayOutputStream bos = new ByteArrayOutputStream(bitmap.getByteCount()); bitmap.compress(Bitmap.CompressFormat.PNG,100,bos); try &#123; DiskLruCache.Editor editor = mDiskCache.edit(key); if(editor != null)&#123; OutputStream os = editor.newOutputStream(DISK_CACHE_INDEX); os.write(bos.toByteArray()); editor.commit(); &#125; // write to disk mDiskCache.flush(); &#125;catch (IOException e)&#123; e.printStackTrace(); return false; &#125; return true; &#125; private Drawable loadFromDiskCache(String key) &#123; Log.v(TAG,"loadFromDiskCache()"); if(mDiskCache == null || mDiskCache.size() &lt;= 0)&#123; return null; &#125; try &#123; DiskLruCache.Snapshot snapshot = mDiskCache.get(key); if(snapshot != null) &#123; FileInputStream fis = (FileInputStream) snapshot.getInputStream(DISK_CACHE_INDEX); Bitmap bitmap = BitmapFactory.decodeStream(fis); return new BitmapDrawable(getContext().getResources(),bitmap); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; return null; &#125; private File getDiskCachePath(Context context)&#123; boolean isExternalMounted = Environment.getExternalStorageState(). equals(Environment.MEDIA_MOUNTED); File diskCacheDir; if(!isExternalMounted)&#123; diskCacheDir = new File(context.getCacheDir(),DISK_CACHE_NAME); &#125;else&#123; diskCacheDir = new File(Environment.getExternalStorageDirectory(),DISK_CACHE_NAME); &#125; return diskCacheDir; &#125; private long getUsableSpace(File path)&#123; long size = path.getUsableSpace(); Log.v(TAG,"getUsableSpace(): size = " + size); return size; &#125; private String bytesToHexString(byte[] bytes) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; bytes.length; i++) &#123; String hex = Integer.toHexString(0xFF &amp; bytes[i]); if (hex.length() == 1) &#123; sb.append('0'); &#125; sb.append(hex); &#125; return sb.toString(); &#125;&#125; 最后，建立一个ListAdapter，用于将数据与GridView进行绑定： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * an app item adapter to bind data to grid view */public class AppItemAdapter extends BaseAdapter&#123; private static final String TAG = "AppItemAdapter"; private static final int DEFAULT_WIDTH = 150; private static final int DEFAULT_HEIGHT = 150; private Context mContext; private List&lt;AppItem&gt; mAppList = Collections.EMPTY_LIST; private static SparseArray&lt;View&gt; sViewCache; private ItemClickListener mListener; public interface ItemClickListener&#123; void onItemClick(int position); &#125; public AppItemAdapter(Context context)&#123; mContext = context; &#125; public void setListener(ItemClickListener listener)&#123; mListener = listener; &#125; public void setData(List&lt;AppItem&gt; data)&#123; mAppList = data; sViewCache = new SparseArray&lt;&gt;(data.size()); &#125; @Override public int getCount() &#123; return mAppList.size(); &#125; @Override public AppItem getItem(int position) &#123; return mAppList.get(position); &#125; @Override public long getItemId(int position) &#123; return 0; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; // if use convertView, the binded data list seems to be wrong View root = sViewCache.get(position); if(root == null) &#123; LayoutInflater inflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE); root = inflater.inflate(R.layout.layout_app_item, parent, false); ViewHolder vh = new ViewHolder(root, position); sViewCache.setValueAt(position,root); //TODO: icon size may be different for different apps // keep the size the same Drawable d = mAppList.get(position).getAppIcon(); Bitmap bitmap = BitmapUtil.drawableToBitmap(d); Bitmap scaleBitmap = Bitmap.createScaledBitmap(bitmap, DEFAULT_WIDTH, DEFAULT_HEIGHT, false); vh.ivIcon.setImageBitmap(scaleBitmap); vh.tvName.setText(mAppList.get(position).getAppName()); Log.v(TAG, "application label = " + vh.tvName.getText()); &#125; return root; &#125; private class ViewHolder&#123; ImageView ivIcon; TextView tvName; public ViewHolder(View root, final int pos)&#123; ImageView icon = (ImageView)root.findViewById(R.id.iv_app_icon); TextView name = (TextView)root.findViewById(R.id.tv_app_name); ivIcon = icon; tvName = name; root.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mListener.onItemClick(pos); &#125; &#125;); &#125; public ViewHolder(ImageView icon,TextView name)&#123; ivIcon = icon; tvName = name; &#125; &#125;&#125; 这样一个简单的Launcher就写好了，项目详情请参考: https://github.com/runningforlife/AndroidExamples]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Launcher</tag>
        <tag>SystemServer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Java中调用C_C++方法]]></title>
    <url>%2F2017%2F01%2F07%2F%E5%A6%82%E4%BD%95%E5%9C%A8Java%E4%B8%AD%E8%B0%83%E7%94%A8C-C-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[有时，需要在Java中直接调用本地（native)方法，把一些耗时的操作使用效率更高C/C++实现。在Java中调用本地方法通常被称为Java Native Interface(JNI)。那么，什么时候需要用到JNI了？ 需要在底层实现耗时更小、更快的程序 在Java中需要调用本地代码库 需要使用平台相关但Java标准库文件不支持的特性 接下来，我们就来看一看，如何在Java中通过JNI来调用本地方法？ 准备工作在开始JNI编程之前，需要确保在系统环境中有配置好了如下程序： Java虚拟机程序， Java编译器(javac),一个本地方法的头文件生成程序(javah) 定义JNI的库文件以及本地头文件: jni.h,jvm.lib,jvm.dll,jvm.so c/C++编译器，用于创建共享库代码 前面两条中的程序只要安装了JDK开发环境，都已包含在系统中了，可以直接使用。另外，需要注意的是，利用System.loadLibrary来加载本地库文件时，不同系统对于生成的库文件命名存在差异，例如在HelloWorld.java使用System.loadLibrary(“HelloWorld”)： Solaris: libHelloWorld.so Linux: libHelloWorld.so Win: HelloWorld.dll Mac: libHelloWorld.jnilib 在生成本地库文件时需要留意。接下来，我们就一步步来看下如何在Java中调用本地方法（以下实现均基于Ubuntu 16.04 64bit版本)。 六步实现在Java中调用本地方法１．编写Java文件指定一个文件夹下，新建一个HelloJni.java文件,并在其中声明需要调用的本地方法： 1234567891011121314151617181920212223public class HelloJni&#123; public native int add(int x, int y); public native String talkBack(String str); public native void sayHello(String str); static&#123; System.loadLibrary("HelloJni"); &#125; public static void main(String[] args)&#123; HelloJni jni = new HelloJni(); int add = jni.add(5,3); jni.sayHello("hello jni"); System.out.println("add: " + add); System.out.println("talkBack: " + jni.talkBack("hello")); &#125;&#125; ２. 编译Java文件，生成.class文件在HelloJni.java目录下，打开命令行工具，输入: 123javac HelloJni.java 查看该文件夹，可以看到已经生成了相应的.class文件。 ３. 生成本地方法对应的头文件利用JDK中提供的javah程序，我们可以生成Java文件中对应的本地方法头文件,在命令行中输入: 123javah HelloJni 在对应的目录下，可以看到一个名为HelloJni.h的文件,长成这样子: 123456789101112131415161718192021222324252627282930313233343536373839/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class HelloJni */#ifndef _Included_HelloJni#define _Included_HelloJni#ifdef __cplusplusextern "C" &#123;#endif/* * Class: HelloJni * Method: add * Signature: (II)I */JNIEXPORT jint JNICALL Java_HelloJni_add (JNIEnv *, jobject, jint, jint);/* * Class: HelloJni * Method: talkBack * Signature: (Ljava/lang/String;)Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_HelloJni_talkBack (JNIEnv *, jobject, jstring);/* * Class: HelloJni * Method: sayHello * Signature: (Ljava/lang/String;)V */JNIEXPORT void JNICALL Java_HelloJni_sayHello (JNIEnv *, jobject, jstring);#ifdef __cplusplus&#125;#endif#endif ４. 编写对应的C/C++方法按照上述生成的HelloJni.h文件，注意函数的名称与返回值必须与HelloJni.h中完全一致： 1234567891011121314151617181920212223242526272829303132#include "HelloJni.h"#include &lt;stdio.h&gt;#include &lt;string.h&gt;JNIEXPORT jint JNICALL Java_HelloJni_add (JNIEnv *env, jobject obj, jint n1, jint n2)&#123; return n1 + n2;&#125;JNIEXPORT jstring JNICALL Java_HelloJni_talkBack (JNIEnv *env, jobject obj, jstring str)&#123; //注意在C中，应为:const char *s = (*env)-&gt;GetStringUTFChars(str,0) const char *s = env-&gt;GetStringUTFChars(str,0); if(strcmp(s,"hello") == 0 || strcmp(s,"hi") == 0)&#123; return env-&gt;NewStringUTF("jni from c/c++"); &#125; return env-&gt;NewStringUTF("unknow talking");&#125;JNIEXPORT void JNICALL Java_HelloJni_sayHello (JNIEnv *env, jobject obj, jstring str)&#123; const char *s = env-&gt;GetStringUTFChars(str,0); char chs[100]; strcpy(chs,s); printf(chs);&#125; ５. 生成共享库文件这里利用Ubuntu系统自带的编译器gcc来产生共享库文件。有关gcc命令的参数可参考 http://man7.org/linux/man-pages/man1/gcc.1.html;在这里，需要主义两点，一是编译时需要包含两个JNI相关的头文件jni.h以及jni_md.h,否则编译时会出现错误： 对于Ubuntu系统，JDK一般安装在：/usr/lib/jvm 123456:~/Java$ gcc -shared -fPIC libHelloJni.so HelloJni.cppIn file included from HelloJni.cpp:1:0:HelloJni.h:2:17: fatal error: jni.h: No such file or directorycompilation terminated. 一个时生成的库文件名前面需要加上lib，如libHelloJni.so,使用System.loadLibrary调用时则去掉lib:System.loadLibrary(“HelloJni”)，否则调用时可能出现无法找到库文件的错误java.lang.UnsatisfiedLinkError，完整的编译命令如下： 123gcc -I/usr/lib/jvm/java-1.8.0-openjdk-amd64/include/ -I/usr/lib/jvm/java-1.8.0-openjdk-amd64/include/linux -fPIC -shared -o libHelloJni.so HelloJni.cpp ６. 运行java程序在命令行中输入(需要指定.class文件的搜索路径): 123java -Djava.library.path=/home/jason/Java HelloJni java命令可参考:http://docs.oracle.com/javase/7/docs/technotes/tools/windows/java.html 需要注意的地方 确保.c/.cpp文件中函数名称与生成的.h头文件中的一致 不同操作系统中，生成的共享库文件名称不一样,例如: 在HelloJni.java,System.loadLibrary(“HelloJni”);Solaris: libHelloJni.soLinux: libHelloJni.soWin: HelloJni.dllMac: libHelloJni.jnilib 执行Java程序时,添加参数 -Djava.library.path=PATH，这里PATH就是JNI库所在位置 参考文献 http://docs.oracle.com/javase/7/docs/technotes/guides/jni/index.html http://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html http://www.bogotobogo.com/cplusplus/eclipse_CDT_JNI_MinGW_64bit.php]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JNI</tag>
        <tag>共享库文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[罗素《权威与个人》]]></title>
    <url>%2F2016%2F12%2F26%2F%E7%BD%97%E7%B4%A0%E3%80%8A%E6%9D%83%E5%A8%81%E4%B8%8E%E4%B8%AA%E4%BA%BA%E3%80%8B%2F</url>
    <content type="text"><![CDATA[《权威与个人》是罗素在1948年里斯讲座所做的几次演讲的文章合集，里边谈到了个人自由与国家权威之间的关系，以及如何平衡这两者以促进人类的进步，确保个人生活的活力。对于缺乏自由与民主熏陶，在集体主义与强权政府成长起来的我而言，这种书无疑是一种解毒剂，让我意识到自由于个人、社会的重要意义。 社会凝聚力与人性 在这些演讲里，我打算考虑这样一个根本问题：我们怎样才能把进步所必需的那种程度的个人首创性和生存所必需的那种程度的社会凝聚力结合起来？…随后，我还将探讨我们时代的一个基本问题，即由现代技术所引发的在组织和人性之间的冲突，或者换一种说法，经济动机和创造以及占有冲动的分离。在论述了这一问题以后，我将考察为了解决这一问题，我们能做什么。 我们早期的、初有人性的祖先，不可能依据一种深思熟虑的策略来做事，而必定一直是被一种本能的机制所驱使，这是一种由部落里的友谊和对所有其他人的敌意组成的二元机制。 社会凝聚力始于对群体的忠诚（这种忠诚由于对敌人的恐惧而加强），并通过部分出于本性、部分深思熟虑的进程而发展，直到它形成我们今天所知的像国家这样巨大的凝聚体。对于这些进程而言，很多力量都起了作用。在很早的阶段，对群体的忠诚一定是通过对领袖的忠诚来强化的。在一个大的部落里，即使平民个体常常互为陌路，酋长或者王却可能为每个人所熟知。这样一来，和对部落的忠诚相对的对个人的忠诚，就使群体的规模在不损害本能的情况下获得增长成为可能。 我们本能地把人类区分成朋友和敌人-对于朋友，我们有合作的道义；对于敌人，我们有抗争的道义。但是这种划分也在不断变化：有时候，一个人会仇恨他生意上的对手，而在另一个时候，当他们受到社会主义或者一个外部敌人威胁时，他会马上开始把对方看作兄弟。一旦超出家庭的界限，始终是由外部的敌人为我们提供凝聚起来的力量。 …过于违反本性冲动的生活是这样一种生活，它可能含有各种紧张的结果，这些结果完全可能像陷入被禁止的冲动一样有害。过着违反本性生活的人，超过一定程度很可能会充满妒忌、怨恨以及所有的冷酷无情。他们可能会形成残忍的性情，或者另一方面，他们可能会完全丧失生活中的所有乐趣，以至于不再有能力做出任何努力。（公务猿这种新物种是否是因为长期在权力的熏陶之下，过着违反本性的生活，扭曲了人性，所以才会变得傲慢而自私，冷漠而残酷。） 我们有各种侵略的冲动，也有各种创造的冲动，社会却禁止我们放纵它们，而它们以足球赛和令人筋疲力尽的角力形式所提供的替代品是远远不够的。任何希望最终可能消除战争的人都应该认真思考这一问题，即如何无害地满足我们从一代代久远的原始祖先那里所承袭的各种本能。（这里所说的满足本能，可以认为是如何释放人类的天性，发挥个人的潜能） （社会改革者的）问题是要把人类所不可或缺的那种程度的安全和那些与文明生活方式相容的冒险、危险和竞赛形式结合起来…我们必须牢记，尽管我们的生活方式和制度以及知识已经经历了很多深刻的变化，我们的善与恶两方面的本能，很大程度上仍然保持着我们祖先的大脑最初发展成它们现在大小时候的样子。我并不认为各种原始冲动和文明的生活方式是不可调和的，人类历史学家的研究已经表明，人类的本性对各种不同的文化模式具有广泛的适应性。但我并不认为，这种适应性能够通过完全排除一切基本的冲动来实现。一种缺乏冒险的生活可能并不让人满意，但是一种允许采取任何冒险形式的生活却注定是短命的。（即使到了今天，如果缺乏基本的文明法治，缺乏对民主自由的追求与认知，开着奔驰宝马丰田、住着高楼大厦、坐着飞机高铁的我们，跟人类有共同祖先的猿猴有什么根本的区别了？） 社会凝聚力与政府 在最早有史可查的社会里，比如古埃及，我们发现，除了来自祭司集团的某些限制以外，国王在其辽阔的土地上的权力是绝对的，我们也可以发现数量庞大的奴隶，国王可以为了像金字塔这样的国家事业而随意奴役他们。在这样的社会里，只有社会等级顶端的少数人–国王、贵族和祭司–需要社会凝聚的心理机制；所有其他人不过是服从罢了。大部分人无疑是不幸的…但是通常来说，只要没有外敌为患，这种普遍状况并不会妨碍国家繁荣，并且也不会损害掌权者的生活享受。 从15世纪至今，国家针对个人的权力一直在持续增长，这首先主要是火药发明的结果。就像在早期无政府状态的日子里，大多数有思想的人崇尚法律那样，在国家权利日益增长的时期，存在着不断增长的崇尚自由的趋势…然而，争取自由的冲动今天在改革者当中似乎已大大减弱了；它已经被对平等的热爱所取代，这主要是由没有任何传统优势的新工业资本家的财富和权力的增长所激发的….在世界上大部分地区，似乎都存在着向古埃及神圣王权体制（它受一个新祭司阶层的控制）的复归。尽管这种趋势在西方不像在东方那么极端…个人主动性被国家或者强大的公司限制了，因此就有了一种巨大的危险，即这种状况会像在古罗马一样，产生一种倦怠感和宿命论。这对充满活力的生活是灾难性的…作为纯粹规模方面的恶意个结果，政府变得越来越远离被统治者，并且倾向于–甚至在一个民主国家中–拥有它自己的独立生命。我并不知道如何彻底消除这一弊端，但我认为，认识到它的存在、并找到各种减轻其危害程度的办法是重要的。（罗素八十年前的担忧即使到了今天也还是普遍存在的。不过现在来看，互联网技术的出现让整个世界变得更“平”了，让普通人有了更多个性与自由的空间。政府的公职人员也不敢再为所欲为，违法乱纪的行为更容易传播而被人们获知了；普通老百姓获取资讯的途径更加多样，政府想控制统治者更加困难了。世界的大趋势正朝着更加透明，民主，自由的方向走的） 政府，从它存在的最早时代起就一直有两种职能，一种是消极的，另一种是积极的。政府的消极职能在于防止私人暴力，保护声明财产，制定刑法并保障其实施。但是除此之外，它还一直具有一种积极目的，即促使对大多数公民而言的共同愿望的实现…在任何一种情况下，都有一个管理机构，这一机构实际上，如果不是有意的话，都远离它所控制的那些人。只有管理机构（无论是国家管理机构还是大型企业的管理机构)的成员才能保持个人的积极主动权，而且对管理机构来说，都不可避免地存在一种趋势，即或多或少都会像看待它们的机器那样来看待为他们工作的人，也就是说，仅仅看成一种必要的手段。顺利合作的愿望不断倾向于扩大单位规模，并由此使仍然具有主动性的人数减少…最糟糕的莫过于一种已经广泛存在于英国各领域的体制，在这种体制下，那些具有名义上的积极性的人永远被文官体制（这种体制有的只是否决之权而非开创之责，并由此养成了一种永远倾向于去禁止的消极心理）控制了。在这样的一种体制下，有能力的人变得绝望，在一个更有希望的环境中本该充满活力的人变得倦怠和轻浮，国家的积极职能也就不可能活跃而高效的实现。（在三星这样的大企业里工作，无时无刻不感到官僚体制的张力。个人的能动性受制于臃肿的管理，即使有能力的人想要做点事情，也常常事与愿违，而公司也似乎并不强调、鼓励员工个人突破已有的限制，寻求职业技能上的进步与创新。长此以往，很多员工都处于一种消极被动的工作状态，除了应付手头上的业务之外再无学习其他技术的热情与追求，对外面的技术变化也显得毫无兴趣，反应迟钝。这种状态同样可以在中国的新物种公务猿身上看到。公务猿对待自己的本职工作热情来自于获取财富，以及这份职业所带来的虚无缥缈的权力虚荣感。至于什么职业道德与责任感，什么服务百姓，改善社区环境这种吃苦不讨好的事情，他们都毫无兴趣。个人能动性全然没有了，有的只是国家意志与控制力的执行。） （简述了社会凝聚力在各个历史时代所发生的变化，从中我们可以观察到一种双重运动）一方面，存在着一种周期性的发展，即从松散而原始的组织类型到逐渐有序的政府（更广阔的领土，并且对个人生活的更多方面加以规制）的发展…当新的文明已经定型，当政府已经有机会巩固自己的权力，当习俗、传统和法律已经建立起细致得足以窒息进取心的规则之时，社会就进入了一个停滞阶段。人们赞美前辈的功绩，却再也比不上他们；艺术变得因袭守旧，科学也因为对权威的尊崇而被断送…除了这种周期性运动之外，还有一种运动。在每次循环的顶峰，一个国家的统治的区域比以往任何时候都要大，当局对个人实施控制的程度也高于先前任何一个最高点。罗马帝国比巴比伦和埃及帝国大，今天的各个帝国比罗马帝国更大。在过去历史上，从来没有一个大国能像苏联、或者甚至像西欧各国那样，控制它的公民。既然地球的大小是有限的，如果不加制约的话，这种趋势最终必定会产生一个单一世界国家。但是由于那时不会有对外敌的恐惧来增强凝聚力，这种古老的心理机制将不再适用。在世界政府的各种事务里，将不再有爱国主义的空间；没有憎恨和恐惧这些强大的动机，人们不得不在自利和善行中寻找动力。这样的社会能持续下去吗？ 个性的作用 艺术在我们时代的衰落，并不仅仅是由于艺术家的社会功能已经不像从前那样重要，而且也同样由于自发的喜悦已不再被认为是某种应该让人享受的东西。在比较淳朴的人们当中，民间舞蹈和大众音乐仍然流行，很多人身上也多少有一些诗人气质。但随着人们变得越来越工业化和组织化，孩子当中普遍存在的那种喜悦对成年人来说变得不可能了，因为他们总是想着下一件事情而无法让自己沉侵于此刻。对任何一种审美价值来说，这种想着“下一件事情”的习惯比任何其他能想到的思考习惯都更要命，在所有重要的意义上，如果艺术谣生存下去，它就不能通过建立各种庄严的学院，而是要通过重新获得那种已经差不多被谨小慎微和深谋远虑毁掉的全身心的悲喜能力来实现。（现如今，有了随时可以获取大量资讯的智能移动终端，个人的生活看似更为丰富，但由此带来的是个人时间与精力的碎片化。人们被应接不暇的新闻报道所吸引，沉浸在各种短暂的感官刺激当中；在关注时事之外，人们还要不停的刷刷朋友圈，看看“朋友们”所做的事情。实际上，现在的人已经很难拿出一长段时间来全身心做一件事情了。资讯焦虑让我们陷入一种浮光掠影的浅浮当中。我们已经很少有孩子般纯粹的喜悦以及全身心投入的体验了） 我们知道的太多，却体验得太少。至少我们对一种美好生活所由以产生的那些创造性冲动体验得太少。重要的原因在于我们是被动的；即使我们是主动的，也只是在琐碎的事情上主动。要想把生活从只能由灾难来缓解的无聊状态中解救出来，就必须找到恢复个人主动性的手段，不仅在琐碎的事情上，而且也在真正重要的事情上。并不是说，我们应该毁灭现代组织当中大多数人所赖以生存的那部分，但是我确实想说，组织一直是通过它令人难以忍受的迅速增长和权力集中而发展起来的，我们的思想情感方式已经无法与之齐头并进，因此组织应该具有更大的灵活性，更多地通过地方自治加以调剂，而且更少地通过它那非人的巨大规模来压抑人的精神。（现代管理者应该意识到，公司与组织的真正价值在于其中具有创造天赋以及个性的人。一个公司与组织想要获得真正的成功，要做的便是为这些具有创造能力的人才营造一个发挥自身才能的空间与环境，让这些人的个性得到最大程度的发挥。） 技术与人性的冲突 与其他动物不同，人类为了达成某个目标或者目的会乐于从事那些未必令人感到愉快的事情。动物做各种事情（鸟儿筑巢，河狸筑坝）只是出自一种生物的本能，而不是像人类一样认识到这些事情是有用的。人类会通过意志来实现自我控制、谨慎从事、深谋远虑以及抑制各种冲动，但所做的事情超过人性能够容忍的范围时，人类会受到心理上的惩罚…在早期石器时代，艺术创造的快乐和盼望能力增长的快乐本身很可能会被扩散到劳动的各个艰苦阶段…为了下滑瞬间的无上快乐，一个男孩会带着平底雪橇吃力地爬上小山…创造性的冲动可以激发比此更加长久的努力，并且能够保持自发性。一个人如果热切的盼望实现一个目的，并且用于克服困难的华，他就可能历经数年的艰难、险阻以及贫困，试图登上珠穆朗玛峰或者抵达南极极点，又或者做出一项科学发现，而且始终像那个带着雪橇的男孩一样，和他自己的各种冲动协调，因为“那里面有光荣”。 竞争，在它存在的地方，是一个极其强大的动机…尽管人们强烈的反对很多形式的竞争，我认为竞争对促进必要的努力却具有实质性的作用，在一些领域，它还为否则将可能引起战争的那些冲动提供了一个相对无害的发泄出口。没有人会赞成取消比赛中的竞争…球队之间、地方之间或者组织之间的竞争，都可以成为一种有效的刺激。 人们一般能够意识到，他们日常生活受远方世界各地发生事情的影响，但除了少数专家之外，他们并不理解这是怎样发生的。大米为什么没了？经济为什么不行了？物价为何上涨了？房价为何水涨船高？（后三条是我添加的）如果你怪罪印度，或者官僚作风，或者资本主义制度，又或者社会主义国家，你就是在人们的头脑当里召唤一个人们容易去仇恨、虚构的人格化恶魔。在每一个不幸当中，寻找一个可以怪罪的敌人是一种自然的冲动；原始人就把所有病痛归结为敌人的魔法。每当各种问题的起因太难理解时，我们往往会求助这种古老的解释…诉诸对假想敌的仇恨来解释我们生活中所有痛苦的事情往往是破坏性和灾难性的；它会激发原始的本能力量，所用的却是那些具有灾难性后果的办法。 在那些为了民主的平等而被不必要牺牲掉的东西里，最重要的也许是自尊。我所指的自尊是自尊中好的那一半–即所谓“自尊心”（proper pride)。坏的那一半则是一种优越感。自尊将使一个处于敌人控制下的人不至于奴颜婢膝，并使他在世人都反对他时仍然能够感到他自己也许是正确的…自尊到今天为止一直都不可避免地是少数人的美德。无论什么地方，只要存在权力的不平等，在屈从于他人统治的那些人当中，都不可能找到它。暴政最令人反感的特征之一是，它们竟然能够使不公正的受害者去谄媚那些虐待他们的人。 在工业社会里，最重要的问题，而且肯定也是最困难的问题之一，也许是使工作变得有趣–在工作不再仅仅是挣工资的手段的意义上。这一问题的产生尤其和无需技能的工作联系在一起。困难的工作对那些胜任它的人来说可能是有吸引力的…现代的工作性质进一步强调了不依赖于任何一种劳动储备库，它们要求较少的技能，却要求高度的稳定性和可靠性…怎么避免这个问题？罗素接着给出了解决办法: 使工人恢复过去和主人翁相联系的一些情感–即这是“我的”劳动成果，或者无论如何也是“我们的”劳动成果–相联系的自豪感；在所有内部事务上，要做到局部的、小范围的民主。詹姆斯-吉尔斯比在《工业中的自由表达》一书中进行了很好的阐述: 当一个个体或者群体存在严重问题时，而又不能带着问题去找高层管理者时，就会有一种挫败感…在大公司里，有一种比挫败感更甚的东西；对公司的运作，基层成员有一种特殊的无意义感。无论是在政治上还是工业里，只要政府或者管理部门被认为是“他们”，是一个遥远的群体，这个群体趾高气扬，傲慢无礼，并且自然地被人们怀着敌意来看待，民主就不会是一种心理上的事实。（自古以来，个性与创造都只属于少部分人，而大多数人则生活在贫穷、困苦以及残酷的重压之下，在敌意或冷酷的非人权的控制下，他们往往感到自己无助而软所无力。在现代工业化社会中，如何避免这些问题？如何释放出个人的潜能与创造力？这是罗素在接下来的两篇讲稿中着力去解决的难题。） 控制与主动性 一个健全而进步的社会既需要集中控制，也需要个人和群体的积极性：没有控制，会出现无政府状态；没有积极性，则会出现停滞…政府的主要目的，罗素认为主要三个：安全、公正和保护。 安全：尽管许多国家保护守法公民不受其他公民的侵害，却并不认为是他们免受国家的侵害也是必要的。在那些存在依行政命令进行逮捕，以及不经过法律程序而进行惩罚的地方，无论国家建立多么稳固，个体民众也没有安全可言…安全，尽管无疑是好事情，却也可能因为追求过度而成为一种迷信。安全的生活未必是幸福的生活；它可能会因为无趣和单调而令人感到沉闷。安全本身是由恐惧所激发的消极目的;令人满意的生活必须是一个由希望所激发的积极目的。 公正：作者认为经济上的公正可以按照社会主义的方式来操作，由国家控制主要工业，并且很大程度上控制对外贸易（国家来控制工业导致的直接后果是，政府的权力会因此膨胀；权力的集中与国家资本扭曲了市场，消弱了民营经济，最后变成了控制民众的一种手段）。公正，和安全一样，但却是在一种更大的程度上，是一个受到各种限制的原则。在人人同样贫困以及人人同样富有的地方，公正是存在的，但使富裕的人变得更贫困-似乎并没有什么意义。 保护:政府不仅要保护古迹与风景区，还要维护公共基础设施…我主要考虑的是保护各种自然资源。罗素担心过度的资源开采会导致资源枯竭。这个问题在今天依然严峻。 权力只有被委托给一些小团体（在这些小团体中，个人不会被纯粹的巨大数目所吞没），勇于冒险的意识，以及有能力实现人们觉得重要的结果的意识才可能恢复…所有健全体制的一个本质体制是，权力尽可能多地掌握在对所要做的工作感兴趣的人的手里。 性格的整齐划一和文化的整齐划一是令人遗憾的。生物的进化取决于个体或者部落间先天的差异，文化的进化则取决与后天获得的差异。如果这些差异消失了，就不再会有任何可选择的事物了。在现代世界里，确实有一种现实的危险，即一个地区和另一个地区在文化方面过于相近了。将这一不幸减到最小的最好办法之一，就是增加不同群体的自主性。 和精神利益相比，物质利益更大程度上是一个占有问题。一个人吃了一份食物，其他人无法就无法吃到了，但一个人写作或者欣赏一首诗歌，却不会阻止另外一个人写作或者欣赏同样优美或者更优美的诗歌。这就是为什么，在涉及物质利益时，公正是重要的，而对精神利益来说，所需要的则是机会以及使成功的希望看起来合理的环境。激励有能力从事创造性工作的人的，并不是巨大的物质回报：几乎没有诗人或者科学人士发过财或者想要发财…在一个当权者控制了所有宣传手段的铁板一块的国家里，一个具有突出原创性的人可能会遇到一种更槽糕的命运：无论他是否屈从于法律的惩罚，他都不可能使他的观念为人所知。如果一个社会里发生了这种事情，这个社会就不再能够为人类的共同生活贡献任何有价值的东西了（看到这里，不禁叹息。在这个国家里，这个社会环境，个人就是鱼肉，就是韭菜，任由那些自以为聪明而又傲慢的当权者宰割。他们集中控制物质财富，集中权力，集中资源，每个人都围绕着权力与物质旋转，你几乎没有质疑的时间与精力，大多数时候大部分人都疲于奔命。而那些敢于挑战权威，想要思考发声的，则会被扼杀，失去自由乃至生命。） 文末，罗素说：“但是我们不能仅仅满足于活着而没有死去；我们希望幸福快乐、充满精力并富于创造力的活着”。有时，看着周围的世界，整天都在追逐利益，追逐物质的享乐，而精神却萎靡焦虑。这个国家与社会所作所为正在扼杀人的首创精神，将人丢入新的桎酷，让人成为一个只在乎物质而对精神与灵魂没有任何追求的行尸走肉。但愿自己不要迷失，在追逐幸福的过程中，可以感受到精神的富足与快乐。 个人伦理与社会伦理 概而言之，我们已经区分了社会活动的两个主要目的：一方面，安全与公正需要集中的政府控制，这种控制要有效的话，就必须扩展建立起一个世界政府。进步，则相反，需要为与社会秩序相容的个人主动性提供最大的空间。罗素认为，要实现这两个目的，就需要尽可能的保证权力下放：给地方机构更多的权力；让铁路等工业有更多的自治空间；而对于报纸、书籍以及政治宣传，要尽可能的允许竞争，避免被政府控制，以及其他形式的垄断。 一个人如果真的想过他可能过上的最好的生活，他就必须学会批判在他的邻人中被普遍接受的那些部落习俗和信念。 在整个有文字记载的历史上，伦理信念一直有两个非常不同的来源，一个是政治的，另一个是则涉及个人的宗教和道德信念…个人与公民道德的两重性仍然存在着…没有公民道德，社会将灭亡；没有个人道德，他们的存在将毫无价值。对一个美好世界来说，公民与个人道德都是必不可少的。 公共责任的承担并不构成美好生活的全部内容；还存在着对个人价值（excellence)的追求。尽管人类部分是社会性的，但是却并不完全如此…个人价值，尽管很大部分存在于对他人的正当行为中，但也有其他方面…危险的，倒是听任政治和社会责任过于彻底支配了我们关于个人价值的观念…苏格拉底和使徒们（耶稣的十二门徒）告诉我们应该服从神而不是人，《福音书》对于爱上帝和爱邻舍则是一样的强调。所有伟大的宗教领袖，以及所有伟大的艺术家和富于才智的发明家，都显示出一种要实现他们创造性冲动的道德强迫感(a sense of moral compulsion),以及当他们实现这些冲动时的道德提升感（a sense of moral exaltation)。这种情感是《福音书》所宣称的对上帝的职分(duty to God)的基础，并且说可以和神学信仰分离的。 人们并不总是记得，政治、经济和社会组织一般来说应归于手段的范围，而不是目的的范围…但是一个社会的存在不是为了满足，或者至少不应该为了满足一种外在的观感，而是要把一种优良的生活带给组成它的个体。正是在个体身上，而不是在整体里，我们才能找到终极的价值。好的社会是给社会成员带来好生活的手段，而不是由于自身的缘故而具有某种独立的价值的东西。接着罗素说到了善恶。他说，只有个体才是善恶的承受者，才谈得上有善恶之分，人类集体是没有善恶的。认为人类集体也有善恶，最终导向的是极权主义。从这一观点延伸，罗素认为国家只是抽象物：不会感受到痛苦与快乐，也没有任何希望与恐惧。它本身并不具有价值而是实现公民福祉的一个手段而已：我们认为是国家目的的那些东西，实际上是掌控国家的那些个人的目的。当我们具体而非抽象地思考，就会发现，特定的某些人取代了“国家”，他们拥有的权力比大多数人所享有的要多的多。由此，对“国家”的赞颂实际上变成了对少数统治者的赞颂。 在此讲的后一部分，罗素再次阐述了如何在社会集体的凝聚力（国家）与个人主动性取得平衡。在如今高度组织化的社会，缺乏的是自发性，而掌控组织的人则往往试图让人去适应制度而不是让制度来适应人。罗素认为，要破除组织对个人的控制与威胁，必须让个人拥有主动改变的可能与成功的希望，使个体能够在组织之中发挥个人的作用与影响力。人类在科学技术方面并不缺乏聪明才智，但至今我们却没有学会怎样利用已有的知识和技能来最大限度的使我们的生活幸福，甚至光辉灿烂。随着科与学技术的发展，外部自然界对我们的束缚正在逐渐减少，这使我们有更多的精力发挥潜能，使比迄今为止存在过的、更大程度的人类福祉变得可能。要实现这种可能，就必须发挥个人的主动性，鼓励使人类生活变得丰富多彩的各种形式的主动性：通过使人驯服和胆怯，我们不可能建立一个美好的世界，而是要通过鼓励他们勇敢大胆、敢于冒险和无所畏惧来创建一个美好的世界。（人类是否可以建立一个伊甸园？是否能够过上美好幸福的生活？如今看来，好像还离的有点远。战争的威胁与地区争端此起彼伏，人类的生活似乎从未有过真正的安宁。虽然对于公平与正义，善良与美好，大部分的国家与民族都会有共同的认知，但是还有很多的地方依然处于黑暗与压制的环境当中。在这些地方，所谓的美好幸福，只是属于少数权贵阶层，而很大部分人仍然被压迫，被控制，被限制。那么，人类走向罗素说的那种组织与个人得到很好平衡的美好境界的趋势是否会因为这些逆流而发生变化了？大概率应该不会。人类曲曲折折走到现在，对于美好幸福生活的共同期许与愿望变得更为深入人心，这些也正是促使人类作为一个整体走向光明，不断进步的动力。）]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>罗素</tag>
        <tag>自由，民主</tag>
        <tag>国家意志与权威</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RILD详解]]></title>
    <url>%2F2016%2F11%2F29%2FAndroid-RILD%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言在上一篇文章里（http://sniffer.site/2016/11/29/Android-RILD%E8%AF%A6%E8%A7%A3/），简要介绍了Android RIL的架构。这一篇文章，就来看一看RILD（RIL Daemon)相关的内容。Android RIL在HAL(Hardware Abstract Layer)层（C++层）由三个部分组成： RILD是系统的守护进程，主要用于初始化LIBRIL以及启动厂商自定义的Vendor RIL； LIBRIL库被RILD初始化完成后，用于与Vendor RIL之间进行交互，负责接收、发送指令； Vendor RIL库是第三方厂商自定义的一个库，用于向Modem发送指令或者接收来自LIBRIL或者Modem的指令, Android有一个基于AT指令的默认参考实现(reference-ril) 三者之间的关系图如下所示： 从这里可以看到，RILD在启动时，负责将LibRil以及Vendor RIL进行初始化，将相应的回调函数以及调用接口进行注册，LibRIL向vendor RIL提供了接口RIL_Env，当Vendor有消息时，利用该回调返回；而Vendor RIL 同样提供了接口RIL_RadioFunctions,给LibRIl调用。这里涉及到3个主要问题： RILD是如何启动？ RILD是如何进行初始化操作的？ 初始完成后，LIBRIL是如何进行消息的接收与发送的？ RILD是如何启动的RILD(RIL Daemon)是系统的守护进程，系统已启动，就会一直运行。手机开机时，kernel完成初始化后，Android启动一个初始化进程Init用于加载系统基础服务，如文件系统，zygote进程，服务管家ServiceManager,以及RILD： 1234567service ril-daemon /system/bin/rild class main socket rild stream 660 root radio socket rild-debug stream 660 radio system user root group radio cache inet misc audio log 这里，init进程从手机文件系统目录system/bin/rild中读取RILD的可执行文件，加载到内存运行；同时，创建两个socket端口:rild和rild-debug,其中rild用于RILJ与RILD之间的数据通信，而rild-debug则用于RILJ与RILD的调试。 开机流程可参考：http://blog.csdn.net/jason_wzn/article/details/52278533 Android初始化语言init可参考：http://blog.csdn.net/jason_wzn/article/details/50790810 RILD是如何进行初始化的RILD启动后，一方面会去初始化Vendor RIL，将LIBRIL的回调接口RIL_Env传递给Vendor RIL；同时将Vendor RIL的接口RIL_RadioFunctions注册到LIBRIL中，这样一旦初始化完成，LIBRIL与Vendor RIL就可以进行数据的交换了。 来看一看RILD的代码： 12345678910111213141516171819202122232425262728293031int main(int argc, char **argv)&#123; ... // Vendor RIL接口函数 const RIL_RadioFunctions *(*rilInit)(const struct RIL_Env *, int, char **); const RIL_RadioFunctions *funcs; ...OpenLib: //从指定路径加载RILD可执行文件 dlHandle = dlopen(rilLibPath, RTLD_NOW); if (dlHandle == NULL) &#123; RLOGE(&quot;dlopen failed: %s&quot;, dlerror()); exit(EXIT_FAILURE); &#125; // 启动LIBRIL的事件处理线程 RIL_startEventLoop(); // Vendor RIL初始化函数，返回一个RIL_RadioFunctions rilInit = (const RIL_RadioFunctions *(*)(const struct RIL_Env *, int, char **))dlsym(dlHandle, &quot;RIL_Init&quot;); ... funcs = rilInit(&amp;s_rilEnv, argc, rilArgv); RLOGD(&quot;RIL_Init rilInit completed&quot;); // 将 RIL_RadioFunctions注册到LIBRIL中 RIL_register(funcs); RLOGD(&quot;RIL_Init RIL_register completed&quot;);&#125; RILD初始化主要完成两件事：（1） 加载Vendor RIL的代码，并对其进行初始化操作，将LIBRIL的接口RIL_Env传递给Vendor RIL，用于回调；(2)开始RIL事件处理线程；（3）将Vendor RIL的接口注册到LIBRIL中，这样LIBRIL就可以将消息发送给Vendor RIL了。 RIL_startEventLoop()启动RIL事件处理线程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253extern &quot;C&quot; void RIL_startEventLoop(void) &#123; /* spin up eventLoop thread and wait for it to get started */ s_started = 0; pthread_mutex_lock(&amp;s_startupMutex); ... // eventLoop函数才是真正开始启动事件处理线程的地方 int result = pthread_create(&amp;s_tid_dispatch, &amp;attr, eventLoop, NULL); if (result != 0) &#123; RLOGE(&quot;Failed to create dispatch thread: %s&quot;, strerror(result)); goto done; &#125; while (s_started == 0) &#123; pthread_cond_wait(&amp;s_startupCond, &amp;s_startupMutex); &#125;done: pthread_mutex_unlock(&amp;s_startupMutex);&#125;// evetLoop static void *eventLoop(void *param) &#123; int ret; int filedes[2]; //初始化事件队列 ril_event_init(); pthread_mutex_lock(&amp;s_startupMutex); s_started = 1; pthread_cond_broadcast(&amp;s_startupCond); pthread_mutex_unlock(&amp;s_startupMutex); ret = pipe(filedes); // 用于监听wakeup事件的pipe端口 s_fdWakeupRead = filedes[0]; s_fdWakeupWrite = filedes[1]; //设置线程唤醒事件，唤醒时，回调processWakeupCallback函数 ril_event_set (&amp;s_wakeupfd_event, s_fdWakeupRead, true, processWakeupCallback, NULL); rilEventAddWakeup (&amp;s_wakeupfd_event); // 真正干活的函数 ril_event_loop(); // kill self to restart on error kill(0, SIGKILL); return NULL;&#125; RILD初始化vendor RIL之后，将返回的RIL_RadioFunctions返回给RILD，RILD接着将其注册到LIBRIL中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950extern &quot;C&quot; void RIL_register (const RIL_RadioFunctions *callbacks) &#123; ... /* Initialize socket1 parameters */ s_ril_param_socket = &#123; RIL_SOCKET_1, /* socket_id */ -1, /* fdListen */ -1, /* fdCommand */ PHONE_PROCESS, /* processName */ &amp;s_commands_event, /* commands_event */ &amp;s_listen_event, /* listen_event */ processCommandsCallback, /* processCommandsCallback */ NULL /* p_rs */ &#125;; .... // back compatibility if (s_started == 0) &#123; RIL_startEventLoop(); &#125; // start listen socket1 startListen(RIL_SOCKET_1, &amp;s_ril_param_socket);&#125;// startListenstatic void startListen(RIL_SOCKET_ID socket_id, SocketListenParam* socket_listen_p) &#123; int fdListen = -1; int ret; char socket_name[10]; memset(socket_name, 0, sizeof(char)*10); switch(socket_id) &#123; case RIL_SOCKET_1: strncpy(socket_name, RIL_getRilSocketName(), 9); break; .... // 获取 Unix domain socket对应的FD fdListen = android_get_control_socket(socket_name); // 监听端口 ret = listen(fdListen, 4); socket_listen_p-&gt;fdListen = fdListen; // 设置监听回调事件 listenCallback，RILJ主动连接RILD时，处理该回调 /* note: non-persistent so we can accept only one connection at a time */ ril_event_set (socket_listen_p-&gt;listen_event, fdListen, false, listenCallback, socket_listen_p); //添加到事件队列中，并唤醒事件处理线程 rilEventAddWakeup (socket_listen_p-&gt;listen_event);&#125; 源代码： /hardware/ril/libril/ril.cpp 接下来，我们就来看一看LIBRIL与Vendor RIL各自提供的接口函数。 这两个接口都在/hardware/ril/include/telephony/ril.h中进行了声明。 Vendor RIL主要提供了5个接口，供LIBRIL调用： RIL_RequestFunc是最主要的一个，所有从RILJ发送过来的请求均由该接口发送给Vendor RIL； RIL_RadioStateRequest从LIBRIL获取modem的即时状态； RIL_Supports判断Vendor RIL是否支持某个请求命令； RIL_Cancel取消某个请求命令； RIL_GetVersion获取RIL的版本号； 12345678910111213141516typedef struct &#123; int version; /* set to RIL_VERSION */ RIL_RequestFunc onRequest; RIL_RadioStateRequest onStateRequest; RIL_Supports supports; RIL_Cancel onCancel; RIL_GetVersion getVersion;&#125; RIL_RadioFunctions;// 将从RILJ发送过来的请求发送给Vendor RILtypedef void (*RIL_RequestFunc) (int request, void *data, size_t datalen, RIL_Token t, RIL_SOCKET_ID socket_id);// 获取 modem 状态typedef RIL_RadioState (*RIL_RadioStateRequest)(RIL_SOCKET_ID socket_id); LIBRIL则向Vendor RIL提供了3个接口： OnRequestComplete:RIL请求完成后，通过该接口将数据返回给LIBRIL，由LIBRIL将数据写入socket RILD; OnUnsolicitedResponse:CP主动上报消息给Vendor RIL后，通过该接口将消息传给LIBRIL; RequestTimedCallback:在指定时间内，LIBRIL调用回调函数RequestTimedCallback； 123456789101112131415161718192021222324252627struct RIL_Env &#123; // 请求完成，返回给LIBRIL void (*OnRequestComplete)(RIL_Token t, RIL_Errno e, void *response, size_t responselen);// Vendor RIL接收到从CP主动上报的消息后，传给LIBRIL#if defined(ANDROID_MULTI_SIM) void (*OnUnsolicitedResponse)(int unsolResponse, const void *data, size_t datalen, RIL_SOCKET_ID socket_id);#else /** * &quot;unsolResponse&quot; is one of RIL_UNSOL_RESPONSE_* * &quot;data&quot; is pointer to data defined for that RIL_UNSOL_RESPONSE_* */ void (*OnUnsolicitedResponse)(int unsolResponse, const void *data, size_t datalen);#endif /** * Call user-specifed &quot;callback&quot; function on on the same thread that * RIL_RequestFunc is called. If &quot;relativeTime&quot; is specified, then it specifies * a relative time value at which the callback is invoked. If relativeTime is * NULL or points to a 0-filled structure, the callback will be invoked as * soon as possible */ // 指定时间内LIBRIL调用回调函数RIL_TimedCallback void (*RequestTimedCallback) (RIL_TimedCallback callback, void *param, const struct timeval *relativeTime);&#125;; 代码路径： /hardware/ril/rild/rild.c 初始化完成了 ，那么RIL事件处理线程是从何时开始处理事件的了？RIL事件处理线程是怎么又是同时处理来自RILJ以及Vendor RIL的消息的？下面就来看一看LIBRIL如何处理RIL事件的。 LIBRIL如何处理RIL事件为处理RIL事件，LIBRIL提供了3个事件队列（由双向列表组成）： 1234static struct ril_event * watch_table[MAX_FD_EVENTS];static struct ril_event timer_list;static struct ril_event pending_list; 其中，watch_table用于事件的监测，timer_list保存定时事件，而pending_list用于保存即将被处理的事件列表。对LIBRIL来讲，有3种类型的RIL事件需要处理： 1234567// RILJ请求事件static struct ril_event s_commands_event;// 事件处理线程唤醒事件static struct ril_event s_wakeupfd_event;// RILD socket端口监听事件static struct ril_event s_listen_event; 上一节我们了解到，在RIL事件处理线程开始时，LIBRIL会添加一个s_wakeupfd_event的唤醒事件，必要时对线程进行唤醒操作；在注册Vendor RIL的接口时，注册一个监听事件s_listen_event，当RILJ尝试通过socket连接RILD时，处理该事件；当RILJ与RILD连接成功后，处理回调函数listenCallback时，会添加一个 s_commands_event事件，用于处理RILD socket的数据。 那么，LIBRIL是从何时开始处理这些事件的？上一节我们了解到，初始化时，LIBRIL启动了一个专门的线程来处理RIL事件： 123456789101112131415161718192021222324void ril_event_loop()&#123; int n; fd_set rfds; struct timeval tv; struct timeval * ptv; for (;;) &#123; // make local copy of read fd_set memcpy(&amp;rfds, &amp;readFds, sizeof(fd_set)); .... // 从FD集合中选择可用的端口 n = select(nfds, &amp;rfds, NULL, NULL, ptv); .... // 处理timer队列中超时的事件 processTimeouts(); // 处理监测队列中的事件: listenCallback, processReadReadies(&amp;rfds, n); // OK，fire pending list firePending(); &#125;&#125; 该线程，一直监听FD(File Descriptor)集合readFds，如果有数据时，就会立即返回，进而开始执行事件的处理：首先处理定时事件队列中的event,如果发现有超时的事件，就将其加入pending队列中；接着，查看监测表（保存了最多8个事件）中是否有readFds对应的RIL事件，如果存在，则也将其放入到pending队列。最后，就要开始处理pending队列了： 1234567891011121314static void firePending()&#123; dlog(&quot;~~~~ +firePending ~~~~&quot;); struct ril_event * ev = pending_list.next; while (ev != &amp;pending_list) &#123; struct ril_event * next = ev-&gt;next; removeFromList(ev); // 执行回调函数: processWakeupCallback,listenCallback,processCommandsCallback... ev-&gt;func(ev-&gt;fd, 0, ev-&gt;param); ev = next; &#125; dlog(&quot;~~~~ -firePending ~~~~&quot;);&#125; 源码：/android/hardware/ril/libril/samsung/ril_event.cpp LIBRIL事件处理线程开始时，只有两个事件：s_wakeupfd_event与s_listen_event，s_wakeupfd_event事件在添加s_listen_event事件，需要唤醒RIL事件处理线程被执行： 1234567891011static void triggerEvLoop() &#123; int ret; if (!pthread_equal(pthread_self(), s_tid_dispatch)) &#123; /* trigger event loop to wakeup. No reason to do this, * if we&apos;re in the event loop thread */ do &#123; ret = write (s_fdWakeupWrite, &quot; &quot;, 1); &#125; while (ret &lt; 0 &amp;&amp; errno == EINTR); &#125;&#125; 接着，开始执行s_listen_event事件，调用回调函数listenCallback: 123456789101112131415161718192021222324252627282930static void listenCallback (int fd, short flags, void *param) &#123; .... // 接受RILJ的链接请求 fdCommand = accept(fd, (sockaddr *) &amp;peeraddr, &amp;socklen); /* check the credential of the other side and only accept socket from * phone process */ is_phone_socket = 0; err = getsockopt(fdCommand, SOL_SOCKET, SO_PEERCRED, &amp;creds, &amp;szCreds); .... ret = fcntl(fdCommand, F_SETFL, O_NONBLOCK); .... p_info-&gt;fdCommand = fdCommand; p_rs = record_stream_new(p_info-&gt;fdCommand, MAX_COMMAND_BYTES); p_info-&gt;p_rs = p_rs; ril_event_set (p_info-&gt;commands_event, p_info-&gt;fdCommand, 1, p_info-&gt;processCommandsCallback, p_info); // 添加指令事件`s_commands_event` rilEventAddWakeup (p_info-&gt;commands_event); // 建立新的连接，告知RILJ链接成功，并上报radio状态 onNewCommandConnect(p_info-&gt;socket_id);&#125; 下次处理pending事件队列时，处理s_commands_event,调用回调函数processCommandsCallback： 123456789101112131415161718192021222324252627282930313233343536373839 static void processCommandsCallback(int fd, short flags, void *param) &#123; // 循环读 RILD socket接口数据流 for (;;) &#123; /* loop until EAGAIN/EINTR, end of stream, or other error */ // 读取 socket数据流 ret = record_stream_get_next(p_rs, &amp;p_record, &amp;recordlen); if (ret == 0 &amp;&amp; p_record == NULL) &#123; /* end-of-stream */ break; &#125; else if (ret &lt; 0) &#123; break; &#125; else if (ret == 0) &#123; /* &amp;&amp; p_record != NULL */ processCommandBuffer(p_record, recordlen, p_info-&gt;socket_id); &#125; &#125; .... // processCommandBuffer static int processCommandBuffer(void *buffer, size_t buflen, RIL_SOCKET_ID socket_id) &#123; RequestInfo *pRI; ... pRI = (RequestInfo *)calloc(1, sizeof(RequestInfo)); pRI-&gt;token = token; // 根据 RILJ的REQUEST类型来获取CommandInfo pRI-&gt;pCI = &amp;(s_commands[request]); pRI-&gt;socket_id = socket_id; ... // 将请求分配给对应的函数处理 pRI-&gt;pCI-&gt;dispatchFunction(p, pRI); return 0; &#125;&#125; 上述代码中，s_commands将所有RILJ的请求命令，对应的请求函数以及响应处理函数组成一个类型为commandInfo的结构体数组，等请求从CP返回时，就可以调用对应的响应函数来处理返回的结果了： 1234567891011121314static CommandInfo s_commands[] = &#123; #include &quot;ril_commands.h&quot;&#125;; &#123;0, NULL, NULL&#125;, //none &#123;RIL_REQUEST_GET_SIM_STATUS, dispatchVoid, responseSimStatus&#125;, &#123;RIL_REQUEST_ENTER_SIM_PIN, dispatchStrings, responseInts&#125;, &#123;RIL_REQUEST_ENTER_SIM_PUK, dispatchStrings, responseInts&#125;, &#123;RIL_REQUEST_ENTER_SIM_PIN2, dispatchStrings, responseInts&#125;, &#123;RIL_REQUEST_ENTER_SIM_PUK2, dispatchStrings, responseInts&#125;, &#123;RIL_REQUEST_CHANGE_SIM_PIN, dispatchStrings, responseInts&#125;, &#123;RIL_REQUEST_CHANGE_SIM_PIN2, dispatchStrings, responseInts&#125;,.... 源码： /android/hardware/ril/libril/samsung/ril_commands.h 参考文献 源码： androidxref - 5.1 http://blog.csdn.net/maxleng/article/details/5576637]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RIL</tag>
        <tag>RILD</tag>
        <tag>Telephony</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android RIL概述]]></title>
    <url>%2F2016%2F11%2F19%2FAndroid-RIL%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[前言Android作为一个通用的移动平台，其首要的功能就是通话、短信以及上网等通信功能。那么，从系统的角度来看，Android究竟是怎么实现与网络的交互的了？ 这篇文章里，就来看一看Android中负责通信功能的Telephony中间层，通常也被称之为RIL(Radio Interface Layer)的具体实现原理与架构。 Android手机要实现与网络端的通信，需要跨越两个层： RIL Java(RILJ)：负责将上层APP的通信请求发送给HAL层； RIL C++(RILD)： 系统守护进程，负责将RILJ的请求命令发送给CP(Communication Processor) 什么是RIL简单的说，RIL(Radio Interface Layer)，就是将应用程序的通信请求发送给CP的中间层，其包括两个部分，一个是Java层RILJ,一个是C++层（不妨看作是CP对应的HAL层）RILD。 RILJ属于系统Phone进程的一部分，随Phone进程启动而加载；而RILD守护进程是通过Android的Init进程进行加载的。 RIL结构下图是一个Android RIL的一个结构图。整个通信过程有四个层： 最上层的是应用程序，如通话，短信以及SIM卡管理，它们主要负责将用户的指令发送到RIL Framework(以后统称RILJ）； RILJ为上层提供了通用的API，如TelephonyManager(包括通话，网络状态； SubscriptionManager(卡状态）以及SmsManager等，同时RILJ还负责维持与RILD的通信，并将上层的请求发送给RILD； RILD是系统的守护进程，对于支持通话功能的移动平台是必不可少的。RILD的功能主要功能是将RILJ发送过来的请求继续传递给CP，同时会及时将CP的状态变化发送给RILJ； Linux驱动层：kernel驱动层接受到数据后，将指令传给CP，最后由CP发送给网络端，等网络返回结果后，CP将传回给RILD； RILJ与RILD（RILD与CP的通信）都是通过一个个消息进行数据传递。消息主要分两种：一种是RILJ主动发送的请求（solicited），常见的有RIL_REQUEST_GET_SIM_STATUS(获取SIM卡状态）， RIL_REQUEST_DIAL(拨打电话），RIL_REQUEST_SEND_SMS（发送短信）， RIL_REQUEST_GET_CURRENT_CALLS（获取当前通话状态），RIL_REQUEST_VOICE_REGISTRATION_STATE（获取网络状态）； 另一种则是从CP主动上报给RIL的消息（unsolicited)，如网络状态发生变化时，CP会上报RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED，有新短信时，会上报RIL_UNSOL_RESPONSE_NEW_SMS，有来电时会上报RIL_UNSOL_CALL_RING。 RIL相关的请求命令与数据结构都定义在/android/hardware/ril/include/telephony/ril.h 在整个过程中，有几个关键问题： 上层是如何得知RILJ状态变化的； RILJ与RILD是怎么进行通信的？ RILJD与CP又是如何进行通信的？ 围绕这三个问题点，我们来看一下具体的细节。 上层如何得知RILJ状态变化为方便上层实时监听网络状态、通话状态以及CP的状态变化，RIL提供了一个专门的监听接口IPhoneStateListener.aidl，上层需要监听上述状态变化时，只需要实现上述接口,并在Android系统服务TelephonyRegistry中对上述接口实现进行注册： 12public void listen(String pkgForDebug, IPhoneStateListener callback, int events, boolean notifyNow); 另外，也可以在TelephonyManager中对RIL状态进行监听： 1public void listen(PhoneStateListener listener, int events) 源代码: /android/frameworks/base/telephony/java/com/android/internal/telephony/IPhoneStateListener.aidl 123456789101112131415161718192021222324oneway interface IPhoneStateListener &#123; void onServiceStateChanged(in ServiceState serviceState); void onSignalStrengthChanged(int asu); void onMessageWaitingIndicatorChanged(boolean mwi); void onCallForwardingIndicatorChanged(boolean cfi); // we use bundle here instead of CellLocation so it can get the right subclass void onCellLocationChanged(in Bundle location); void onCallStateChanged(int state, String incomingNumber); void onDataConnectionStateChanged(int state, int networkType); void onDataActivity(int direction); void onSignalStrengthsChanged(in SignalStrength signalStrength); void onOtaspChanged(in int otaspMode); void onCellInfoChanged(in List&lt;CellInfo&gt; cellInfo); void onPreciseCallStateChanged(in PreciseCallState callState); void onPreciseDataConnectionStateChanged(in PreciseDataConnectionState dataConnectionState); void onDataConnectionRealTimeInfoChanged(in DataConnectionRealTimeInfo dcRtInfo); void onVoLteServiceStateChanged(in VoLteServiceState lteState); void onOemHookRawEvent(in byte[] rawData); void onCarrierNetworkChange(in boolean active); void onFdnUpdated(); void onVoiceRadioBearerHoStateChanged(int state);&#125; RILJ与RILD如何通信RILJ在创建过程中，会启动两个线程：RILSender和RILReceiver,RILSender负责将指令发送给RILD,而RILReceiver则负责从读取从RILD发送过来的数据。RILJ与RILD的通信通道就是在RILReceiver中建立起来的。 我们来看一看RILReciver的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495 class RILReceiver implements Runnable &#123; byte[] buffer; RILReceiver() &#123;... @Override public void run() &#123; int retryCount = 0; String rilSocket = &quot;rild&quot;; // 尝试与RILD建立连接 try &#123;for (;;) &#123; LocalSocket s = null; LocalSocketAddress l; if (mInstanceId == null || mInstanceId == 0 ) &#123; rilSocket = SOCKET_NAME_RIL[0]; &#125; else &#123; rilSocket = SOCKET_NAME_RIL[mInstanceId]; &#125; try &#123; s = new LocalSocket(); l = new LocalSocketAddress(rilSocket, LocalSocketAddress.Namespace.RESERVED); s.connect(l); &#125; catch (IOException ex)&#123; ... // don&apos;t print an error message after the the first time // or after the 8th time if (retryCount == 8) &#123; Rlog.e (RILJ_LOG_TAG, &quot;Couldn&apos;t find &apos;&quot; + rilSocket + &quot;&apos; socket after &quot; + retryCount + &quot; times, continuing to retry silently&quot;); &#125; else if (retryCount &gt;= 0 &amp;&amp; retryCount &lt; 8) &#123; Rlog.i (RILJ_LOG_TAG, &quot;Couldn&apos;t find &apos;&quot; + rilSocket + &quot;&apos; socket; retrying after timeout&quot;); &#125; ... retryCount++; continue; &#125; retryCount = 0; mSocket = s; // 从socket读取数据 int length = 0; try &#123; InputStream is = mSocket.getInputStream(); for (;;) &#123; Parcel p; length = readRilMessage(is, buffer); if (length &lt; 0) &#123; // End-of-stream reached break; &#125; p = Parcel.obtain(); p.unmarshall(buffer, 0, length); p.setDataPosition(0); processResponse(p); p.recycle(); &#125; &#125; catch (java.io.IOException ex) &#123; Rlog.i(RILJ_LOG_TAG, &quot;&apos;&quot; + rilSocket + &quot;&apos; socket closed&quot;, ex); &#125; catch (Throwable tr) &#123; Rlog.e(RILJ_LOG_TAG, &quot;Uncaught exception read length=&quot; + length + &quot;Exception:&quot; + tr.toString()); &#125; //无法读取数据，将CP状态设置为不可用 setRadioState (RadioState.RADIO_UNAVAILABLE); ... mSocket = null; RILRequest.resetSerial(); // Clear request list on close clearRequestList(RADIO_NOT_AVAILABLE, false); &#125;&#125; catch (Throwable tr) &#123; Rlog.e(RILJ_LOG_TAG,&quot;Uncaught exception&quot;, tr); &#125; &#125; &#125; RILReceiver启动时，会建立一个UNIX Domain socket(LocalSocket，kernel层对应/dev/socket/rild)，与RILD进行通信，然后一直从socket中读取数据,并将数据传给上层。连接成功后，RILD会发送一个消息给RILJ，表示连接成功了，这样RILJ就可以将请求数据发送给RILD，进行通信了。 RILD与CP如何进行通信RILD与CP（可以看做是两个运行在不同CPU上的进程通信）交换数据方式一般有两种情况。如果AP与CP集中在一个芯片上，如高通的平台就是将AP与CP集中在一块芯片上，这时通常采用共享内存的方式实现跨进程通信；而如果不是在同一块芯片，而是AP与CP分别采用不同厂商的平台，则一般采用字符设备(character devices) 进行通信。总的说来，共享内存的方式在速度上要优于字符设备。 接下来，主要介绍下RILJ部分的代码结构。 RILJ代码结构RIL Framework (RILJ)的代码按照功能来划分的话，主要有以下几个组成部分： 管理网络状态（信号强度，网络注册状态等）:ServiceStateTracker等； 通话管理（拨号，接听，呼叫等待等）： CallManager,GsmCallTracker等 SMS短信接收发送： InboundSMSHandler,SmsDispater等 SIM卡管理： UiccController, SubscriptionsController等 数据链接管理： DcTracker,DctController等 Telephony 大管家： PhoneBase,GsmPhone,PhoneProxy等 以上代码主要位于两个目录： /android/frameworks/opt/telephony/ （负责与RILD交互） /android/frameworks/base/telephony/ （对上层提供接口） 下面，以拨打电话的流程作为示例看一看RIL是如何发挥作用的。 示例： CALL流程下述是一个MO(Mobile Originated) 通话流程概要： APP向TelecomManager发送拨号请求（关于TelecomManager可以参考另一篇文章Android Telecom系统服务）； TelecomManager将通话请求发送给GsmPhone； GsmPhone继续将指令传递给GsmCallTracker； GsmCallTracker调用RILJ，RILJ将通话请求发送给RILD； RILD接收到通话指令时，发送给CP； CP发送给网络，MT(Mobile Terminal)收到通话后，告知网络，由网络将该信息传递给MO已将通话信息发送给MT了（就是手机发出嘟嘟声音的时候）：通话状态由DIALING –&gt; ALERTING； RILD收到通话状态变化的消息后，发送一个UNSOL_RESPONSE_CALL_STATE_CHANGED的消息给RILJ； RILJ通知GsmCallTracker通话状态变化了； GsmCallTracker主动查询CALL状态：pollCallWhenSafe()，确保得到的信息是对的，没有发生变化； RILJ给RILD发送getCurrentCalls()的请求； RILD获取到CALL状态后，上报给RILJ，再由RILJ返回结果给GsmCallTracker GsmCallTracker得到确定的CALL状态后，通知GsmPhone：notifyPreciseCallStateChanged(); GsmPhone将CALL状态变化的消息告知Telecom系统服务； 最后，Telecom系统服务发送CALL状态变化的广播给上层APP 到这一步后，通话并没有开始，如果MT接听了电话，则MO会收到CALL状态变化的信息，然后，才真正开始建立通话链接。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RIL</tag>
        <tag>RILD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《通往奴役之路》读书摘记]]></title>
    <url>%2F2016%2F11%2F04%2F%E3%80%8A%E9%80%9A%E5%BE%80%E5%A5%B4%E5%BD%B9%E4%B9%8B%E8%B7%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[连生活都要成为艺术 木心 前言出于对社会主义制度演变的兴趣，一直想读哈耶克(维基百科：https://en.wikipedia.org/wiki/Friedrich_Hayek ）的书。最近利用闲暇时间看完了这本久负盛名的《通往奴役之路》，做了点摘记。里边讲了社会主义理论的本质特征，讲了集体主义与个人自由的冲突，讲了垄断与竞争，看看这样的书，算是对自己以往认知的一个纠正与弥补。以后还要继续读一读哈耶克其他的著作，如《致命的自负》，《自由秩序原理》，也好看一看社会主义究竟是怎样的一幅美景。 摘记 如果从长远考虑，我们是自己命运的创造者，那么，从短期着眼，我们就是我们所创造的观念的俘虏。只有我们及时认识到这种危险，才能指望去避免它。 我们这一代人的共同信念讲把我们引向何处，并不是某一党派的问题，而是我们每一个人的问题，是一个有着最重大意义的问题。在我们竭尽全力自觉地根据一些崇高的理想缔造我们的未来时，我们却在实际上不知不觉的创造出与我们一直为之奋斗的东西截然相反的结果，人们还想象的出比这更大的悲剧吗？ 由基督教与古典哲学提供基本原则的个人主义，在文艺复兴时代第一次得到充分发展，此后逐渐成长和发展为我们所了解的西方文明。这种个人主义的基本特征，就是把个人当做人来尊重；就是在他自己的范围内承认他的看法和趣味是至高无上的。纵然这个范围可能被限制的很狭隘；也就是相信人应该发展摘记的天赋和爱好。 “Freedom”和”liberty”这些字眼儿常常被滥用，以致我们在使用它们表明它们当时所代表的理想时，也颇费踌躇。宽容或许时唯一还能保留这个原则完整意义的字眼儿，这个原则在那个时期整个过程中处于上升状态，只是在近来才又趋于低落，且将随极权主义国家的兴起而彻底消亡。 如常有的情况那样，对我们文明的性质，敌人往往比多数朋友看的更清楚:19世纪的极权主义者奥古斯特-孔德所描述的那样：“西方的长年痼疾，是个体对种属的反抗”，实际上时构建我们文明的力量，１９世纪对前一世纪的个人主义增益，仅仅使所有阶级都意识到自由，把偶然地和拼凑地成长起来的东西加以系统和连续的发展，并将其从英国和荷兰传播到欧洲大陆的大部分地区。 这一成就在未来可能会出现的最有意义和最深远的影响，是一种控制他们自己命运力量的新感觉，是那种对于改善自己命运的无限可能性的信心，这些都是已经取得成就在人们中间创造的。随着成功也就发展出雄心－而人们具有一切权利怀有勃勃雄心。曾经激励人心的承诺似乎不再足够了，进步的速度太迟缓了；过去曾使这一发展成为可能的那些原则，现在则被视为阻止更快进展的障碍，迫切需要消除，而不把它视为保持和发展已经取得成就的条件了。 总是使一个国家变成人间地狱的东西，恰恰时人们试图将其变成天堂。(F-荷尔德林) 没有人比德-托克维尔更清楚的意识到，民主在本质上是一种个人主义的制度，与社会主义有这不可调和的冲突，（他在1848年说:）民主扩展个人自由的范围，而社会主义却对其加以限制。民主尽可能地赋予每一个人价值，而社会主义却仅仅使每一个人成为一个工具、一个数字。民主和社会主义除了“平等”一词之外毫无共同之处。但请注意这个区别：民主在自由之中寻求平等，而社会主义则在约束和奴役之中寻求平等。 “马克思主义已经导致了法西斯主义和民族社会主义，因为就其全部本质而言，它就是法西斯主义和民族社会主义“，而沃尔特-李普曼博士也获得了这种信念： 我们所属的这一代人现在正从经验中懂得，当人们放弃自由，转而强制性地将其事务加以组织的时候，情况会怎么样。尽管他们期望一种更富裕的生活，但他们在实践中肯定放弃了这种期望；随着有组织管理的增加，目标的多样化必定会让位于一体化。这是对有计划的社会和人类事务中独裁主义原则的报应。 竞争和集中管理二者如果是不完全的，都将成为拙劣和无效率的工具，它们是用来解决同一问题时只能任择其一的原则，把两者混合起来就意味着哪一个也不能真正地起作用，其结果反而比始终只凭二者之一的情况还要槽糕些。或者换一种说法：计划与竞争只有在为竞争而计划而不是运用计划反对竞争的时候，才能够结合起来。 倾向垄断和计划的趋势，并不是我们不能控制的”客观事实“的结果，而是种种看法的产物，这些看法酝酿和传播到半个世纪之久，最后它们到达了支配我们一切政策的因素。 但我们必须首先考虑一下，现代技术的这种发展在多大程度上使广泛领域中垄断的发展不可避免。 应当注意，垄断的形成常常是规模大成本低以外种种因素的结果。它通过相互串通的协定而形成并为公开的政策所促进。当这些协定失效和当这些政策扭转过来时，竞争的条件能够恢复的。 在社会演进中，没有什么东西不可避免的，使其成为不可避免的是思想。 虽然在短时期内我们为多样化和选择的自由所必须付出的代价有时可能是很高的，但在长期内即使是物质福利的进展也将有赖于这种多样性，因为我们不能预见从那些可以提供商品或劳务的许多形态中，究竟哪一种可能发展出更好的东西来。 在一个经济生活受到彻底管制的国家中，甚至形式上承认个人权利或少数人的平等权利都会失去任何意义，对于这一点中欧各个国家的经验给予了充分的说明。那里的经验还表明，完全可能通过运用公认的经济政策方面的工具赖推行一种无情的歧视少数民族的政策，同时又保护少数民族权利法规中文字没有任何侵犯。这种以经济政策为手段的压迫由于以下事实而得到极大的促进：某些产业或活动基本上是由少数民族来从事的，因此，许多表面上针对一个产业或一个职业阶层的措施实际上是指向一个少数民族的。 人们常说，没有经济自由的政治自由是没有意义的。这当然对，但在某种意义上，它是和我们的计划着使用这句话的意思几乎相反。作为任何其他自由前提的经济自由，不能是那种社会主义着允诺给我们的、免于经济劳心的自由，也不可能是只能通过解决个人选择的必要性和权力才能获得的自由；经济自由必须是我们经济活动的自由，这种自由，因其具有选择的权利，不可避免地带来那种权利的风险与责任。 我们这一代已经忘了的是:私有制是自由的最重要的保障。 私有财产制度是给人以有限的自由与平等的主要因素之一，而马克思则希望通过消除这个制度来给与人们以无限的自由与平等。奇怪得很，马克思是第一个看到这一点的。是他告诉我们：回顾以往，私人资本主义连同其自由市场的发展成了我们一切民主自由的发展的先决条件。他从未想到，向前瞻望，如果是他所说的那样，那些其他的自由，恐怕就会随着自由市场的取消而消逝。 证明某种计划是正当的这一工作所需要的不是合理的说服，而是接受信条。其实，各地的社会主义者都最先承认：他们承担的任务要求普遍承认一个共同的世界观，一套明确的价值标准。社会主义者正是在发动一个受到这样一个单一世界观支持的群众运动的努力中，首先创造出了这些灌输工具中的最大部分，这些灌输工具也是纳粹和法西斯主义者有效的加以利用过。 有意识控制的可能性只限于存在真正一致的领域中，而在一些领域中必须听任事情的自由发展，这就是民主的代价。但在一个依赖中央计划行使其职能的社会中，就不可能让这种控制依赖于能达成多数一致；将一个微弱少数的意志强加给人民，这往往是必要的，因为这个少数将是人民中间对有争议的问题能达成一致的最大集体。只要政府的职能能根据一种广为接受的信念，能限定在多数人中通过自由讨论能达成一致的领域时，民主政府便能有效地运行。 撇开所有的技术细节不论，法制的意思就是指政府在一切行动中都受到事前规定并宣布的规则的约束－这种规则使得一个人有可能十分肯定地预见到当局在某一种情况会怎样使用它的强制权力，和根据对此的了解计划它自己的个人事务。虽然因为立法者及那些受委托执行法律的大都是不可能不犯错误的凡人，从而这个理想也永远不可能达到尽善尽美的地步，但是法治的基本点是很清楚的：即留给执掌强制权力的执行机构的行动自由，应当减少到最低限度。虽则每一条法律，通过变动人们可能用以追求其目的的手段而在一定程度上限制了个人自由，但是在法治之下，却防止了政府采取特别的行动破坏个人的行动。 只要政府政策对某种人的精确的影响是已知的，只要政府的直接目的是要达到那些特定的影响，它就不能不了解这些影响，因而也就不能做到不偏不倚。它必定有所偏袒，把它的评价强加于人民，并且，不是帮助他们实现自己的目标，而是为他们选择目标。只要当制定法律的时候就已预见到这些特定的影响，那么，法律就不再仅仅是一个供人民使用的工具，反而成为立法者为了他的目的而影响人民的工具。政府不再是一个旨在帮助个人充分发展其个性的实用的机构，而成为一个“道德的”机构－这里的“道德的”一词不是作为“不道德”的反义词来使用的，而是指这样一种机构，它把它对一切道德问题的观点都强加于其成员，而不管这种观点是道德的或者非常不道德的。在这种意义上，纳粹或者其他任何集体主义的国家都是“道德的”，而自由主义国家则不是。 只有在自由主义时代，法制才被有意识地加以发展，并且是自由主义时代最伟大的成就之一，它不仅是自由的保障，而且也是自由在法律上的体现。正像康德所说的那样（并且在他以前，伏尔泰也用非常相似的措辞说过），“如果一个人不需要服从任何人，只服从法律，那么，他就是自由的。” 因此，如果说，在一个有计划的社会，法治不能保持，这并不是说，政府的行动将不是合法的，或者说，这样一种社会就一定是没有法律的。它只是说，政府强制权力的使用不再受事先规定的规则的限制和决定。法律能够（并且为了集中管理经济活动也必须）使那种实质上是专断的行动合法化。如果法律规定某一部门或当局可以为所欲为，那么，那个部门和当局所做的任何事都是合法的－但它的行动肯定地不不是在受法制原则的支配。通过赋予政府以无限制的权力，可以把最专断的统治合法化；并且一个民主制度就可以以这样的一种方式建立起一种可以想象得到的最完全的专制政治来。 只要社会主义运动在一个国家里同一个特定的集团－通常是技术较高的工人－的利益密切的结合起来，对社会各阶层人民的应用地位形成一种共同观点的问题，就比较简单。这种运动直接关涉到某个特定集团的地位，并且，它的目的就是要提高那个集团与其他集团之间的相对地位。但在向社会主义继续前进的过程中，这个问题的性质就会发生变化，每个人越来越明显地看到，他的收入和一般地位要由国家的强制性机器来决定，为了保持或改善其地位，唯有成为一个有组织集团的成员，那个集团能够根据其利益影响或者支配国家机器。 这个问题当然是更加重要的，因为事实上除非与他们自己的利益直接相关，不然的话，世界上的人们是不太可能作出最大努力的。对大多数人来说，要竭尽全力做某事，就需要施加某种外来的压力。在这个意义上，刺激的问题是一个现实的问题，无论在一般的劳动中或管理活动方面都一样，把工程技术应用于整个国家（这就是计划的意义）“会引起一些难于解决的纪律问题”，这是一位对政府计划有很多经验，并且把这一问题看的清楚的美国工程师所讲的话。 如果需要一个人数众多的、有足够力量能把他们自己对生活的标准价值的看法强加在其余所有的人身上的集团，那么，它的构成者绝不会是具有高度不同的和高度发展的趣味的人，而是那些构成“群众”（就这一名词的贬义而言的），很少有创造性和独立性，是那些能够把人数方面的分量作为他们的理想后盾的人。 只有在存在着、或者有可能建立各个人的统一目标的地方，集体主义的社会才能得到发展，这是一个基本事实，除此之外还有一些因素助长了集体主义的门户之见和唯我独尊的倾向。其中一个最重要的因素是个人认同于一个集团的愿望，这常常是一种自卑感引起的，因而，只有那个集团的成员资格能够使他比这个集团之外的大有优越性，他的需要才会得到满足。 每个集体主义制度都有两个主要特征，首先，需要有一个为整个集团共同接受的目标体系，另外，还需要为了达到这些目标而给予该集团以最大限度的权力的压倒一切的愿望，从这种特征产生了一个特定的道德体系，这个道德体系有些方面是同我们的体系相符的，而有些地方则与我们的体系形成了强烈的对比－但其中有一点同我们的体系不同，这使我们怀疑是否能够称之为道德，即它不让个人的良心自由地运用它自己的规则，甚至也没有个人在任何环境中都必须或可以遵守一般性的规则。这便是集体主义道德和我们所知道的那些道德有那么大的区别，以致我们很难在他们仍然保持的那些道德中发现任何原则。 所有权力都易腐化，绝对的权力则绝对地会腐化。 迷信科学，认为科学可以适应于包括道德领域在内的一切领域，我重申，这是19世纪的一种认识。至于那些鼓吹这个学说的人是否真的信仰它，或者他们是否只是想为他们内心的情感披上一种科学威望的外衣，而他们完全知道它只是一种热情而已，这还有待于通过考察去发现。应当注意的是，历史服从于科学的规律这一教条特别被主张专制权力的人所宣传，这是很自然的。因为这个教条可以消除他们最恨的两种现实，即人类自由和个人的历史活动。 他们（集体主义者）似乎还缺少大多数很细小的、但很重要的品质，就是在一个自由社会里会促进人与人之间相互交往的那些品质：和蔼和幽默感，个人谦逊，尊重别人的隐私和对邻人的善意怀有信任。 集体主义者为了达到他们的目的，必须建立起前所未有的巨大权力－人支配人的那种权力－并且他们的成功也取决于他们获得这种权力的程度。 社会主义只有停留在理论层面时，它才是国际主义的，无论是德国还是在俄国，它就马上变成强烈的民族主义。这就从一个方面说明了西方世界大多数人所想象的那种“自由社会主义”何以是纯理论的，而各处实行的社会主义为什么却是极权主义的。集体主义不能容纳自由主义那博大的人道主义，它只能容纳极权主义的狭隘的门户之见。 我们应当重新学习坦白地面对这一事实：即只有花代价才能得到自由，并且，就我们个人来说，我们必须准备作出重大的物质牺牲，以维护我们的自由。如果我们希望保存自由，我们就必须回复作为盎格鲁－撒克逊国家的自由制度之基础的那种信息；这种信心曾经被本杰明-富兰克林表现在一个适用于我们个人的生活，同时也适用于一切国家的生活的句子里：“那些愿意放弃基本自由来换得少许暂时保障的人，即不配得到自由，也不配得到保障”。 有些人争辩说，我们已经以令人惊骇的程度学会了驾驭自然力量，但可惜的是，我们在如何成功地利用社会合作的可能性这一方面是落后了。如果此话就此打住，那么它是相当对头的。但是，如果他们继续作出对比并且争辩说，我们必须像学会如何驾驭自然力量那样学会驾驭社会力量，那他们就错了。这不仅是一条通往极权主义的道路，而且是一条通往我们文明的毁灭的道路，一条必然阻碍未来进步的道路。那些提出这些要求的人，恰恰是通过他们的要求来表明他们尚未了解光是维护我们的即得成果，我们得在何等程度上依赖非人为力量对个人的努力所起的协调作用。 在过去，使文明能够成长壮大的正是人们对市场的非人为力量的服从，没有这种服从，文明就不可能得到发展；正是通过这种服从，我们才能够每天协力筑造某种比我们当中任何人所能充分了解的还有伟大的东西。过去人们的服从是出于现在有些人认为是迷信的那些信仰，出于宗教的谦卑精神，还是出于对早期的经济学者的浅薄说教的尊重，这都没关系；要紧的是，从理性上去了解服从那些我们不能详细地领会其运作机制的力量的必要性，就要比宗教甚或对各种经济学说的敬意所激发的卑下的敬畏感驱使我们去服从它们时还要困难的多。 即使在垄断无法避免的条件下，控制它的最好办法是不是让政府来掌握它，这也是很值得怀疑的。如果我们所讨论的只是单独一种产业，那或许可以这么做。但当我们必须讨论许多不同的垄断产业时，那就有理由主张，宁可让它们存留在不同的个人手中，而不要把它它们合为一体而由政府单独管理。 集体主义思想的悲剧在于：它起初把理性推到至高无上的地位，却以毁灭理性而告终，因为它误解了理性成长所依据的那个过程。我们的确可以这样说，正是一切集体主义学说的谬论和它对“自觉的”控制或“自觉的”计划的要气，才必然会导致这样的一种要求，即某个人的思想应支配一切－虽然只有对社会现象作个人主义式的探讨才会使我们认识到那些指导理性成长的超个人力量。因此，个人主义在社会过程面前的态度是谦逊的，而对其他意见的态度则是容忍的，并且，它恰好是思想上的傲慢自大的对立面，而想全面指导社会过程的那种要求的根源，正是这种思想上的傲慢自大。 我们这一代人很可能忘记的是，道德不仅必定是个人行为的现象，而且只能存在于一定范围之内。在该范围内，个人有为自己作出决定的自由，而且被要求自愿牺牲个人利益来遵守道德的规则。在个人负责的范围以外，就既没有善，也没有恶，既没有机会获得道德评价，也没有机会通过为自己认为是正确的事务牺牲个人欲望来表明个人的道德信念。只有当我们对我们自己的厉害关系负责并且有牺牲它们的自由时，我们的决定才有道德价值。我们没有权利以他人的利益为代价来博取自己无私的美名，而我们要是在没有选择自由的情况下做到了无私，在道德上也不足以称道。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>通往奴役之路</tag>
        <tag>哈耶克</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android系统时间自动更新机制]]></title>
    <url>%2F2016%2F10%2F24%2FAndroid%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android系统是如何更新时间的了？Android提供了两种时间更新方式，NITZ和NTP,其中NITZ是基于移动基站通信更新的，与语音通话时相同的一个通道，而NTP则是通过数据通道（此时手机必须能上网）来更新的。这里，就来了解下这两种时间更新方式具体是如何工作的吧？ 两种时间更新机制NITZNITZ(Network Identity and Time Zone，网络标识和时区），是一种用于自动配置本地的时间和日期的机制，同时也通过无线网向移动设备提供运营商信息。NITZ是自从PHASE 2+ RELEASE 96 的GSM中的可选功能，经常被用来自动更新移动电话的系统时钟。NITZ需要运营商网络支持（通过CS网络），目前国内电信、移动都支持NITZ方式更新时间日期，而联通目前不支持。 参考： https://en.wikipedia.org/wiki/NITZ NTPNTP：NTP(Network Time Protocol)提供准确时间，首先要有准确的时间来源，这一时间应该是国际标准时间UTC。 NTP获得UTC的时间来源可以是原子钟、天文台、卫星，也可以从Internet上获取。这样就有了准确而可靠的时间源。时间按NTP服务器的等级传播。与NITZ不同的是，NTP需要从专门的NTP服务器来获取时间，只要手机连接上网络，都可以实现时间的更新。 参考： https://en.wikipedia.org/wiki/Network_Time_Protocol Android如何更新系统时间Android有一个专门的系统服务 NetworkTimeUpdateServcie来负责更新系统时间，该服务在系统启动时在SystemServer.java中被创建： 12345678910111213141516if (!disableNetwork &amp;&amp; !disableNetworkTime) &#123; try &#123; Slog.i(TAG, "NetworkTimeUpdateService"); networkTimeUpdater = new NetworkTimeUpdateService(context); &#125; catch (Throwable e) &#123; reportWtf("starting NetworkTimeUpdate service", e); &#125;&#125;...try &#123; if (networkTimeUpdaterF != null) networkTimeUpdaterF.systemRunning();&#125; catch (Throwable e) &#123; reportWtf("Notifying NetworkTimeService running", e);&#125; 源码： /frameworks/base/services/core/java/com/android/server/NetworkTimeUpdateService.java 服务初始化NetworkTimeUpdateService初始时会： 注册RIL的ACTION_NETWORK_SET_TIME以及ACTION_NETWORK_SET_TIMEZONE事件，以接受来自Telephony FW的NITZ时间更新； 监听 ACTION_POLL事件(定时更新时间)以及手机网络连接状态； 发送消息同步NTP时间 监听 Settings中“自动更新时间”选项的变化 123456789101112131415/** Initialize the receivers and initiate the first NTP request */public void systemRunning() &#123; registerForTelephonyIntents(); registerForAlarms(); registerForConnectivityIntents(); HandlerThread thread = new HandlerThread(TAG); thread.start(); mHandler = new MyHandler(thread.getLooper()); // Check the network time on the new thread mHandler.obtainMessage(EVENT_POLL_NETWORK_TIME).sendToTarget(); mSettingsObserver = new SettingsObserver(mHandler, EVENT_AUTO_TIME_CHANGED); mSettingsObserver.observe(mContext);&#125; 同步NTP时间如果没有收到NITZ时间的更新并且NTP超过一定间隔没有更新时间，服务会主动去同步NTP时间： 1234// force refresh NTP cache when outdatedif (mTime.getCacheAge() &gt;= mPollingIntervalMs) &#123; mTime.forceRefresh();&#125; NTP从服务器获取时间： 12345678910111213141516171819202122@Overridepublic boolean forceRefresh() &#123;... // We can't do this at initialization time: ConnectivityService might not be running yet. synchronized (this) &#123; if (mCM == null) &#123; mCM = (ConnectivityManager) sContext.getSystemService(Context.CONNECTIVITY_SERVICE); &#125; &#125;... if (LOGD) Log.d(TAG, "forceRefresh() from cache miss"); final SntpClient client = new SntpClient(); if (client.requestTime(mServer, (int) mTimeout)) &#123; mHasCache = true; mCachedNtpTime = client.getNtpTime(); mCachedNtpElapsedRealtime = client.getNtpTimeReference(); mCachedNtpCertainty = client.getRoundTripTime() / 2; return true; &#125; else &#123; return false; &#125;&#125; 源码: /frameworks/base/core/java/android/util/NtpTrustedTime.java 接收NITZ时间Telephony Framework层在接收到最新的NITZ时间后，会主动发送广播请求更新系统时间，NetworkTimeUpateService接收到广播后，保存相应的NITZ时间,下一次poll请求时，就会将该事件更新为系统时间。 1234567891011private BroadcastReceiver mNitzReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (TelephonyIntents.ACTION_NETWORK_SET_TIME.equals(action)) &#123; mNitzTimeSetTime = SystemClock.elapsedRealtime(); &#125; else if (TelephonyIntents.ACTION_NETWORK_SET_TIMEZONE.equals(action)) &#123; mNitzZoneSetTime = SystemClock.elapsedRealtime(); &#125; &#125;&#125;; 监听Settings中 “自动确定时间和日期”的变化在setting中勾选“自动确定时间和日期”、“自动确定时区”后对key值为AUTO_TIME和AUTO_TIME_ZONE的Preference进行了赋值. 源码路径：packages/apps/Settings/src/com/android/settings/DateTimeSettings.java 12345678910void observe(Context context) &#123; ContentResolver resolver = context.getContentResolver(); resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.AUTO_TIME), false, this); &#125; @Override public void onChange(boolean selfChange) &#123; mHandler.obtainMessage(mMsg).sendToTarget(); &#125; NetworkTimeUpdateService在检测到key值改变的时，就会发送一个消息EVENT_AUTO_TIME_CHANGED;handler接到消息后进行消息处理调用onPollNetworkTime(msg.what): 123456789public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case EVENT_AUTO_TIME_CHANGED: case EVENT_POLL_NETWORK_TIME: case EVENT_NETWORK_CONNECTED: onPollNetworkTime(msg.what); break; &#125;&#125; 在onPollNetworkTime方法中先判断是否勾选“自动更新时间”，如果没勾选直接退出，如果勾选了再看。如果NITZ已经更新了（不为NOT_SET(-1))，且更新间隔小于mPollingIntervalMs(mPollingIntervalMs=246060*1000)，则直接用NITZ更新系统时间，否则用NTP同步时间。 1234567891011121314151617181920// If NITZ time was received less than mPollingIntervalMs time ago,// no need to sync to NTP.if (mNitzTimeSetTime != NOT_SET &amp;&amp; refTime - mNitzTimeSetTime &lt; mPollingIntervalMs) &#123; resetAlarm(mPollingIntervalMs); return;&#125; final long ntp = mTime.currentTimeMillis(); mTryAgainCounter = 0; // If the clock is more than N seconds off or this is the first time it's been // fetched since boot, set the current time. if (Math.abs(ntp - currentTime) &gt; mTimeErrorThresholdMs || mLastNtpFetchTime == NOT_SET) &#123; // Set the system time ...... if (ntp / 1000 &lt; Integer.MAX_VALUE) &#123; SystemClock.setCurrentTimeMillis(ntp); &#125; 当从NTP服务器上获取的时间和当前时间之差的绝对值大于一个阀值，则认为当前时间错误，需要更新时间。 总结： 时间自动同步选项未勾选，不主动更新时间，直接返回； NITZ已同步且上次NITZ同步未超过24小时，则设置定时器24小时后再触发同步，即广播NetworkTimeUpdateService.ACTION_POLL； NTP上次成功同步超过24小时或用户勾选自动同步选项，则进行下面的NTP同步，否则同上设置定时器24小时后再触发同步 参考文献 http://www.2cto.com/kf/201409/334153.html http://blog.csdn.net/lindir/article/details/7973700 https://en.wikipedia.org/wiki/NITZ https://en.wikipedia.org/wiki/Network_Time_Protocol]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统时间更新</tag>
        <tag>NITZ</tag>
        <tag>NTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java程序编译过程]]></title>
    <url>%2F2016%2F10%2F24%2FJava%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java编译过程一般，C/C++程序的编译过程可以分为５个步骤（见下图）：Preprocessing(预处理),Parsing(解析), Translation(翻译),Assembling(汇编）,Linking(链接)。 Java程序具有平台无关性，其在Java Virtual Machine(JVM)上执行，因此编译过程与C/C++大不相同：Java程序首先由编译器翻译成包含了Bytecode(字节码）的.class文件，程序执行时，由类加载器(class loader)将该类的字节码加载到JVM中，JVM会解释执行相应的Bytecode。 那么，一个Java程序是如何变成Bytecode的了?主要由3个过程： (1) 解析：Java源代码文件被解析成一个个标记(Token)，解析器根据Token生成语法树(syntax trees);(2) 注释处理:注释处理器(annotation processors)处理所有注释；如果注释处理器产生了新的源文件或者class文件，会重启编译过程，直到没有新的文件产生为止；(3) 语义分析与字节码生成：在这一步，将语法树转化成类文件,生成字节码。 变量/引用等变量或符号标注； 数据与控制流分析：局部变量赋值、方法返回值以及异常处理等逻辑验证; 解析语法糖：如泛型与类型擦除，遍历循环、自动拆箱（装箱）以及条件编译等 产生字节码，输出到磁盘 Java字节码最后，我们来看一看Java字节码究竟长什么样子。 新建一个.java文件， 1234567public class HelloWorld&#123; private static final String helloWorld = "hello world"; public static void main(String[] args)&#123; System.out.println(helloWorld); &#125;&#125; 利用javac编译生成对应的.class文件,输入下列命令 1javap -c xxx.class 可以反汇编对应class文件的字节码： 1234567891011121314151617//Compiled from "HelloWorld.java"public class HelloWorld &#123; public HelloWorld(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return public static void main(java.lang.String[]); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #4 // String hello world 5: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return&#125; 这里，bytecode实际上就成了JVM的机器语言，里边是一条条JVM可执行的指令。 参考文献 http://www.borjournals.com/a/index.php/jecas/article/viewFile/289/866 http://openjdk.java.net/groups/compiler/doc/compilation-overview/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Compiling process</tag>
        <tag>字节码</tag>
        <tag>class　file</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由人定胜天说起]]></title>
    <url>%2F2016%2F10%2F16%2F%E7%94%B1%E4%BA%BA%E5%AE%9A%E8%83%9C%E5%A4%A9%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[我同意叔本华说的，引导人们通向艺术和科学的最强烈动机之一是摆脱日常生活及其中令人痛苦的粗糙状态和无望的枯燥乏味，摆脱一个人自身总是在变化着的欲望的羁绊。。。就像画家、诗人或者哲学家一样，科学家努力要创造一个属于他自己的世界。他们中的每个个人都是这个宇宙及它的结构成为它的感情生活的支点，这是为了以这种方法寻找到他在狭窄的个人经历的漩涡中无法找到的宁静与安全 爱因斯坦 前言中国社会经济的快速发展，给人一种无限的权能感：只要敢于做，大胆做，我们就可以做到想做的任何事情。权力阶层无不如此。因而才有了轰轰烈烈的城市改造，把老祖宗留下的一点建筑文化遗迹都拆除干净；把过去的东西都拆掉，重新修高楼大厦。才有了四万亿的经济刺激计划，才有了最近闹得红红火火的“大众创新，万众创业”。这些冒进的措施与口号，即使出发点是好的，但由于脱离实际，没有考虑到事物的自然发展规律，因而注定是要失败的，长远来看，只会损害社会的发展与民族的进步。 这些表面上的繁华与个人的好大喜功，常常使我想起“人定胜天”这个词语的含义在中国社会的演变。这里，就来谈一谈我由人定胜天这个观念想到的一些事情。 词义演变讲到“人定胜天”，现在一般人的理解是：反映人的主观能动性可以克服客观的任何困难。《现代汉语词典-第五版》（商务印书馆）里解释为：人力能够战胜自然。可是，这个词原本就是这个意思？古语里究竟是怎么来的？这个词语有着怎么样的演变历史，又是如何跟中国近几十年社会的变化相联系的？ 《吕氏春秋》（亦称《吕览》）中有，“天定则胜人，人定则胜天；故狼众则食人，人众则食狼 ”，而南宋词人刘过的《襄阳歌》:“人定兮胜天,半壁久无胡日月”。“人定”是“人谋”的意思,是指在一定条件下,人谋的因素比天命还重要,“胜”是“比什么更为重要”而不是要战胜的意思。冯梦龙的《喻世明言》讲相与命的关系,说:“却又犯着恶相的,却因心地端正,肯积阴功,反祸为福。此是人定胜天,非相法之不灵也。”意思是一个人相貌虽犯恶,但心地端正、肯积阴功,人的因素更为重要。其实“人定胜天”只是鼓励人不要因命运崎岖而放弃努力的意思。 自古以来,中国文化都强调天人合一,强调顺应自然,不要拂逆天意,皇帝也只敢自称“天子”,根本就没有要战胜老天爷的文化。 “人定胜天”变成了现在这个意思，是出自毛泽东的手笔。毛泽东曾说过，“四川的老百姓，一怕老天爷，二怕瞎指挥。我毛泽东管不了老天爷，马克思也管不着。但是我提倡‘人定胜天’。一方面，要‘听天由命’；另一方面，要‘人定胜天’，要充分发挥人的主观能动性。上井冈山时，我们只有几个人，可是后来我们建立了新中国。” 毛早年的文章《愚公移山》,还没有战天斗地的涵意,到1957年他发出“愚公移山,改造中国”的口号,却把原来古老故事中的“(天)帝感其诚”的涵义阉割掉,掀起了“人有多大胆,地有多大产”的大跃进。从此，“人定胜天”演变成了现在这个意思。 由历史想到的从50年代后期开始的“大跃进”运动，以及后来发生的文化大革命，彻彻底底的“改造”了中国社会。精英与知识分子几乎被清洗殆尽，官运亨通的是那些会溜须拍马屁，会投机取巧与钻营狠毒的人。这是一个民族的悲剧，也是民族的悲哀，同样是毛本人的悲哀。看一看，那个时代各种标语与口号，就能看出不受限制的权能与权力感，会造成怎样的荒唐：人有多大胆，地有多大产 一个萝卜千斤重，两头毛驴拉不动 土地潜力无穷尽，亩产多少在人为 倾家荡产大炼钢铁 今天来看，毛本人的”人定胜天“思想，是完完全全失败的，这种观念对中国社会产生的危害一时也无法估量。不难发现，如今大权在握的领导无不是毛时代成长起来的，这些人依然沿袭了那个时代的好大喜功，喊口号的模式，而完全忽略了人性的需求与自然的规律。 毛及其所领导的党企图利用马克思主义理论就要再造一个所谓的新社会，要创造一个社会主义中国。这种狂妄自大与盲目自信让他们忘记了自然规律的存在，忘记了尊重自然与顺应人性的必要性。这是一种人自身权能感无限膨胀后的结果，这是对人性与生命，对自然与宇宙缺乏基本敬畏之心的必然。 当下社会，到处都是灯火辉煌，歌舞升平，人类再不比以往。科学技术的发展已经让人衣食无忧，不用再受到来自其他生物的生存威胁，不用再在草原里奔跑以获取必要的食物，不要再辛苦的劳作，因为机器已经代替了很多繁重的工作。人类已经可以上天下地了，可以修筑高达几百米的建筑，人类在地球上已经完全是“王者”的地位了，人类在某些方面的确进步了不少，但今天的人是否比几万年钱的祖辈更快乐幸福了？不，不！相反，如今的人在纸醉金迷与虚浮享乐的路上越走越远，忘了人自身的本性需求，忘了自然馈赠的可贵，而成为了自造工具的奴隶，变得越来不像人了，变得越来越像一个原始的动物，变得越来越麻木而茫然。权能感的上升让人走路轻都飘飘了。 我们破坏了山丘，破坏了田野，污染了河流，污染了大地，到处是人自己建设的单调而沉闷的建筑。这何时是个尽头？这是否会有尽头？这里的人，何时才能找回对自然与宇宙，对人性与自然秩序的尊敬与敬畏？]]></content>
      <categories>
        <category>社会万象</category>
      </categories>
      <tags>
        <tag>历史</tag>
        <tag>哲学</tag>
        <tag>社会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停机问题]]></title>
    <url>%2F2016%2F10%2F15%2F%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[停机问题(The halting problem) 是可计算理论（Computability theory）中至关重要的一个问题。简单的来说，它要解决:给定一个输入，需要确定一个计算机程序是否能停机（产生问题的解）或者陷入死循环。究竟是否存在一个机器，能够检查给定任何输入的任何程序，确定程序是否在有限时间里停机了？ 通常，使用Turning Machines(图灵机）来证明该理论：停机意味着图灵机接受或者拒绝一个输入，而如果一个程序在图灵机上陷入了死循环，则说明该图灵机不能在给定的输入上产生解。早在1936年，Alan Turing就证明了，停机问题是不可判定的，因而不可解。如果停机问题存在解，则其他许多计算机科学的难题也会得到解答，如 Kolmogorov compexity, the Busy Beaver function等。 参考文献 https://en.wikipedia.org/wiki/Halting_problem https://brilliant.org/wiki/halting-problem/]]></content>
      <categories>
        <category>Computer theory</category>
      </categories>
      <tags>
        <tag>Halting Problem</tag>
        <tag>Computability theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Shell快速入门]]></title>
    <url>%2F2016%2F10%2F14%2FLinux-Shell%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言开始使用Ubuntu操作系统，感觉使用起来也没有太多的障碍，但是对于Shell脚本一直了解不多，于是打算学习下。以下是一个简单的小结（学习Linux 命令对于Android的开发也大有帮助，很多Linux Shell命令在Android中都有对应的版本）。 脚本语言，既然冠之以“语言”，就说明它跟其他C/C++等编译语言在形式上是完全一样的，有变量，有函数，有if,else,while等条件分支，只是脚本语言是解释性的执行：碰到一句，解释一句，执行。 写一个脚本看一看运行脚本之前，需要做三件事情： 写一个脚本 使Shell有权限执行该脚本 把脚本放在Shell可以找到的地方 打开文本编辑器，输入下列文本,保存为my_scripts.sh： 1234#!/bin/bash# this is my first shell scriptecho "hello shell scripts" 第一脚本就写成了。运行脚本之前，你可能需要修改脚本的权限： 1chmod 755 my_scripts 输入下面命令执行脚本： 1./my_scripts.sh 基础变量shell脚本提供了不少环境变量来获取系统信息，如用户名，主机名，时间等： 1$HOSTNAME,$USER,$DATE 这些变量是全局的，在任何时候都可以使用。但，要在脚本中使用的变量（变量无需声明，直接使用即可），却并不具备这样的全局性，例如，有如下脚本 myvar.sh： 1234#! /bin/shecho "MY_VAR is: $MY_VAR"MY_VAR= "hi, there"echo "MY_VAR is : $MY_VAR" 执行如下脚本命令： 1234$ MY_VAR=hello$ ./myvar.shMY_VAR is:MY_VAR is: hi, there 输出： 12MY_VAR is:MY_VAR is: hi, there 因而，变量MY_VAR并不具有全局的作用域，如果要像环境变量一样使用该变量，必须将其export： 12345$ MY_VAR=hello$ export MY_VAR$ ./myvar.shMY_VAR is:MY_VAR is: hi, there 这样输出就变了： 12MY_VAR is: helloMY_VAR is: hi, there 附几个比较特殊的变量： $$ 该脚本对应的PID(进程ID） $？ 上一个脚本命令的退出条件值 函数1function fcn_name()&#123; ... &#125; 那么，怎么知道函数的参数了？很简单，$1对应第一个参数，$2对应第二个参数，以此类推，$0则表示执行脚本本身的名字，另外有几个个比较特殊的变量： $# 函数的参数个数(执行脚本的参数） $@ 除了脚本名外所有的参数，$1 $2 .... 1234567 #! /bin/shwhile [ "$#" -gt "0" ]do echo "\$1 is $1" shiftdone 不是还有递归吗？Shell脚本同样可以实现： 1234567891011121314151617181920#! /bin/shfactor()&#123; if [ "$1" -gt "1" ]; then i= 'expr $1 - 1' j='factor $i' k='expr $1 \* $j' echo $k else echo 1 fi&#125;while:do echo "enter a number" read x factor $xdone 语句多举几个栗子就看懂了。 if/else 条件判断123456789101112131415161718# first formif condition ; then commandsfi# Second formif condition ; then commandselse commandsfi# Third formif condition ; then commandselif condition ; then commandsfi 循环123456789101112131415#! /bin/shfor i in 1 2 3 5 9do echo "number $i"done#! /bin/shINPUT_STR=hellowhile [ "$INPUT_STR" != "bye" ]do echo "Please type something (bye to quit)" read INPUT_STR echo "you just typed: $INPUT_STR"done 上述ffor循环可以写成C风格的形式: 1234567#! /bin/shfor (( i = 1; i &lt; 9; i++ ))do echo "number $i"done Case12345678910111213141516171819202122#! /bin/shecho "please say something to me..."while:do read INPUT_STR case $INPUT_STR in hello) echo "hello you too!" ;; bye) echo "See you again!" break; ;; *) echo "fail to understand" ;; esacdoneechoecho "that's the all my folks!" 退出条件应用执行是否成功的标志，是一个0～255之间的整数，0表示应用没有发生错误，执行成功；其他任何值都表示发生了错误。 用 $? 即可查看一个命令是否执行成功。 例如判断某个文件是否存在： 123456#! /bin/bashif [ -f .bash_profile ]; then echo "You have a .bash_profile. Things are fine."else echo "Yikes! You have no .bash_profile!"fi 命令索引 Expression Description Example &amp; run the previous command in the background ls &amp; &amp;&amp; logical AND if [ &quot;$foo&quot; -ge &quot;0&quot; ] &amp;&amp; [ &quot;$foo&quot; -le &quot;9&quot; ] or logical OR if [ &quot;$foo&quot; -ge &quot;0&quot; ] or [ &quot;$foo&quot; -le &quot;9&quot; ] ^ start of line grep &quot;^foo $ end of line grep &quot;foo$ = string equlity if [ &quot;$foo&quot; = &quot;bar&quot; ] ! logical NOT if [ &quot;$foo&quot; != &quot;bar&quot; ] $$ pid of current shell echo &quot;PID=$$ $! pid of last background command ls &amp; echo &quot;PID of ls = $! &amp;? exit status of last command ls; echo &quot;ls returned code $? $0 name of current command echo &quot;I am $0&quot; $1 name of 1st parameter echo &quot;first argument is $1 $9 name of 9th parameter echo &quot;nith argument is $9 $@ all of current commands’ parameters(preserving whitespace/quoting) echo &quot;my arguments are $@ $* all of current commands’ parameters(not preserving whitespace/quoting) echo &quot;my arguments are $* -d file True if file is a directory if [ -d /bin ] -e file True if file exists if [ -e /home/bin/my.text ] -f file True if file exists and is a regular file if [ -f /bin/fs] -L file True if file is symbolic link if [ -L /bin/fs ] -r file True if file is readable if [ -r /bin/fs ] -w file True if file is writable if [ -w /bin/fs ] -x file True if file is executable if [ -x /bin/fs ] f1 -nt f2 True if f1 is newer than f2(modification time) if [ &quot;@f1&quot; -nt &quot;$f2&quot; ] f1 -ot f2 True if f1 is older than f2 if [ &quot;@f1&quot; -ot &quot;$f2&quot; ] -z string True if string is empty if [ -z &quot;$f00&quot; ] -n string True if string is not empty if [ -n &quot;$f00&quot; ] str1=str2 True if str1 equal str2 if [ &quot;$foo&quot; = &quot;bar&quot; ] str1!=str2 True if str1 not equal to str2 if [ &quot;$foo&quot; != &quot;bar&quot; ] Markdown显示原因： or实际为 || 参考文献 https://google.github.io/styleguide/shell.xml http://www.shellscript.sh/ https://coolshell.cn/articles/8883.html https://coolshell.cn/articles/8619.html https://github.com/alebcay/awesome-shell https://github.com/awesome-lists/awesome-bash https://github.com/epety/100-shell-script-examples http://tldp.org/LDP/abs/html/]]></content>
      <categories>
        <category>Linux Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell Scripting</tag>
        <tag>Bash</tag>
        <tag>Unbuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dependency Inversion Principle]]></title>
    <url>%2F2016%2F10%2F13%2FDependency-Inversion-Principle%2F</url>
    <content type="text"><![CDATA[依赖反转原则 原文链接 by Robert C. Martin(Uncle Bob) 前言这篇文章写于1996年，里边清晰而简明的介绍了“依赖反转原则”，对了解Dependency Injection很有帮助。今天看来，仍然具有很好的释疑作用。 介绍我上一篇96年的文章谈到了 Liskov Substitution Principle(LSP)。 这个原则应用到了C++时，为使用公开(public)继承（inheritance)提供了指导。 该原则说，每一个操作一个基类的引用或者指针的函数，都应能够同样操作该基类的派生类，即使其对该派生类一无所知。这就意味着，派生类的虚成员函数必须与基类的虚成员函数保持一致，并且不应该做更多的事情。也就是说，基类中的虚成员函数必须要在派生类中，并且保证只做有用的工作。如果违背LSP原则，操作基类的引用或指针的函数将不得不检查具体对象的类型，以确保操作正确。而检查对象类型则违反了上周讲到的Open-Closed Principle(OCP)。 在此次专栏里，我们将讨论OCP与LSP结构化带来的启示。 严格使用这些原则所产生的结构，可以被一般化成一个更为基本的原则，我称之为“Dependency Inversion Principle”(DIP)。 软件出现了什么问题？大部分人都与有着”糟糕设计“的软件打过交道。有些人则往往发现，自己就是那些具有“糟糕设计”的软件的作者。那么，究竟是什么让一个设计变得如此糟糕了？ 大多数软件工程师并不准备创造”糟糕的设计”。然后大多数软件最终都沦为到某个一个点：有人宣称这个设计很不靠谱。为什么发生这种事了？是否设计一开始就很糟糕，抑或设计实际上像一块腐肉一样变得越来越烂？该问题的关键在于，我们缺乏一个”糟糕设计”的好的定义。 什么是糟糕的设计你是否曾提交过一个令自己感到自豪的软件设计，被同行所评审？而那个评审人员却发牢骚似的讥讽道，“你为什么要这么设计”。当然，这时在我身上发生过，我也见过它发生在其他很多工程师身上。很明显，有不同意见的评审工程师并没有使用相同的标准去定义糟糕的设计是什么。我见过最常使用的原则是，“这不会是我实现它的方式”。 但是，我以为应该有一套标准为所有的工程师所认同。一个软件如果满足其设计需求，但是仍然表现出如下三个特征中的任何一个的话，就是一个糟糕的设计： 难以修改： 每个修改都会影响到系统的很多部分(Regidity) 修改时，系统某些部分难以预料出现崩溃（Fragility) 因为无法从当前应用中分离出来，很难在其他应用中复用(Immobility) 而且，很难说，一个软件并没表现出上述三个特征中的任何一个的话，它做到了可扩展性（flexible)，健壮性（robust)以及可复用性（reusable),并且满足了设计需求，会有糟糕的设计。因此，我们可以用上述三个特征来清晰的区分什么是好的设计，什么是坏的设计。 糟糕设计的源头什么导致一个设计缺乏可扩展性、健壮性以及可复用性了？设计里相互依赖的模块。一个设计不容易被修改，则不可扩展。如此僵化源自于一个事实，修改一个模块之间严重依赖的软件会导致一系列其他的相关模块的改动。当此种修改的范围超出设计者或者维护人员的预期时，修改的影响是无法估计的。这使得修改的代价难以预料。项目管理人员，面临如此不可预料的改动，常常不愿意授权修改。如此，这样的修改就被正式确定下来。 不具备健壮性，意味着一个小的修改都会引起程序其他部分发送崩溃。往往，新问题的发生点与修改点并没有概念上的关联。这种设计上的脆弱很大程度上降低了设计与维护公司的信用度。用户与管理人员无法预料他们产品的质量。在应用一个部分的小改动导致了其他毫不相关部分的崩溃。修复这些问题导致更多的问题，致使维护过程变成了一个狗追咬自己尾巴的恶性循环。 一个设计不可复用，是由于期望设计的部分严重依赖于其他部分的实现细节。如果设计考量下该设计是否可能在其他应用中复用，可能他会对该设计在新的应用中的表现有更深的印象。倘若该设计模块之间高度依赖，设计者们同样会被将需要的部分与不需要的部分分离所苦恼。大部分情况下，这样的设计不可复用，是因为分离的代价要远高于重新开发设计的代价。 示例： “Copy”程序为了更好的阐述上述观点，先看个简单的例子。考虑实现一个将键盘输入的字符拷贝到一个打印机上的程序。假定，实现平台并没有一个支持设备独立的操作系统。这个程序的结构看起来如下图1所示： 图 1 是一个框架图：程序由3个部分组成，”Copy”模块调用其他两个模块。其对应的代码实现如下所示：主体循环不断地调用“读取键盘”模块，以获取键盘输入字符，然后将字符发送到“写打印机”模块以打印字符。 12345 void copy()&#123;int c;while((c == ReadKeyboard()) != EOF) WritePrinter(c);&#125; 两个低层模块具有很好的可复用性。他们可以用在其他程序中操作键盘与打印机。这与从库中调用子程序很类似。 但是，如果没有键盘或者打印机的时候，这个“Copy”模块就不具备可复用性了。这个系统所蕴含的智慧仅仅用在了这个模块，这真是让人惭愧。正是”Copy”模块蕴藏了一个我们可以复用而很有趣的策略。 例如，考虑一个将键盘字符拷贝到磁盘文件的新程序。当然，我们希望使用已有的“Copy”程序，其包含了一个我们需要的高层策略；它知道如何将字符从一个源拷贝到另一个源。不幸的是，“Copy”模块依赖于“Write Printer”模块，因此在此种情况下，不能使用。 为此，我们可以赋予”Copy”模块一个新的功能（代码如下）。通过对输出设备进行判定，来决定是写入“Printer”还是“Disk”。但是，这却增加了系统彼此依赖的程度。随着时间的推移，越来越多的设备希望使用复制功能，而“Copy”模块则会被一长串的 if/else弄凌乱，也因此它需要依赖于更底层的模块。最后，代码的可复用性与健壮性都会受到影响。 12345678910 enum OutputDevice &#123; printer, disk&#125;void Copy(outDevice dev)&#123; int c; while(( c == ReadKeyboard() != EOF)&#123; if( dev == printer) WritePrinter(c); esle WriteDisk(c); &#125;&#125; 依赖反转(Dependency Inversion)一个描述上述问题的方法是，注意到包含了上层策略的“Copy”模块，依赖于底层它控制模块的实现细节。如果，我们能找到一个办法，使”Copy()”模块独立于它控制的细节的话，代码的可复用性就大大提高了。我们可以使用该模块从任何设备拷贝字符，然后复制字符到任意的输出设备。面向对象设计（OOD）给了我们一个实现依赖反转的机制。 考虑下图2的类结构图：有一个Copy类，包含了一个抽象的Reader类、Writer类。不难以此写出一个从Reader获取字符然后发送到Writer的”Copy“类（见下列代码）。这个“Copy”类不依赖于“KeyBoard Reader”，也不依赖于”Printer Writer”。因而依赖被反转了；”Copy”类依赖于抽象，并且reader与writer的具体实现依赖于同一个抽象。 现在，只要派生出“AbstractReader”以及”AbstractWriter“,我们可以复用“copy”类。并且，不管有多少新的”Reader”,”Writer”，“Copy“都不会依赖于它们。这里并没有什么相互依赖使得程序变得不可复用或者健壮性差。而且，Copy类可以再不同的输入输出环境里使用。同样满足了可复用性。 12345678910111213141516class Reader&#123; public: virutal int Read() = 0;&#125;class Writer&#123; public: virutal void Write(char) = 0;&#125;void Copy(Reader&amp; r, Writer&amp; w)&#123; int c; while((c = r.Read()) != EOF)&#123; w.Write(c); &#125;&#125; 设备无关到现在为止，很多人可能会想，利用stdio.h中的设备无关性，完全可以用C来实现同样的 Copy功能：getChar(),putChar()（具体代码如下所示）。如果你仔细考虑下上一节中OO版本的代码与C版本的代码，你会认识都两者在逻辑上完全是等价的。图3 中的抽象类被另一种形式的抽象替代了。尽管，C版本代码没有使用类和纯虚函数，但它仍然使用了抽象与多态来实现相同的目的。而且，也同样使用了依赖反转：Copy 并不依赖于任何实现的细节，而是依赖于stdio.h提供的抽象；调用的IO驱动也依赖于stdio.h中的抽象。因此，stdio.h中的设备无关性是另一个依赖反转的栗子。 12345678#include&lt;stdio.h&gt;void Copy()&#123; int c; while(( c == getchar()) ！= EOF)&#123; putchar(c); &#125;&#125; 看过了几个例子之后，我们来叙述下DIP的更一般形式。 The Dependency Inversion Principle High Level modules should not depend upon low level modules. Both should depend upon abstractions.(上层模块不应该依赖于底层模块；两者都应该依赖于抽象) Abstractions should not depend upon details. Details should depend upon abstractions（抽象不应该依赖于细节；细节应该依赖于抽象）. 有人可能疑惑，我为什么要用“inversion”（反转)。坦白说，是因为传统的软件开发技术，如结构化分析与设计，通常创造出一种上层依赖于底层的软件结构，而且抽象依赖于细节。此种方法的目标之一是定义描述上层模块如何调用下层模块的子程序层级结构。下图3是一个很好的示例。因此，相对于传统的面向过程的方法，一个设计良好的OOP程序结构被“反转(inverted)”了。这是中间层设计的核心原则。 分层根据Grady Booch的说法，“所有结构良好的OO架构都有很清晰的分层结构，每一层通过清晰定义的接口提供了一套一致性的服务”，简单的利用该原则，我们可以将图3中的结构改变成类似的结构。在这个结构图中，上层Policy类使用底层的机制，而该机制反过来使用了一个细节化的Utility类。尽管这种方法看起来不错，但它有一个隐藏的要害：Policy层容易受到Mechanism层一直到Utility层的影响。依赖具有传递性。Policy层依赖于Utility层的某些接口，因此Policy层传递性的依赖于Utility层。这很不幸。 图4展示了一个更为合适的模型。底层都是由抽象接口来表示。实际的实现都是直接继承了该接口，而上层则通过接口与底层进行交互。因此，各个层之间是相互独立的。相反，层是依赖于抽象接口。这样，Policy层与Utility层之间的依赖传递被阻断了，并且Policy层与Mechanism层的直接依赖关系也被打破了。 使用这个模型，Policy层不会受到Mechanism层或者Utility层变化的影响。更重要的是，只要提供了一个与Mechanism接口一致的底层模块，Policy层可以被复用。因此，通过反转依赖，我们创造出来一种同时具备可扩展性、可持续性以及可复用性的结构。 在C++中将接口与实现分离有人可能抱怨说，图3的结构并没有表现我所说的依赖关系以及依赖传递。毕竟，Policy层仅仅依赖于Mechanism层的接口。为什么Mechanism层的修改会影响到Policy层了？ 对某些OO编程语言来说，确实如此。在这些语言中，接口（interface）与实现（implementation）是自动分离的。然而，在C++中，并没有将接口与实现分离，相反，这种分离存在于类的定义以及类的成员函数定义之间。 在C++中，我们通常将一个类分成两个模块：.h和.cc。.h模块包含了类的定义，.cc文件包含了类成员函数的定义。在.h类的定义中，包含了所有成员函数与变量的声明。这种声明超过了简单的接口。所有通用的函数以及私有变量都在.h模块中声明了。这些通用函数以及私用变量是类实现的一部分，然后他们出现在用户需要依赖的模块中了。因此，在C++中，实现并没有与接口分离。 接口与实现分离的情况可以通过纯虚类来处理。一个纯虚类是一个只有纯虚函数的类。由于.h文件中并没有该类的实现，因此纯虚类是一个单纯的接口。图4就是这样的结构：抽象类是纯抽象的，以至每一层都仅仅依赖于下一层的接口(interface)。 一个简单的示例只要一个类需要发送消息给另一个类，依赖反转就适用。接下来，以一个Button对象和Lamp对象为例说明这种情况。 Button对象感知外界环境，确定是否有用户按下。具体的原理怎么样，并无关系，它可以是一个GUI界面上的按钮图标，一个被手指按压的物理按钮，甚至可以是一个家庭安全系统中的运动检测器。Button对象检测是否有用户按下。Lamp对象在接收到TurnOn的信息之后，点亮一个类似于灯的东西；如果接收到TurnOff的消息，则熄灭灯。 怎么才能设计一个Button对象控制Lamp对象的系统了？下图5是该系统的一个简图。Button对象只是将TurnOn/TurnOff发送给Lamp对象。为实现一目的，Button类包含了一个Lamp类作为类成员。 下列代码实现了图5中的模型。注意到，Button类直接依赖于Lamp类。这意味着，如果Lamp类改变了，Button至少需要重新编译。而且，用来控制一个Motor对象，Button类就不可复用了。因而，该实现违背了DIP原则：上层并没有与底层分离开；抽象也没有与细节分离。没有这样的分离，上层会自动依赖于底层，而抽象也会自动依赖于细节。 12345678910111213141516171819202122232425262728293031323334// lamp.h class Lamp&#123; public: void TurnOn(); void TurnOff();&#125;;// button.hclass Lamp;class Button&#123; public: Button(Lamp&amp; l) : mLamp(&amp;l) &#123; &#125; void Detect(); private: Lamp* mLamp;&#125;// button.cc#include"button.h"#include"lamp.h"void Button:Detect()&#123; bool buttonOn = GetPhysicalState(); if(buttonOn)&#123; mLamp-&gt;TurnOn(); &#125;else&#123; mLamp-&gt;TurnOff(); &#125;&#125; 寻找潜在的抽象什么才是上层需要的策略？是构成应用的某种抽象，细节的变化并不会引起上层变化的事实。在Button/Lamp示例中，潜在的抽象是，从用户那里检测on/off的动作，并将其传递给目标对象。究竟是什么机制来检测该动作？这毫不相关。什么是目标对象？毫不相关！这些实现的细节不应该影响抽象。 为了实现DIP原则，必须要讲问题的抽象与实现细节分离。因此，需要将设计的依赖换一个方向，使得细节依赖于抽象。下图6展示了这样一个设计。 在图6中，我们将Button类的抽象与其实现的细节隔离开来。下面是其实现的代码。现在上层的策略全部在抽象的Button类中了。Button类不知道任何检测用户物理状态的机制。这些细节全部被隔离在具体的派生类：ButtonImpl以及Lamp类。 下列代码中的上层策略可以针对任何按钮与设备复用，而且它并不会受到底层机制变化的影响。因此，它具有很好的健壮性，可扩展性以及可复用性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// buttonClient.hclass ButtonClient &#123; public: virtual void TurnOn() = 0; virtual void TurnOff() = 0;&#125;// button.hclass ButtonClient;class Button &#123; public: Button(ButtonClient&amp;); void Detect(); virtual bool GetState() = 0; private: ButtonClient* mClient;&#125;//button.cc#include"button.h"#include"buttonClient.h"Button::Button(ButtonClient&amp; bc) : mClient(&amp;bc) &#123; &#125;Button::Detect() &#123; bool buttonOn = GetState(); if(buttonOn) &#123; mClient-&gt;TurnOn(); &#125;else &#123; mClient-&gt;TurnOff(); &#125;&#125;// lamp.hclass Lamp: public ButtonClient &#123; public: virtual void TurnOff(); virtual void TurnOn();&#125;// buttonImp.hclass ButtonImpl: public Button &#123; public: ButtonImpl(ButtonClient&amp;); virtual bool GetState();&#125; 进一步扩展抽象有人也许会对图6中的设计抱怨说，被Button控制的设备必须从ButtonClient中派生出来，假如Lamp类来自第三方库的话，我们无法修改源代码了。下图7展示了如何用Adapter模式将第三方库的Lamp对象加入到该模型中来：LampAdapter将继承自ButtonClient的TurnOn/TurnOff消息转换成任何Lamp类可以理解的消息。 结论依赖反转的原则深植于许多面向对象技术的优点之中。它可以很好的应用于需要创建可复用中间件的情况。同时对于构建不易受变化影响的代码也是至关重要的。并且，由于抽象与细节隔离开来，代码的往往更容易维护。 这篇文章是我即将被Printice Hall出版的新书Patterns and Advanced Principles of OOD一章的压缩版。在接下来的系列文章中，我们将探讨许多面向对象设计的原则，研究不同设计模式在C++实现中的优点与缺点。我们会对“cohesion”（内聚）与“coupling”（耦合）进行定义，也会发展一种衡量面向对象设计质量的标准。最后，我们还会讨论其他许多有趣的主题。]]></content>
      <categories>
        <category>Software Architecture</category>
      </categories>
      <tags>
        <tag>Dependency Inversion</tag>
        <tag>DIP</tag>
        <tag>Dependency Injection</tag>
        <tag>Uncle Bob</tag>
        <tag>依赖反转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Binder入门]]></title>
    <url>%2F2016%2F10%2F01%2FBinder%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[背景如今的操作系统都支持多进程并发执行， 系统一般都存在多种不同的服务运行在多个进程当中。那么，进程与进程之间如何通信，即跨进程通信（IPC， Inter-Process Communication）是如何进行的呢？ Linux已有好几种IPC机制： Signals: 最早的IPC方式，一个进程通过发送信号给另一个有相同UID/GID的进程或者在同一进程组的进程 Pipes（包括 named pipes): Pipes是一个单向的用于连接一个进程的标准输出与另一个进程的标准输入的字节流通道 Sockets: 双向的通道，两个进程通过打开同一个socket进行通信 Message queues: 一个进程将消息写入消息队列，另一个进程从改队列中读取消息 Semaphores: 信号量是一个可以被多个进程读写的共有变量 Shared Memeory: 一个系统的内存区域，通过将其映射到两个不同进程的虚拟地址空间，因此每个进程都可以访问该地址空间 D-Bus(Desktop Bus): 用于桌面组件与服务通讯的协议 对于Android而言，除了上述几种IPC方式之外，其最重要的IPC方式是binder。在了解Binder 的具体机制之前，先来看看Android系统组件。我们都知道，Android有Activity&lt;直接与用户交互的UI&gt;, Service&lt;负责执行特定的任务，不与用户交互&gt;, Content Provider&lt;负责提供数据访问服务&gt;， BroadCast Receiver&lt;广播接收&gt;四大组件。使用这四种组件都需要在应用的manifest文件AndroidManifest.xml中进行配置声明。 Activity是一个应用的UI界面，它主要负责前台与用户进行交互；Service一般用于执行后台长时间的任务； Content Provider 用于保存用户需要长久保存的数据，它为本地或者远端的数据提供了一个统一的操作接口； Broadcaset Receiver用于接收系统级别的消息，告知应用系统的状态与事件，如短息、来电以及低电量。 那么，如何让不同进程中的组件进行数据与消息的交换了？Android提供了Intents用于组件的通信。一个 Intent由URI和一个action组成，URI用于定位目标组件，而action则用于标识执行的操作。事实上，Intent本质是基于Binder这一基础设施来进行消息传递的。 Binder 术语与很多RPC(Remote Procedure Call)l类似, Android Binder IPC也是基于C/S(Client/Server)的架构方式, 其主要有如下几个组成部分: 客户端(Binder Client): 需要使用某个服务的应用或者进程通过AIDL接口发起远程调用, 调用服务端的接口 服务端(Binder Service): 为所有客户端提供API的service 服务管理(Service Manager): 用于注册管理系统的Binder服务, 为客户端提供服务的查找 驱动(Binder Driver): 所有Binder通信的基础, 指令数据的接收与发送都是通过驱动来实现的 这里罗列了与Binder相关的一些术语: Binder Driver：用于跨进程通信的Kernel 层驱动，对用户空间提供一个/dev/binder的设备节点 Binder protocol： 用于与Binder 驱动交互的数据交换协议(ioctl-based) IBinder interface： 每个Binder对象都需要实现的接口 Binder Token : 用于标识Binder对象的32bit的整数 AIDL : Android Interface Definition Language, 用于描述在IBinder接口上的操作 Proxy: Android为每一个AIDL接口创建的代理对象，用于客户端调用服务对应的接口（An implementation of the AIDL interface that un/marshals and maps methods calls to transactions submitted via a wrapped IBinder reference to the Binder object） Stub: 每个AIDL接口对应的存根对象，用于服务端接受来自客户端的请求，将其转化为对应的函数调用（A partial implementation of the AIDL interface that maps transactions to Binder service method calls while un/marshals data Context Manager: 即ServiceManager, 特殊的Binder对象，注册时的句柄值为0，用于其他Binder服务对象的注册与查找 什么是BinderBinder起源于由Dianne Hackborn 主导的OpenBinder ，OpenBinder“是一个系统层的组件架构，在OS系统服务之上提供一个高层次、丰富的抽象接口”，Android Binder在OpenBinder的基础上做了修改，但其基本的思想仍然保持一致。 相比上述如信号、socket等传统IPC方式，Binder有哪些不一样的特点？ Binder是一个实现了IPC机制的内核驱动 Binder提供了轻量级的 RPC（Remote Procedure Communication) 机制 每一个进程都有一个线程池来处理Binder请求 通过在服务端与设备文件/dev/binder进行内存共享的方式减少数据拷贝&lt;只需要一次数据拷贝&gt; 为什么需要Binder考虑到安全(security)、稳定性（stability）以及内存管理等因素，Android 应用程序和系统服务运行在不同的进程中，因而需要通信与交换数据，即通常IPC方法需要解决的问题。 安全: 每个进程都有自己唯一的系统ID（UID,GID,PID),并且在沙箱（sandbox)中运行 稳定： 如果一个进程崩溃，不会影响到其他进程 内存管理：每个进程管理自己的内存资源，不需要时会释放出来给需要的进程使用 而在另一方面Android的 libc（bionic) 并不支持 SystemV IPC, 没有SystemV IPC 方法，如 semaphores, shared memory, message queues 当进程退出时忘记释放共享的IPC资源时，SystemV IPC 方法容易泄露kernel资源 Binder 通过内建的引用计数机制以及death-notification，确保IPC过程没有资源泄露：当一个binder service 不在被任何 clients引用时，binder的管理者会被通知销毁该binder service，因此 Binder 可以很好的适应低内存、低功耗等移动设备。 那么, 具体来说,Binder主要有如下一些特点： 支持 线程迁移(thread migration): 线程池自动化管理 支持远程调用 支持同步和异步(oneway) 调用 通过UID/PID 来识别调用者（clients） 可以跨进程发送文件描述符 支持常用数据类型的marshalling/unmarshalling 简单的AIDL接口 如果 client/service 在同一进程，同样可以使用 基本概念通信模型Binder 架构通信基于Client/Server模型：client（进程A）向Binder发起通信请求，并等待server的响应。在Client端，Binder为其提供了一个Proxy的接口；server（进程B）收到请求后，由线程池启动的线程对请求进行处理： 这里可以看到， Binder通信进程需要跨越三个层次(具体可以参考老罗的系列文章 https://blog.csdn.net/luoshengyang/article/details/6618363)： Binder 内核驱动的通信( C ) 中间件(middleware)的通信( C++ ) 应用层的通信 ( Java ) 应用层Binder通信Java应用层主要通过AIDL接口来描述Client与Service之间的通信接口。 AIDL定义了远程service的调用接口，其在Client端产生一个Proxy类，在Server端产生一个Stub类。 AIDL的详细说明请参考： http://blog.csdn.net/jason_wzn/article/details/51916983 有了接口之后，那么client要如何向server发送数据了？在Android中，一个进程向另一个进程发送数据，该过程称为Transaction(交易)，交易所传递的数据，则称为transaction data， 在Java 应用层，交易数据就是一个Parcel对象。 Parcel可以用来传递flatted data，可以用于传递Parcelable对象，也可以用于传递IBinder对象的引用。 Parcel提供了诸如 writeByte/readByte,writeDouble/readDouble,writeInt/readInt等一系列接口用于写入、读取Java中的基本数据类型。通常， 从一个对象创建一个parcel的过程被称为编组一个对象(marshalling),而将从Parcel重建一个对象的过程称为解组一个对象(unmarshalling)。 我们知道，Android的四个组件之间的通信都是依赖于Intent的，正是Intent将数据从一个组件传递到了另一个组件。从Intent的定义可以看出，其本质上是一个可以被编组与解组的Parcel对象，因而可以实现跨组件、跨进程的数据通信。 1public class Intent implements Parcelable, Cloneable&#123; ... &#125; 中间件层Binder通信中间件层的编程语言主要是C++，其作用是： 管理用于处理Binder请求的线程池 对相关数据进行序列化与反序列化(marshalling/unmarshalling) 与Binder内核驱动进行交互 通过 /android/frameworks/native/include/binder/IServiceManager.h 中定义的接口： 1sp&lt;IServiceManager&gt; defaultServiceManager() 可以获取到全局的变量 sp&lt;IServiceManager&gt;,可以添加与获取相应的系统服务。 有关中间件更详细的介绍请参考： http://blog.csdn.net/luoshengyang/article/details/6627260 内核驱动层的Binder通信Binder驱动定义了对外的操作接口： open, mmap, release, poll, 以及系统调用ioctl。 ioctl接口的定义： 1ioctl(int binderFD, BINDER_WRITE_READ, &amp;bwd) 这里， &amp;bwd 为写入Binder驱动的一个数据结构，如下： 12345678struct binder_write_read &#123; binder_size_t write_size; binder_size_t write_consumed; binder_uintptr_t write_buffer; binder_size_t read_size; binder_size_t read_consumed; binder_uintptr_t read_buffer;&#125;; ioctl 主要有以下几个命令，其中 ： BINDER_WRITE_READ用于写入或者读取内存中的交易数据的（最常用的一个命令） BINDER_SET_MAX_THREADS 用于设置线程池支持的最大线程数目（一般的service都设置为15） BINDER_SET_CONEXT_MGR 设置 Context(Service) manager 1234567#define BINDER_WRITE_READ _IOWR('b', 1, struct binder_write_read)#define BINDER_SET_IDLE_TIMEOUT _IOW('b', 3, __s64)#define BINDER_SET_MAX_THREADS _IOW('b', 5, __u32)#define BINDER_SET_IDLE_PRIORITY _IOW('b', 6, __s32)#define BINDER_SET_CONTEXT_MGR _IOW('b', 7, __s32)#define BINDER_THREAD_EXIT _IOW('b', 8, __s32)#define BINDER_VERSION _IOWR('b', 9, struct binder_version) Binder Client与Server 通信流程这里，再来回顾下，Android中基于Binder架构，Client与Server之间的通信流程。(图片来自 《deep dive into Android Binder Framework》 参考文献 Android Binder 设计与实现 老罗 Android Binder 系列 Android Binder - 里边很多Binder介绍资料]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Binder</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Fota升级]]></title>
    <url>%2F2016%2F08%2F18%2FAndroid-Fota%E5%8D%87%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Android设备的系统升级有两种方式：（1）下载更新包到手机后，手动安装，即所谓“卡刷包”的形式更新；（2） 通过 Over-the-air（OTA）的方式更新系统，简称为FOTA（Firmware Over The Air)，FOTA升级有两种方式，一种是Full update，即将整个IMG置于升级包中，然后将升级包直接拷贝到系统；一种是Increamental update,即通过增量式的差分包,只是将系统更新的部分打包，然后以打补丁的形式应用到系统。 在介绍FOTA升级流程之前，先来看看Android系统的分区。一般，Android系统有如下几个分区（不同厂商、设备可能有差异）： /boot: 用于系统启动的分区，主要包括Kernel和ramdisk。主要用于挂载system和其他分区，并加载system分区的代码。没有该分区，手机是无法正常启动的； ramdisk.img is a small partition image that is mounted read-only by the kernel at boot time. It only contains /init and a few config files. It is used to start init which will mount the rest of the system images properly and run the init procedure. A Ramdisk is a standard Linux feature. /system：该分区包含了出了 kernel/ramdisk之外的系统应用程序和库文件；正常操作情况下，该分区是只读状态； /recovery:用于系统升级打补丁，包含了一个完整的Linux操作系统和一个特殊的recovery包。FOTA升级时，下载完更新包后，进入recovery模式，recovery程序会读更新包，然后将各个patch应用到各个分区； /misc：升级时，recovery用于存储相关信息的小分区 /data：主要包含了用户的数据，如联系人、短信、设置以及安装的应用。清除该分区等同于将手机重置，OTA不会影响该分区； /cache：用于存放需要经常访问使用的数据和应用组件，访问该分区需要特殊的应用程序权限；OTA升级时下载的升级包就位于该分区； FOTA升级流程 设备定时检查FOTA服务器是否有更新；如有更新，服务其发送消息（包括更新包URL，以及关于该更新包的描述）通知设备 更新程序下载升级包到 cache 或者 data 分区，并验证升级包的签名证书（证书位于/system/etc/security/otacerts.zip），验证通过后，通知用户准备安装 设备重启至 recovery模式，此时启动的是recovery分区的kernel/system init进程通过init.rc脚本: service recovery /sbin/recovery 启动 recovery程序 执行 /cache/recovery/command中的脚本命令，将其指向于升级包： 1&quot;/sbin/recovery&quot; &quot;--update_package=/cache/fota/update.zip&quot; recovery首先校验升级包的签名是否与 /res/keys （ramdisk）中的公钥相匹配 recovery通过FOTA中的脚本解析更新包，然后将修改分别更新到对应的boot/system等分区；在系统分区包含的新文件包含了用于更新recovery分区的内容 系统正常重启： 启动更新后的boot/system 分区 启动时，系统检查当前recovery分区和需要更新的recovery分区（事先保存在/system分区），如果有差异，则更新recovery分区 设备通知FOTA服务器升级完成 参考文献 https://source.android.com/devices/tech/ota/index.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>FOTA</tag>
        <tag>Firm Over The Air</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2016%2F03%2F07%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git是目前使用最普遍的开源分布式版本控制系统，代码托管网站Github就是基于Git作版本管理; Android Studio也支持使用Git来进行版本控制。 这里就来看一看基本的Git命令操作。 更新Git版本12$ git clone git://git.kernel.org/pub/scm/git/git.git 配置Git添加用户名与邮箱123$ git config --global user.name "John Doe"$ git config --global user.email johndoe@example.com 配置编辑器12$ git config --global core.editor emacs 在Windows下，如果想使用Notepad++,则可以这么设置： 12$ git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -nosession" 对于64bit 系统， 12$ git config --global core.editor "'C:/Program Files (x86)/Notepad++/notepad++.exe' -multiInst -nosession" 确认当前配置12$ git config --list 保存当前用户验证信息在使用Git提交代码时，每次提交git都会要求输入 用户名和密码，很浪费时间。执行如下git命令，将用户名和密码保存到远端服务器，即可跳过该环节： 123$ git config credential.helper store$ git push http://example.com/repo.git 接着输入用户名跟密码后，执行修改提交都不用再验证了。 获取Git代码仓库初始化代码仓库在当前项目文件夹下，执行如下命令，会在该目录下创建一个子文件夹.git ： 12$ git init 如果想要将当前的代码进行版本控制，则需要跟踪这些文件并做一个初始化的执行操作： 1234$ git add *.c$ git add LICENSE$ git commit -m 'initial project version' 这里把所有.c 文件以及LICENSE文件标记为跟踪(tracking)状态，然后进行commit操作，将其添加到Git的本地工作目录下。 获取已有的Git仓库 12$ git clone https://github.com/libgit2/libgit2 将仓库映射到mylibgit文件夹下： 12$ git clone https://github.com/libgit2/libgit2 mylibgit 在仓库中记录文件修改在介绍具体的操作命令之前，先来看一看Git文件各个状态的生命周期。对于一个工作目录下的文件而言，主要有两种状态：untracked//tracked;tracked 文件在最近的一个Snapshot当中，它们可以是unmodified, modified,staged；而untracked 文件则是那些不在最近Snapshot和不在Staged area中的文件。当你第一次从克隆一个代码仓库时，所有文件都处于Tracked并且unmodified(未被修改）。 查看文件状态12$ git status 跟踪新创建的文件12$ git add README staging 已修改文件若某个文件已经处于Tracked，则执行add命令将其添加到Staging area 12$ git add CONTRIBUTING.md 查看文件的详细修改12$ git diff 执行修改最简单的命令是 git commit, 但是接着会弹出一个编辑器，需要输入该修改的简短描述，因此更为常用的是如下命令： 12$ git commit -m "Story 182: Fix benchmarks for speed" 上述执行命令只是添加了处于Staging 状态的文件修改，那么要如何跳过staging，直接执行Tracked文件的修改？ 12$ git commit -a -m 'added new benchmarks' 移除文件12$ git rm PROJECTS.md 重命名文件12$ git mv file_from file_to 查看修改记录12$ git log 如果有时git status提示detached HEAD， 通过git branch -a会发现当前的分支处在detached HEAD状态，此时要如何处理？这种状态说明你本地的修改没有合入到主分支上，可以通过git reflog/git log -p找到本地修改的commit ID，然后切换到住分支后通过git cherry-pick &lt;commit-id&gt;将修改合入。 取消修改Unstage 一个staged文件 12$ git reset HEAD CONTRIBUTING.md 取消上一个修改: 123git reset --soft HEAD^ // orgit reset --soft HEAD~1 如果需要取消某个commit的文件修改可以执行如下操作: 12git show commit_sha1 -- some_file.c | git apply -R revert修改12$ git checkout -- CONTRIBUTING.md 如要将某文件revert到指定的commit,可以执行如下操作: 12git checkout &lt;commit_id&gt; -- &lt;file&gt; 取消所有合入修改12$ git reset --merge 远程操作查看远程Git服务器12$ git remote 指定参数-v,可以查看Git服务的URL 12$ git remote -v 添加远程仓库指定一个短名字（以后使用该名字来操作远程仓库），可以获取相应的仓库： git remote add : 12$ git remote add pb https://github.com/paulboone/ticgit 这样通过 fetch pb，便可以获得远程仓库的数据： 12$ git fetch pb fetch/pull 操作通过指定远程仓库的名字，fetch操作用于获取远程仓库的数据： 12$ git fetch origin 如果本地Git仓库已经设置成Track远程仓库，通过pull命令可以将远程的仓库的修改合入本地仓库： 12$ git pull 将本地修改push到远程仓库push用于将本地的数据修改合入到远程的仓库；在某一时刻，只允许一个用户执行该操作，若另一个用户也在执行该操作，则你的push会被拒绝。这样，在进行一下此push操作时，你首先需要获取该用户的修改（fetch），然后执行push操作 git push [remote-name] [branch-name] 12$ git push origin master 获取远程仓库的状态如果想要获取某个远程仓库的具体信息，可以使用 git remote show [remote-name] ， 12$ git remote show origin 重命名/移除远程代码仓库12$ git remote rename pb paul 这样远端的分支从 pb/master 更改为 paul/master. 如果想要移除某个仓库，使用 rm命令： 12$ git remote rm paul 同步fork 分支(0) 跟踪fork分之代码12$ git remote add upstream &lt;remote-url&gt; (1) 从fork 的master 分支获取最新的修改12$ git fetch upstream (2) 切换到本地 master 分支12$ git checkout master (3) 将upstream/master 分支的修改合入 本地 master 分支12$ git merge upstream/master 查看所有远程分支状态12$ git branch -a 切换本地的工作分支-&gt;（提交代码对应的远程分支） 12$ git checkout -b mybranch origin/remote-branch 如何新建一个Github项目？ 在Git 新建一个 repository, 无需添加 README.md 在本地你的项目文件夹下，打开 git bash 初始化 本地 repository12$ git init 跟踪（Track）本地文件到本地 repository12$ git add . 提交修改到本地 repository12$ git commit -m "initial commit" 添加远程repository12$ git remote add origin https://github.com/your-name/your-repo.git 将本地修改push到远程repository12$ git push -u origin master 如何使用git生成/合入patch在向外部代码仓库提交修改时可能需要手动生成patch，或者将他人的patch合入到自己的代码分支。这里来看下如何通过git来实现代码patch的修改与合入。 生成patch1git format-patch master --stdout &gt; fix_empty_poster.patch *合入patch12git apply --stat fix_empty_poster.patch 参考文献 https://www.devroom.io/2009/10/26/how-to-create-and-apply-a-patch-with-git/ https://git-scm.com/docs]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>
