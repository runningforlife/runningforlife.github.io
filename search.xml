<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[怎么招聘SRE工程师-看看Google是如何招人]]></title>
      <url>http://sniffer.site/2021/07/16/%E6%80%8E%E4%B9%88%E6%8B%9B%E8%81%98SRE%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%9C%8B%E7%9C%8BGoogle%E6%98%AF%E5%A6%82%E4%BD%95%E6%8B%9B%E4%BA%BA%E7%9A%84-%E8%AF%91/</url>
      <content type="html"><![CDATA[<p>看到左耳朵耗子的一篇文章<a href="https://coolshell.cn/articles/20977.html" target="_blank" rel="noopener">程序员如何把控自己的职业</a>, 里边提到了Google SRE的评分卡, 用于招聘时软件工程师对自己技能水平的评估, 总共分为11个等级:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">0. You are unfamiliar with the subject area.</span><br><span class="line">    - 对相关的技术领域还不熟悉</span><br><span class="line"></span><br><span class="line">1. You can read/understand the most fundamental aspects of the subject area.</span><br><span class="line">    - 能够读懂相关领域相关的基础知识</span><br><span class="line"></span><br><span class="line">2. Ability to implement small changes, understand basic principles and able to figure out additional details with minimal help.</span><br><span class="line">    - 可以实现一些小的改动，清楚基本的原理，并能够在简单的指导下自己找到更多的细节</span><br><span class="line"></span><br><span class="line">3. Basic proficiency in a subject area without relying on help.</span><br><span class="line">    - 基本精通一个技术领域, 完全不需要别人的帮助</span><br><span class="line"></span><br><span class="line">4. You are comfirtable with the subject area and all routine work on it: For software areas - ability to develop medium programs using all basic language features w/o book, awareness of more esoteric feature(with book).</span><br><span class="line">For systems areas - understanding of many fundamentals of networking and systems administration, ability to run a small network of system including recovery, debugging and nontrivial troubleshooting that relies on the knowledge of internals.</span><br><span class="line">    - 对这个技术领域非常的熟悉和舒适，可以应对和完成所有的日常工作</span><br><span class="line">    	- 对于软件领域 – 有能力开发中等规模的程序，能够熟练和掌握并使用所有的语言特性，而不是需要翻书，并且能够找到所有的冷知识</span><br><span class="line">    	- 对于系统领域 – 掌握网络和系统管理的很多基础知识，并能够掌握一些内核知识以运维一个小型的网络系统，包括恢复、调试和能解决一些不常见的故障。</span><br><span class="line"></span><br><span class="line">5. An even lower degree of reliance on reference materials. Deeper skills in a field or specific technology in the subject area.</span><br><span class="line">    -  对于该技术领域有非常底层的了解和深入的技能</span><br><span class="line"></span><br><span class="line">6. Ability to develop large programs and systems from scratch. Understanding of low level details and internals. Ability to design / deploy most large, distributed systems from scratch.</span><br><span class="line">    - 能够从零开发大型程序和系统。理解底层和内部细节。能够从零设计和部署大型分布式系统</span><br><span class="line"></span><br><span class="line">7. You understand and make use of most lesser known language features, technologies, and associated internals. Ability to automate significant amounts of systems administration.</span><br><span class="line">    - 理解并能利用高级技术，以及相关的内在原理，并可以从根本上自动化大量的系统管理和运维工作</span><br><span class="line"></span><br><span class="line">8. Deep understanding of corner cases, esoteric features, protocols and systems including “theory of operation”. Demonstrated ability to design, deploy and own very critical or large infrastructure, build accompanying automation.</span><br><span class="line">    - 对于一些边角和晦涩的技术、协议和系统工作原理有很深入的理解和经验。能够设计，部署并负责非常关键以及规模很大的基础设施，并能够构建相应的自动化设施</span><br><span class="line"></span><br><span class="line">9. Could have written the book about the subject area but didn’t; works with standards committees on defining new standards and methodologies.</span><br><span class="line">    - 能够在该技术领域出一本经典的书。并和标准委员会的人一起工作制定相关的技术标准和方法</span><br><span class="line"></span><br><span class="line">10. Wrote the book on the subject area(there actually has to be a book). Recognized industry expert in the field, might have invented it</span><br><span class="line">    - 在该领域写过一本书，被业内尊为专家，并是该技术的发明人</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">SRE自评涉及到的技术领域主要有如下这些:</span><br></pre></td></tr></table></figure>
<p>– TCP/IP Networking (OSI stack, DNS etc)<br>– Unix/Linux internals<br>– Unix/Linux Systems administration<br>– Algorithms and Data Structures<br>– C/C++<br>– Python<br>– Java<br>– Perl<br>– Go<br>– Shell Scripting (sh, Bash, ksh, csh)<br>– SQL and/or Database Admin<br>– Scripting language of your choice (not already mentioned)<br>– People Management<br>– Project Management</p>
<p><code>`</code></p>
<p>看到这个自评表, 对照下自己的技能水平, 瞬间感觉路途慢慢了. 需要提升学习的东西太多了. </p>
<p>SRE(Site Reliability Engineering), 直译过来就是现场可靠性工程, 最开始由Google发起的运维大型分布式系统一整套流程与方法, 有点类似于云服务运维中的DevOps, 目前有很多大公司如Facebook/Netflix等都在使用. </p>
<p>说到SRE, 这里有一篇十分值得一看的文章, 里边大概描述了什么是SRE以及Google是如何招聘SRE工程师: 什么样的人才是Google需要的; 如何面试；如何做出招聘的决策, 文章讲了很多方法与流程, 最终的目的就是要招聘到符合Google要求的人才, 为Google的发展注入动力. Google始终秉承着”宁可不招人, 也不要招错人”, “新招聘的候选人需要比已有团队的员工能力要更突出”的要求, 在人才的储备上下了很多功夫. 整篇文章看下来, 不得不佩服顶级互联网公司在人才培养方面的用心用力, 也正是这种严格高标准的人才招聘才不断的推动Google公司的业务发展.</p>
<blockquote>
<p>原文链接:<a href="https://www.usenix.org/system/files/login/articles/login_june_07_jones.pdf" target="_blank" rel="noopener">Hiring Site Reliability Engineers</a></p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://sre.google/" target="_blank" rel="noopener">https://sre.google/</a></li>
<li><a href="https://www.usenix.org/system/files/login/articles/login_june_07_jones.pdf" target="_blank" rel="noopener">https://www.usenix.org/system/files/login/articles/login_june_07_jones.pdf</a></li>
<li><a href="https://cloud.kapostcontent.net/pub/1418185e-b325-49d3-b65c-de338e45cb6f/ebook-10-essential-skills-of-a-site-reliability-engineer-sre.pdf" target="_blank" rel="noopener">SRE工程师需要具备的10个基本技能</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 软件工程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SRE </tag>
            
            <tag> Site Reliability Engineering </tag>
            
            <tag> Google </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一个SMMU内存访问异常的问题]]></title>
      <url>http://sniffer.site/2021/06/22/%E4%B8%80%E4%B8%AASMMU%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>最近碰到棘手的问题: 以太网进行iperf测试时, 发生了SMMU (System Memory Management Unit)访问异常导致内核崩溃. 原本只是内部测试发现, 后面在试验车上也概率性的出现. 问题发生的概率还不小. 很严重. 只能先从头把一些基本概念与流程梳理清楚. 好在最后还是找到了原因并解决了. 松了口气, 才有时间把整个问题的来龙去脉细细的总结下, 算是一个SMMU相关问题的案例.</p>
<p>首先来看看问题的发生的背景.</p>
<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a><strong>问题背景</strong></h2><p>问题发生在利用<code>iperf</code>做网络性能测试的时候, 测试系统(采用高通8155平台, 内置一个EMAC芯片, 最高支持1Gbps速率)作为客户端:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">iperf -c <span class="number">172.20</span><span class="number">.2</span><span class="number">.33</span> -p <span class="number">8989</span> -f m -R</span><br></pre></td></tr></table></figure>
<p>这里加<code>-R</code>参数表示客户端作为数据接收方(奇怪的是, 测试不加<code>-R</code>参数就不会有问题, 这也说明只有在接收数据的过程才会出现问题), 而服务端是发送方:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">iperf -s -p <span class="number">8989</span> -f m</span><br></pre></td></tr></table></figure>
<p>这么测试几十个小时就很快出现了, 抓取到的问题堆栈如下. 前面的日志是SMMU相关的寄存器状态打印, 后面是内核调用堆栈.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="number">53480.526297</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: FAR    = <span class="number">0x00000000a2a2a000</span></span><br><span class="line">[<span class="number">53480.533192</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: PAR    = <span class="number">0x0000000000000000</span></span><br><span class="line">[<span class="number">53480.540466</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: FSR    = <span class="number">0x40000402</span> [TF W SS ]</span><br><span class="line">[<span class="number">53480.547750</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: TTBR0  = <span class="number">0x000f00035bbaa000</span></span><br><span class="line">[<span class="number">53480.554990</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: TTBR1  = <span class="number">0x000f000000000000</span></span><br><span class="line">[<span class="number">53480.562192</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: SCTLR  = <span class="number">0x00c000e7</span> ACTLR  = <span class="number">0x00000000</span></span><br><span class="line">[<span class="number">53480.570572</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: CBAR  = <span class="number">0x0001f300</span></span><br><span class="line">[<span class="number">53480.576741</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: MAIR0   = <span class="number">0xf404ff44</span> MAIR1   = <span class="number">0x00000000</span></span><br><span class="line">[<span class="number">53480.585071</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: Unhandled context fault: iova=<span class="number">0xa2a2a000</span>, cb=<span class="number">14</span>, fsr=<span class="number">0x40000402</span>, fsynr0=<span class="number">0x7e0013</span>, fsynr1=<span class="number">0x0</span></span><br><span class="line">[<span class="number">53480.597668</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: soft iova-to-phys=<span class="number">0x0000000000000000</span></span><br><span class="line">[<span class="number">53480.605440</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: SOFTWARE TABLE WALK FAILED! Looks like <span class="number">15000000.</span>apps-smmu accessed an unmapped address!</span><br><span class="line">[<span class="number">53480.617935</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: hard iova-to-phys (ATOS) failed</span><br><span class="line">[<span class="number">53480.625147</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: SID=<span class="number">0x3c0</span></span><br><span class="line">[<span class="number">53480.630332</span>] arm-smmu <span class="number">15000000.</span>apps-smmu: Unhandled arm-smmu context fault!</span><br><span class="line">[<span class="number">53480.638310</span>] ------------[ cut here ]------------</span><br><span class="line">[<span class="number">53480.638324</span>] kernel BUG at /home/jenkins/.jenkins/workspace/SourceCode/kernel/msm<span class="number">-4.14</span>/drivers/iommu/arm-smmu.c:<span class="number">1762</span>!</span><br><span class="line">[<span class="number">53480.649128</span>] [KERN Warning] ERROR/WARN forces debug_lock off!</span><br><span class="line">[<span class="number">53480.649135</span>] [KERN Warning] check backtrace:</span><br><span class="line">[<span class="number">53480.649151</span>] CPU: <span class="number">0</span> PID: <span class="number">319</span> Comm: irq/<span class="number">386</span>-arm-smm Tainted: G S         O    <span class="number">4.14</span><span class="number">.170</span>+ #<span class="number">2</span></span><br><span class="line">[<span class="number">53480.649160</span>] Hardware name: Qualcomm Technologies, Inc. SA8155P v2 PM8150 ADP-STAR model-D55 (DT)</span><br><span class="line">[<span class="number">53480.649171</span>] Call trace:</span><br><span class="line">[<span class="number">53480.649215</span>]  dump_backtrace+<span class="number">0x0</span>/<span class="number">0x1f4</span></span><br><span class="line">[<span class="number">53480.649226</span>]  show_stack+<span class="number">0x20</span>/<span class="number">0x2c</span></span><br><span class="line">[<span class="number">53480.649241</span>]  dump_stack+<span class="number">0xe4</span>/<span class="number">0x134</span></span><br><span class="line">[<span class="number">53480.649255</span>]  debug_locks_off+<span class="number">0x54</span>/<span class="number">0x88</span></span><br><span class="line">[<span class="number">53480.649268</span>]  oops_enter+<span class="number">0x14</span>/<span class="number">0x20</span></span><br><span class="line">[<span class="number">53480.649275</span>]  die+<span class="number">0x38</span>/<span class="number">0x16c</span></span><br><span class="line">[<span class="number">53480.649284</span>]  bug_handler+<span class="number">0x50</span>/<span class="number">0x88</span></span><br><span class="line">[<span class="number">53480.649293</span>]  brk_handler+<span class="number">0x6c</span>/<span class="number">0xb4</span></span><br><span class="line">[<span class="number">53480.649301</span>]  do_debug_exception+<span class="number">0x7c</span>/<span class="number">0x114</span></span><br><span class="line">[<span class="number">53480.649309</span>]  el1_dbg+<span class="number">0x18</span>/<span class="number">0x74</span></span><br><span class="line">[<span class="number">53480.649321</span>]  arm_smmu_context_fault+<span class="number">0x8e0</span>/<span class="number">0x944</span></span><br><span class="line">[<span class="number">53480.649332</span>]  irq_thread_fn+<span class="number">0x2c</span>/<span class="number">0x70</span></span><br><span class="line">[<span class="number">53480.649340</span>]  irq_thread+<span class="number">0xc0</span>/<span class="number">0x144</span></span><br><span class="line">[<span class="number">53480.649350</span>]  kthread+<span class="number">0x128</span>/<span class="number">0x138</span></span><br><span class="line">[<span class="number">53480.649357</span>]  ret_from_fork+<span class="number">0x10</span>/<span class="number">0x18</span></span><br><span class="line">[<span class="number">53480.649367</span>] Internal error: Oops - BUG: <span class="number">0</span> [#<span class="number">1</span>] PREEMPT SMP</span><br></pre></td></tr></table></figure>
<p>从堆栈来看大致可以了解到, 这是由于SMMU监测到某个模块非法的访问DMA地址后, 引起了内核崩溃. 那么, 为何有这个错误SMMU访问错误? 这个错误又是哪个模块导致的? 是在什么情况下引起的SMMU内存错误了?  这不得不从SMMU本身说起.</p>
<h2 id="什么是SMMU"><a href="#什么是SMMU" class="headerlink" title="什么是SMMU"></a><strong>什么是SMMU</strong></h2><p>简单来说, SMMU(System Memory Management Unit)是ARM为外设访问系统RAM提供了一种类似于MMU的虚拟内存访问机制, 外设可以通过DMA直接访问RAM, 而无需CPU的干预. 如此, 外设可以通过一个虚拟的地址即可访问物理地址(可以不连续), 做到了不同外设之间IO地址空间的彼此独立与隔离. 因此, SMMU也通常被称为IOMMU(Input/Output MMU).</p>
<p>下图是从ARM SMMU Spec手册里的一张SMMU简图: SMMU为设备与RAM之间构建了一个设备虚拟地址(IOVA)与物理地址之间的映射关系, 每次执行DMA数据传输的时候, 都要通过SMMU将IOVA地址翻译成对应的物理地址.</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/arm_smmu_diagram.png" alt="ARM SMMU Diagram"></p>
<p>那么对于设备驱动来说, 如何使用SMMU了? 不妨来看下SMMU相关的API. </p>
<ul>
<li><code>arm_iommu_create_mapping</code>: 配置设备所要使用的VA(Virtual Address, 虚拟地址)的范围</li>
<li><code>arm_iommu_attach_device</code>: 将分配好的VA地址范围与设备绑定, 并开启SMMU地址转换</li>
<li><code>dma_map_single/dma_unmap_single</code>: 分配/去除某个DMA地址, 这种方式是异步的, 常用于一次性传输的场景(传输完成后DMA的映射即解除了) </li>
<li><code>dma_alloc_coherent/dma_free_coherent</code>: 一致性(consistent), 同步(synchronous)的DMA内存分配方法, 确保CPU与设备的数据始终是同步的, 一般用于需要常驻内存的一些数据</li>
</ul>
<p>这里不对IOMMU的代码做深入分析了. 有关IOMMU相关的流程可以参考内核代码:</p>
<ul>
<li><code>kernel/drivers/iommu</code>: SMMU驱动, 用于配置SMMU, 为设备驱动提供接口</li>
<li><code>kernel/arch/arm64/mm</code>: 与平台相关的SMMU的页表分配的实现</li>
</ul>
<p>有了这些SMMU的基础知识, 我们就来分析下最开始那个问题.</p>
<h2 id="SMMU访问异常问题分析"><a href="#SMMU访问异常问题分析" class="headerlink" title="SMMU访问异常问题分析"></a><strong>SMMU访问异常问题分析</strong></h2><p>继续来看下问题的日志. 堆栈的前面一部分是有关SMMU的状态寄存器:</p>
<ul>
<li>FSR(<code>Fault Status Register</code>)表示SMMU错误的类型(转换/权限等), 这里的值<code>0x40000402 [TF W SS ]</code>, 说明是一个写操作时引起的页表访问错误</li>
<li>FAR(<code>Fault Address Register)</code>: 表示发生错误的IO虚拟地址</li>
<li>PAR(<code>Physical Address Register</code>): 发生错误时查找到的物理地址, 这里是全0, 说明相应的IOVA地址没有映射</li>
<li>TTBRm(<code>Translation Table Base Address</code>):<ul>
<li>TTBR0: 保存Translation Table0的基地址</li>
<li>TTBR1: 保存Translation Table1的基地址</li>
</ul>
</li>
</ul>
<p>重点看下如下两行日志, 我们可以知道发生内存映射异常的IOVA地址是<code>0xa2a2a000</code>, 对应的SID是<code>0x3c0</code>(SID是对应设备使用SMMU映射内存时的标识),SID一般在设备树DTS的配置中指定的. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[53480.585071] arm-smmu 15000000.apps-smmu: Unhandled context fault: iova=0xa2a2a000, cb=14, fsr=0x40000402, fsynr0=0x7e0013, fsynr1=0x0</span><br><span class="line"> ....</span><br><span class="line">[53480.625147] arm-smmu 15000000.apps-smmu: SID=0x3c0</span><br></pre></td></tr></table></figure>
<p>查看内核的DTS配置, <code>iommus</code>这个对应了设备节点SMMU的配置;可以看到发生问题的设备正是以太网:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">emac_emb_smmu: emac_emb_smmu &#123;</span><br><span class="line">	compatible = <span class="string">"qcom,emac-smmu-embedded"</span>;</span><br><span class="line">	iommus = &lt;&amp;apps_smmu <span class="number">0x3C0</span> <span class="number">0x0</span>&gt;;</span><br><span class="line">	qcom,iova-mapping = &lt;<span class="number">0x80000000</span> <span class="number">0x40000000</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>理清楚这些SMMU的日志只是第一步, 但是对于为何会发生SMMU访问异常还是毫无头绪. 这个只能通过阅读驱动源代码弄清楚以太网网卡数据的接收流程才能一步步揭开迷雾了. </p>
<p>对于目前的以太网网卡来说, 一般采用ring buffer(环形缓冲区)的形式来接收数据; 驱动在初始化的时候为网卡的ring buffer预分配DMA内存, 用于接收数据. 总体来收, 网卡的数据接收流程有如下三个步骤:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/arm_SMMU_architecture.png" alt="EMAC DMA Process"></p>
<ul>
<li>网卡需要传数据时, 获取到当前的缓冲区对应的DMA内存地址(IOVA)后, 通过SMMU向对应的RAM地址传输数据</li>
<li>发送完成后, 通过中断告知驱动有数据需要接收</li>
<li>CPU接收到中断后, 驱动会把DMA的映射解除, 数据交由CPU处理; 接着驱动把对应的数据发送到协议栈继续处理</li>
</ul>
<p>那么, 问题来了, SMMU是何时收到DMA访问异常错误的了? 是在第三个步骤, 驱动解除DMA地址映射后, 有地方再次尝试使用该DMA地址导致的吗? 从驱动的逻辑来看, 每次传送完成, DMA地址与RAM地址解除映射后, 没有地方会再次尝试获取该DMA地址了(对应buffer的DMA地址已经置空). 退一步说, 如果是驱动使用的时候发生的问题, 那么异常的堆栈应该会打印出来, 但是现在只有SMMU相关的日志.</p>
<p>所以, 问题的源头只能是在网卡通过SMMU往对应的DMA地址发送数据的时候, 就是说如果网卡给DMA传输数据的大小超过了预分配的buffer的大小的话, SMMU会发现对应的DMA地址没有映射到物理地址, 从而报错. 解决问题的办法也很简单, 只需要把buffer大小由原来的1538修改为2048(2kb)就可以了:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-<span class="meta">#<span class="meta-keyword">define</span> DWC_ETH_QOS_ETH_FRAME_LEN (ETH_FRAME_LEN + ETH_FCS_LEN + VLAN_HLEN + PADDING_ISSUE)</span></span><br><span class="line">+<span class="meta">#<span class="meta-keyword">define</span> DWC_ETH_QOS_ETH_FRAME_LEN (1&lt;&lt;11)</span></span><br></pre></td></tr></table></figure>
<p>修改后再次验证, 问题不再出现. 但这里有个问题, DMA的buffer大小为何设置成2kb而不是其他如4kb了?  这个实际跟以太网网卡(EMAC)本身的设计有关, 一般以太网的一帧数据是一个MTU(一般是1500, 如果有VLAN数据, 则会多4个字节), 但为何网卡传输的一帧数据会超过设定的MTU大小, 这个目前咨询了供应商仍然没有得到答案(供应商怀疑是发送端给到的一帧数据超过了最大的MTU 1538, 这个结论仍然值得怀疑).</p>
<p>从高通给的一些问题案例来说, 一般SMMU都是由于需要传输的数据大小与实际的buf大小不一致导致的. 总的说来, SMMU的问题看起来十分棘手, 但只要把基本的概念与原理弄清楚, 把代码流程梳理完整, 解决这类问题并不是件十分困难的事情.</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="https://developer.arm.com/documentation/ihi0070/latest" target="_blank" rel="noopener">ARM SMMU spec</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/DMA-API-HOWTO.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/DMA-API-HOWTO.txt</a></li>
<li><a href="https://www.ti.com/lit/ug/spruhh1/spruhh1.pdf?ts=1624513771099&amp;ref_url=https%253A%252F%252Fwww.google.com.hk%252F" target="_blank" rel="noopener">TI EMAC design</a></li>
<li><a href="https://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-get.cgi/2015/MSC/MSC-2015-10.pdf" target="_blank" rel="noopener">rethinking IOMMU</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kernel </tag>
            
            <tag> Linux </tag>
            
            <tag> SMMU </tag>
            
            <tag> MMU </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从Wifi热点功能说一说Android Wifi框架]]></title>
      <url>http://sniffer.site/2021/04/29/%E4%BB%8EWifi%E7%83%AD%E7%82%B9%E5%8A%9F%E8%83%BD%E8%AF%B4%E4%B8%80%E8%AF%B4Android-Wifi%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<p>之前帮着解决了项目中WIFI相关的问题, 一直想梳理下WIFI的框架, 方便后续代码阅读以及问题的解决. 恰好年初修改了车机上WIFI热点相关的一些代码, 重新看了下Android 10(Q)的逻辑, 于是想通过WIFI热点相关的功能作为切入点, 完整的梳理下Android WIFI的整体框架.</p>
<p>先不多说, 看下Android WIFI的大致框架:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/android_wifi_fw.png" alt="android wifi framwork"></p>
<p>从上至下, 对应的代码路径如下:</p>
<ul>
<li>应用层: <code>/packages/apps/Settings</code></li>
<li>框架层<ul>
<li><code>/framework/opt/net/wifi/</code>: wifiservice的核心逻辑</li>
<li><code>/framework/base/wifi</code>: 公共接口部分</li>
<li><code>/framework/base/services/core/java/com/android/server/connectivity</code>: 热点共享实现</li>
</ul>
</li>
<li>native层<ul>
<li><code>/hardware/interface/wifi</code>: HAL层接口</li>
<li><code>/external/wpa_supplicant_8</code>: 主要包括AP(access point)和STA(Station) 身份验证与数据加密的实现, 分为<code>hostapd</code>与<code>wpa_supplicant</code>两个部分</li>
<li><code>/system/connectivity/wificond</code>: wifi控制通道代码, 负责创建网口以及获取扫描结果等</li>
<li><code>/system/netd</code>:  网络管理的守护进程, 负责路由/流量统计等相关的配置</li>
</ul>
</li>
</ul>
<p>接下来就来看下通过WIFI来分享热点时的具体代码流程.</p>
<h2 id="开启热点"><a href="#开启热点" class="headerlink" title="开启热点"></a><strong>开启热点</strong></h2><p>Android除了支持通过热点共享网络之外, 还支持通过USB/蓝牙的方式共享数据连接. 热点共享的接口都通过<code>ConnectivityManager</code>提供:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tether</span><span class="params">(String iface)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String pkgName = mContext.getOpPackageName();</span><br><span class="line">           Log.i(TAG, <span class="string">"tether caller:"</span> + pkgName);</span><br><span class="line">           <span class="keyword">return</span> mService.tether(iface, pkgName);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="meta">@SystemApi</span></span><br><span class="line"><span class="meta">@RequiresPermission</span>(android.Manifest.permission.TETHER_PRIVILEGED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startTethering</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">boolean</span> showProvisioningUi,</span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="keyword">final</span> OnStartTetheringCallback callback)</span> </span>&#123;</span><br><span class="line">	startTethering(type, showProvisioningUi, callback, <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@SystemApi</span></span><br><span class="line">   <span class="meta">@RequiresPermission</span>(android.Manifest.permission.TETHER_PRIVILEGED)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startTethering</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">boolean</span> showProvisioningUi,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">final</span> OnStartTetheringCallback callback, Handler handler)</span> </span>&#123;</span><br><span class="line">       Preconditions.checkNotNull(callback, <span class="string">"OnStartTetheringCallback cannot be null."</span>);</span><br><span class="line"></span><br><span class="line">       ResultReceiver wrappedCallback = <span class="keyword">new</span> ResultReceiver(handler) &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onReceiveResult</span><span class="params">(<span class="keyword">int</span> resultCode, Bundle resultData)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (resultCode == TETHER_ERROR_NO_ERROR) &#123;</span><br><span class="line">                   callback.onTetheringStarted();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   callback.onTetheringFailed();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String pkgName = mContext.getOpPackageName();</span><br><span class="line">           Log.i(TAG, <span class="string">"startTethering caller:"</span> + pkgName);</span><br><span class="line">           mService.startTethering(type, wrappedCallback, showProvisioningUi, pkgName);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">           Log.e(TAG, <span class="string">"Exception trying to start tethering."</span>, e);</span><br><span class="line">           wrappedCallback.send(TETHER_ERROR_SERVICE_UNAVAIL, <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>ConnectivityManager</code>实际调用了<code>ConnectivityService</code>的接口, 这里看下<code>startTethering</code>这个接口的实现: 首先判断下是否支持热点共享, 然后调用<code>mTethering.startTethering</code>发起热点共享.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startTethering</span><span class="params">(<span class="keyword">int</span> type, ResultReceiver receiver, <span class="keyword">boolean</span> showProvisioningUi,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callerPkg)</span> </span>&#123;</span><br><span class="line">    ConnectivityManager.enforceTetherChangePermission(mContext, callerPkg);</span><br><span class="line">    <span class="keyword">if</span> (!isTetheringSupported()) &#123;</span><br><span class="line">        receiver.send(ConnectivityManager.TETHER_ERROR_UNSUPPORTED, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mTethering.startTethering(type, receiver, showProvisioningUi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>mTethering</code>实际是在系统初始化<code>ConnectivityService</code>的时候创建的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">       mTethering = makeTethering();</span><br><span class="line">       ....</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Tethering <span class="title">makeTethering</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Move other elements into @Overridden getters.</span></span><br><span class="line">	<span class="keyword">final</span> TetheringDependencies deps = <span class="keyword">new</span> TetheringDependencies() &#123;</span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTetheringSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ConnectivityService.<span class="keyword">this</span>.isTetheringSupported();</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> NetworkRequest <span class="title">getDefaultNetworkRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mDefaultRequest;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Tethering(mContext, mNMS, mStatsService, mPolicyManager,</span><br><span class="line">		IoThread.get().getLooper(), <span class="keyword">new</span> MockableSystemProperties(),</span><br><span class="line">		deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看<code>Tethering.java</code>(代码位于<code>/frameworks/base/services/core/java/com/android/server</code>)代码, 可以知道这部分主要起中介的作用: </p>
<ul>
<li>首先要根据热点共享的类型创建对应的网络, 比如通过WIFI共享的话需要先打开WIFI热点</li>
<li>其次是要监听需要共享的网络连接(比如4G网络/以太网连接等), 将两个网络进行数据的转发配置</li>
</ul>
<p><code>startTethering</code>实际最后调用了一个内部实现<code>enableTetheringInternal</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enableTetheringInternal</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">boolean</span> enable, ResultReceiver receiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> TETHERING_WIFI:</span><br><span class="line">            result = setWifiTethering(enable);</span><br><span class="line">            sendTetherResult(receiver, result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TETHERING_USB:</span><br><span class="line">            result = setUsbTethering(enable);</span><br><span class="line">            sendTetherResult(receiver, result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TETHERING_BLUETOOTH:</span><br><span class="line">            setBluetoothTethering(enable, receiver);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TETHERING_P2P:</span><br><span class="line">            result = setP2pTethering(enable);</span><br><span class="line">            sendTetherResult(receiver, result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            Log.w(TAG, <span class="string">"Invalid tether type."</span>);</span><br><span class="line">            sendTetherResult(receiver, TETHER_ERROR_UNKNOWN_IFACE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会根据热点类型来创建对应的网络, 对于WIFI热点会调用<code>setWifiTethering</code>来开启WIFI热点:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">setWifiTethering</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> enable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPublicSync) &#123;</span><br><span class="line">            <span class="keyword">final</span> WifiManager mgr = getWifiManager();</span><br><span class="line">            <span class="keyword">if</span> (mgr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mLog.e(<span class="string">"setWifiTethering: failed to get WifiManager!"</span>);</span><br><span class="line">                <span class="keyword">return</span> TETHER_ERROR_SERVICE_UNAVAIL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((enable &amp;&amp; mgr.startSoftAp(<span class="keyword">null</span> <span class="comment">/* use existing wifi config */</span>)) ||</span><br><span class="line">                (!enable &amp;&amp; mgr.stopSoftAp())) &#123;</span><br><span class="line">                mWifiTetherRequested = enable;</span><br><span class="line">                <span class="keyword">return</span> TETHER_ERROR_NO_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(ident);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TETHER_ERROR_MASTER_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里, 就完成了第一步, 把WIFI热点开起来了. 再来看下WIFI热点的创建流程. 这个才是整个流程的关键步骤.</p>
<h2 id="创建WIFI热点"><a href="#创建WIFI热点" class="headerlink" title="创建WIFI热点"></a><strong>创建WIFI热点</strong></h2><p>为了更清晰的看到WIFI AP的流程, 这里分为两个部分来阐述具体的代码: </p>
<ul>
<li>Java Framework的逻辑</li>
<li>Native的代码逻辑</li>
</ul>
<h3 id="创建WIFI热点-Framework流程"><a href="#创建WIFI热点-Framework流程" class="headerlink" title=" 创建WIFI热点-Framework流程 "></a><strong><em> 创建WIFI热点-Framework流程 </em></strong></h3><p><code>WifiManager</code>(代码位于<code>/framework/base/wifi</code>)的<code>startSoftAp</code>实际就是调用了<code>WifiService</code>的接口而已, 我们直接看下<code>WifiService</code>的实现逻辑<code>WifiServiceImpl</code>(<code>/framework/opt/net/wifi</code>):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startSoftAp</span><span class="params">(WifiConfiguration wifiConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// NETWORK_STACK is a signature only permission.</span></span><br><span class="line">    enforceNetworkStackPermission();</span><br><span class="line">    <span class="comment">// If we're in crypt debounce, ignore any wifi state change APIs.</span></span><br><span class="line">    <span class="keyword">if</span> (mFrameworkFacade.inStorageManagerCryptKeeperBounce()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLog.info(<span class="string">"startSoftAp uid=%"</span>).c(Binder.getCallingUid()).flush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLocalOnlyHotspotRequests) &#123;</span><br><span class="line">        <span class="comment">// If a tethering request comes in while we have an existing tethering session, return</span></span><br><span class="line">        <span class="comment">// error.</span></span><br><span class="line">        <span class="keyword">if</span> (mIfaceIpModes.contains(WifiManager.IFACE_IP_MODE_TETHERED)) &#123;</span><br><span class="line">            mLog.err(<span class="string">"Tethering is already active."</span>).flush();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If a tethering request comes in while we have LOHS running (or requested), call stop</span></span><br><span class="line">        <span class="comment">// for softap mode and restart softap with the tethering config.</span></span><br><span class="line">        <span class="keyword">if</span> (!isConcurrentLohsAndTetheringSupported() &amp;&amp; !mLocalOnlyHotspotRequests.isEmpty()) &#123;</span><br><span class="line">            stopSoftApInternal(WifiManager.IFACE_IP_MODE_LOCAL_ONLY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> startSoftApInternal(wifiConfig, WifiManager.IFACE_IP_MODE_TETHERED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数首先会判断是否有本地热点(Local Only Hotspot, 就是无法使用网络连接的热点, 只用于两个设备之间通讯), 如果有的话, 就开启一个非共享的热点, 否则开启一个有共享的热点. 这里只看下有共享的流程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startSoftApInternal</span><span class="params">(WifiConfiguration wifiConfig, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    mLog.trace(<span class="string">"startSoftApInternal uid=% mode=%"</span>)</span><br><span class="line">            .c(Binder.getCallingUid()).c(mode).flush();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// null wifiConfig is a meaningful input for CMD_SET_AP</span></span><br><span class="line">    <span class="keyword">if</span> (wifiConfig == <span class="keyword">null</span> || WifiApConfigStore.validateApWifiConfiguration(wifiConfig)) &#123;</span><br><span class="line">        SoftApModeConfiguration softApConfig = <span class="keyword">new</span> SoftApModeConfiguration(mode, wifiConfig);</span><br><span class="line">        mWifiController.sendMessage(CMD_SET_AP, <span class="number">1</span>, <span class="number">0</span>, softApConfig);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Slog.e(TAG, <span class="string">"Invalid WifiConfiguration"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Wifi Framework的代码涉及到STA/AP两个模式, 有不少的状态机代码；在查看具体代码流程之前, 先抛出一个具体的代码流程方便跟踪:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">WifiServiceImpl --&gt; WifiController --&gt; ActiveModeWarden --&gt; SoftApManager --&gt; WifiNative --&gt; HostapdHal</span><br></pre></td></tr></table></figure>
<p><code>WifiController</code>是一个用于管控Wifi内部状态的状态机, 其有如下几个状态:</p>
<ul>
<li>默认状态<code>DefaultState</code>:  其他状态的父状态</li>
<li>STA开启状态<code>StaEnabledState</code>: Wifi打开, 处于STA模式, 这个时候会进行热点扫描</li>
<li>STA关闭状态<code>StaDisabledState</code>: Wifi关闭, STA模式关闭, 无法进行扫描</li>
<li>STA关闭可扫描状态<code>StaDisabledWithScanState</code>: STA模式关闭, 但WIFI会进入扫描模式</li>
<li>ECM状态<code>EcmState</code>: 紧急呼叫状态(如手机终端正在进行紧急呼叫等)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> DefaultState mDefaultState = <span class="keyword">new</span> DefaultState();</span><br><span class="line"><span class="keyword">private</span> StaEnabledState mStaEnabledState = <span class="keyword">new</span> StaEnabledState();</span><br><span class="line"><span class="keyword">private</span> StaDisabledState mStaDisabledState = <span class="keyword">new</span> StaDisabledState();</span><br><span class="line"><span class="keyword">private</span> StaDisabledWithScanState mStaDisabledWithScanState = <span class="keyword">new</span> StaDisabledWithScanState();</span><br><span class="line"><span class="keyword">private</span> EcmState mEcmState = <span class="keyword">new</span> EcmState();</span><br></pre></td></tr></table></figure>
<p>一般来说, WifiService启动时的初始状态为<code>StaDisabledState</code>, 如果默认WIFI是开的, 则会进入<code>StaEnabledState</code>状态, 这里假定系统初始状态为<code>StaDisabledState</code>. 从上面的流程可以看到, WifiService实际向<code>WifiController</code>发送了一个消息:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mWifiController.sendMessage(CMD_SET_AP, <span class="number">1</span>, <span class="number">0</span>, softApConfig);</span><br></pre></td></tr></table></figure>
<p>此时, <code>StaDisabledState</code>状态机会把消息丢给<code>DefaultState</code>处理(返回了<code>NOT_HANDLED</code>):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaDisabledState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mDeferredEnableSerialNumber = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mHaveDeferredEnable = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mDisabledTimestamp;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mActiveModeWarden.disableWifi();</span><br><span class="line">        <span class="comment">// Supplicant can't restart right away, so note the time we switched off</span></span><br><span class="line">        mDisabledTimestamp = SystemClock.elapsedRealtime();</span><br><span class="line">        mDeferredEnableSerialNumber++;</span><br><span class="line">        mHaveDeferredEnable = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> CMD_WIFI_TOGGLED:</span><br><span class="line">                <span class="keyword">if</span> (mSettingsStore.isWifiToggleEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (doDeferEnable(msg)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mHaveDeferredEnable) &#123;</span><br><span class="line">                            <span class="comment">//  have 2 toggles now, inc serial number and ignore both</span></span><br><span class="line">                            mDeferredEnableSerialNumber++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        mHaveDeferredEnable = !mHaveDeferredEnable;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    transitionTo(mStaEnabledState);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkScanOnlyModeAvailable()) &#123;</span><br><span class="line">                    <span class="comment">// only go to scan mode if we aren't in airplane mode</span></span><br><span class="line">                    <span class="keyword">if</span> (mSettingsStore.isAirplaneModeOn()) &#123;</span><br><span class="line">                        transitionTo(mStaDisabledWithScanState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                ....</span><br><span class="line">            <span class="keyword">case</span> CMD_SET_AP:</span><br><span class="line">                <span class="keyword">if</span> (msg.arg1 == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// remember that we were disabled, but pass the command up to start softap</span></span><br><span class="line">                    mSettingsStore.setWifiSavedState(WifiSettingsStore.WIFI_DISABLED);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> NOT_HANDLED;</span><br><span class="line">                ....</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> NOT_HANDLED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DefaultState</code>状态收到<code>CMD_SET_AP</code>的消息后会尝试调用<code>ActiveModeWarden.enterSoftAPMode</code>开启AP:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">case</span> CMD_SET_AP:</span><br><span class="line">                <span class="comment">// note: CMD_SET_AP is handled/dropped in ECM mode - will not start here</span></span><br><span class="line">                <span class="keyword">if</span> (msg.arg1 == <span class="number">1</span>) &#123;</span><br><span class="line">                    SoftApModeConfiguration config = (SoftApModeConfiguration) msg.obj;</span><br><span class="line">                    mActiveModeWarden.enterSoftAPMode((SoftApModeConfiguration) msg.obj);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mActiveModeWarden.stopSoftAPMode(msg.arg2);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CMD_AIRPLANE_TOGGLED:</span><br><span class="line">                <span class="keyword">if</span> (mSettingsStore.isAirplaneModeOn()) &#123;</span><br><span class="line">                    log(<span class="string">"Airplane mode toggled, shutdown all modes"</span>);</span><br><span class="line">                    mActiveModeWarden.shutdownWifi();</span><br><span class="line">                    transitionTo(mStaDisabledState);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log(<span class="string">"Airplane mode disabled, determine next state"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (mSettingsStore.isWifiToggleEnabled()) &#123;</span><br><span class="line">                        transitionTo(mStaEnabledState);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkScanOnlyModeAvailable()) &#123;</span><br><span class="line">                        transitionTo(mStaDisabledWithScanState);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// wifi should remain disabled, do not need to transition</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CMD_EMERGENCY_CALL_STATE_CHANGED:</span><br><span class="line">            <span class="keyword">case</span> CMD_EMERGENCY_MODE_CHANGED:</span><br><span class="line">                <span class="keyword">if</span> (msg.arg1 == <span class="number">1</span>) &#123;</span><br><span class="line">                    transitionTo(mEcmState);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CMD_AP_STOPPED:</span><br><span class="line">                log(<span class="string">"SoftAp mode disabled, determine next state"</span>);</span><br><span class="line">                <span class="keyword">if</span> (mSettingsStore.isWifiToggleEnabled()) &#123;</span><br><span class="line">                    transitionTo(mStaEnabledState);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkScanOnlyModeAvailable()) &#123;</span><br><span class="line">                    transitionTo(mStaDisabledWithScanState);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// wifi should remain disabled, do not need to transition</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"WifiController.handleMessage "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ActiveModeWarden</code>这个类的主要作用是负责WIFI不同操作模式的切换, 比如从STA模式切换到扫描模式, 从AP切换到STA等等:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterSoftAPMode</span><span class="params">(@NonNull SoftApModeConfiguration wifiConfig)</span> </span>&#123;</span><br><span class="line">    mHandler.post(() -&gt; &#123;</span><br><span class="line">        startSoftAp(wifiConfig);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startSoftAp</span><span class="params">(SoftApModeConfiguration softapConfig)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"Starting SoftApModeManager"</span>);</span><br><span class="line"></span><br><span class="line">    WifiConfiguration config = softapConfig.getWifiConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; config.SSID != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"Passing config to SoftApManager! "</span> + config);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        config = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SoftApCallbackImpl callback = <span class="keyword">new</span> SoftApCallbackImpl(softapConfig.getTargetMode());</span><br><span class="line">    ActiveModeManager manager = mWifiInjector.makeSoftApManager(callback, softapConfig);</span><br><span class="line">    callback.setActiveModeManager(manager);</span><br><span class="line">    manager.start();</span><br><span class="line">    mActiveModeManagers.add(manager);</span><br><span class="line">    updateBatteryStatsWifiState(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>makeSoftApManager</code>实际构造了一个<code>SoftApManager</code>对象实例, 然后调用<code>start</code>启动AP的创建. 这里<code>mStateMachine</code>是<code>SoftApManager</code>内部的一个状态机<code>SoftApStateMachine</code>, 其有两个状态: <code>IdleState</code>/<code>StartedState</code>, 其初始状态为<code>Idle</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Start soft AP with the supplied config.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mStateMachine.sendMessage(SoftApStateMachine.CMD_START, mApConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部状态机</span></span><br><span class="line">SoftApStateMachine(Looper looper) &#123;</span><br><span class="line">    <span class="keyword">super</span>(TAG, looper);</span><br><span class="line"></span><br><span class="line">    addState(mIdleState);</span><br><span class="line">    addState(mStartedState);</span><br><span class="line"></span><br><span class="line">    setInitialState(mIdleState);</span><br><span class="line">    start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IdleState</code>在收到<code>CMD_START</code>的消息后,  主要做了如下几件事情:</p>
<ul>
<li>首先通过<code>WifiNative</code>创建一个AP的网口</li>
<li>调用<code>startSoftAp</code>执行AP的开启: 比如设置WIFI的国家码(不同地区有不同的5G频段)</li>
<li>进入<code>StartedState</code>状态, 等待AP开启</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">IdleState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mApInterfaceName = <span class="keyword">null</span>;</span><br><span class="line">        mIfaceIsUp = <span class="keyword">false</span>;</span><br><span class="line">        mIfaceIsDestroyed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> CMD_START:</span><br><span class="line">            	....</span><br><span class="line">                mApInterfaceName = mWifiNative.setupInterfaceForSoftApMode(</span><br><span class="line">                        mWifiNativeInterfaceCallback);</span><br><span class="line">                <span class="keyword">if</span> (TextUtils.isEmpty(mApInterfaceName)) &#123;</span><br><span class="line">                    Log.e(TAG, <span class="string">"setup failure when creating ap interface."</span>);</span><br><span class="line">                    updateApState(WifiManager.WIFI_AP_STATE_FAILED,</span><br><span class="line">                            WifiManager.WIFI_AP_STATE_DISABLED,</span><br><span class="line">                            WifiManager.SAP_START_FAILURE_GENERAL);</span><br><span class="line">                    mWifiMetrics.incrementSoftApStartResult(</span><br><span class="line">                            <span class="keyword">false</span>, WifiManager.SAP_START_FAILURE_GENERAL);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                updateApState(WifiManager.WIFI_AP_STATE_ENABLING,</span><br><span class="line">                        WifiManager.WIFI_AP_STATE_DISABLED, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">int</span> result = startSoftAp((WifiConfiguration) message.obj);</span><br><span class="line">                <span class="keyword">if</span> (result != SUCCESS) &#123;</span><br><span class="line">                    <span class="keyword">int</span> failureReason = WifiManager.SAP_START_FAILURE_GENERAL;</span><br><span class="line">                    <span class="keyword">if</span> (result == ERROR_NO_CHANNEL) &#123;</span><br><span class="line">                        failureReason = WifiManager.SAP_START_FAILURE_NO_CHANNEL;</span><br><span class="line">                    &#125;</span><br><span class="line">                    updateApState(WifiManager.WIFI_AP_STATE_FAILED,</span><br><span class="line">                                  WifiManager.WIFI_AP_STATE_ENABLING,</span><br><span class="line">                                  failureReason);</span><br><span class="line">                    stopSoftAp();</span><br><span class="line">                    mWifiMetrics.incrementSoftApStartResult(<span class="keyword">false</span>, failureReason);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                transitionTo(mStartedState);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// Ignore all other commands.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此, 最后AP的创建都是通过WifiNative调用Native的接口来实现热点的创建:</p>
<ul>
<li>首先是通过<code>WifiNative.setupInterfaceForSoftApMode</code>创建AP网口, 并启动<code>hostapd</code></li>
<li>然后通过<code>WifiNative.startSoftAp</code>启动AP, 准备接受来自客户端的连接请求</li>
</ul>
<p>接下来就看看这两个流程对应的Native代码.</p>
<h3 id="创建WIFI热点-Native流程"><a href="#创建WIFI热点-Native流程" class="headerlink" title=" 创建WIFI热点-Native流程 "></a><strong><em> 创建WIFI热点-Native流程 </em></strong></h3><p>WIFI热点的创建在Native层主要依赖两个服务来完成:</p>
<ul>
<li><code>WifiCond</code>: 负责创建AP的网口<code>wlan0</code>, 并获取当前的热点数量等信息</li>
<li><code>Hostapd</code>: 负责热点连接的管理以及身份验证等</li>
</ul>
<p>接着上面的流程,  <code>WifiNative.setupInterfaceForSoftApMode</code>这个方法的首先会尝试启动<code>Hostapd</code>守护进程, 接着调用<code>WifiCondControl.setupInterfaceForSoftApMode</code>来创建一个AP接口.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">setupInterfaceForSoftApMode</span><span class="params">(@NonNull InterfaceCallback interfaceCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!startHal()) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Failed to start Hal"</span>);</span><br><span class="line">            mWifiMetrics.incrementNumSetupSoftApInterfaceFailureDueToHal();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!startHostapd()) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Failed to start hostapd"</span>);</span><br><span class="line">            mWifiMetrics.incrementNumSetupSoftApInterfaceFailureDueToHostapd();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Iface iface = mIfaceMgr.allocateIface(Iface.IFACE_TYPE_AP);</span><br><span class="line">        <span class="keyword">if</span> (iface == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Failed to allocate new AP iface"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iface.externalListener = interfaceCallback;</span><br><span class="line">        iface.name = createApIface(iface);</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(iface.name)) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Failed to create AP iface in vendor HAL"</span>);</span><br><span class="line">            mIfaceMgr.removeIface(iface.id);</span><br><span class="line">            mWifiMetrics.incrementNumSetupSoftApInterfaceFailureDueToHal();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用HAL接口创建AP网口</span></span><br><span class="line">        <span class="keyword">if</span> (mWificondControl.setupInterfaceForSoftApMode(iface.name) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Failed to setup iface in wificond on "</span> + iface);</span><br><span class="line">            teardownInterface(iface.name);</span><br><span class="line">            mWifiMetrics.incrementNumSetupSoftApInterfaceFailureDueToWificond();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iface.networkObserver = <span class="keyword">new</span> NetworkObserverInternal(iface.id);</span><br><span class="line">        <span class="keyword">if</span> (!registerNetworkObserver(iface.networkObserver)) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Failed to register network observer on "</span> + iface);</span><br><span class="line">            teardownInterface(iface.name);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Just to avoid any race conditions with interface state change callbacks,</span></span><br><span class="line">        <span class="comment">// update the interface state before we exit.</span></span><br><span class="line">        onInterfaceStateChanged(iface, isInterfaceUp(iface.name));</span><br><span class="line">        Log.i(TAG, <span class="string">"Successfully setup "</span> + iface);</span><br><span class="line"></span><br><span class="line">        iface.featureSet = getSupportedFeatureSetInternal(iface.name);</span><br><span class="line">        <span class="keyword">return</span> iface.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里, 实际就是调用<code>IWifiCond</code>这个HAL接口来创建AP的网口. <code>WifiCond</code>这个服务在系统启动的时候加载的. 我们不妨直接跳到<code>/system/connectivity/wificond</code>来看下WifiCond服务的实现逻辑.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// WifiCondControl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IApInterface <span class="title">setupInterfaceForSoftApMode</span><span class="params">(@NonNull String ifaceName)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"Setting up interface for soft ap mode"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!retrieveWificondAndRegisterForDeath()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IApInterface apInterface = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        apInterface = mWificond.createApInterface(ifaceName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e1) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Failed to get IApInterface due to remote exception"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    Binder.allowBlocking(apInterface.asBinder());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Refresh Handlers</span></span><br><span class="line">    mApInterfaces.put(ifaceName, apInterface);</span><br><span class="line">    <span class="keyword">return</span> apInterface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IWifiCond</code>的实现都在<code>Server.cpp</code>中, <code>createApInterface</code>这个函数实际创建一个接口, 并返回<code>IApInterface</code>的远程调用接口给到上层使用.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Server.cpp</span></span><br><span class="line">Status Server::createApInterface(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; iface_name,</span><br><span class="line">	                         sp&lt;IApInterface&gt;* created_interface) &#123;</span><br><span class="line">  InterfaceInfo interface;</span><br><span class="line">  <span class="keyword">if</span> (!SetupInterface(iface_name, &amp;interface)) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::ok();  <span class="comment">// Logging was done internally</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;ApInterfaceImpl&gt; ap_interface(<span class="keyword">new</span> ApInterfaceImpl(</span><br><span class="line">      interface.name,</span><br><span class="line">      interface.index,</span><br><span class="line">      interface.is_bridge,</span><br><span class="line">      netlink_utils_,</span><br><span class="line">      if_tool_.get()));</span><br><span class="line">  *created_interface = ap_interface-&gt;GetBinder();</span><br><span class="line">  BroadcastApInterfaceReady(ap_interface-&gt;GetBinder());</span><br><span class="line">  ap_interfaces_[iface_name] = <span class="built_in">std</span>::move(ap_interface);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里, 热点的创建算是完成了第一步. 等到<code>WifiCond</code>创建完成之后, <code>wlanx</code>的网口UP之后, 会将状态回调给<code>SoftApManager</code>, 在这里会发送一个热点已经开启成功的广播, <code>Tethering</code>服务收到该广播之后, 就会为该网口分配IP, 并启动DHCP相关的进程, 这样就可以愉快的接受来自客户端的连接请求了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// SoftApManager</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onUpChanged</span><span class="params">(<span class="keyword">boolean</span> isUp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isUp == mIfaceIsUp) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// no change</span></span><br><span class="line">    &#125;</span><br><span class="line">    mIfaceIsUp = isUp;</span><br><span class="line">    <span class="keyword">if</span> (isUp) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"SoftAp is ready for use"</span>);</span><br><span class="line">        updateApState(WifiManager.WIFI_AP_STATE_ENABLED,</span><br><span class="line">                WifiManager.WIFI_AP_STATE_ENABLING, <span class="number">0</span>);</span><br><span class="line">        mWifiMetrics.incrementSoftApStartResult(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCallback.onNumClientsChanged(mNumAssociatedStations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// the interface was up, but goes down</span></span><br><span class="line">        sendMessage(CMD_INTERFACE_DOWN);</span><br><span class="line">    &#125;</span><br><span class="line">    mWifiMetrics.addSoftApUpChangedEvent(isUp, mMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateApState</span><span class="params">(<span class="keyword">int</span> newState, <span class="keyword">int</span> currentState, <span class="keyword">int</span> reason)</span> </span>&#123;</span><br><span class="line">    mCallback.onStateChanged(newState, reason);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//send the AP state change broadcast</span></span><br><span class="line">    <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(WifiManager.WIFI_AP_STATE_CHANGED_ACTION);</span><br><span class="line">    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);</span><br><span class="line">    intent.putExtra(WifiManager.EXTRA_WIFI_AP_STATE, newState);</span><br><span class="line">    intent.putExtra(WifiManager.EXTRA_PREVIOUS_WIFI_AP_STATE, currentState);</span><br><span class="line">    <span class="keyword">if</span> (newState == WifiManager.WIFI_AP_STATE_FAILED) &#123;</span><br><span class="line">        <span class="comment">//only set reason number when softAP start failed</span></span><br><span class="line">        intent.putExtra(WifiManager.EXTRA_WIFI_AP_FAILURE_REASON, reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    intent.putExtra(WifiManager.EXTRA_WIFI_AP_INTERFACE_NAME, mApInterfaceName);</span><br><span class="line">    intent.putExtra(WifiManager.EXTRA_WIFI_AP_MODE, mMode);</span><br><span class="line">    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="网络配置与DHCP服务的启动"><a href="#网络配置与DHCP服务的启动" class="headerlink" title="网络配置与DHCP服务的启动"></a><strong>网络配置与DHCP服务的启动</strong></h2><p>上面说到, WIFI热点的网口UP之后, 会发送一个<code>WIFI_AP_STATE_CHANGED_ACTION</code>的广播, 而<code>Tethering</code>服务在启动的时候就监听了该广播:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">StateReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context content, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (action.equals(UsbManager.ACTION_USB_STATE)) &#123;</span><br><span class="line">            handleUsbAction(intent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(CONNECTIVITY_ACTION)) &#123;</span><br><span class="line">            handleConnectivityAction(intent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(WifiManager.WIFI_AP_STATE_CHANGED_ACTION)) &#123;</span><br><span class="line">            handleWifiApAction(intent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)) &#123;</span><br><span class="line">            handleWifiP2pAction(intent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) &#123;</span><br><span class="line">            mLog.log(<span class="string">"OBSERVED configuration changed"</span>);</span><br><span class="line">            updateConfiguration();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里对应就会调用<code>handleWifiApAction</code>: 根据AP的状态来执行对应的动作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleWifiApAction</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> curState = intent.getIntExtra(EXTRA_WIFI_AP_STATE, WIFI_AP_STATE_DISABLED);</span><br><span class="line">    <span class="keyword">final</span> String ifname = intent.getStringExtra(EXTRA_WIFI_AP_INTERFACE_NAME);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> ipmode = intent.getIntExtra(EXTRA_WIFI_AP_MODE, IFACE_IP_MODE_UNSPECIFIED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (Tethering.<span class="keyword">this</span>.mPublicSync) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (curState) &#123;</span><br><span class="line">            <span class="keyword">case</span> WifiManager.WIFI_AP_STATE_ENABLING:</span><br><span class="line">                <span class="comment">// We can see this state on the way to both enabled and failure states.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WifiManager.WIFI_AP_STATE_ENABLED:</span><br><span class="line">                enableWifiIpServingLocked(ifname, ipmode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WifiManager.WIFI_AP_STATE_DISABLED:</span><br><span class="line">            <span class="keyword">case</span> WifiManager.WIFI_AP_STATE_DISABLING:</span><br><span class="line">            <span class="keyword">case</span> WifiManager.WIFI_AP_STATE_FAILED:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                disableWifiIpServingLocked(ifname, curState);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据热点开启模式(共享还是本地)开启IP配置流程:</p>
<ul>
<li><code>maybeTrackNewInterfaceLocked</code>: 开启一个<code>IpServer</code>的状态机用于配置热点IP以及启动DHCP服务</li>
<li><code>changeInterfaceState</code>:  让<code>IpServer</code>进入热点共享状态, 等待客户端请求以及上游网络连接(比如4G)</li>
</ul>
<p>到这里, 我们大致可以看到, 热点共享功能还需要如下3个步骤才能最终完成:</p>
<ul>
<li>配置<code>wlanx</code>网口IP地址</li>
<li>启动DHCP服务</li>
<li>如果发现当前系统有可用的网络连接, 则将热点的数据口<code>wlanx</code>转发到对应的网口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enableWifiIpServingLocked</span><span class="params">(String ifname, <span class="keyword">int</span> wifiIpMode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Map wifiIpMode values to IpServer.Callback serving states, inferring</span></span><br><span class="line">    <span class="comment">// from mWifiTetherRequested as a final "best guess".</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> ipServingMode;</span><br><span class="line">    <span class="keyword">switch</span> (wifiIpMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> IFACE_IP_MODE_TETHERED:</span><br><span class="line">            ipServingMode = IpServer.STATE_TETHERED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IFACE_IP_MODE_LOCAL_ONLY:</span><br><span class="line">            ipServingMode = IpServer.STATE_LOCAL_ONLY;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            mLog.e(<span class="string">"Cannot enable IP serving in unknown WiFi mode: "</span> + wifiIpMode);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(ifname)) &#123;</span><br><span class="line">        maybeTrackNewInterfaceLocked(ifname, TETHERING_WIFI);</span><br><span class="line">        changeInterfaceState(ifname, ipServingMode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLog.e(String.format(</span><br><span class="line">               <span class="string">"Cannot enable IP serving in mode %s on missing interface name"</span>,</span><br><span class="line">               ipServingMode));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上<code>IpServer</code>就是一个状态机, 其有<code>InitialState</code>/<code>LocalHotspotState</code>/<code>TetheredState</code>/<code>UnavailableState</code>这么四个状态, 其初始状态为<code>InitialState</code>; 在状态机收到消息<code>CMD_TETHER_REQUESTED</code>后, 就会进入<code>TetheredState</code>状态.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeTrackNewInterfaceLocked</span><span class="params">(<span class="keyword">final</span> String iface, <span class="keyword">int</span> interfaceType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we have already started a TISM for this interface, skip.</span></span><br><span class="line">    <span class="keyword">if</span> (mTetherStates.containsKey(iface)) &#123;</span><br><span class="line">        mLog.log(<span class="string">"active iface ("</span> + iface + <span class="string">") reported as added, ignoring"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLog.log(<span class="string">"adding TetheringInterfaceStateMachine for: "</span> + iface);</span><br><span class="line">    <span class="keyword">final</span> TetherState tetherState = <span class="keyword">new</span> TetherState(</span><br><span class="line">            <span class="keyword">new</span> IpServer(iface, mLooper, interfaceType, mLog, mNMService, mStatsService,</span><br><span class="line">                         makeControlCallback(), mConfig.enableLegacyDhcpServer,</span><br><span class="line">                         mDeps.getIpServerDependencies()));</span><br><span class="line">    mTetherStates.put(iface, tetherState);</span><br><span class="line">    tetherState.ipServer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IpServer</code>在进入<code>TetheredState</code>之后主要是配置IP/路由以及启动DHCP；需要说明的是, Android Q实际使用了两套DHCP逻辑,一个是通过<code>dnsmasq</code>来实现(LegacyDhcpServer); 一个是通过一个Java进程来实现. 目前默认使用的是通过Java进程(<code>/packages/modules/networkstack</code>)来实现的. 有兴趣的可以自行看下具体的代码实现.</p>
<p><code>IpServer</code>中的<code>TetheredState</code>继承了<code>BaseServingState</code>, 因此实际进入<code>TetheredState</code>时就会做如下几个事情:</p>
<ul>
<li><code>startIPv4</code>: 配置网口IP地址, 启动DHCP服务</li>
<li><code>mNMService.tetherInterface</code>: 添加路由信息</li>
<li><code>startIPv6</code>: 启动IPv6路由广播(Route Advertisement)守护进程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseServingState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!startIPv4()) &#123;</span><br><span class="line">            mLastError = ConnectivityManager.TETHER_ERROR_IFACE_CFG_ERROR;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mNMService.tetherInterface(mIfaceName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            mLog.e(<span class="string">"Error Tethering: "</span> + e);</span><br><span class="line">            mLastError = ConnectivityManager.TETHER_ERROR_TETHER_IFACE_ERROR;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!startIPv6()) &#123;</span><br><span class="line">            mLog.e(<span class="string">"Failed to startIPv6"</span>);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Make this a fatal error once Bluetooth IPv6 is sorted.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里, 热点共享功能也算启动完成了, 对于非本地功能的热点, 还需要完成最后一件事情: 监听系统当前默认网络连接(具备上网功能), 然后热点网口数据转发到默认数据网口, 这样连接过来的热点就可以访问外网了. 这里只是来看下<code>IpServer</code>在收到默认网络可用时的处理流程, 具体是如何监听系统当前的网络状态, 可以参考<code>Tethering.java/UpStreamNetworkMonitor.java</code>这两个文件中代码.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">TetheredState</span> <span class="keyword">extends</span> <span class="title">BaseServingState</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span>.enter();</span><br><span class="line">           <span class="keyword">if</span> (mLastError != ConnectivityManager.TETHER_ERROR_NO_ERROR) &#123;</span><br><span class="line">               transitionTo(mInitialState);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (DBG) Log.d(TAG, <span class="string">"Tethered "</span> + mIfaceName);</span><br><span class="line">           sendInterfaceState(STATE_TETHERED);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">super</span>.processMessage(message)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">           logMessage(<span class="keyword">this</span>, message.what);</span><br><span class="line">           <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">               <span class="keyword">case</span> CMD_TETHER_REQUESTED:</span><br><span class="line">                   mLog.e(<span class="string">"CMD_TETHER_REQUESTED while already tethering."</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 上游网络连接可用</span></span><br><span class="line">               <span class="keyword">case</span> CMD_TETHER_CONNECTION_CHANGED:</span><br><span class="line">                   <span class="keyword">final</span> InterfaceSet newUpstreamIfaceSet = (InterfaceSet) message.obj;</span><br><span class="line">                   <span class="keyword">if</span> (noChangeInUpstreamIfaceSet(newUpstreamIfaceSet)) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (VDBG) Log.d(TAG, <span class="string">"Connection changed noop - dropping"</span>);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (newUpstreamIfaceSet == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       cleanupUpstream();</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span> (String removed : upstreamInterfacesRemoved(newUpstreamIfaceSet)) &#123;</span><br><span class="line">                       cleanupUpstreamInterface(removed);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">final</span> Set&lt;String&gt; added = upstreamInterfacesAdd(newUpstreamIfaceSet);</span><br><span class="line">                   <span class="comment">// This makes the call to cleanupUpstream() in the error</span></span><br><span class="line">                   <span class="comment">// path for any interface neatly cleanup all the interfaces.</span></span><br><span class="line">                   mUpstreamIfaceSet = newUpstreamIfaceSet;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span> (String ifname : added) &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           mNMService.enableNat(mIfaceName, ifname);</span><br><span class="line">                           mNMService.startInterfaceForwarding(mIfaceName, ifname);</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                           mLog.e(<span class="string">"Exception enabling NAT: "</span> + e);</span><br><span class="line">                           cleanupUpstream();</span><br><span class="line">                           mLastError = ConnectivityManager.TETHER_ERROR_ENABLE_NAT_ERROR;</span><br><span class="line">                           transitionTo(mInitialState);</span><br><span class="line">                           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       ....</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Android WIFI模块设计的代码量比较大, 涉及到的模块也比较多, 要吃透其中的流程, 首先要建立一个整体的代码框架, 其次要通过某个具体的应用场景一步步梳理, 才能做到阅读代码时心中有数.</p>
<ul>
<li><a href="https://wireless.wiki.kernel.org/en/users/documentation" target="_blank" rel="noopener">https://wireless.wiki.kernel.org/en/users/documentation</a></li>
<li>Android Open Source Code Project</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Framework </tag>
            
            <tag> Wifi </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux网络协议之数据发送流程]]></title>
      <url>http://sniffer.site/2021/04/08/Linux%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>最近抽空学习下Linux网络协议栈, 读源码时总会前一天看到的源码, 第二天再来看却发现又忘记的差不多, 只能又看一遍, 这么看了几遍才完全的把整个逻辑理清楚. 于是下定想着要把看过的代码逻辑整理下来, 算是对这段时间学习的总结, 也方便后面的查阅. </p>
<p>在之前的一篇有关网络协议的文章<a href="http://sniffer.site/2020/05/12/%E4%BB%8ENAPI%E8%AF%B4%E4%B8%80%E8%AF%B4Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/">从NAPI说一说Linux内核数据的接收流程</a>简单的讲到了Linux的数据接收流程, 但主要是集中在数据链路层与设备驱动之间的交互, 并没有涉及到IP网络层以及TCP传输层的逻辑.这篇文章, 着重看下数据的发送流程, 并梳理下Linux协议栈大致的结构与初始化流程, 主要分为如下两个部分:</p>
<ul>
<li>Linux内核协议栈的初始化流程</li>
<li>数据是如何从TCP传输层发送到设备驱动的</li>
</ul>
<blockquote>
<p>本文基于Linux 4.14版本的ipv4, 没有关注ipv6部分的实现</p>
</blockquote>
<h2 id="内核协议栈的初始化"><a href="#内核协议栈的初始化" class="headerlink" title="内核协议栈的初始化"></a><strong>内核协议栈的初始化</strong></h2><p>Linux内核的初始化的逻辑都放在了<code>af_inet.c</code>(<code>kernel/net/ipv4</code>)这个文件, 系统启动的时候, 会调用初始化的函数<code>inet_init</code>, 由这个函数负责注册socket层的接口,初始化TCP/IP层以及注册IP层与数据链路层的接口.</p>
<ul>
<li><code>proto_register</code>注册TCP/UDP/ICMP相关的协议, 并分配相应的slab空间； 这些传输层协议负责与socket层进行交互, 比如用户写入到socket数据后会发送到这些协议; 并接收来自网络层的数据后将数据写入到用户空间的缓冲区</li>
<li><code>sock_register</code>注册接口用于创建socket对象</li>
<li>接着把通过<code>inet_add_protocol</code>把传输层的各个协议如TCP/UDP/ICMP等的接口注册到网络层, 这样网络层数据回来之后就可以通过这些注册的回调接口进行处理, 并将数据写到对应应用的socket缓冲区</li>
<li><code>inet_register_protosw</code>注册socket层的接口, linux内核提供了三种形式的<code>SOCK_STREAM</code>/<code>SOCK_DGRAM</code>/<code>SOCK_RAW</code> socket, 一般来说TCP使用的是<code>SOCK_STREAM</code>字节流形式的socket, 而UDP/ICMP使用的是<code>SOCK_DGRAM</code>数据报文形式的socket</li>
<li><code>xxx_init</code>函数会依次初始化ARP/IP/TCP等各个模块, 为其分配相应的slab内存空间</li>
<li>最后<code>dev_add_pack</code>向链路层添加一个数据接收的接口<code>ip_packet_type</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// af_inet.c</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">inet_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">q</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">r</span>;</span></span><br><span class="line">    <span class="keyword">int</span> rc = -EINVAL;</span><br><span class="line"></span><br><span class="line">    sock_skb_cb_check_size(<span class="keyword">sizeof</span>(struct inet_skb_parm));</span><br><span class="line"></span><br><span class="line">    rc = proto_register(&amp;tcp_prot, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc)</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    rc = proto_register(&amp;udp_prot, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc)</span><br><span class="line">      <span class="keyword">goto</span> out_unregister_tcp_proto;</span><br><span class="line"></span><br><span class="line">    rc = proto_register(&amp;raw_prot, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc)</span><br><span class="line">      <span class="keyword">goto</span> out_unregister_udp_proto;</span><br><span class="line"></span><br><span class="line">    rc = proto_register(&amp;ping_prot, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc)</span><br><span class="line">      <span class="keyword">goto</span> out_unregister_raw_proto;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *	Tell SOCKET that we are alive...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    (<span class="keyword">void</span>)sock_register(&amp;inet_family_ops);</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSCTL</span></span><br><span class="line">    ip_static_sysctl_init();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *	Add all the base protocols.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inet_add_protocol(&amp;icmp_protocol, IPPROTO_ICMP) &lt; <span class="number">0</span>)</span><br><span class="line">      pr_crit(<span class="string">"%s: Cannot add ICMP protocol\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">if</span> (inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &lt; <span class="number">0</span>)</span><br><span class="line">      pr_crit(<span class="string">"%s: Cannot add UDP protocol\n"</span>, __func__);</span><br><span class="line">    <span class="keyword">if</span> (inet_add_protocol(&amp;tcp_protocol, IPPROTO_TCP) &lt; <span class="number">0</span>)</span><br><span class="line">      pr_crit(<span class="string">"%s: Cannot add TCP protocol\n"</span>, __func__);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IP_MULTICAST</span></span><br><span class="line">    <span class="keyword">if</span> (inet_add_protocol(&amp;igmp_protocol, IPPROTO_IGMP) &lt; <span class="number">0</span>)</span><br><span class="line">      pr_crit(<span class="string">"%s: Cannot add IGMP protocol\n"</span>, __func__);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Register the socket-side information for inet_create. */</span></span><br><span class="line">    <span class="keyword">for</span> (r = &amp;inetsw[<span class="number">0</span>]; r &lt; &amp;inetsw[SOCK_MAX]; ++r)</span><br><span class="line">      INIT_LIST_HEAD(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)</span><br><span class="line">      inet_register_protosw(q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *	Set the ARP module up</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    arp_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *	Set the IP module up</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    ip_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup TCP slab cache for open requests. */</span></span><br><span class="line">    tcp_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup UDP memory threshold */</span></span><br><span class="line">    udp_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add UDP-Lite (RFC 3828) */</span></span><br><span class="line">    udplite4_register();</span><br><span class="line"></span><br><span class="line">    ping_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *	Set the ICMP layer up</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (icmp_init() &lt; <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">"Failed to create the ICMP control socket.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *	Initialise the multicast router</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_IP_MROUTE)</span></span><br><span class="line">    <span class="keyword">if</span> (ip_mr_init())</span><br><span class="line">      pr_crit(<span class="string">"%s: Cannot init ipv4 mroute\n"</span>, __func__);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (init_inet_pernet_ops())</span><br><span class="line">      pr_crit(<span class="string">"%s: Cannot init ipv4 inet pernet ops\n"</span>, __func__);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *	Initialise per-cpu ipv4 mibs</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (init_ipv4_mibs())</span><br><span class="line">      pr_crit(<span class="string">"%s: Cannot init ipv4 mibs\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">    ipv4_proc_init();</span><br><span class="line"></span><br><span class="line">    ipfrag_init();</span><br><span class="line"></span><br><span class="line">    dev_add_pack(&amp;ip_packet_type);</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fs_initcall(inet_init);</span><br></pre></td></tr></table></figure>
<p>总的说来, Linux内核把网络协议栈的实现大致分为了四个层级:</p>
<ul>
<li>socket层: 为用户空间提供系统调用的接口, 并负责与下一层TCP传输层进行交互</li>
<li>TCP传输层: 就是通常所说的TCP/IP协议栈对应的数据传输层, 传输层一方面要为socket层提供接口, 另一方面要为网络层的数据接收提供接口</li>
<li>IP网络层: 对应TCP/IP协议栈的网络层, 负责将传输层的数据分片/路由, 并发送到对应的网络设备; 接收到数据后发送给对应的传输层协议</li>
<li>数据链路层: 需要负责物理设备与IP地址之间的转换, 将数据发送给物理设备, 接收来自物理设备的数据</li>
</ul>
<p>对协议栈有了这个大致的框架层级图, 梳理整个协议栈的代码就会清晰很多.在讲具体的代码细节之前, 我们先来看一个大致的数据收发流程图:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/linux_network_stack_flow.png" alt="Linux Network stack flow"></p>
<p>沿着这个流程简图, 我们就来仔细看下数据的发送流程(基于TCP协议).</p>
<h2 id="数据发送流程"><a href="#数据发送流程" class="headerlink" title="数据发送流程"></a><strong>数据发送流程</strong></h2><p>这里把整个发送流程按照TCP/IP协议栈分为三个部分来分析:</p>
<ul>
<li>TCP传输层</li>
<li>IP网络层</li>
<li>数据链路层</li>
</ul>
<h3 id="TCP传输层流程"><a href="#TCP传输层流程" class="headerlink" title="TCP传输层流程"></a><strong>TCP传输层流程</strong></h3><p>在分析具体流程之前, 可以看下TCP层数据传输的具体流程简图, 方便跟踪代码:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/network_stack_tcp_flow.png" alt="TCP data flow"></p>
<p>简单起见, 这里跳过了TCP socket创建与连接建立的过程(感兴趣的可以参看<code>kernel/net/socket.c</code>), 只着重于数据的发送过程. 在第一部分初始化的时候, 我们看到, socket层与TCP传输层的接口是<code>tcp_prot</code>, 这个结构体在<code>tcp_ipv4.c</code>中定义, 其接口包含了socket连接(<code>connect</code>), 连接断开(<code>disconnect</code>), 接受连接(<code>accept</code>), 接收消息(<code>recvmsg</code>), 发送消息<code>sendmsg</code>等.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//tcp_ipv4.c</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">tcp_prot</span> = &#123;</span></span><br><span class="line">    .name			= <span class="string">"TCP"</span>,</span><br><span class="line">    .owner			= THIS_MODULE,</span><br><span class="line">    .close			= tcp_close,</span><br><span class="line">    .connect		= tcp_v4_connect,</span><br><span class="line">    .disconnect		= tcp_disconnect,</span><br><span class="line">    .accept			= inet_csk_accept,</span><br><span class="line">    .ioctl			= tcp_ioctl,</span><br><span class="line">    .init			= tcp_v4_init_sock,</span><br><span class="line">    .destroy		= tcp_v4_destroy_sock,</span><br><span class="line">    .shutdown		= tcp_shutdown,</span><br><span class="line">    .setsockopt		= tcp_setsockopt,</span><br><span class="line">    .getsockopt		= tcp_getsockopt,</span><br><span class="line">    .keepalive		= tcp_set_keepalive,</span><br><span class="line">    .recvmsg		= tcp_recvmsg,</span><br><span class="line">    .sendmsg		= tcp_sendmsg,</span><br><span class="line">    .sendpage		= tcp_sendpage,</span><br><span class="line">    .backlog_rcv		= tcp_v4_do_rcv,</span><br><span class="line">    .release_cb		= tcp_release_cb,</span><br><span class="line">    .hash			= inet_hash,</span><br><span class="line">    .unhash			= inet_unhash,</span><br><span class="line">    .get_port		= inet_csk_get_port,</span><br><span class="line">    .enter_memory_pressure	= tcp_enter_memory_pressure,</span><br><span class="line">    .leave_memory_pressure	= tcp_leave_memory_pressure,</span><br><span class="line">    .stream_memory_free	= tcp_stream_memory_free,</span><br><span class="line">    .sockets_allocated	= &amp;tcp_sockets_allocated,</span><br><span class="line">    .orphan_count		= &amp;tcp_orphan_count,</span><br><span class="line">    .memory_allocated	= &amp;tcp_memory_allocated,</span><br><span class="line">    .memory_pressure	= &amp;tcp_memory_pressure,</span><br><span class="line">    .sysctl_mem		= sysctl_tcp_mem,</span><br><span class="line">    .sysctl_wmem		= sysctl_tcp_wmem,</span><br><span class="line">    .sysctl_rmem		= sysctl_tcp_rmem,</span><br><span class="line">    .max_header		= MAX_TCP_HEADER,</span><br><span class="line">    .obj_size		= <span class="keyword">sizeof</span>(struct tcp_sock),</span><br><span class="line">    .slab_flags		= SLAB_TYPESAFE_BY_RCU,</span><br><span class="line">    .twsk_prot		= &amp;tcp_timewait_sock_ops,</span><br><span class="line">    .rsk_prot		= &amp;tcp_request_sock_ops,</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">  EXPORT_SYMBOL(tcp_prot);</span><br></pre></td></tr></table></figure>
<p>socket层接收到用户进程的数据发送请求后, <code>inet_sendmsg</code>就是调用了<code>tcp_prot</code>的<code>sendmsg</code>来传输数据的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//af_inet.c</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">inet_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line"></span><br><span class="line">		sock_rps_record_flow(sk);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* We may need to bind the socket. */</span></span><br><span class="line">		<span class="keyword">if</span> (!inet_sk(sk)-&gt;inet_num &amp;&amp; !sk-&gt;sk_prot-&gt;no_autobind &amp;&amp;</span><br><span class="line">		    inet_autobind(sk))</span><br><span class="line">			<span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> sk-&gt;sk_prot-&gt;sendmsg(sk, msg, size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	  ###<span class="meta"># tcp.c  ####</span></span><br><span class="line">	  <span class="function"><span class="keyword">int</span> <span class="title">tcp_sendmsg</span><span class="params">(struct sock *sk, struct msghdr *msg, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">	  </span>&#123;</span><br><span class="line">		    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">		    lock_sock(sk);</span><br><span class="line">		    ret = tcp_sendmsg_locked(sk, msg, size);</span><br><span class="line">		    release_sock(sk);</span><br><span class="line"></span><br><span class="line">		    <span class="keyword">return</span> ret;</span><br><span class="line">	  &#125;</span><br></pre></td></tr></table></figure>
<p>在发送数据之前, 先通过<code>lock_sock</code>获取到锁后, 然后调用<code>tcp_sendmsg_locked</code>发送数据, 这里主要做如下几个事情:</p>
<ul>
<li>查看socket标志位是否有<code>MSG_ZEROCOPY</code>以及<code>MSG_FASTOPEN</code>(在三次握手时即开始传输数据)</li>
<li>判断当前TCP是否处于<code>TCPF_ESTABLISHED</code>连接状态, 否则需要等待连接成功后再发送数据</li>
<li>如果发生了数据拷贝, 则调用<code>tcp_push</code>执行数据的发送</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// tcp.c</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">tcp_sendmsg_locked</span><span class="params">(struct sock *sk, struct msghdr *msg, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ubuf_info</span> *<span class="title">uarg</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockcm_cookie</span> <span class="title">sockc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> flags, err, copied = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mss_now = <span class="number">0</span>, size_goal, copied_syn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> process_backlog = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> sg;</span><br><span class="line">    <span class="keyword">long</span> timeo;</span><br><span class="line"></span><br><span class="line">    flags = msg-&gt;msg_flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MSG_ZEROCOPY &amp;&amp; size &amp;&amp; sock_flag(sk, SOCK_ZEROCOPY)) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)) &#123;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> out_err;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      skb = tcp_send_head(sk) ? tcp_write_queue_tail(sk) : <span class="literal">NULL</span>;</span><br><span class="line">      uarg = sock_zerocopy_realloc(sk, size, skb_zcopy(skb));</span><br><span class="line">      <span class="keyword">if</span> (!uarg) &#123;</span><br><span class="line">        err = -ENOBUFS;</span><br><span class="line">        <span class="keyword">goto</span> out_err;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!(sk_check_csum_caps(sk) &amp;&amp; sk-&gt;sk_route_caps &amp; NETIF_F_SG))</span><br><span class="line">        uarg-&gt;zerocopy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(flags &amp; MSG_FASTOPEN || inet_sk(sk)-&gt;defer_connect) &amp;&amp;</span><br><span class="line">        !tp-&gt;repair) &#123;</span><br><span class="line">      err = tcp_sendmsg_fastopen(sk, msg, &amp;copied_syn, size);</span><br><span class="line">      <span class="keyword">if</span> (err == -EINPROGRESS &amp;&amp; copied_syn &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> out_err;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for a connection to finish. One exception is TCP Fast Open</span></span><br><span class="line"><span class="comment">    * (passive side) where data is allowed to be sent before a connection</span></span><br><span class="line"><span class="comment">    * is fully established.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)) &amp;&amp;</span><br><span class="line">        !tcp_passive_fastopen(sk)) &#123;</span><br><span class="line">      err = sk_stream_wait_connect(sk, &amp;timeo);</span><br><span class="line">      <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> do_error;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ok commence sending. */</span></span><br><span class="line">    copied = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  restart:</span><br><span class="line">    mss_now = tcp_send_mss(sk, &amp;size_goal, flags);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断发送msg消息中的数据</span></span><br><span class="line">    <span class="keyword">while</span> (msg_data_left(msg)) &#123;</span><br><span class="line">      <span class="keyword">int</span> copy = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> max = size_goal;</span><br><span class="line"></span><br><span class="line">      skb = tcp_write_queue_tail(sk);</span><br><span class="line">      <span class="keyword">if</span> (tcp_send_head(sk)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_NONE)</span><br><span class="line">          max = mss_now;</span><br><span class="line">        copy = max - skb-&gt;len;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (copy &lt;= <span class="number">0</span> || !tcp_skb_can_collapse_to(skb)) &#123;</span><br><span class="line">        <span class="keyword">bool</span> first_skb;</span><br><span class="line"></span><br><span class="line">  new_segment:</span><br><span class="line">        <span class="comment">/* Allocate new segment. If the interface is SG,</span></span><br><span class="line"><span class="comment">        * allocate skb fitting to single page.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (!sk_stream_memory_free(sk))</span><br><span class="line">          <span class="keyword">goto</span> wait_for_sndbuf;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (process_backlog &amp;&amp; sk_flush_backlog(sk)) &#123;</span><br><span class="line">          process_backlog = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">goto</span> restart;</span><br><span class="line">        &#125;</span><br><span class="line">        first_skb = skb_queue_empty(&amp;sk-&gt;sk_write_queue);</span><br><span class="line">        skb = sk_stream_alloc_skb(sk,</span><br><span class="line">                select_size(sk, sg, first_skb),</span><br><span class="line">                sk-&gt;sk_allocation,</span><br><span class="line">                first_skb);</span><br><span class="line">        <span class="keyword">if</span> (!skb)</span><br><span class="line">          <span class="keyword">goto</span> wait_for_memory;</span><br><span class="line"></span><br><span class="line">        process_backlog = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Check whether we can use HW checksum.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (sk_check_csum_caps(sk))</span><br><span class="line">          skb-&gt;ip_summed = CHECKSUM_PARTIAL;</span><br><span class="line"></span><br><span class="line">        skb_entail(sk, skb);</span><br><span class="line">        copy = size_goal;</span><br><span class="line">        max = size_goal;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">/* Try to append data to the end of skb. */</span></span><br><span class="line">      <span class="keyword">if</span> (copy &gt; msg_data_left(msg))</span><br><span class="line">        copy = msg_data_left(msg);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Where to copy to? */</span></span><br><span class="line">      <span class="keyword">if</span> (skb_availroom(skb) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* We have some space in skb head. Superb! */</span></span><br><span class="line">        copy = <span class="keyword">min_t</span>(<span class="keyword">int</span>, copy, skb_availroom(skb));</span><br><span class="line">        err = skb_add_data_nocache(sk, skb, &amp;msg-&gt;msg_iter, copy);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">          <span class="keyword">goto</span> do_fault;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!uarg || !uarg-&gt;zerocopy) &#123;</span><br><span class="line">        <span class="keyword">bool</span> merge = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i = skb_shinfo(skb)-&gt;nr_frags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page_frag</span> *<span class="title">pfrag</span> = <span class="title">sk_page_frag</span>(<span class="title">sk</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sk_page_frag_refill(sk, pfrag))</span><br><span class="line">          <span class="keyword">goto</span> wait_for_memory;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!skb_can_coalesce(skb, i, pfrag-&gt;page,</span><br><span class="line">                  pfrag-&gt;offset)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i &gt;= sysctl_max_skb_frags || !sg) &#123;</span><br><span class="line">            tcp_mark_push(tp, skb);</span><br><span class="line">            <span class="keyword">goto</span> new_segment;</span><br><span class="line">          &#125;</span><br><span class="line">          merge = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        copy = <span class="keyword">min_t</span>(<span class="keyword">int</span>, copy, pfrag-&gt;size - pfrag-&gt;offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sk_wmem_schedule(sk, copy))</span><br><span class="line">          <span class="keyword">goto</span> wait_for_memory;</span><br><span class="line"></span><br><span class="line">        err = skb_copy_to_page_nocache(sk, &amp;msg-&gt;msg_iter, skb,</span><br><span class="line">                    pfrag-&gt;page,</span><br><span class="line">                    pfrag-&gt;offset,</span><br><span class="line">                    copy);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">          <span class="keyword">goto</span> do_error;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update the skb. */</span></span><br><span class="line">        <span class="keyword">if</span> (merge) &#123;</span><br><span class="line">          skb_frag_size_add(&amp;skb_shinfo(skb)-&gt;frags[i - <span class="number">1</span>], copy);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          skb_fill_page_desc(skb, i, pfrag-&gt;page,</span><br><span class="line">                pfrag-&gt;offset, copy);</span><br><span class="line">          page_ref_inc(pfrag-&gt;page);</span><br><span class="line">        &#125;</span><br><span class="line">        pfrag-&gt;offset += copy;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = skb_zerocopy_iter_stream(sk, skb, msg, copy, uarg);</span><br><span class="line">        <span class="keyword">if</span> (err == -EMSGSIZE || err == -EEXIST)</span><br><span class="line">          <span class="keyword">goto</span> new_segment;</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">goto</span> do_error;</span><br><span class="line">        copy = err;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!copied)</span><br><span class="line">        TCP_SKB_CB(skb)-&gt;tcp_flags &amp;= ~TCPHDR_PSH;</span><br><span class="line"></span><br><span class="line">      tp-&gt;write_seq += copy;</span><br><span class="line">      TCP_SKB_CB(skb)-&gt;end_seq += copy;</span><br><span class="line">      tcp_skb_pcount_set(skb, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      copied += copy;</span><br><span class="line">      <span class="comment">// 没有数据, 则中断拷贝</span></span><br><span class="line">      <span class="keyword">if</span> (!msg_data_left(msg)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(flags &amp; MSG_EOR))</span><br><span class="line">          TCP_SKB_CB(skb)-&gt;eor = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (skb-&gt;len &lt; max || (flags &amp; MSG_OOB) || unlikely(tp-&gt;repair))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前写入的数据超过了最大window的2倍, 就直接发送</span></span><br><span class="line">      <span class="keyword">if</span> (forced_push(tp)) &#123;</span><br><span class="line">        tcp_mark_push(tp, skb);</span><br><span class="line">        __tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skb == tcp_send_head(sk))</span><br><span class="line">        tcp_push_one(sk, mss_now);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  wait_for_sndbuf:</span><br><span class="line">      set_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);</span><br><span class="line">  wait_for_memory:</span><br><span class="line">      <span class="keyword">if</span> (copied)</span><br><span class="line">        tcp_push(sk, flags &amp; ~MSG_MORE, mss_now,</span><br><span class="line">          TCP_NAGLE_PUSH, size_goal);</span><br><span class="line"></span><br><span class="line">      err = sk_stream_wait_memory(sk, &amp;timeo);</span><br><span class="line">      <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> do_error;</span><br><span class="line"></span><br><span class="line">      mss_now = tcp_send_mss(sk, &amp;size_goal, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  out:</span><br><span class="line">    <span class="comment">// 当前有数据需要发送</span></span><br><span class="line">    <span class="keyword">if</span> (copied) &#123;</span><br><span class="line">      tcp_tx_timestamp(sk, sockc.tsflags, tcp_write_queue_tail(sk));</span><br><span class="line">      tcp_push(sk, flags, mss_now, tp-&gt;nonagle, size_goal);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>tcp_push</code>首先检查发送队列是否为空, 为空则直接返回, 接着会检查标志位<code>flags</code>是否包含有<code>MSG_MORE/MSG_OOB</code>;另外, 还会判断是否满足<code>auto cork</code>的条件(简单来说, <code>auto corking</code>是TCP针对小包发送的一种优化, 详细可以参考<a href="https://lwn.net/Articles/576263/)" target="_blank" rel="noopener">https://lwn.net/Articles/576263/)</a>. 最后通过<code>__tcp_push_pending_frames</code>传送对应的数据.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// tcp.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tcp_push</span><span class="params">(struct sock *sk, <span class="keyword">int</span> flags, <span class="keyword">int</span> mss_now,</span></span></span><br><span class="line"><span class="function"><span class="params">		     <span class="keyword">int</span> nonagle, <span class="keyword">int</span> size_goal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tcp_send_head(sk))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	skb = tcp_write_queue_tail(sk);</span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; MSG_MORE) || forced_push(tp))</span><br><span class="line">		tcp_mark_push(tp, skb);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 是否属于OOB(out of band)紧急数据</span></span><br><span class="line">	tcp_mark_urg(tp, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcp_should_autocork(sk, skb, size_goal)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* avoid atomic op if TSQ_THROTTLED bit is already set */</span></span><br><span class="line">		<span class="keyword">if</span> (!test_bit(TSQ_THROTTLED, &amp;sk-&gt;sk_tsq_flags)) &#123;</span><br><span class="line">			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPAUTOCORKING);</span><br><span class="line">			set_bit(TSQ_THROTTLED, &amp;sk-&gt;sk_tsq_flags);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* It is possible TX completion already happened</span></span><br><span class="line"><span class="comment">		 * before we set TSQ_THROTTLED.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (refcount_read(&amp;sk-&gt;sk_wmem_alloc) &gt; skb-&gt;truesize)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MSG_MORE)</span><br><span class="line">		nonagle = TCP_NAGLE_CORK;</span><br><span class="line"></span><br><span class="line">	__tcp_push_pending_frames(sk, mss_now, nonagle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__tcp_push_pending_frames</code>首先会判断当前socket是否close, 非close状态则调用<code>tcp_write_xmit</code>继续发送数据:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// tcp_output.c</span></span><br><span class="line">	<span class="keyword">void</span> __tcp_push_pending_frames(struct sock *sk, <span class="keyword">unsigned</span> <span class="keyword">int</span> cur_mss,</span><br><span class="line">				       <span class="keyword">int</span> nonagle)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* If we are closed, the bytes will have to remain here.</span></span><br><span class="line"><span class="comment">		 * In time closedown will finish, we empty the write queue and</span></span><br><span class="line"><span class="comment">		 * all will be happy.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(sk-&gt;sk_state == TCP_CLOSE))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tcp_write_xmit(sk, cur_mss, nonagle, <span class="number">0</span>,</span><br><span class="line">				   sk_gfp_mask(sk, GFP_ATOMIC)))</span><br><span class="line">			tcp_check_probe_timer(sk);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>tcp_write_xmit</code>的函数的核心逻辑就是不断取出socket发送队列中的skb_buff, 然后通过<code>tcp_transmit_skb</code>发送出去, 而<code>tcp_transmit_skb</code>实际只是调用了<code>__tcp_transmit_skb</code>而已:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// tcp_output.c</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">tcp_write_xmit</span><span class="params">(struct sock *sk, <span class="keyword">unsigned</span> <span class="keyword">int</span> mss_now, <span class="keyword">int</span> nonagle,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">int</span> push_one, <span class="keyword">gfp_t</span> gfp)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> tso_segs, sent_pkts;</span><br><span class="line">		<span class="keyword">int</span> cwnd_quota;</span><br><span class="line">		<span class="keyword">int</span> result;</span><br><span class="line">		<span class="keyword">bool</span> is_cwnd_limited = <span class="literal">false</span>, is_rwnd_limited = <span class="literal">false</span>;</span><br><span class="line">		u32 max_segs;</span><br><span class="line"></span><br><span class="line">		sent_pkts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		tcp_mstamp_refresh(tp);</span><br><span class="line">		<span class="comment">// 如果不是发送一个段的包, 则执行PMTU</span></span><br><span class="line">		<span class="keyword">if</span> (!push_one) &#123;</span><br><span class="line">			<span class="comment">/* Do MTU probing. */</span></span><br><span class="line">			result = tcp_mtu_probe(sk);</span><br><span class="line">			<span class="keyword">if</span> (!result) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				sent_pkts = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		max_segs = tcp_tso_segs(sk, mss_now);</span><br><span class="line">		<span class="keyword">while</span> ((skb = tcp_send_head(sk))) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (tcp_pacing_check(sk))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			tso_segs = tcp_init_tso_segs(skb, mss_now);</span><br><span class="line">			BUG_ON(!tso_segs);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (unlikely(tp-&gt;repair) &amp;&amp; tp-&gt;repair_queue == TCP_SEND_QUEUE) &#123;</span><br><span class="line">				<span class="comment">/* "skb_mstamp" is used as a start point for the retransmit timer */</span></span><br><span class="line">				skb-&gt;skb_mstamp = tp-&gt;tcp_mstamp;</span><br><span class="line">				<span class="keyword">goto</span> repair; <span class="comment">/* Skip network transmission */</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			cwnd_quota = tcp_cwnd_test(tp, skb);</span><br><span class="line">			<span class="keyword">if</span> (!cwnd_quota) &#123;</span><br><span class="line">				<span class="keyword">if</span> (push_one == <span class="number">2</span>)</span><br><span class="line">					<span class="comment">/* Force out a loss probe pkt. */</span></span><br><span class="line">					cwnd_quota = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (unlikely(!tcp_snd_wnd_test(tp, skb, mss_now))) &#123;</span><br><span class="line">				is_rwnd_limited = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (tso_segs == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (unlikely(!tcp_nagle_test(tp, skb, mss_now,</span><br><span class="line">							     (tcp_skb_is_last(sk, skb) ?</span><br><span class="line">							      nonagle : TCP_NAGLE_PUSH))))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (!push_one &amp;&amp;</span><br><span class="line">				    tcp_tso_should_defer(sk, skb, &amp;is_cwnd_limited,</span><br><span class="line">							 &amp;is_rwnd_limited, max_segs))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			limit = mss_now;</span><br><span class="line">			<span class="keyword">if</span> (tso_segs &gt; <span class="number">1</span> &amp;&amp; !tcp_urg_mode(tp))</span><br><span class="line">				limit = tcp_mss_split_point(sk, skb, mss_now,</span><br><span class="line">							    <span class="keyword">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>,</span><br><span class="line">								  cwnd_quota,</span><br><span class="line">								  max_segs),</span><br><span class="line">							    nonagle);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (skb-&gt;len &gt; limit &amp;&amp;</span><br><span class="line">			    unlikely(tso_fragment(sk, skb, limit, mss_now, gfp)))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (test_bit(TCP_TSQ_DEFERRED, &amp;sk-&gt;sk_tsq_flags))</span><br><span class="line">				clear_bit(TCP_TSQ_DEFERRED, &amp;sk-&gt;sk_tsq_flags);</span><br><span class="line">			<span class="keyword">if</span> (tcp_small_queue_check(sk, skb, <span class="number">0</span>))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Argh, we hit an empty skb(), presumably a thread</span></span><br><span class="line"><span class="comment">			 * is sleeping in sendmsg()/sk_stream_wait_memory().</span></span><br><span class="line"><span class="comment">			 * We do not want to send a pure-ack packet and have</span></span><br><span class="line"><span class="comment">			 * a strange looking rtx queue with empty packet(s).</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;end_seq == TCP_SKB_CB(skb)-&gt;seq)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 发送数据</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(tcp_transmit_skb(sk, skb, <span class="number">1</span>, gfp)))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	repair:</span><br><span class="line">			<span class="comment">/* Advance the send_head.  This one is sent out.</span></span><br><span class="line"><span class="comment">			 * This call will increment packets_out.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			tcp_event_new_data_sent(sk, skb);</span><br><span class="line"></span><br><span class="line">			tcp_minshall_update(tp, mss_now, skb);</span><br><span class="line">			sent_pkts += tcp_skb_pcount(skb);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (push_one)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (is_rwnd_limited)</span><br><span class="line">			tcp_chrono_start(sk, TCP_CHRONO_RWND_LIMITED);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tcp_chrono_stop(sk, TCP_CHRONO_RWND_LIMITED);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(sent_pkts)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tcp_in_cwnd_reduction(sk))</span><br><span class="line">				tp-&gt;prr_out += sent_pkts;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Send one loss probe per tail loss episode. */</span></span><br><span class="line">			<span class="keyword">if</span> (push_one != <span class="number">2</span>)</span><br><span class="line">				tcp_schedule_loss_probe(sk, <span class="literal">false</span>);</span><br><span class="line">			is_cwnd_limited |= (tcp_packets_in_flight(tp) &gt;= tp-&gt;snd_cwnd);</span><br><span class="line">			tcp_cwnd_validate(sk, is_cwnd_limited);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> !tp-&gt;packets_out &amp;&amp; tcp_send_head(sk);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>__tcp_transmit_skb</code>是TCP传输层与IP网络层的分界函数, 在组装完TCP头后, 就调用IP层的接口<code>queue_xmit</code>往网络层继续发送数据:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// tcp_output.c </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> __tcp_transmit_skb(struct sock *sk, struct sk_buff *skb,</span><br><span class="line">				      <span class="keyword">int</span> clone_it, <span class="keyword">gfp_t</span> gfp_mask, u32 rcv_nxt)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> = <span class="title">inet_csk</span>(<span class="title">sk</span>);</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcp_skb_cb</span> *<span class="title">tcb</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcp_out_options</span> <span class="title">opts</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> tcp_options_size, tcp_header_size;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">oskb</span> = <span class="title">NULL</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcp_md5sig_key</span> *<span class="title">md5</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">		<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">		BUG_ON(!skb || !tcp_skb_pcount(skb));</span><br><span class="line">		tp = tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (clone_it) &#123;</span><br><span class="line">			TCP_SKB_CB(skb)-&gt;tx.in_flight = TCP_SKB_CB(skb)-&gt;end_seq</span><br><span class="line">				- tp-&gt;snd_una;</span><br><span class="line">			oskb = skb;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(skb_cloned(skb)))</span><br><span class="line">				skb = pskb_copy(skb, gfp_mask);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				skb = skb_clone(skb, gfp_mask);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">				<span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">		&#125;</span><br><span class="line">		skb-&gt;skb_mstamp = tp-&gt;tcp_mstamp;</span><br><span class="line"></span><br><span class="line">		inet = inet_sk(sk);</span><br><span class="line">		tcb = TCP_SKB_CB(skb);</span><br><span class="line">		<span class="built_in">memset</span>(&amp;opts, <span class="number">0</span>, <span class="keyword">sizeof</span>(opts));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(tcb-&gt;tcp_flags &amp; TCPHDR_SYN))</span><br><span class="line">			tcp_options_size = tcp_syn_options(sk, skb, &amp;opts, &amp;md5);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tcp_options_size = tcp_established_options(sk, skb, &amp;opts,</span><br><span class="line">								   &amp;md5);</span><br><span class="line">		tcp_header_size = tcp_options_size + <span class="keyword">sizeof</span>(struct tcphdr);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* if no packet is in qdisc/device queue, then allow XPS to select</span></span><br><span class="line"><span class="comment">		 * another queue. We can be called from tcp_tsq_handler()</span></span><br><span class="line"><span class="comment">		 * which holds one reference to sk_wmem_alloc.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">TODO:</span> Ideally, in-flight pure ACK packets should not matter here.</span></span><br><span class="line"><span class="comment">		 * One way to get this would be to set skb-&gt;truesize = 2 on them.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		skb-&gt;ooo_okay = sk_wmem_alloc_get(sk) &lt; SKB_TRUESIZE(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If we had to use memory reserve to allocate this skb,</span></span><br><span class="line"><span class="comment">		 * this might cause drops if packet is looped back :</span></span><br><span class="line"><span class="comment">		 * Other socket might not have SOCK_MEMALLOC.</span></span><br><span class="line"><span class="comment">		 * Packets not looped back do not care about pfmemalloc.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		skb-&gt;pfmemalloc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		skb_push(skb, tcp_header_size);</span><br><span class="line">		skb_reset_transport_header(skb);</span><br><span class="line"></span><br><span class="line">		skb_orphan(skb);</span><br><span class="line">		skb-&gt;sk = sk;</span><br><span class="line">		skb-&gt;destructor = skb_is_tcp_pure_ack(skb) ? __sock_wfree : tcp_wfree;</span><br><span class="line">		skb_set_hash_from_sk(skb, sk);</span><br><span class="line">		refcount_add(skb-&gt;truesize, &amp;sk-&gt;sk_wmem_alloc);</span><br><span class="line"></span><br><span class="line">		skb_set_dst_pending_confirm(skb, sk-&gt;sk_dst_pending_confirm);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Build TCP header and checksum it. */</span></span><br><span class="line">		th = (struct tcphdr *)skb-&gt;data;</span><br><span class="line">		th-&gt;source		= inet-&gt;inet_sport;</span><br><span class="line">		th-&gt;dest		= inet-&gt;inet_dport;</span><br><span class="line">		th-&gt;seq			= htonl(tcb-&gt;seq);</span><br><span class="line">		th-&gt;ack_seq		= htonl(rcv_nxt);</span><br><span class="line">		*(((__be16 *)th) + <span class="number">6</span>)	= htons(((tcp_header_size &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">						tcb-&gt;tcp_flags);</span><br><span class="line"></span><br><span class="line">		th-&gt;check		= <span class="number">0</span>;</span><br><span class="line">		th-&gt;urg_ptr		= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* The urg_mode check is necessary during a below snd_una win probe */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(tcp_urg_mode(tp) &amp;&amp; before(tcb-&gt;seq, tp-&gt;snd_up))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (before(tp-&gt;snd_up, tcb-&gt;seq + <span class="number">0x10000</span>)) &#123;</span><br><span class="line">				th-&gt;urg_ptr = htons(tp-&gt;snd_up - tcb-&gt;seq);</span><br><span class="line">				th-&gt;urg = <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (after(tcb-&gt;seq + <span class="number">0xFFFF</span>, tp-&gt;snd_nxt)) &#123;</span><br><span class="line">				th-&gt;urg_ptr = htons(<span class="number">0xFFFF</span>);</span><br><span class="line">				th-&gt;urg = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tcp_options_write((__be32 *)(th + <span class="number">1</span>), tp, &amp;opts);</span><br><span class="line">		skb_shinfo(skb)-&gt;gso_type = sk-&gt;sk_gso_type;</span><br><span class="line">		<span class="keyword">if</span> (likely(!(tcb-&gt;tcp_flags &amp; TCPHDR_SYN))) &#123;</span><br><span class="line">			th-&gt;window      = htons(tcp_select_window(sk));</span><br><span class="line">			tcp_ecn_send(sk, skb, th, tcp_header_size);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* RFC1323: The window in SYN &amp; SYN/ACK segments</span></span><br><span class="line"><span class="comment">			 * is never scaled.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			th-&gt;window	= htons(min(tp-&gt;rcv_wnd, <span class="number">65535U</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		....</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 计算checksum</span></span><br><span class="line">		icsk-&gt;icsk_af_ops-&gt;send_check(sk, skb);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(tcb-&gt;tcp_flags &amp; TCPHDR_ACK))</span><br><span class="line">			tcp_event_ack_sent(sk, tcp_skb_pcount(skb), rcv_nxt);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;len != tcp_header_size) &#123;</span><br><span class="line">			tcp_event_data_sent(tp, sk);</span><br><span class="line">			tp-&gt;data_segs_out += tcp_skb_pcount(skb);</span><br><span class="line">			tcp_internal_pacing(sk, skb);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (after(tcb-&gt;end_seq, tp-&gt;snd_nxt) || tcb-&gt;seq == tcb-&gt;end_seq)</span><br><span class="line">			TCP_ADD_STATS(sock_net(sk), TCP_MIB_OUTSEGS,</span><br><span class="line">				      tcp_skb_pcount(skb));</span><br><span class="line"></span><br><span class="line">		tp-&gt;segs_out += tcp_skb_pcount(skb);</span><br><span class="line">		<span class="comment">/* OK, its time to fill skb_shinfo(skb)-&gt;gso_&#123;segs|size&#125; */</span></span><br><span class="line">		skb_shinfo(skb)-&gt;gso_segs = tcp_skb_pcount(skb);</span><br><span class="line">		skb_shinfo(skb)-&gt;gso_size = tcp_skb_mss(skb);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Our usage of tstamp should remain private */</span></span><br><span class="line">		skb-&gt;tstamp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Cleanup our debris for IP stacks */</span></span><br><span class="line">		<span class="built_in">memset</span>(skb-&gt;cb, <span class="number">0</span>, max(<span class="keyword">sizeof</span>(struct inet_skb_parm),</span><br><span class="line">				       <span class="keyword">sizeof</span>(struct inet6_skb_parm)));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将当前数据发送给IP网络层</span></span><br><span class="line">		err = icsk-&gt;icsk_af_ops-&gt;queue_xmit(sk, skb, &amp;inet-&gt;cork.fl);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(err &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">			tcp_enter_cwr(sk);</span><br><span class="line">			err = net_xmit_eval(err);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!err &amp;&amp; oskb) &#123;</span><br><span class="line">			oskb-&gt;skb_mstamp = tp-&gt;tcp_mstamp;</span><br><span class="line">			tcp_rate_skb_sent(sk, oskb);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>那么, <code>queue_xmit</code>这个接口又是在何时赋值的? 实际在socket创建时初始化TCP部分时, 在<code>tcp_v4_init_sock</code>这个函数传入了网络层的接口:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// tcp_ipv4.c</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_v4_init_sock</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> = <span class="title">inet_csk</span>(<span class="title">sk</span>);</span></span><br><span class="line"></span><br><span class="line">		tcp_init_sock(sk);</span><br><span class="line"></span><br><span class="line">		icsk-&gt;icsk_af_ops = &amp;ipv4_specific;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock_af_ops</span> <span class="title">ipv4_specific</span> = &#123;</span></span><br><span class="line">	.queue_xmit	   = ip_queue_xmit,</span><br><span class="line">	.send_check	   = tcp_v4_send_check,</span><br><span class="line">	.rebuild_header	   = inet_sk_rebuild_header,</span><br><span class="line">	.sk_rx_dst_set	   = inet_sk_rx_dst_set,</span><br><span class="line">	.conn_request	   = tcp_v4_conn_request,</span><br><span class="line">	.syn_recv_sock	   = tcp_v4_syn_recv_sock,</span><br><span class="line">	.net_header_len	   = <span class="keyword">sizeof</span>(struct iphdr),</span><br><span class="line">	.setsockopt	   = ip_setsockopt,</span><br><span class="line">	.getsockopt	   = ip_getsockopt,</span><br><span class="line">	.addr2sockaddr	   = inet_csk_addr2sockaddr,</span><br><span class="line">	.sockaddr_len	   = <span class="keyword">sizeof</span>(struct sockaddr_in),</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">	.compat_setsockopt = compat_ip_setsockopt,</span><br><span class="line">	.compat_getsockopt = compat_ip_getsockopt,</span><br><span class="line">#endif</span><br><span class="line">	.mtu_reduced	   = tcp_v4_mtu_reduced,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(ipv4_specific);</span><br></pre></td></tr></table></figure>
<h3 id="IP网络层数据路由与寻址"><a href="#IP网络层数据路由与寻址" class="headerlink" title="IP网络层数据路由与寻址"></a><strong>IP网络层数据路由与寻址</strong></h3><p>IP层主要负责数据的路由,寻址, 同时还会对数据报文基于设定的iptables规则进行过滤. 函数<code>ip_queue_xmit</code>首先要做的就是找到需要发送数据的路由出口<code>struct rtable</code>, 如果没有找到路由,则直接返回<code>EHOSTUNREACH</code>的错误; 有了路由信息之后, 接着会构造IP协议头, 然后尝试通过本地的NETFILETER模块<code>ip_local_out</code>对包进行过滤处理. 下图是对应的流程简图:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/network_stack_ip_flow.png" alt="IP data flow"></p>
<blockquote>
<p>Linux内核路由实现原理的可以参考<a href="http://kernelspec.blogspot.com/2014/10/zoom-into-packet-routing-in-linux-kernel.html" target="_blank" rel="noopener">Linux路由实现原理</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ip_output.c</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ip_queue_xmit</span><span class="params">(struct sock *sk, struct sk_buff *skb, struct flowi *fl)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> = <span class="title">inet_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">sock_net</span>(<span class="title">sk</span>);</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ip_options_rcu</span> *<span class="title">inet_opt</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">flowi4</span> *<span class="title">fl4</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">		<span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Skip all of this if the packet is already routed,</span></span><br><span class="line"><span class="comment">		 * f.e. by something like SCTP.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		inet_opt = rcu_dereference(inet-&gt;inet_opt);</span><br><span class="line">		fl4 = &amp;fl-&gt;u.ip4;</span><br><span class="line">		rt = skb_rtable(skb);</span><br><span class="line">		<span class="keyword">if</span> (rt)</span><br><span class="line">			<span class="keyword">goto</span> packet_routed;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Make sure we can route this packet. */</span></span><br><span class="line">		rt = (struct rtable *)__sk_dst_check(sk, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (!rt) &#123;</span><br><span class="line">			__be32 daddr;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Use correct destination address if we have options. */</span></span><br><span class="line">			daddr = inet-&gt;inet_daddr;</span><br><span class="line">			<span class="keyword">if</span> (inet_opt &amp;&amp; inet_opt-&gt;opt.srr)</span><br><span class="line">				daddr = inet_opt-&gt;opt.faddr;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* If this fails, retransmit mechanism of transport layer will</span></span><br><span class="line"><span class="comment">			 * keep trying until route appears or the connection times</span></span><br><span class="line"><span class="comment">			 * itself out.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			rt = ip_route_output_ports(net, fl4, sk,</span><br><span class="line">						   daddr, inet-&gt;inet_saddr,</span><br><span class="line">						   inet-&gt;inet_dport,</span><br><span class="line">						   inet-&gt;inet_sport,</span><br><span class="line">						   sk-&gt;sk_protocol,</span><br><span class="line">						   RT_CONN_FLAGS(sk),</span><br><span class="line">						   sk-&gt;sk_bound_dev_if);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(rt))</span><br><span class="line">				<span class="keyword">goto</span> no_route;</span><br><span class="line">			sk_setup_caps(sk, &amp;rt-&gt;dst);</span><br><span class="line">		&#125;</span><br><span class="line">		skb_dst_set_noref(skb, &amp;rt-&gt;dst);</span><br><span class="line"></span><br><span class="line">	packet_routed:</span><br><span class="line">		<span class="keyword">if</span> (inet_opt &amp;&amp; inet_opt-&gt;opt.is_strictroute &amp;&amp; rt-&gt;rt_uses_gateway)</span><br><span class="line">			<span class="keyword">goto</span> no_route;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* OK, we know where to send it, allocate and build IP header. */</span></span><br><span class="line">		skb_push(skb, <span class="keyword">sizeof</span>(struct iphdr) + (inet_opt ? inet_opt-&gt;opt.optlen : <span class="number">0</span>));</span><br><span class="line">		skb_reset_network_header(skb);</span><br><span class="line">		iph = ip_hdr(skb);</span><br><span class="line">		*((__be16 *)iph) = htons((<span class="number">4</span> &lt;&lt; <span class="number">12</span>) | (<span class="number">5</span> &lt;&lt; <span class="number">8</span>) | (inet-&gt;tos &amp; <span class="number">0xff</span>));</span><br><span class="line">		<span class="keyword">if</span> (ip_dont_fragment(sk, &amp;rt-&gt;dst) &amp;&amp; !skb-&gt;ignore_df)</span><br><span class="line">			iph-&gt;frag_off = htons(IP_DF);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			iph-&gt;frag_off = <span class="number">0</span>;</span><br><span class="line">		iph-&gt;ttl      = ip_select_ttl(inet, &amp;rt-&gt;dst);</span><br><span class="line">		iph-&gt;protocol = sk-&gt;sk_protocol;</span><br><span class="line">		ip_copy_addrs(iph, fl4);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Transport layer set skb-&gt;h.foo itself. */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (inet_opt &amp;&amp; inet_opt-&gt;opt.optlen) &#123;</span><br><span class="line">			iph-&gt;ihl += inet_opt-&gt;opt.optlen &gt;&gt; <span class="number">2</span>;</span><br><span class="line">			ip_options_build(skb, &amp;inet_opt-&gt;opt, inet-&gt;inet_daddr, rt, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ip_select_ident_segs(net, skb, sk,</span><br><span class="line">				     skb_shinfo(skb)-&gt;gso_segs ?: <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* TODO : should we use skb-&gt;sk here instead of sk ? */</span></span><br><span class="line">		skb-&gt;priority = sk-&gt;sk_priority;</span><br><span class="line">		skb-&gt;mark = sk-&gt;sk_mark;</span><br><span class="line"></span><br><span class="line">		res = ip_local_out(net, sk, skb);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	no_route:</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		IP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES);</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		<span class="keyword">return</span> -EHOSTUNREACH;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>ip_local_out</code>首先要通过<code>LOCAL_OUT</code>的模块进行包过滤, 如果可以通过, 则会调直接通过<code>dst_out</code>将数据发送出去</p>
<blockquote>
<p>有关Linux Netfilter框架的介绍可以参考Wiki百科的文章<a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Netfilter</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ip_output.c</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ip_local_out</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">		err = __ip_local_out(net, sk, skb);</span><br><span class="line">		<span class="keyword">if</span> (likely(err == <span class="number">1</span>))</span><br><span class="line">			err = dst_output(net, sk, skb);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> __ip_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)</span><br><span class="line">      &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> = <span class="title">ip_hdr</span>(<span class="title">skb</span>);</span></span><br><span class="line"></span><br><span class="line">		iph-&gt;tot_len = htons(skb-&gt;len);</span><br><span class="line">		ip_send_check(iph);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* if egress device is enslaved to an L3 master device pass the</span></span><br><span class="line"><span class="comment">		 * skb to its handler for processing</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		skb = l3mdev_ip_out(sk, skb);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		skb-&gt;protocol = htons(ETH_P_IP);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// nf_hook如果返回1, 则表示包可以正常通过, 否则被拒绝, 无法发送出去</span></span><br><span class="line">		<span class="keyword">return</span> nf_hook(NFPROTO_IPV4, NF_INET_LOCAL_OUT,</span><br><span class="line">			       net, sk, skb, <span class="literal">NULL</span>, skb_dst(skb)-&gt;dev,</span><br><span class="line">			       dst_output);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>dst_output</code>实际调用了<code>skb-&gt;dst_entry</code>的<code>output</code>函数把包发出去而已, 那么, <code>struct dst_entry</code>这个接口又是在何时初始化的? 从<code>struct dst_entry</code>的定义来看, 我们知道这个是表示<code>struct skb_buff</code>的出去的路由信息, 因此可以推断出<code>dst_entry-&gt;output</code>这个接口应该是在路由查找的过程中赋值的.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// dst.h</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dst_output</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> skb_dst(skb)-&gt;output(net, sk, skb);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>继续看下<code>route.c</code>中的<code>rt_dst_alloc</code>函数, 可以看到这个<code>output</code>函数就是在路由初始化的时候根据目标地址的类型来赋值的, 如果是本地的数据, 则赋值为<code>ip_local_deliver</code>; 如果是是广播数据, 则是<code>ip_mc_output</code>, 其他的则为<code>ip_output</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// route.c</span></span><br><span class="line">	<span class="function">struct rtable *<span class="title">rt_dst_alloc</span><span class="params">(struct net_device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, u16 type,</span></span></span><br><span class="line"><span class="function"><span class="params">				    <span class="keyword">bool</span> nopolicy, <span class="keyword">bool</span> noxfrm, <span class="keyword">bool</span> will_cache)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span>;</span></span><br><span class="line"></span><br><span class="line">		rt = dst_alloc(&amp;ipv4_dst_ops, dev, <span class="number">1</span>, DST_OBSOLETE_FORCE_CHK,</span><br><span class="line">			       (will_cache ? <span class="number">0</span> : DST_HOST) |</span><br><span class="line">			       (nopolicy ? DST_NOPOLICY : <span class="number">0</span>) |</span><br><span class="line">			       (noxfrm ? DST_NOXFRM : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rt) &#123;</span><br><span class="line">			rt-&gt;rt_genid = rt_genid_ipv4(dev_net(dev));</span><br><span class="line">			rt-&gt;rt_flags = flags;</span><br><span class="line">			rt-&gt;rt_type = type;</span><br><span class="line">			rt-&gt;rt_is_input = <span class="number">0</span>;</span><br><span class="line">			rt-&gt;rt_iif = <span class="number">0</span>;</span><br><span class="line">			rt-&gt;rt_pmtu = <span class="number">0</span>;</span><br><span class="line">			rt-&gt;rt_mtu_locked = <span class="number">0</span>;</span><br><span class="line">			rt-&gt;rt_gateway = <span class="number">0</span>;</span><br><span class="line">			rt-&gt;rt_uses_gateway = <span class="number">0</span>;</span><br><span class="line">			rt-&gt;rt_table_id = <span class="number">0</span>;</span><br><span class="line">			INIT_LIST_HEAD(&amp;rt-&gt;rt_uncached);</span><br><span class="line"></span><br><span class="line">			rt-&gt;dst.output = ip_output;</span><br><span class="line">			<span class="keyword">if</span> (flags &amp; RTCF_LOCAL)</span><br><span class="line">				rt-&gt;dst.input = ip_local_deliver;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> rt;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>ip_output</code>在确定好链路层的协议<code>ETH_P_IP</code>后, 通过<code>NF_HOOK_COND</code>进入<code>POSTROUTING</code>的NETFILETER模块, 如果包可以正常通过过滤, 则会调用<code>ip_finish_output</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ip_output.c</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ip_output</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">skb_dst</span>(<span class="title">skb</span>)-&gt;<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">		IP_UPD_PO_STATS(net, IPSTATS_MIB_OUT, skb-&gt;len);</span><br><span class="line"></span><br><span class="line">		skb-&gt;dev = dev;</span><br><span class="line">		skb-&gt;protocol = htons(ETH_P_IP);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING,</span><br><span class="line">				    net, sk, skb, <span class="literal">NULL</span>, dev,</span><br><span class="line">				    ip_finish_output,</span><br><span class="line">				    !(IPCB(skb)-&gt;flags &amp; IPSKB_REROUTED));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>ip_finish_output</code>主要做两个事情:</p>
<ul>
<li>确认是否有<code>SNAT</code>, 如果有就进行调用<code>dst_output</code>进行处理(SNAT一般在POSTROUTING过滤阶段完成)</li>
<li>skb的长度是否超过了当前网络的MTU, 如果是则需要进行分片处理, 否则通过<code>ip_finish_output2</code>将包发送出去</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ip_output.c </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ip_finish_output</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mtu;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = BPF_CGROUP_RUN_PROG_INET_EGRESS(sk, skb);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_NETFILTER) &amp;&amp; defined(CONFIG_XFRM)</span></span><br><span class="line">	<span class="comment">/* Policy lookup after SNAT yielded a new policy */</span></span><br><span class="line">	<span class="keyword">if</span> (skb_dst(skb)-&gt;xfrm) &#123;</span><br><span class="line">		IPCB(skb)-&gt;flags |= IPSKB_REROUTED;</span><br><span class="line">		<span class="keyword">return</span> dst_output(net, sk, skb);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	mtu = ip_skb_dst_mtu(sk, skb);</span><br><span class="line">	<span class="keyword">if</span> (skb_is_gso(skb))</span><br><span class="line">		<span class="keyword">return</span> ip_finish_output_gso(net, sk, skb, mtu);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;len &gt; mtu || (IPCB(skb)-&gt;flags &amp; IPSKB_FRAG_PMTU))</span><br><span class="line">		<span class="keyword">return</span> ip_fragment(net, sk, skb, mtu, ip_finish_output2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ip_finish_output2(net, sk, skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到<code>ip_finish_output2</code>这里实际已经到了数据链路层了, 其主要的作用是找到数据需要发送的下一个<code>邻居</code>: 简单来说就是要根据下一跳的路由信息找到数据包发送下一个目标节点的MAC地址, 比如默认网关, 路由器等MAC地址; 对于IPv4协议来说, IP地址与MAC的对应关系是通过ARP(Address Resolution Protocol)来实现的; 而IPv6则是通过NDP(Neighbour Discovery Protocol)协议来实现的. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">// ip_output.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ip_finish_output2</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dst_entry</span> *<span class="title">dst</span> = <span class="title">skb_dst</span>(<span class="title">skb</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span> = (<span class="title">struct</span> <span class="title">rtable</span> *)<span class="title">dst</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">dst</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hh_len = LL_RESERVED_SPACE(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">neighbour</span> *<span class="title">neigh</span>;</span></span><br><span class="line">	u32 nexthop;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rt-&gt;rt_type == RTN_MULTICAST) &#123;</span><br><span class="line">		IP_UPD_PO_STATS(net, IPSTATS_MIB_OUTMCAST, skb-&gt;len);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rt-&gt;rt_type == RTN_BROADCAST)</span><br><span class="line">		IP_UPD_PO_STATS(net, IPSTATS_MIB_OUTBCAST, skb-&gt;len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Be paranoid, rather than too clever. */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(skb_headroom(skb) &lt; hh_len &amp;&amp; dev-&gt;header_ops)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb2</span>;</span></span><br><span class="line"></span><br><span class="line">		skb2 = skb_realloc_headroom(skb, LL_RESERVED_SPACE(dev));</span><br><span class="line">		<span class="keyword">if</span> (!skb2) &#123;</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;sk)</span><br><span class="line">			skb_set_owner_w(skb2, skb-&gt;sk);</span><br><span class="line">		consume_skb(skb);</span><br><span class="line">		skb = skb2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lwtunnel_xmit_redirect(dst-&gt;lwtstate)) &#123;</span><br><span class="line">		<span class="keyword">int</span> res = lwtunnel_xmit(skb);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (res &lt; <span class="number">0</span> || res == LWTUNNEL_XMIT_DONE)</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock_bh();</span><br><span class="line">	<span class="comment">// 通过nexthop来找到对应的neighbour, 如果没有则创建一个新的, 并发起ARP请求</span></span><br><span class="line">	nexthop = (__force u32) rt_nexthop(rt, ip_hdr(skb)-&gt;daddr);</span><br><span class="line">	neigh = __ipv4_neigh_lookup_noref(dev, nexthop);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!neigh))</span><br><span class="line">		neigh = __neigh_create(&amp;arp_tbl, &amp;nexthop, dev, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(neigh)) &#123;</span><br><span class="line">		<span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">		sock_confirm_neigh(skb, neigh);</span><br><span class="line">		res = neigh_output(neigh, skb);</span><br><span class="line"></span><br><span class="line">		rcu_read_unlock_bh();</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_read_unlock_bh();</span><br><span class="line"></span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>struct neighbour</code>已经做了ARP解析, 并且是可用状态, 则通过<code>neigh_hh_output</code>直接把数据发送给对应的网络设备, 如果不可用, 则先要通过<code>n-&gt;output</code>执行ARP解析后才能发送. 有关<code>struct neighbour</code>中的接口初始化可以参考<code>arp.c</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// neighbour.h</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">neigh_output</span><span class="params">(struct neighbour *n, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">hh_cache</span> *<span class="title">hh</span> = &amp;<span class="title">n</span>-&gt;<span class="title">hh</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((n-&gt;nud_state &amp; NUD_CONNECTED) &amp;&amp; hh-&gt;hh_len)</span><br><span class="line">			<span class="keyword">return</span> neigh_hh_output(hh, skb);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> n-&gt;output(n, skb);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>neigh_hh_output</code>只是把网络设备的MAC地址保存到链路层协议头上, 然后通过<code>dev_queue_xmit</code>把数据发送给驱动层. 至此数据还需要经过队列优先级(QoS)处理, 然后就可以通过驱动发送出去了.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// neighbour.h</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">neigh_hh_output</span><span class="params">(<span class="keyword">const</span> struct hh_cache *hh, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> hh_alen = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> seq;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> hh_len;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			seq = read_seqbegin(&amp;hh-&gt;hh_lock);</span><br><span class="line">			hh_len = READ_ONCE(hh-&gt;hh_len);</span><br><span class="line">			<span class="keyword">if</span> (likely(hh_len &lt;= HH_DATA_MOD)) &#123;</span><br><span class="line">				hh_alen = HH_DATA_MOD;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* skb_push() would proceed silently if we have room for</span></span><br><span class="line"><span class="comment">				 * the unaligned size but not for the aligned size:</span></span><br><span class="line"><span class="comment">				 * check headroom explicitly.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">if</span> (likely(skb_headroom(skb) &gt;= HH_DATA_MOD)) &#123;</span><br><span class="line">					<span class="comment">/* this is inlined by gcc */</span></span><br><span class="line">					<span class="built_in">memcpy</span>(skb-&gt;data - HH_DATA_MOD, hh-&gt;hh_data,</span><br><span class="line">					       HH_DATA_MOD);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				hh_alen = HH_DATA_ALIGN(hh_len);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (likely(skb_headroom(skb) &gt;= hh_alen)) &#123;</span><br><span class="line">					<span class="built_in">memcpy</span>(skb-&gt;data - hh_alen, hh-&gt;hh_data,</span><br><span class="line">					       hh_alen);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (read_seqretry(&amp;hh-&gt;hh_lock, seq));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(skb_headroom(skb) &lt; hh_alen)) &#123;</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			<span class="keyword">return</span> NET_XMIT_DROP;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		__skb_push(skb, hh_len);</span><br><span class="line">		<span class="keyword">return</span> dev_queue_xmit(skb);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最后的旅程-优先级队列QoS与软中断"><a href="#最后的旅程-优先级队列QoS与软中断" class="headerlink" title="最后的旅程: 优先级队列QoS与软中断"></a><strong>最后的旅程: 优先级队列QoS与软中断</strong></h3><p>发送的数据包在达到网络设备之前, 还需要经过一个优先级队列进行流量控制与调度, 然后再通过触发软中断才会最终发送出去.优先级队列的作用是对发送数据包进行流量整形, 调度, 确保数据包可以更优先地发送出去. 有关Linux中的流量控制可以参考:</p>
<ul>
<li><a href="https://tldp.org/HOWTO/Traffic-Control-HOWTO/overview.html" target="_blank" rel="noopener">Linux Traffic Control -HOWTO</a></li>
<li><a href="https://netbeez.net/blog/how-to-use-the-linux-traffic-control/" target="_blank" rel="noopener">How to use Linux Traffic Contro</a></li>
</ul>
<p>Linux内核默认使用了pfifo队列来实现流量控制, pfifo类似与fifo(先进先出), 只是在此基础上把队列根据数据包的优先级(这个优先级就是根据IP协议头中的TOS映射过来的)将包分别放到三个优先级队列中, 然后再根据对应的优先级进行出队的操作. </p>
<p>函数<code>dev_queue_xmit</code>实际调用了另外一个函数<code>__dev_queue_xmit</code>进行数据的发送; <code>__dev_queue_xmit</code>首先确认<code>Qdisc</code>是否有定义了入队<code>enqueue</code>函数, 如果有定义则通过<code>__dev_xmit_skb</code>压入队列；如果没有, 则直接发送到网络设备驱动<code>dev_hard_start_xmit</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">// dev.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dev_queue_xmit</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __dev_queue_xmit(skb, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __dev_queue_xmit(struct sk_buff *skb, <span class="keyword">void</span> *accel_priv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">skb</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">netdev_queue</span> *<span class="title">txq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span> *<span class="title">q</span>;</span></span><br><span class="line">	<span class="keyword">int</span> rc = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	skb_reset_mac_header(skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(skb_shinfo(skb)-&gt;tx_flags &amp; SKBTX_SCHED_TSTAMP))</span><br><span class="line">		__skb_tstamp_tx(skb, <span class="literal">NULL</span>, skb-&gt;sk, SCM_TSTAMP_SCHED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Disable soft irqs for various locks below. Also</span></span><br><span class="line"><span class="comment">	 * stops preemption for RCU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rcu_read_lock_bh();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 更新skbuff的优先级(根据cgroup定义的优先级)</span></span><br><span class="line">	skb_update_prio(skb);</span><br><span class="line"></span><br><span class="line">	qdisc_pkt_len_init(skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If device/qdisc don't need skb-&gt;dst, release it right now while</span></span><br><span class="line"><span class="comment">	 * its hot in this cpu cache.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;priv_flags &amp; IFF_XMIT_DST_RELEASE)</span><br><span class="line">		skb_dst_drop(skb);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		skb_dst_force(skb);</span><br><span class="line"></span><br><span class="line">	txq = netdev_pick_tx(dev, skb, accel_priv);</span><br><span class="line">	q = rcu_dereference_bh(txq-&gt;qdisc);</span><br><span class="line"></span><br><span class="line">	trace_net_dev_queue(skb);</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;enqueue) &#123;</span><br><span class="line">		rc = __dev_xmit_skb(skb, q, dev, txq);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The device has no queue. Common case for software devices:</span></span><br><span class="line"><span class="comment">	 * loopback, all the sorts of tunnels...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 * Really, it is unlikely that netif_tx_lock protection is necessary</span></span><br><span class="line"><span class="comment">	 * here.  (f.e. loopback and IP tunnels are clean ignoring statistics</span></span><br><span class="line"><span class="comment">	 * counters.)</span></span><br><span class="line"><span class="comment">	 * However, it is possible, that they rely on protection</span></span><br><span class="line"><span class="comment">	 * made by us here.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 * Check this and shot the lock. It is not prone from deadlocks.</span></span><br><span class="line"><span class="comment">	 *Either shot noqueue qdisc, it is even simpler 8)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;flags &amp; IFF_UP) &#123;</span><br><span class="line">		<span class="keyword">int</span> cpu = smp_processor_id(); <span class="comment">/* ok because BHs are off */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (txq-&gt;xmit_lock_owner != cpu) &#123;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(__this_cpu_read(xmit_recursion) &gt;</span><br><span class="line">				     XMIT_RECURSION_LIMIT))</span><br><span class="line">				<span class="keyword">goto</span> recursion_alert;</span><br><span class="line"></span><br><span class="line">			skb = validate_xmit_skb(skb, dev);</span><br><span class="line">			<span class="keyword">if</span> (!skb)</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">			HARD_TX_LOCK(dev, txq, cpu);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!netif_xmit_stopped(txq)) &#123;</span><br><span class="line">				__this_cpu_inc(xmit_recursion);</span><br><span class="line">				skb = dev_hard_start_xmit(skb, dev, txq, &amp;rc);</span><br><span class="line">				__this_cpu_dec(xmit_recursion);</span><br><span class="line">				<span class="keyword">if</span> (dev_xmit_complete(rc)) &#123;</span><br><span class="line">					HARD_TX_UNLOCK(dev, txq);</span><br><span class="line">					<span class="keyword">goto</span> out;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			HARD_TX_UNLOCK(dev, txq);</span><br><span class="line">			net_crit_ratelimited(<span class="string">"Virtual device %s asks to queue packet!\n"</span>,</span><br><span class="line">					     dev-&gt;name);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Recursion is detected! It is possible,</span></span><br><span class="line"><span class="comment">			 * unfortunately</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">recursion_alert:</span><br><span class="line">			net_crit_ratelimited(<span class="string">"Dead loop on virtual device %s, fix it urgently!\n"</span>,</span><br><span class="line">					     dev-&gt;name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rc = -ENETDOWN;</span><br><span class="line">	rcu_read_unlock_bh();</span><br><span class="line"></span><br><span class="line">	atomic_long_inc(&amp;dev-&gt;tx_dropped);</span><br><span class="line">	kfree_skb_list(skb);</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">out:</span><br><span class="line">	rcu_read_unlock_bh();</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__dev_xmit_skb</code>根据队列的状态来执行数据的发送:</p>
<ul>
<li>如果队列处于非激活状态, 比如网卡处于down状态, 则直接丢弃数据</li>
<li>如果当前队列为空且没有在执行状态, 则选择直接发送数据到网卡驱动</li>
<li>否则先将数据入队, 然后执行<code>__qdisc_run</code>, 把数据从队列中一一取出, 触发软中断数据发送流程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// dev.c</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,</span><br><span class="line">					 struct net_device *dev,</span><br><span class="line">					 struct netdev_queue *txq)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">spinlock_t</span> *root_lock = qdisc_lock(q);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">to_free</span> = <span class="title">NULL</span>;</span></span><br><span class="line">		<span class="keyword">bool</span> contended;</span><br><span class="line">		<span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">		qdisc_calculate_pkt_len(skb, q);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Heuristic to force contended enqueues to serialize on a</span></span><br><span class="line"><span class="comment">		 * separate lock before trying to get qdisc main lock.</span></span><br><span class="line"><span class="comment">		 * This permits qdisc-&gt;running owner to get the lock more</span></span><br><span class="line"><span class="comment">		 * often and dequeue packets faster.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		contended = qdisc_is_running(q);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(contended))</span><br><span class="line">			spin_lock(&amp;q-&gt;busylock);</span><br><span class="line"></span><br><span class="line">		spin_lock(root_lock);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(test_bit(__QDISC_STATE_DEACTIVATED, &amp;q-&gt;state))) &#123;</span><br><span class="line">			__qdisc_drop(skb, &amp;to_free);</span><br><span class="line">			rc = NET_XMIT_DROP;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((q-&gt;flags &amp; TCQ_F_CAN_BYPASS) &amp;&amp; !qdisc_qlen(q) &amp;&amp;</span><br><span class="line">			   qdisc_run_begin(q)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * This is a work-conserving queue; there are no old skbs</span></span><br><span class="line"><span class="comment">			 * waiting to be sent out; and the qdisc is not running -</span></span><br><span class="line"><span class="comment">			 * xmit the skb directly.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"></span><br><span class="line">			qdisc_bstats_update(q, skb);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (sch_direct_xmit(skb, q, dev, txq, root_lock, <span class="literal">true</span>)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (unlikely(contended)) &#123;</span><br><span class="line">					spin_unlock(&amp;q-&gt;busylock);</span><br><span class="line">					contended = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				__qdisc_run(q);</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">				qdisc_run_end(q);</span><br><span class="line"></span><br><span class="line">			rc = NET_XMIT_SUCCESS;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			rc = q-&gt;enqueue(skb, q, &amp;to_free) &amp; NET_XMIT_MASK;</span><br><span class="line">			<span class="keyword">if</span> (qdisc_run_begin(q)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (unlikely(contended)) &#123;</span><br><span class="line">					spin_unlock(&amp;q-&gt;busylock);</span><br><span class="line">					contended = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				__qdisc_run(q);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		spin_unlock(root_lock);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(to_free))</span><br><span class="line">			kfree_skb_list(to_free);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(contended))</span><br><span class="line">			spin_unlock(&amp;q-&gt;busylock);</span><br><span class="line">		<span class="keyword">return</span> rc;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>__qdisc_run</code>需要做的就是不断从优先级队列中取出包, 然后通过<code>sch_direct_xmit</code>直接发送到驱动(这里不再贴出具体代码, 有兴趣的可以参考<code>dev.c</code>/<code>sch_generic.c</code>两个文件的实现. 如果发送的数据达到了设备设定的配额(Linux默认网卡数据发送配额为64), 或者其他CPU被其他优先级高的任务抢占后, 则调用<code>__netif_schedule</code>执行软中断任务.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// sch_generic.c</span></span><br><span class="line">	<span class="keyword">void</span> __qdisc_run(struct Qdisc *q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> quota = dev_tx_weight;</span><br><span class="line">		<span class="keyword">int</span> packets;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (qdisc_restart(q, &amp;packets)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Ordered by possible occurrence: Postpone processing if</span></span><br><span class="line"><span class="comment">			 * 1. we've exceeded packet quota</span></span><br><span class="line"><span class="comment">			 * 2. another process needs the CPU;</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			quota -= packets;</span><br><span class="line">			<span class="keyword">if</span> (quota &lt;= <span class="number">0</span> || need_resched()) &#123;</span><br><span class="line">				__netif_schedule(q);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		qdisc_run_end(q);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>__netif_schedule</code>首先检查到优先级队列<code>Qdisc</code>是否处于非调度状态, 然后就通过<code>__netif_reschedule</code>执行软中触发调度:</p>
<ul>
<li>保存并禁止本地中断<code>local_irq_save</code></li>
<li>获取当前CPU的<code>struct softnet_data</code>数据, 把需要调度的<code>Qdisc</code>优先级队列放到发送队列末尾</li>
<li>发送一个软中断信号<code>raise_softirq_irqoff(NET_TX_SOFTIRQ)</code>, 恢复本地中断</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// dev.c</span></span><br><span class="line">	<span class="keyword">void</span> __netif_schedule(struct Qdisc *q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!test_and_set_bit(__QDISC_STATE_SCHED, &amp;q-&gt;state))</span><br><span class="line">			__netif_reschedule(q);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> __netif_reschedule(struct Qdisc *q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">		local_irq_save(flags);</span><br><span class="line">		sd = this_cpu_ptr(&amp;softnet_data);</span><br><span class="line">		q-&gt;next_sched = <span class="literal">NULL</span>;</span><br><span class="line">		*sd-&gt;output_queue_tailp = q;</span><br><span class="line">		sd-&gt;output_queue_tailp = &amp;q-&gt;next_sched;</span><br><span class="line">		raise_softirq_irqoff(NET_TX_SOFTIRQ);</span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>软中断的初始化在内核启动的时候初始化完成的, 可以参考<code>dev.c</code>; <code>net_tx_action</code>对应发送软中断的处理函数, 其主要做两件事情:</p>
<ul>
<li>检查发送完成队列<code>completion_queue</code>是否有需要释放的<code>skb_buf</code>, 如果有就释放掉对应的内存</li>
<li>从本地CPU<code>struct softnet_data</code>中获取对应的发送队列<code>output_queue</code>数据, 不断通过<code>qdisc_run</code>发送到驱动中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// dev.c</span></span><br><span class="line">	<span class="keyword">static</span> __<span class="function">latent_entropy <span class="keyword">void</span> <span class="title">net_tx_action</span><span class="params">(struct softirq_action *h)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> = <span class="title">this_cpu_ptr</span>(&amp;<span class="title">softnet_data</span>);</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (sd-&gt;completion_queue) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">clist</span>;</span></span><br><span class="line"></span><br><span class="line">			local_irq_disable();</span><br><span class="line">			clist = sd-&gt;completion_queue;</span><br><span class="line">			sd-&gt;completion_queue = <span class="literal">NULL</span>;</span><br><span class="line">			local_irq_enable();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (clist) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> = <span class="title">clist</span>;</span></span><br><span class="line"></span><br><span class="line">				clist = clist-&gt;next;</span><br><span class="line"></span><br><span class="line">				WARN_ON(refcount_read(&amp;skb-&gt;users));</span><br><span class="line">				<span class="keyword">if</span> (likely(get_kfree_skb_cb(skb)-&gt;reason == SKB_REASON_CONSUMED))</span><br><span class="line">					trace_consume_skb(skb);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					trace_kfree_skb(skb, net_tx_action);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (skb-&gt;fclone != SKB_FCLONE_UNAVAILABLE)</span><br><span class="line">					__kfree_skb(skb);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					__kfree_skb_defer(skb);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			__kfree_skb_flush();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (sd-&gt;output_queue) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span> *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line">			local_irq_disable();</span><br><span class="line">			head = sd-&gt;output_queue;</span><br><span class="line">			sd-&gt;output_queue = <span class="literal">NULL</span>;</span><br><span class="line">			sd-&gt;output_queue_tailp = &amp;sd-&gt;output_queue;</span><br><span class="line">			local_irq_enable();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (head) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">Qdisc</span> *<span class="title">q</span> = <span class="title">head</span>;</span></span><br><span class="line">				<span class="keyword">spinlock_t</span> *root_lock;</span><br><span class="line"></span><br><span class="line">				head = head-&gt;next_sched;</span><br><span class="line"></span><br><span class="line">				root_lock = qdisc_lock(q);</span><br><span class="line">				spin_lock(root_lock);</span><br><span class="line">				<span class="comment">/* We need to make sure head-&gt;next_sched is read</span></span><br><span class="line"><span class="comment">				 * before clearing __QDISC_STATE_SCHED</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				smp_mb__before_atomic();</span><br><span class="line">				clear_bit(__QDISC_STATE_SCHED, &amp;q-&gt;state);</span><br><span class="line">				qdisc_run(q);</span><br><span class="line">				spin_unlock(root_lock);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>至此, 数据的发送就完成了. 感兴趣的话,可以选择某个特定设备的驱动看下驱动层是如何处理数据的发送的. 相信跟着Linux源代码流程, 我们对Linux内核协议栈也有了大致的了解, 如果想要深入某个模块进行了解, 读源码的同时结合相关协议的文档, 相信会有更多的收获.</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="http://www.embeddedlinux.org.cn/linux_net/" target="_blank" rel="noopener">Understanding Linux Network Internals</a></li>
<li><a href="https://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html" target="_blank" rel="noopener">里边有很多源码的分析, 值得参考</a></li>
<li><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/" target="_blank" rel="noopener">Linux 内核数据发送流程解析</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 网络协议 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络协议栈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一个ADB无法识别设备的问题]]></title>
      <url>http://sniffer.site/2021/02/20/ADB%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
      <content type="html"><![CDATA[<p>这两天隔壁部门的同事反馈说新项目上, 车机(Android系统)上挂载的USB外设(一个可以上网的TBOX设备)无法通过ADB(Android Debug Bridge)进行连接. 心里有点纳闷, USB不都识别到了吗, 上次也把ADB相关的客户端都移植过去了, 为啥还会识别不到设备了? 只得从头开始理下ADB相关的代码与逻辑.先来看看ADB的基本原理.</p>
<p>ADB(全称Android Debug Bridge)是Android上用途十分广泛的调试工具, 可用于与开发设备进行连接;ADB命令既可以用来主机与设备之间传输文件, 也可以通过SHELL命令对设备进行操作. 如下所示, 是ADB的一个工作原理图:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/how_adb_works.png" alt="How ADB works"></p>
<p>可以看到, ADB主要有3个部分组成:</p>
<ul>
<li>ADB clients: 客户端程序, 运行在开发设备上, 用于发送指令, 用户可以通过adb shell/devices来激活客户端</li>
<li>ADBD: 守护进程, 作为后台进程运行在调试设备上, 一般在系统启动的时候加载</li>
<li>ADB server: 服务端进程, 运行在开发设备上, 负责ADBD与客户端进程的通讯, 由ADB客户端负责加载</li>
</ul>
<p>对于模拟设备, ADB server与ADB一般是通过TCP/IP协议建立的通讯链接; 对于外接的USB调试设备, 则可以选择通过USB/TCP两种方式进行连接. 一般来说, 一个ADB指令的执行需要经过如下几个步骤:</p>
<ul>
<li>用户输入<code>adb shell/devices</code>时, 会判断是否有<code>ADB server</code>进程存在,如果没有就启动一个进程</li>
<li>ADB server通过TCP 5037端口监听来自客户进程请求, 在初始化的时候, 如果使用的是TCP连接模式, ADB Server会通过扫面一个固定的TCP端口范围<code>5555 ~ 5585</code>中的奇数号来尝试连接到目标调试设备;如果是USB连接模式, 则会通过扫描当前已连接的USB设备, 从中找出用于ADB通讯的接口用于通讯. 不指定连接模式, 则会扫描所有的设备</li>
<li>ADB server找到设备并建立连接后, 就可以把来自客户端的请求发送给调试设备的ADBD进程了, 由ADBD来执行用户的请求并返回结果</li>
</ul>
<p>这里就从源码的角度具体分析下ADB的具体执行流程(主要以USB连接模式为例). 在分析具体的流程之前, 不妨来简单看看Android ADB的代码结构. 以Android Pie代码为例:</p>
<ul>
<li>ADB的源码位于<code>/system/core/adb</code>, 客户端代码位于<code>client</code>目录, 而ADBD的代码则位于<code>daemon</code>目录</li>
<li>根目录下的代码包含了客户端/服务端以及守护进程的共用的逻辑; 查看共用代码部分时, 定义了<code>ADB_HOST</code>宏的表示是需要在HOST端执行的代码逻辑(包括客户端以及服务端), 其他则是调试设备上ADBD的逻辑.</li>
</ul>
<h2 id="ADB客户端-服务进程的启动"><a href="#ADB客户端-服务进程的启动" class="headerlink" title="ADB客户端/服务进程的启动"></a><strong>ADB客户端/服务进程的启动</strong></h2><p>查看<code>client</code>下面的代码, 有个main函数, 就是输入<code>adb shell//devices</code>执行的入口:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    adb_trace_init(argv);</span><br><span class="line">    <span class="keyword">return</span> adb_commandline(argc - <span class="number">1</span>, <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>**&gt;(argv + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>adb_commandline</code>最终会调用函数<code>adb_connect</code>尝试连接服务进程, 如果当前没有服务进程,则启动一个新的进程, 然后读取服务端返回的结果, 直接看下<code>adb_connect</code> 的逻辑:</p>
<ul>
<li>首先尝试连接服务端进程, 没有, 则通过<code>launch_server</code>启动一个新的进程</li>
<li>启动完成后, 通过<code>_adb_connect</code>连接到服务进程</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">adb_connect</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; service, <span class="built_in">std</span>::<span class="built_in">string</span>* error)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// first query the adb server's version</span></span><br><span class="line">    <span class="keyword">int</span> fd = _adb_connect(<span class="string">"host:version"</span>, error);</span><br><span class="line"></span><br><span class="line">    D(<span class="string">"adb_connect: service %s"</span>, service.c_str());</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-2</span> &amp;&amp; !is_local_socket_spec(__adb_server_socket_spec)) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"* cannot start server on remote host\n"</span>);</span><br><span class="line">	<span class="comment">// error is the original network connection error</span></span><br><span class="line">	<span class="keyword">return</span> fd;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fd == <span class="number">-2</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"* daemon not running; starting now at %s\n"</span>, __adb_server_socket_spec);</span><br><span class="line">    start_server:</span><br><span class="line">	<span class="keyword">if</span> (launch_server(__adb_server_socket_spec)) &#123;</span><br><span class="line">	    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"* failed to start daemon\n"</span>);</span><br><span class="line">	    <span class="comment">// launch_server() has already printed detailed error info, so just</span></span><br><span class="line">	    <span class="comment">// return a generic error string about the overall adb_connect()</span></span><br><span class="line">	    <span class="comment">// that the caller requested.</span></span><br><span class="line">	    *error = <span class="string">"cannot connect to daemon"</span>;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"* daemon started successfully\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// The server will wait until it detects all of its connected devices before acking.</span></span><br><span class="line">	<span class="comment">// Fall through to _adb_connect.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// If a server is already running, check its version matches.</span></span><br><span class="line">	<span class="keyword">int</span> version = ADB_SERVER_VERSION - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we have a file descriptor, then parse version result.</span></span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="built_in">std</span>::<span class="built_in">string</span> version_string;</span><br><span class="line">	    <span class="keyword">if</span> (!ReadProtocolString(fd, &amp;version_string, error)) &#123;</span><br><span class="line">	        adb_close(fd);</span><br><span class="line">	        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    ReadOrderlyShutdown(fd);</span><br><span class="line">	    adb_close(fd);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(&amp;version_string[<span class="number">0</span>], <span class="string">"%04x"</span>, &amp;version) != <span class="number">1</span>) &#123;</span><br><span class="line">	        *error = android::base::StringPrintf(<span class="string">"cannot parse version string: %s"</span>,</span><br><span class="line">	                                             version_string.c_str());</span><br><span class="line">	        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="comment">// If fd is -1 check for "unknown host service" which would</span></span><br><span class="line">	    <span class="comment">// indicate a version of adb that does not support the</span></span><br><span class="line">	    <span class="comment">// version command, in which case we should fall-through to kill it.</span></span><br><span class="line">	    <span class="keyword">if</span> (*error != <span class="string">"unknown host service"</span>) &#123;</span><br><span class="line">	        <span class="keyword">return</span> fd;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (version != ADB_SERVER_VERSION) &#123;</span><br><span class="line">	    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"adb server version (%d) doesn't match this client (%d); killing...\n"</span>,</span><br><span class="line">	            version, ADB_SERVER_VERSION);</span><br><span class="line">	    adb_kill_server();</span><br><span class="line">	    <span class="keyword">goto</span> start_server;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the command is start-server, we are done.</span></span><br><span class="line">    <span class="keyword">if</span> (service == <span class="string">"host:start-server"</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = _adb_connect(service, error);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">	D(<span class="string">"_adb_connect error: %s"</span>, error-&gt;c_str());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(fd == <span class="number">-2</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"* daemon still not running\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    D(<span class="string">"adb_connect: return fd %d"</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看<code>launch_server</code> linux部分的实现, 其实际的入口与客户端的函数入口是一样的, 只是参数不一样而已: 服务端启动完成之后, 发送<code>OK</code>的状态给客户端, 告知其启动完成.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (pipe(fd)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pipe failed in launch_server, errno: %d\n"</span>, errno);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> path = android::base::GetExecutablePath();</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// child side of the fork</span></span><br><span class="line"></span><br><span class="line">    adb_close(fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> reply_fd[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(reply_fd, <span class="keyword">sizeof</span>(reply_fd), <span class="string">"%d"</span>, fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    <span class="keyword">int</span> result = execl(path.c_str(), <span class="string">"adb"</span>, <span class="string">"-L"</span>, socket_spec.c_str(), <span class="string">"fork-server"</span>, <span class="string">"server"</span>,</span><br><span class="line">                       <span class="string">"--reply-fd"</span>, reply_fd, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// this should not return</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"adb: execl returned %d: %s\n"</span>, result, strerror(errno));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// parent side of the fork</span></span><br><span class="line">    <span class="keyword">char</span> temp[<span class="number">3</span>] = &#123;&#125;;</span><br><span class="line">    <span class="comment">// wait for the "OK\n" message</span></span><br><span class="line">    adb_close(fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> ret = adb_read(fd[<span class="number">0</span>], temp, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> saved_errno = errno;</span><br><span class="line">    adb_close(fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"could not read ok from ADB Server, errno = %d\n"</span>, saved_errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">3</span> || temp[<span class="number">0</span>] != <span class="string">'O'</span> || temp[<span class="number">1</span>] != <span class="string">'K'</span> || temp[<span class="number">2</span>] != <span class="string">'\n'</span>) &#123;</span><br><span class="line">        ReportServerStartupFailure(pid);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设备的识别与扫描"><a href="#设备的识别与扫描" class="headerlink" title="设备的识别与扫描"></a><strong>设备的识别与扫描</strong></h2><p>我们重点来看下ADB SERVER是如何扫描设备的. 执行服务端进程后, 调用<code>adb_server_main</code>函数来执行服务端的逻辑:</p>
<ul>
<li><code>usb_init</code>扫描USB设备</li>
<li><code>adb_wait_for_device_initialization</code>等待扫描完成后, 发送<code>OK</code>给客户端进程</li>
<li><code>fdevent_loop</code> 进入循环, 等待来自客户端的请求</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">adb_server_main</span><span class="params">(<span class="keyword">int</span> is_daemon, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; socket_spec, <span class="keyword">int</span> ack_reply_fd)</span> </span>&#123;</span><br><span class="line">    signal(SIGINT, [](<span class="keyword">int</span>) &#123;</span><br><span class="line">        fdevent_run_on_main_thread([]() &#123; <span class="built_in">exit</span>(<span class="number">0</span>); &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* leak = getenv(<span class="string">"ADB_LEAK"</span>);</span><br><span class="line">    <span class="keyword">if</span> (leak &amp;&amp; <span class="built_in">strcmp</span>(leak, <span class="string">"1"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        intentionally_leak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_transport_registration();</span><br><span class="line">    init_mdns_transport_discovery();</span><br><span class="line"></span><br><span class="line">    usb_init();</span><br><span class="line">    local_init(DEFAULT_ADB_LOCAL_TRANSPORT_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we told a previous adb server to quit because of version mismatch, we can get to this</span></span><br><span class="line">    <span class="comment">// point before it's finished exiting. Retry for a while to give it some time.</span></span><br><span class="line">    <span class="keyword">while</span> (install_listener(socket_spec, <span class="string">"*smartsocket*"</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, &amp;error) !=</span><br><span class="line">           INSTALL_STATUS_OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::chrono::steady_clock::now() - start &gt; <span class="number">0.5</span>s) &#123;</span><br><span class="line">            fatal(<span class="string">"could not install *smartsocket* listener: %s"</span>, error.c_str());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">100</span>ms);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    adb_auth_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_daemon) &#123;</span><br><span class="line">        <span class="comment">// Start a new session for the daemon. Do this here instead of after the fork so</span></span><br><span class="line">        <span class="comment">// that a ctrl-c between the "starting server" and "done starting server" messages</span></span><br><span class="line">        <span class="comment">// gets a chance to terminate the server.</span></span><br><span class="line">        <span class="comment">// setsid will fail with EPERM if it's already been a lead process of new session.</span></span><br><span class="line">        <span class="comment">// Ignore such error.</span></span><br><span class="line">        <span class="keyword">if</span> (setsid() == <span class="number">-1</span> &amp;&amp; errno != EPERM) &#123;</span><br><span class="line">            fatal(<span class="string">"setsid() failed: %s"</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait for the USB scan to complete before notifying the parent that we're up.</span></span><br><span class="line">        <span class="comment">// We need to perform this in a thread, because we would otherwise block the event loop.</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="function">thread <span class="title">notify_thread</span><span class="params">([ack_reply_fd]() &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            adb_wait_for_device_initialization();</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">// Any error output written to stderr now goes to adb.log. We could</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">// keep around a copy of the stderr fd and use that to write any errors</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">// encountered by the following code, but that is probably overkill.</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">// TODO(danalbert): Can't use SendOkay because we're sending "OK\n", not</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">// "OKAY".</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">if</span> (!android::base::WriteStringToFd(<span class="string">"OK\n"</span>, ack_reply_fd)) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                fatal_errno(<span class="string">"error writing ACK to fd %d"</span>, ack_reply_fd);</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            unix_close(ack_reply_fd);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span></span>;</span><br><span class="line">        notify_thread.detach();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    D(<span class="string">"Event loop starting"</span>);</span><br><span class="line">    fdevent_loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里着重看下USB设备的扫描<code>usb_init</code>&lt;<code>usb_dispatch.cpp</code>&gt;, 对ADB客户端/服务端都不是使用<code>libusb</code>来识别USB设备, 直接看<code>linux</code>下的实现<code>usb_linux.cpp</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// usb_dispatch.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usb_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (should_use_libusb()) &#123;</span><br><span class="line">	LOG(DEBUG) &lt;&lt; <span class="string">"using libusb backend"</span>;</span><br><span class="line">	libusb::usb_init();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	LOG(DEBUG) &lt;&lt; <span class="string">"using native backend"</span>;</span><br><span class="line">	native::usb_init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>usb_init</code>主要是启动一个设备查找的线程, 用于不断识别接入的USB设备而已. 到这里, 我们大概知道了如何查找到USB设备并且读取设备的配置: 通过遍历<code>/dev/bus/usb</code>下面的节点, 即对应USB设备的字符设备, USB设备的信息就可以通过这些字符设备读取到. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">device_poll_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    adb_thread_setname(<span class="string">"device poll"</span>);</span><br><span class="line">    D(<span class="string">"Created device thread"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Use inotify.</span></span><br><span class="line">	find_usb_device(<span class="string">"/dev/bus/usb"</span>, register_device);</span><br><span class="line">	kick_disconnected_devices();</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(<span class="number">1</span>s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usb_linux.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usb_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">actions</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;actions, <span class="number">0</span>, <span class="keyword">sizeof</span>(actions));</span><br><span class="line">    sigemptyset(&amp;actions.sa_mask);</span><br><span class="line">    actions.sa_flags = <span class="number">0</span>;</span><br><span class="line">    actions.sa_handler = [](<span class="keyword">int</span>) &#123;&#125;;</span><br><span class="line">    sigaction(SIGALRM, &amp;actions, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::thread(device_poll_thread).detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于ADB设备节点来说, 其有特殊的类别以及协议, 因此需要通过<code>is_adb_interface</code>来过滤掉非ADB的设备.感兴趣的可以仔细看下<code>find_usb_device</code>这个函数看下具体的设备查找流程.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADB_CLASS 0xff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADB_SUBCLASS 0x42</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADB_PROTOCOL 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_adb_interface</span><span class="params">(<span class="keyword">int</span> usb_class, <span class="keyword">int</span> usb_subclass, <span class="keyword">int</span> usb_protocol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (usb_class == ADB_CLASS &amp;&amp; usb_subclass == ADB_SUBCLASS &amp;&amp; usb_protocol == ADB_PROTOCOL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="无法识别ADB设备的问题"><a href="#无法识别ADB设备的问题" class="headerlink" title="无法识别ADB设备的问题"></a><strong>无法识别ADB设备的问题</strong></h2><p>梳理了ADB的一些代码, 我们大致知道对于客户端来说,在USB模式下, 只是通过一个特定的USB设备节点来与调试设备通讯, 那么, 客户端找不到设备的原因就只有两个(如前所述, HOST端已经识别到了调试设备):</p>
<ul>
<li>客户端的配置有问题</li>
<li>调试设备的ADB配置有问题</li>
</ul>
<p>可问题在于, 同样的设备在PC上是可以正常识别到并使用ADB的, 那么可以基本可以确信调试设备上的ADB配置是没有问题的;关于如何在调试设备上适配ADB, 大家可以参考之前的一篇文章<a href="http://sniffer.site/2019/12/31/Recovery%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81ADB/">Recovery下如何配置ADB</a>. 那么, 问题就可以聚焦在客户端的配置上了.</p>
<p>对比下正常的配置与异常的配置, 发现异常的配置tty设备枚举到了5个(从<code>ttyUSB0</code>到<code>ttyUSB4</code>), 而正常只有4个(<code>ttyUSB0</code>到<code>ttyUSB3</code>), 进入<code>/sys/bus/usb/devices</code>找到对应的<code>ttyUSB4</code> 设备, 看了下相应的配置,<br><code>bInterfaceClass</code>/<code>bInterfaceProtocol</code>/<code>bInterfaceSubClass</code>与上述ADB的配置是完全一致的, <code>interface</code>的结果为<code>ADB interface</code>. 现在应该可以肯定, 这个多出来的<code>ttyUSB4</code> 串口设备应该就是用于ADB通讯的设备, 但是不知道为何被枚举成了串口. 看看串口驱动源码(<code>drivers/usb/serial/option.c</code>):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">option_probe</span><span class="params">(struct usb_serial *serial,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_interface_descriptor</span> *<span class="title">iface_desc</span> =</span></span><br><span class="line"><span class="class">				&amp;<span class="title">serial</span>-&gt;<span class="title">interface</span>-&gt;<span class="title">cur_altsetting</span>-&gt;<span class="title">desc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">usb_device_descriptor</span> *<span class="title">dev_desc</span> = &amp;<span class="title">serial</span>-&gt;<span class="title">dev</span>-&gt;<span class="title">descriptor</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> device_flags = id-&gt;driver_info;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Never bind to the CD-Rom emulation interface	*/</span></span><br><span class="line">	<span class="keyword">if</span> (iface_desc-&gt;bInterfaceClass == <span class="number">0x08</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Don't bind reserved interfaces (like network ones) which often have</span></span><br><span class="line"><span class="comment">	 * the same class/subclass/protocol as the serial interfaces.  Look at</span></span><br><span class="line"><span class="comment">	 * the Windows driver .INF files for reserved interface numbers.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (device_flags &amp; RSVD(iface_desc-&gt;bInterfaceNumber))</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Don't bind network interface on Samsung GT-B3730, it is handled by</span></span><br><span class="line"><span class="comment">	 * a separate module.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (dev_desc-&gt;idVendor == cpu_to_le16(SAMSUNG_VENDOR_ID) &amp;&amp;</span><br><span class="line">	    dev_desc-&gt;idProduct == cpu_to_le16(SAMSUNG_PRODUCT_GT_B3730) &amp;&amp;</span><br><span class="line">	    iface_desc-&gt;bInterfaceClass != USB_CLASS_CDC_DATA)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	</span><br><span class="line">	...		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里明确指出了, 有些保留(<code>RSVD)</code>的端口不需要枚举, 从这里我们大致可以推测问题的原因: ADB对应的设备节点被枚举成了串口, 导致ADB服务端无法与调试设备进行连接通讯. 就是说, 只要把对应端口号的设备保留下来即可. 找到调试设备VID/PID所在的地方, 加上<code>RSVD</code>标志即可:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123; USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_AG35), </span><br><span class="line">.driver_info = RSVD(<span class="number">4</span>)&#125;,  <span class="comment">// 4 对应设备的节点数字, bInterfaceNumber</span></span><br></pre></td></tr></table></figure>
<p>修改后, 就可以看到<code>adb devices</code>有设备列出了.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul>
<li><a href="https://developer.android.com/studio/command-line/adb" target="_blank" rel="noopener">https://developer.android.com/studio/command-line/adb</a></li>
<li><a href="https://events.static.linuxfound.org/images/stories/pdf/lf_abs12_kobayashi.pdf" target="_blank" rel="noopener">https://events.static.linuxfound.org/images/stories/pdf/lf_abs12_kobayashi.pdf</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> ADB </tag>
            
            <tag> Android Debug Bridge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[<我的工程格言>[译]]]></title>
      <url>http://sniffer.site/2021/01/08/%E8%AF%91-%E6%88%91%E7%9A%84%E5%B7%A5%E7%A8%8B%E6%A0%BC%E8%A8%80/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>The major problems of our work are not so much technological as sociological in nature</p>
<p>  《people-ware:productive projects/teams》</p>
</blockquote>
<p>几个月前，我做了一个有关个人工程格言的演讲-大致讲了过去几年来在写代码，打磨产品(building things)以及跟人合作时,积累的一些有用而且一般来说都是正确的想法。<a id="more"></a></p>
<p>格言是一个很有意思的单词，但是从词源学的角度追根溯源，<code>axiom</code>来自希腊语<a href="https://en.wiktionary.org/wiki/%E1%BC%80%CE%BE%CE%AF%CF%89%CE%BC%CE%B1" target="_blank" rel="noopener"><code>ἀξίωμα</code></a>, 含义是“合适或值得思考的想法”。我喜欢这个说法，将我格言中的每一项都当作是值得深思的。</p>
<p>当然，他们都是根据我过往经验并且我认为有用的工程格言。你的个人经验可能有所不同。也许你已经了解了<code>zero termination</code>（C字符串通常用0结尾），抑或有比<code>scissors to remove bugs</code>更好的工具。</p>
<p>不管怎样，我以为通过简要的阐述将格言清单列出来是件有趣的事情。有些表述可能相当平淡，但还是希望有人可以因此产生更多深入的思考或者有趣的不同意见。</p>
<blockquote>
<p>这里只翻译了几个我认为比较重要的条目，有兴趣的可以直接看原文<a href="https://martinrue.com/my-engineering-axioms/" target="_blank" rel="noopener">My Engineer Axioms</a></p>
</blockquote>
<h2 id="1-Change-is-contant"><a href="#1-Change-is-contant" class="headerlink" title="1. Change is contant"></a><strong>1. Change is contant</strong></h2><p>这条不应该有太多的争议。几乎万事万物都时刻在变化，包括变化本身（又想起那句“世界永远不变的是变化本身”）。我们不仅要认识到我们应对变化的能力至关重要，同时要意识到我们怎么做好一件事（时间，成本，质量，可靠性）通常是我们竞争力的衡量标准。</p>
<h2 id="2-Your-product-is-an-asset-but-code-is-a-liability"><a href="#2-Your-product-is-an-asset-but-code-is-a-liability" class="headerlink" title="2. Your product is an asset, but code is a liability"></a><strong>2. Your product is an asset, but code is a liability</strong></h2><p>你的产品解决了客户的问题，因此是你的资产。而代码本身是你创造这个资产的负债。代码越多，就需要更多的阅读，测试，修改以及理解。当你将此与格言1联系在一起时，这一点尤为明显。保守地接受新的代码（包括对外部代码的依赖）。最好的代码是你什么都不用写。</p>
<h2 id="3-Duplication-is-less-costly-than-premature-abstraction"><a href="#3-Duplication-is-less-costly-than-premature-abstraction" class="headerlink" title="3. Duplication is less costly than premature abstraction"></a><strong>3. Duplication is less costly than premature abstraction</strong></h2><p>除非你十分确信抽象由于能解决一个实际/抽象的问题，能带来足够的收益，否则不要轻易做。等待并且学习更多（掌握足够信息后再做决策）。在此之前，重复的代码有益于避免依赖，这会让代码更容易修改或者删除。过早的抽象可能通过依赖或间接的方式引入复杂度，这个可能会成为未来你应对改变的一个瓶颈。</p>
<h2 id="4-Code-should-be-easy-to-delete"><a href="#4-Code-should-be-easy-to-delete" class="headerlink" title="4. Code should be easy to delete"></a><strong>4. Code should be easy to delete</strong></h2><p>写的代码应该是可以随时移除的，从某种角度来说就是要“解耦”.可以肯定的说，并不是所有代码都需要保持同样的可移除状态，但最小化依赖，通过好的接口提供清晰的边界，并且慎重考虑整体的系统设计以便某些部分可以更容易的删除/修改。我以前听说有人使用“花出去的代码”而不是“写好的代码”，我喜欢这种表述;我倾向于说，删除代码就是减少未来的成本。</p>
<h2 id="5-Existing-Code-exerts-a-powerful-influence"><a href="#5-Existing-Code-exerts-a-powerful-influence" class="headerlink" title="5. Existing Code exerts a powerful influence "></a><strong>5. Existing Code exerts a powerful influence </strong></h2><p>一段代码存在就表明它是正确的，必要的。希望如此，但实际情况并不总是这样。我们需要保持两份信心去修改它，有能力推断是否我们应该修改它。不要让代码存在本身制造一种它不可被删除的疑惑。就像第4条说的那样，代码应该总是很容易的删除，而且一个好的系统设计应该使我们可以理解我们是否需要它。(给予已有代码足够的重视与尊重, 老的代码虽然有这样那样的问题, 但至少是经历了足够的验证测试, 可以很好的运行, 如果下定决心要修改老代码, 首先要吃透其中的逻辑, 修改后做好充分的验证测试)</p>
<h2 id="6-Accidental-complexity-is-one-of-the-biggest-risks"><a href="#6-Accidental-complexity-is-one-of-the-biggest-risks" class="headerlink" title="6. Accidental complexity is one of the biggest risks"></a><strong>6. Accidental complexity is one of the biggest risks</strong></h2><p>偶然性的复杂度是指那些本可以避免，却由于诸如糟糕的设计，错误的决策或者未将简单作为系统设计的首要原则等因素引入的复杂。如果简单不是一个目标，偶然的复杂则可能随着系统的扩展而出现，会逐渐的对几乎所有事情产生负面影响，从修改系统到理解设计背后的逻辑。2006年有一篇关于次主题的文章<a href="http://curtclifton.net/papers/MoseleyMarks06a.pdf" target="_blank" rel="noopener">跳出焦油坑(out of tar pit)</a>值得一读。</p>
<blockquote>
<p>后面几条(7 ~ 10) 都是关于团队协作以及如何与人沟通的，只翻译了部分，其余可以参考原文</p>
</blockquote>
<h2 id="7-Technical-execellence-can-be-shadowned-by-bad-personal-skills"><a href="#7-Technical-execellence-can-be-shadowned-by-bad-personal-skills" class="headerlink" title=" 7. Technical execellence can be shadowned by bad personal skills"></a><strong> 7. Technical execellence can be shadowned by bad personal skills</strong></h2><p>除非你单独工作，否则真正起作用的不仅仅是个人解决技术问题/写好代码的能力。相反，如果你使身边的人不开心或者效率变低，这些能力实际影响更小。正如写好代码需要学习，你必须学习如何与人相处。同理心是其中很重要的部分，要认识到每个人都并不相同-主动关心别人，理解他人，帮助别人，并请求他人的帮助，保持友好。努力成为一个别人愿意共事的工程师。</p>
<ul>
<li>(8) You are not your code. Be kind to the coder, not to the code</li>
<li>(9) Treat people who know less than you with respect and patience</li>
<li>(10) The only true authority stems from knowledge, not from position</li>
<li>(11) Teaching is a form of learning in disguise</li>
</ul>
<h2 id="12-Lift-the-skills-of-people-around-you-not-just-yourself"><a href="#12-Lift-the-skills-of-people-around-you-not-just-yourself" class="headerlink" title="12. Lift the skills of people around you, not just yourself"></a><strong>12. Lift the skills of people around you, not just yourself</strong></h2><p>优秀的团队绝不会因为一个厉害的就变得优秀。团队之所以优秀是因为每个人都互相挑战对方，每个人都相互成长。当你学习到某个有意思的东西，分享出来-帮助团队其他人变得更好。当其他人做同样的事情时，每个人都从中受益，没有人会落后。这样做可以获得更多的乐趣。第二点好处参考第11条。</p>
<h2 id="13-The-longer-you-wait-the-more-you’ll-know"><a href="#13-The-longer-you-wait-the-more-you’ll-know" class="headerlink" title="13. The longer you wait the more you’ll know "></a><strong>13. The longer you wait the more you’ll know </strong></h2><p>我一直学习这一点，努力避免快速决策的内在冲动。事实上，对于非核心的决策，延迟越久，等到需要做决定时，获取到的信息就越多。当然你不能总是拖延决策，但是常常可以这么做;最不济的来说，你应该至少要考虑当前是否知道问题的答案是否可以接受。</p>
<h2 id="14-A-good-type-system-is-worth-its-weight-plus-some"><a href="#14-A-good-type-system-is-worth-its-weight-plus-some" class="headerlink" title="14. A good type system is worth its weight plus some"></a><strong>14. A good type system is worth its weight plus some</strong></h2><p>有关编程语言类型的（略过）</p>
<h2 id="15-The-right-team-of-people-trumps-everything-else"><a href="#15-The-right-team-of-people-trumps-everything-else" class="headerlink" title="15. The right team of people trumps everything else"></a><strong>15. The right team of people trumps everything else</strong></h2><p>有一个彼此愿意工作在一起创造好的产品的团队，会使很多其他问题更容易处理。这里的”对“其实是相当主观，情景相关的，但至少是秩闻一样。同理心，尊重，友谊一直是我待过的优秀团队的特质。</p>
<h2 id="16-Stick-to-boring-technology-unless-there’s-a-good-reason-not-to"><a href="#16-Stick-to-boring-technology-unless-there’s-a-good-reason-not-to" class="headerlink" title="16. Stick to boring technology, unless there’s a good reason not to"></a><strong>16. Stick to boring technology, unless there’s a good reason not to</strong></h2><p>无聊的技术通常更老，更好的被理解。为了更有效的使用这些技术，更好的理解其失败的模式，人们曾经有过通过挣扎的经历，因此通常更容易找到知道如何进行最佳实践的人跟资源。我很喜欢<code>Dan Mackinley</code>的<a href="https://mcfunley.com/choose-boring-technology" target="_blank" rel="noopener"><code>Innovation tokens</code></a>的想法; 你只需要3个无聊的技术。用它们来构建新的东西-最好是那些可以提升核心竞争力的东西。不要超过3个，否则会增加（技术）从未到达稳定与成熟的风险。</p>
<h2 id="17-Have-the-smallest-team-possible-but-no-smaller-Grow-it-carefully"><a href="#17-Have-the-smallest-team-possible-but-no-smaller-Grow-it-carefully" class="headerlink" title="17. Have the smallest team possible, but no smaller. Grow it carefully"></a><strong>17. Have the smallest team possible, but no smaller. Grow it carefully</strong></h2><p>小团队可以更有效的合作，减少沟通摩擦（个人表述，原文翻译略）</p>
<h2 id="18-Rest"><a href="#18-Rest" class="headerlink" title="18. Rest"></a><strong>18. Rest</strong></h2><p>长期996实在不够明智，除了身心疲惫，可能你也失去了自我学习与成长的时间与机会。偶尔996,平时多注意锻炼身体，放松自己（个人表述，原文翻译略）</p>
<h2 id="19-Don’t-pick-a-solution-until-you’ve-thought-of-at-least-one-more"><a href="#19-Don’t-pick-a-solution-until-you’ve-thought-of-at-least-one-more" class="headerlink" title="19. Don’t pick a solution until you’ve thought of at least one more"></a><strong>19. Don’t pick a solution until you’ve thought of at least one more</strong></h2><p>在找到了一个问题的答案之前，不要匆忙解决问题，而是要尝试多几个解决方案，充分考虑各个条件的平衡（trade-off)。（个人表述，原文翻译略）</p>
<h2 id="20-Have-opinions-but-avoid-expressing-them-in-ways-that-cause-other-people-to-believe-you-won’t-change-them"><a href="#20-Have-opinions-but-avoid-expressing-them-in-ways-that-cause-other-people-to-believe-you-won’t-change-them" class="headerlink" title="20. Have opinions, but avoid expressing them in ways that cause other people to believe you won’t change them"></a><strong>20. Have opinions, but avoid expressing them in ways that cause other people to believe you won’t change them</strong></h2><p>表达观点是不要太过肯定，不是100%确定，而是留有余地，为后续的沟通保持一定的空间（个人表述，原文翻译略）</p>
<h2 id="21-It’s-OK-to-say-“I-don’t-know”-or-“I-need-to-research-that-before-I-have-an-answer”"><a href="#21-It’s-OK-to-say-“I-don’t-know”-or-“I-need-to-research-that-before-I-have-an-answer”" class="headerlink" title="21. It’s OK to say “I don’t know” or “I need to research that before I have an answer”"></a><strong>21. It’s OK to say “I don’t know” or “I need to research that before I have an answer”</strong></h2><p>承认自己不知道某件事情，并不丢人;当你不知道某件事情，表示你愿意与对方一起探讨问题，是一种更为友好的姿态（个人表述，原文翻译略）</p>
<h2 id="22-Writing-throwaway-code-to-explore-a-problem-space-is-underrated"><a href="#22-Writing-throwaway-code-to-explore-a-problem-space-is-underrated" class="headerlink" title="22. Writing throwaway code to explore a problem space is underrated"></a><strong>22. Writing throwaway code to explore a problem space is underrated</strong></h2><p>如果你对某个问题理解不够，允许自己犯错，写一些尝试性的代码，你可以学的更快（个人表述，原文翻译略）</p>
<h2 id="23-Manage-state-carefully"><a href="#23-Manage-state-carefully" class="headerlink" title="23. Manage state carefully"></a><strong>23. Manage state carefully</strong></h2><p>管理好代码中的状态，认真对待系统中状态的变化（个人表述，原文翻译略）</p>
<h2 id="24-It’s-all-about-trade-offs"><a href="#24-It’s-all-about-trade-offs" class="headerlink" title="24. It’s all about trade-offs"></a><strong>24. It’s all about trade-offs</strong></h2><p>所有的工程决策都包含中某种平衡; 仔细考虑这些平衡，在你想要修改某个已有的代码设计时，考虑这一点，这样你可能会做出更好的决策（个人表述，原文翻译略）</p>
<h2 id="25-A-good-design-is-one-in-which-you-can-change-your-mind-without-changing-too-much-code"><a href="#25-A-good-design-is-one-in-which-you-can-change-your-mind-without-changing-too-much-code" class="headerlink" title="25. A good design is one in which you can change your mind without changing too much code"></a><strong>25. A good design is one in which you can change your mind without changing too much code</strong></h2><p>世界不变的永远是变化本身。代码要面向未来的变化，系统设计要能适应未来的变化（对标产品，新特性等）（个人表述，原文翻译略）</p>
]]></content>
      
        <categories>
            
            <category> 软件工程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件开发 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 项目管理 </tag>
            
            <tag> 团队协作 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[不得不说的2020]]></title>
      <url>http://sniffer.site/2021/01/03/%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%842020/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>心灵是自己的地方，在那里可以把地狱变成天堂，也可以把天堂变成地狱</p>
<p>  约翰-弥尔顿《失乐园》</p>
</blockquote>
<p>2020年已然成为过往，但过去一年发生的种种却影响尤在，注定会成为很多人人生中的转折点：忽然而至的病毒导致经济颓败，很多公司工厂倒闭，有人失去了工作; 更悲伤的是，很多人因为新冠病毒失去了生命/亲人。中国的疫情虽说已经得到控制，最初的悲观情绪已经慢慢散去，人们开始了正常的生活，但欧美、印度等国家却还深陷病毒传播的泥沼，感染人数/死亡人数仍然居高不下。这是人类历史的悲怆之年。<a id="more"></a>不知道要等多久那些受到创伤的个人，家庭才能从疫情的阴霾当中走出来。但愿美好能很快就降临到不幸的人间;但愿快乐的日子又会像疫情之前一样带给每个人希望与甜美。</p>
<p>对我而言，这一年也可谓波折不断，身体与思想都经历了考验。因为女儿刚出生，疫情开始严重之时，我正在老家休假，所以并没有感受到太明显的变化;唯一不同的是，原本预计半个月休假回GZ，最后足足休息了一个月才回去。即便回到GZ，远程办公了大半个月才真正回到公司开始正常的工作。毫无疑问，疫情的发展速度超过了大多数人的想象，我们都有点措手不及。公司上下也对未来的预期变得悲观，有些部门甚至开始了裁撤人员。大家内心里有点不安与焦虑。但沉浸在危机之中的人，却往往容易忽略：每一次危机当中往往也蕴藏了巨大的机会。事实证明，这种悲观情绪被过度的渲染了;几个月后，公司融到了足够的资金，市场对于整个新能源市场的认知也发生了天翻地覆的变化，乐观与热情开始在行业内蔓延。看看蔚来的股价，从年初不到3美金，直接窜升到如今的超过45美金，真是跌宕起伏。这种过山车式的变化，对我来说是一次全新的体验，是认知上的巨大冲击。从这个角度来说，2020也是难忘的一年，不得不说的一年。</p>
<p>且把这一年的得失与感悟都写下来，当是对往后的勉励。</p>
<h2 id="拥抱变化，保持学习的心态"><a href="#拥抱变化，保持学习的心态" class="headerlink" title="拥抱变化，保持学习的心态"></a><strong>拥抱变化，保持学习的心态</strong></h2><p>一直以来，我都保持积极努力的姿态，平时会要求自己看书，学习，并尝试着提升自己各方面的能力。日积月累，虽有效果，但实则收效有限。我反思过，却未能找到真正的原因，也并没有完全实现自己理想中的突破。直到这次疫情在公司中经历行业的动荡与变化，才让我醒悟过来。为何我没能看到这些事后看来如此明显的趋势？为何我早早的把很多可能性排除在外，而只选择了一种更为保守与稳妥却实际不可能的可能了？为何我这么长时间都没有走出思维的舒适圈，拓宽自己视野的边界？从理论上来说，人的思维不应该有任何边界才对，可一直以来我都给自己设定了框架与边界，并且坚守了下来。这让我过的安稳舒适，却也让我失去了成长的机会。</p>
<p>高瓴资本创始人张磊一直强调说：世界永远不变的是变化本身。面对变化，面对新生事物，面对与以往认知不同甚至相抵触的东西时，我们要做的不是排斥，不是质疑，不是置之不理，而是要保持开放的思维方式，努力理解变化与新事物背后的历史与逻辑，努力去把握它，直到完全理解。对于未知的变化/事物，不要急于下结论，而是要”让子弹飞一会“，掌握了足够充分的信息后再做判断。意识到自己的无知，并不断的学习调整，才能在剧烈变化的环境中看到机会，并不断自我成长。</p>
<p>庄子说：吾生也有涯，而知也无涯;以有涯随无涯，怠矣。乔布斯也曾说：keep hugry, keep folish。面对不断变化的世界，面对未来的诸多不确定性，面对不断涌现的新生事物，不应该排斥，而是要积极拥抱，保持好奇之心，保持空杯与学习的心态，不断调整自我认知，不断探索各种可能，如此，方能最大程度的把握属于自己的机会，获得源源不断的成长动力。</p>
<h2 id="学会投资"><a href="#学会投资" class="headerlink" title="学会投资"></a><strong>学会投资</strong></h2><p>程序员的圈子里经常讨论的话题是996，35岁职场焦虑，中年危机等等，再加上家庭责任，这些重担压在身上，让大家都有种难以摆脱的浮躁与压力。处在软件开发这种快速变化的行业，我们这些程序员确实要承受不一样的压力与工作强度。但总的来说，软件尤其是互联网行业还在快速发展当中，人才缺口很大，只要足够努力用心，我们还是会有机会选择。对个人来说，改变不了大环境，那就努力改变自己; 改变不了行业的观念与风气，那就努力让自己变得更优秀。</p>
<p>这次突然的疫情，打破了往日正常的生活节奏，也让我意识到生活并不会像预期一样顺风顺水，而是充满了诸多的不确定性。如何应对这种不确定性，在发生外部风险时如何减少对自己的影响确是我之前很少思考的问题。平日高强度的工作，锻炼身体却越来越少，每次体检都看到不断升高的血脂/尿酸水平也在不断提醒自己该去运动运动了。因此，今年开始要重拾运动的习惯。确保每周都有锻炼，改善体质，注意平时的饮食，丰富自己的食物来源，减少油脂的摄入。健康的身体与充沛的精力只是抵御风险的第一步。在这之外，重要的还要学会财务投资。</p>
<p>财务投资迫使你学习基本的经济知识，了解世界经济的运作方式，去观察身边的经济现象，这是一种理解现代世界的必须途径。同时，也要看到，自2008年美国金融危机以来，几乎全球所有国家都在进行量化宽松的政策，货币发行量连年上升，这种超发的货币实际上是政府通过印钞机变相的掠夺你放在银行里的存款。因此，要抵消这些货币带来的通货膨胀，正确的财务投资必不可少。这是今年要重点去学习积累的一个方向：不能只是依赖单一的收入来源，而是要努力尝试财务投资，让自己有额外稳定的收益。</p>
<h2 id="与时间做朋友，专注长期价值"><a href="#与时间做朋友，专注长期价值" class="headerlink" title="与时间做朋友，专注长期价值"></a><strong>与时间做朋友，专注长期价值</strong></h2><p>软件行业发展迅猛，几乎每一年都有新事物涌现，从云计算，到加密货币，再到人工智能，这些热门的概念催生了很多的需求，也带来了所谓的风口。但作为一个普通的程序员，结合自己的职业发展，如何面对这些风口？虽说每个风口都代表着巨大的机遇，但个人的时间精力毕竟有限，与其盲目的追逐热门技术，不如踏踏实实做好基础的工作，把关键性的基础技术把握牢固，然后在心力有余的情况下，选择拓展技术边界。</p>
<p>要把基础知识系统性的学好，构建一个完整的技术框架，绝非短时间就能完成的，而是需要我们做好长期投入的准备，不断去累积，不断的学习总结，做到融会贯通。先争取在一个小的领域成为专家，深耕下去，然后再选择一个值得长期投入的方向，逐渐的拓展技术的领地，有深度的同时，也要有足够的广度。</p>
<p>与时间为友，不是只关心短期收益，追求立竿见影的效果，而是要注重长期的价值，把学好技术当作人生的追求。</p>
<p>2021已经来临，自律，延迟满足，不断积累，相信新的一年能有更大的突破。</p>
]]></content>
      
        <categories>
            
            <category> 思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 2020 </tag>
            
            <tag> 新冠病毒 </tag>
            
            <tag> 个人成长 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MAC与PHY调试遇到的那些坑]]></title>
      <url>http://sniffer.site/2020/12/31/MAC%E4%B8%8EPHY%E8%B0%83%E8%AF%95%E9%81%87%E5%88%B0%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>这次新平台采用了与之前不同的以太网方案， MAC是内置在SoC(System On Chip)上，而PHY采用了Marvell的一款100Mps的车规级的芯片，MAC/PHY的驱动都要重新开发适配，工作难度比之前预想的要大了很多，完成时间比预想的慢了近一个星期。<a id="more"></a>不过，往后看，这种直接与硬件打交道的经验很能锻炼人，在一定程度改善了我对系统的认知与理解。这篇文章重点在梳理总结下车在以太网MAC/PHY遇到的一些问题，以及Linux下MAC/PHY驱动的一些基本流程。</p>
<p>大致分为如下几个部分：</p>
<ul>
<li>MAC/PHY的基础知识</li>
<li>Linux下MAC/PHY驱动的加载流程</li>
<li>车载以太网MAC/PHY调试的一些经验总结</li>
</ul>
<h2 id="MAC-PHY的基本概念"><a href="#MAC-PHY的基本概念" class="headerlink" title="MAC/PHY的基本概念"></a><strong>MAC/PHY的基本概念</strong></h2><p>MAC即媒介访问控制层(<a href="https://en.wikipedia.org/wiki/Medium_access_control" target="_blank" rel="noopener">Media Access Control</a>, 位于TCP/IP协议栈的第二层-数据链路层，用于数据传输过程的数据流控制，其将上层IP数据包分割成适合于物理层传输的数据帧，并负责数据传输的冲突管理。按照 IEEE Std 802-2001 上的定义，MAC主要做如下几个事情：</p>
<ul>
<li>数据帧的封装与识别</li>
<li>根据MAC地址来与目标主机进行通讯</li>
<li>检测数据传输错误（MAC帧中有一个FCS, Frame Checksum Sequence)</li>
<li>物理媒介的访问控制，半双工情况下需要进行传输冲突控制，如<a href="https://en.wikipedia.org/wiki/Carrier-sense_multiple_access_with_collision_detection" target="_blank" rel="noopener">CSMA/CD</a></li>
</ul>
<p>而PHY（Physical layer)即物理层， 其主要负责物理信号的传输， 其通过线束（如光纤/铜线）与其他设备进行连接。一个PHY芯片主要包含了两个部分: PCS(Physical Coding Sublayer), PMD(Physical Medium Dependent), 对车载PHY芯片来说，通常还包含了一个PMA(Physical Media Attachment)子层, 位于PCS与PMD之间; 下图是一个以太网的大致结构图：</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ethernet_model.jpg" alt="MAC/PHY structure"></p>
<p>那么，MAC与PHY是具体如何通讯的？ 其通讯接口实际分控制接口与数据接口。控制接口是用于访问控制PHY的寄存器的<a href="https://en.wikipedia.org/wiki/Management_Data_Input/Output" target="_blank" rel="noopener">MDIO(Management Data Input/Output)</a>/MDC(Management Data Clock)， 其中MDIO是数据传输用，而MDC是为MDIO的访问提供时序。MDIO最初是在IEEE RFC802.3中定义，只有Clause22一种标准，允许MAC访问32个PHY的寄存器;后来，为了适应千兆以太网PHY，提供了clause45协议，最多支持65,536个寄存器的访问，同时兼容clause22的方式来访问clause45的寄存器。下图是Clause22协议访问PHY寄存器的帧结构: </p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/mdio-clause22.png" alt="clause22 protocol frame"></p>
<p>其中：</p>
<ul>
<li>ST(2bits): SOF(start of frame), 对Clause22来说是01</li>
<li>OP(2bits): 操作码， 读或写(01-write/10-read)</li>
<li>PHYADDR(5bits): PHY的物理地址，这个与硬件配置有关</li>
<li>REGADDR(5bits): 32位寄存器地址</li>
<li>TA(2bits): 从STA(MAC)到MMD(PHY)总线使用权切换所需要的翻转时间(turnaround time)</li>
<li>DATA(16bits): 数据，写寄存器是MAC将数据放到该位置; 读寄存器时PHY将结果放入该位置</li>
</ul>
<p>更多关于MDIO的两种协议Clause22/Cluase45的信息可以参考：<a href="https://www.totalphase.com/support/articles/200349206-MDIO-Background" target="_blank" rel="noopener">MDIO background</a></p>
<p>除了控制接口，MAC/PHY之间还有数据传输的接口MII<a href="https://en.wikipedia.org/wiki/Media-independent_interface" target="_blank" rel="noopener">(Media Independent Interface)</a>, 针对不同的应用场景，目前已有RMII(Reduced MII), GMII(Gigabit MII), RGMII(Reduced Gigabit MII), SGMII(Serial Gigabit MII), XGMII(10-gigabit MII)等多种接口。</p>
<h2 id="Linux中MAC-PHY驱动的启动流程"><a href="#Linux中MAC-PHY驱动的启动流程" class="headerlink" title="Linux中MAC/PHY驱动的启动流程"></a><strong>Linux中MAC/PHY驱动的启动流程</strong></h2><p>这里讲MAC/PHY驱动，不会涉及具体的芯片，只分析MAC/PHY启动的关键流程。总的来说， MAC/PHY启动大致有几个步骤：</p>
<ul>
<li>内核加载MAC驱动</li>
<li>MAC驱动对MAC/PHY芯片上电，并读取PHY的状态寄存器确认PHY正常上电</li>
<li>MAC注册一个MDIO总线对象，提供PHY寄存器操作的接口</li>
<li>MAC获取到MDIO总线上的PHY设备，并将其与MAC对应的网络设备进行连接</li>
<li>用户进程进行了interface up的操作并配置IP，MAC与PHY可以准备接发数据</li>
</ul>
<p>这里只讲述下与硬件平台无关的核心部分流程（中间三个部分）：</p>
<h3 id="MDIO总线访问接口注册"><a href="#MDIO总线访问接口注册" class="headerlink" title="MDIO总线访问接口注册"></a><strong>MDIO总线访问接口注册</strong></h3><p>在MAC/PHY都正常上电后， MAC驱动需要注册一个MDIO的总线接口供后续PHY驱动读写寄存器使用，接口位于<code>include/linux/phy.h</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct mii_bus *<span class="title">mdiobus_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mdiobus_alloc_size(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mdiobus_alloc_size(0)</code>为<code>mii_bus</code>对象分配内存空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">struct mii_bus *<span class="title">mdiobus_alloc_size</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mii_bus</span> *<span class="title">bus</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> aligned_size = ALIGN(<span class="keyword">sizeof</span>(*bus), NETDEV_ALIGN);</span><br><span class="line">	<span class="keyword">size_t</span> alloc_size;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we alloc extra space, it should be aligned */</span></span><br><span class="line">	<span class="keyword">if</span> (size)</span><br><span class="line">		alloc_size = aligned_size + size;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		alloc_size = <span class="keyword">sizeof</span>(*bus);</span><br><span class="line"></span><br><span class="line">	bus = kzalloc(alloc_size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!bus)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	bus-&gt;state = MDIOBUS_ALLOCATED;</span><br><span class="line">	<span class="keyword">if</span> (size)</span><br><span class="line">		bus-&gt;priv = (<span class="keyword">void</span> *)bus + aligned_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialise the interrupts to polling */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PHY_MAX_ADDR; i++)</span><br><span class="line">		bus-&gt;irq[i] = PHY_POLL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bus;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(mdiobus_alloc_size);</span><br></pre></td></tr></table></figure>
<p>这个结构<code>mii_bus</code>对象即是MAC与PHY之间控制访问的接口，主要包括了用于访问PHY寄存器的函数<code>read/write</code>以及用于PHY芯片软复位的<code>reset</code>函数，这三个函数通常需要在MAC驱动根据实际的PHY寄存器访问协议来实现;另外还包括了mdio总线所包含的所有PHY设备<code>mdio_map</code>（最多支持32个PHY）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The Bus class for PHYs.  Devices which provide access to</span></span><br><span class="line"><span class="comment"> * PHYs should register using this structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mii_bus</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="keyword">char</span> id[MII_BUS_ID_SIZE];</span><br><span class="line">	<span class="keyword">void</span> *priv;</span><br><span class="line">	<span class="keyword">int</span> (*read)(struct mii_bus *bus, <span class="keyword">int</span> addr, <span class="keyword">int</span> regnum);</span><br><span class="line">	<span class="keyword">int</span> (*write)(struct mii_bus *bus, <span class="keyword">int</span> addr, <span class="keyword">int</span> regnum, u16 val);</span><br><span class="line">	<span class="keyword">int</span> (*reset)(struct mii_bus *bus);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A lock to ensure that only one thing can read/write</span></span><br><span class="line"><span class="comment">	 * the MDIO bus at a time</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mdio_lock</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="keyword">enum</span> &#123;</span><br><span class="line">		MDIOBUS_ALLOCATED = <span class="number">1</span>,</span><br><span class="line">		MDIOBUS_REGISTERED,</span><br><span class="line">		MDIOBUS_UNREGISTERED,</span><br><span class="line">		MDIOBUS_RELEASED,</span><br><span class="line">	&#125; state;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* list of all PHYs on bus */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mdio_device</span> *<span class="title">mdio_map</span>[<span class="title">PHY_MAX_ADDR</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* PHY addresses to be ignored when probing */</span></span><br><span class="line">	u32 phy_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* PHY addresses to ignore the TA/read failure */</span></span><br><span class="line">	u32 phy_ignore_ta_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * An array of interrupts, each PHY's interrupt at the index</span></span><br><span class="line"><span class="comment">	 * matching its address</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> irq[PHY_MAX_ADDR];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* GPIO reset pulse width in microseconds */</span></span><br><span class="line">	<span class="keyword">int</span> reset_delay_us;</span><br><span class="line">	<span class="comment">/* RESET GPIO descriptor pointer */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">reset_gpiod</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>初始化完<code>mii_bus</code>后， MAC驱动会通过<code>mdiobus_register</code>注册该对象; 在这里，做的最重要的一个事情就是扫描所有MDIO下面的PHY设备，并将其保存到<code>mdio_map</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> __mdiobus_register(struct mii_bus *bus, struct <span class="keyword">module</span> *owner)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mdio_device</span> *<span class="title">mdiodev</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i, err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == bus || <span class="literal">NULL</span> == bus-&gt;name ||</span><br><span class="line">	    <span class="literal">NULL</span> == bus-&gt;read || <span class="literal">NULL</span> == bus-&gt;write)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	BUG_ON(bus-&gt;state != MDIOBUS_ALLOCATED &amp;&amp;</span><br><span class="line">	       bus-&gt;state != MDIOBUS_UNREGISTERED);</span><br><span class="line"></span><br><span class="line">	bus-&gt;owner = owner;</span><br><span class="line">	bus-&gt;dev.parent = bus-&gt;parent;</span><br><span class="line">	bus-&gt;dev.class = &amp;mdio_bus_class;</span><br><span class="line">	bus-&gt;dev.groups = <span class="literal">NULL</span>;</span><br><span class="line">	dev_set_name(&amp;bus-&gt;dev, <span class="string">"%s"</span>, bus-&gt;id);</span><br><span class="line"></span><br><span class="line">	err = device_register(&amp;bus-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_err(<span class="string">"mii_bus %s failed to register\n"</span>, bus-&gt;id);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_init(&amp;bus-&gt;mdio_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* de-assert bus level PHY GPIO reset */</span></span><br><span class="line">	gpiod = devm_gpiod_get_optional(&amp;bus-&gt;dev, <span class="string">"reset"</span>, GPIOD_OUT_LOW);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpiod)) &#123;</span><br><span class="line">		dev_err(&amp;bus-&gt;dev, <span class="string">"mii_bus %s couldn't get reset GPIO\n"</span>,</span><br><span class="line">			bus-&gt;id);</span><br><span class="line">		device_del(&amp;bus-&gt;dev);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpiod);</span><br><span class="line">	&#125; <span class="keyword">else</span>	<span class="keyword">if</span> (gpiod) &#123;</span><br><span class="line">		bus-&gt;reset_gpiod = gpiod;</span><br><span class="line"></span><br><span class="line">		gpiod_set_value_cansleep(gpiod, <span class="number">1</span>);</span><br><span class="line">		udelay(bus-&gt;reset_delay_us);</span><br><span class="line">		gpiod_set_value_cansleep(gpiod, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bus-&gt;reset)</span><br><span class="line">		bus-&gt;reset(bus);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扫描所有PHY设备</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PHY_MAX_ADDR; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((bus-&gt;phy_mask &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">phy_device</span> *<span class="title">phydev</span>;</span></span><br><span class="line"></span><br><span class="line">			phydev = mdiobus_scan(bus, i);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(phydev) &amp;&amp; (PTR_ERR(phydev) != -ENODEV)) &#123;</span><br><span class="line">				err = PTR_ERR(phydev);</span><br><span class="line">				<span class="keyword">goto</span> error;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);</span><br><span class="line"></span><br><span class="line">	bus-&gt;state = MDIOBUS_REGISTERED;</span><br><span class="line">	pr_info(<span class="string">"%s: probed\n"</span>, bus-&gt;name);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	<span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		mdiodev = bus-&gt;mdio_map[i];</span><br><span class="line">		<span class="keyword">if</span> (!mdiodev)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		mdiodev-&gt;device_remove(mdiodev);</span><br><span class="line">		mdiodev-&gt;device_free(mdiodev);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Put PHYs in RESET to save power */</span></span><br><span class="line">	<span class="keyword">if</span> (bus-&gt;reset_gpiod)</span><br><span class="line">		gpiod_set_value_cansleep(bus-&gt;reset_gpiod, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	device_del(&amp;bus-&gt;dev);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扫描MIDO总线的PHY设备"><a href="#扫描MIDO总线的PHY设备" class="headerlink" title="扫描MIDO总线的PHY设备"></a><strong>扫描MIDO总线的PHY设备</strong></h3><p>函数<code>mdiobus_scan</code>首先调用<code>get_phy_device</code>获取指定地址上的PHY设备ID,并创建一个 <code>phy_device</code>对象，然后通过<code>phy_device_register</code>初始化创建的<code>phy_device</code>对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">struct phy_device *<span class="title">mdiobus_scan</span><span class="params">(struct mii_bus *bus, <span class="keyword">int</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">phy_device</span> *<span class="title">phydev</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	phydev = get_phy_device(bus, addr, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(phydev))</span><br><span class="line">		<span class="keyword">return</span> phydev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For DT, see if the auto-probed phy has a correspoding child</span></span><br><span class="line"><span class="comment">	 * in the bus node, and set the of_node pointer in this case.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	of_mdiobus_link_mdiodev(bus, &amp;phydev-&gt;mdio);</span><br><span class="line"></span><br><span class="line">	err = phy_device_register(phydev);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		phy_device_free(phydev);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> phydev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>get_phy_id</code>通过读取<code>MII_PHYSID1/MII_PHYSID2</code>两个PHY的ID寄存器获取PHY的ID，这里<code>mdiobus_read</code>正是之前MAC实现的<code>mii_bus</code>的中的<code>read</code>接口，如果该接口实现有问题，MAC就无法正常与PHY进行通讯。另外需要注意的是，默认情况下，Linux都是基于MDIO的Clause22协议来访问PHY的寄存器的（调试PHY驱动的时候需要留意）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_phy_id</span><span class="params">(struct mii_bus *bus, <span class="keyword">int</span> addr, u32 *phy_id,</span></span></span><br><span class="line"><span class="function"><span class="params">		      <span class="keyword">bool</span> is_c45, struct phy_c45_device_ids *c45_ids)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> phy_reg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_c45)</span><br><span class="line">		<span class="keyword">return</span> get_phy_c45_ids(bus, addr, phy_id, c45_ids);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Grab the bits from PHYIR1, and put them in the upper half */</span></span><br><span class="line">	phy_reg = mdiobus_read(bus, addr, MII_PHYSID1);</span><br><span class="line">	<span class="keyword">if</span> (phy_reg &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line">	*phy_id = (phy_reg &amp; <span class="number">0xffff</span>) &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Grab the bits from PHYIR2, and put them in the lower half */</span></span><br><span class="line">	phy_reg = mdiobus_read(bus, addr, MII_PHYSID2);</span><br><span class="line">	<span class="keyword">if</span> (phy_reg &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line">	*phy_id |= (phy_reg &amp; <span class="number">0xffff</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扫描到PHY后，将其注册到对应的<code>mii_bus</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phy_device_register</span><span class="params">(struct phy_device *phydev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = mdiobus_register_device(&amp;phydev-&gt;mdio);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Run all of the fixups for this PHY */</span></span><br><span class="line">	err = phy_scan_fixups(phydev);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_err(<span class="string">"PHY %d failed to initialize\n"</span>, phydev-&gt;mdio.addr);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	phydev-&gt;mdio.dev.groups = phy_dev_groups;</span><br><span class="line"></span><br><span class="line">	err = device_add(&amp;phydev-&gt;mdio.dev);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_err(<span class="string">"PHY %d failed to add\n"</span>, phydev-&gt;mdio.addr);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	mdiobus_unregister_device(&amp;phydev-&gt;mdio);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MAC与PHY进行匹配连接"><a href="#MAC与PHY进行匹配连接" class="headerlink" title="MAC与PHY进行匹配连接"></a><strong>MAC与PHY进行匹配连接</strong></h3><p>通过<code>mdiobus_get_phy</code>这个接口，MAC获取到当前MDIO总线上对应物理地址的PHY设备，然后通过<code>phy_connect_direct</code>将MAC对应的网络设备与PHY设备进行连接绑定：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * phy_connect_direct - connect an ethernet device to a specific phy_device</span></span><br><span class="line"><span class="comment"> * @dev: the network device to connect</span></span><br><span class="line"><span class="comment"> * @phydev: the pointer to the phy device</span></span><br><span class="line"><span class="comment"> * @handler: callback function for state change notifications</span></span><br><span class="line"><span class="comment"> * @interface: PHY device's interface</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phy_connect_direct</span><span class="params">(struct net_device *dev, struct phy_device *phydev,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">void</span> (*handler)(struct net_device *),</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">phy_interface_t</span> interface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	rc = phy_attach_direct(dev, phydev, phydev-&gt;dev_flags, interface);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">	phy_prepare_link(phydev, handler);</span><br><span class="line">	phy_start_machine(phydev);</span><br><span class="line">	<span class="keyword">if</span> (phydev-&gt;irq &gt; <span class="number">0</span>)</span><br><span class="line">		phy_start_interrupts(phydev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将MAC网络设备与PHY进行绑定，并进行初始化，如进行PHY的软复位; 这里要注意的时，PHY的驱动要根据PHYID提前做好适配，不然这里的<code>d-&gt;driver</code>值未空，就无法正常进行phy的初始化了，网络自然无法正常工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phy_attach_direct</span><span class="params">(struct net_device *dev, struct phy_device *phydev,</span></span></span><br><span class="line"><span class="function"><span class="params">		      u32 flags, <span class="keyword">phy_interface_t</span> interface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">ndev_owner</span> = <span class="title">dev</span>-&gt;<span class="title">dev</span>.<span class="title">parent</span>-&gt;<span class="title">driver</span>-&gt;<span class="title">owner</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mii_bus</span> *<span class="title">bus</span> = <span class="title">phydev</span>-&gt;<span class="title">mdio</span>.<span class="title">bus</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">d</span> = &amp;<span class="title">phydev</span>-&gt;<span class="title">mdio</span>.<span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> using_genphy = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	get_device(d);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Assume that if there is no driver, that it doesn't</span></span><br><span class="line"><span class="comment">	 * exist, and we should use the genphy driver.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!d-&gt;driver) &#123;</span><br><span class="line">		<span class="keyword">if</span> (phydev-&gt;is_c45)</span><br><span class="line">			d-&gt;driver = &amp;genphy_10g_driver.mdiodrv.driver;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			d-&gt;driver = &amp;genphy_driver.mdiodrv.driver;</span><br><span class="line"></span><br><span class="line">		using_genphy = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!try_module_get(d-&gt;driver-&gt;owner)) &#123;</span><br><span class="line">		dev_err(&amp;dev-&gt;dev, <span class="string">"failed to get the device driver module\n"</span>);</span><br><span class="line">		err = -EIO;</span><br><span class="line">		<span class="keyword">goto</span> error_put_device;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (using_genphy) &#123;</span><br><span class="line">		err = d-&gt;driver-&gt;probe(d);</span><br><span class="line">		<span class="keyword">if</span> (err &gt;= <span class="number">0</span>)</span><br><span class="line">			err = device_bind_driver(d);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> error_module_put;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	phydev-&gt;phy_link_change = phy_link_change;</span><br><span class="line">	phydev-&gt;attached_dev = dev;</span><br><span class="line">	dev-&gt;phydev = phydev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Some Ethernet drivers try to connect to a PHY device before</span></span><br><span class="line"><span class="comment">	 * calling register_netdevice() -&gt; netdev_register_kobject() and</span></span><br><span class="line"><span class="comment">	 * does the dev-&gt;dev.kobj initialization. Here we only check for</span></span><br><span class="line"><span class="comment">	 * success which indicates that the network device kobject is</span></span><br><span class="line"><span class="comment">	 * ready. Once we do that we still need to keep track of whether</span></span><br><span class="line"><span class="comment">	 * links were successfully set up or not for phy_detach() to</span></span><br><span class="line"><span class="comment">	 * remove them accordingly.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	phydev-&gt;sysfs_links = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	err = sysfs_create_link(&amp;phydev-&gt;mdio.dev.kobj, &amp;dev-&gt;dev.kobj,</span><br><span class="line">				<span class="string">"attached_dev"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!err) &#123;</span><br><span class="line">		err = sysfs_create_link_nowarn(&amp;dev-&gt;dev.kobj,</span><br><span class="line">					       &amp;phydev-&gt;mdio.dev.kobj,</span><br><span class="line">					       <span class="string">"phydev"</span>);</span><br><span class="line">		<span class="keyword">if</span> (err) &#123;</span><br><span class="line">			dev_err(&amp;dev-&gt;dev, <span class="string">"could not add device link to %s err %d\n"</span>,</span><br><span class="line">				kobject_name(&amp;phydev-&gt;mdio.dev.kobj),</span><br><span class="line">				err);</span><br><span class="line">			<span class="comment">/* non-fatal - some net drivers can use one netdevice</span></span><br><span class="line"><span class="comment">			 * with more then one phy</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		phydev-&gt;sysfs_links = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	phydev-&gt;dev_flags = flags;</span><br><span class="line"></span><br><span class="line">	phydev-&gt;interface = interface;</span><br><span class="line"></span><br><span class="line">	phydev-&gt;state = PHY_READY;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initial carrier state is off as the phy is about to be</span></span><br><span class="line"><span class="comment">	 * (re)initialized.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	netif_carrier_off(phydev-&gt;attached_dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do initial configuration here, now that</span></span><br><span class="line"><span class="comment">	 * we have certain key parameters</span></span><br><span class="line"><span class="comment">	 * (dev_flags and interface)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	err = phy_init_hw(phydev);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	phy_resume(phydev);</span><br><span class="line">	phy_led_triggers_register(phydev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关PHY驱动与PHY设备如何进行匹配的实现细节，可以参考Linux内核的文档:</p>
<blockquote>
<p>/kernel/msm-4.14/Documentation/driver-model/*.txt</p>
</blockquote>
<h2 id="MAC-PHY调试容易踩到的坑"><a href="#MAC-PHY调试容易踩到的坑" class="headerlink" title="MAC/PHY调试容易踩到的坑"></a><strong>MAC/PHY调试容易踩到的坑</strong></h2><p>一般来说，MAC跟PHY的连接有这么几种形式：</p>
<ul>
<li>MAC/PHY都采用独立的芯片，MAC通过PCI总线接入到系统</li>
<li>MAC集成到SoC上，PHY采用外接芯片的形式</li>
<li>MAC/PHY集成在一个芯片上，然后通过PCI总线接入到系统</li>
</ul>
<blockquote>
<p>现在也开始采用另外一种连接方式: MAC集成到SoC上, 与一个Switch的MAC端口直连(不再有PHY设备了), 即MAC直连, 这种只需要在MAC驱动添加一个虚拟的FIXED PHY, EMAC就可以正常工作, 可以参考<a href="https://patchwork.kernel.org/project/linux-arm-kernel/patch/1373902450-11857-2-git-send-email-thomas.petazzoni@free-electrons.com/" target="_blank" rel="noopener">FIXED PHY driver</a>；或者Linux源代码&lt;drivers/of/of_mdio.c&gt;</p>
</blockquote>
<p>对现如今集成度越来越高的系统来说，很多SoC都会采用将MAC集成到系统，采用EMAC(Embedded  MAC)的形式，这样简化了硬件与软件的设计，对于开发人员来说最主要的工作就是PHY驱动以及相关协议的适配了。由于之前对MAC/PHY驱动的工作接触不多，这次是第一次完全从零开发以太网驱动，遇到了不少坑，总结下主要有如下几点：</p>
<ul>
<li>MAC/PHY之间的通讯实际上都是标准的MDIO/MII接口，相对而言都比较成熟了，驱动适配首先还是要确保使用的接口，比如是RGMII还是GMII，两者要一致; 另外速率要保持一致，比如MAC配置成100Mbps，同样PHY要对应是100Mbps，否则以太网可能没法工作</li>
<li>如今的PHY都支持千兆网速了，所以很多PHY都开始支持clause45的协议寄存器的访问，有些PHY是clause22/clause45都支持，有些PHY则只支持clause45,这个是比较容易出问题的地方。使用正确的MDIO协议访问寄存器才能正常读到PHY芯片的状态</li>
<li>最后也是很重要的一点，认真读下厂商提供的PHY芯片手册，以及硬件设计的要点，避免踩到不必要的坑</li>
</ul>
<p>总的说来，梳理好MAC/PHY的流程，再进行驱动开发就会顺手不少。</p>
]]></content>
      
        <categories>
            
            <category> 汽车电子 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MAC </tag>
            
            <tag> PHY </tag>
            
            <tag> 车载以太网 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[汽车网络演化-从CAN到以太网]]></title>
      <url>http://sniffer.site/2020/11/06/%E6%B1%BD%E8%BD%A6%E7%BD%91%E7%BB%9C%E6%BC%94%E5%8C%96-%E4%BB%8ECAN%E5%88%B0%E4%BB%A5%E5%A4%AA%E7%BD%91/</url>
      <content type="html"><![CDATA[<p>汽车电子的发展伴随着技术迭代而不断进化，汽车网络总线从最开的CAN，CAN-FD,到后来的Flexray, MOST再到LIN，到Ethernet，在市场需求与技术发展双重合力之下，经过了不断的发展积累，到如今已经有进40年的历史。近几年，随着各大汽车公司，尤其是新能源汽车公司如特斯拉/蔚来/小鹏等在自动驾驶领域的大力投入，汽车网络开始向高带宽/低延时的以太网方向发展。在这篇文章我们就来对比看看各种汽车网络总线的工作原理以及使用场景。</p>
<h2 id="CAN-Controller-Area-Network"><a href="#CAN-Controller-Area-Network" class="headerlink" title="CAN(Controller Area Network)"></a><strong>CAN(Controller Area Network)</strong></h2><p>CAN最初是由博世(Bosch)于1985年开发出来的车内总线。在这之前，汽车厂商需要通过一条条线将各种汽车控制器连接起来，形成一个个点对点的连接网络。这也导致了增加了汽车本身的重量，增加了系统的复杂度与成本。</p>
<p>CAN作为一个串行总线，具有低成本，轻量化的优势，最高支持1Mb/s的速率，因此迅速被各大厂商采用，并于1993年被定为ISO国际化标准(ISO 11898).</p>
<p>下图是CAN报文的结构：</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/CAN_frame_format.jpeg" alt="CAN frame format"></p>
<ul>
<li>SOF(Start of Frame): 帧开始标记位，一般为0</li>
<li>Arbitration ID: 11位的仲裁优先级，用于标识消息以及消息的优先级</li>
<li>IDE(Identifier Extension): 占1位，表示允许标准帧与扩展帧的差别</li>
<li>RTP(Remote Transmission Request): 1bit, 区分一个数据帧与远端帧(remote frame), 0表示数据帧，1表示远端帧</li>
<li>DLC(Data length code): 表示数据的长度</li>
<li>Data Field: 包含0～8字节的数据</li>
<li>CRC(Cyclic Redundancy Check):循环冗余检测码，用于检查数据错误</li>
<li>ACK: 接收端在收到数据后，发送一个ACK帧，发送端收到后确认发送成功，否则就要重发数据</li>
<li>EOF(End of Frame): 结束位 </li>
</ul>
<p>CAN是一个点对点的网络，对于CAN总线的访问没有一个仲裁节点用于控制各个节点的数据发送/接收。 所有节点在发送数据之前都要检查当前总线上是否有数据传输，如果多个节点尝试同时发送数据，拥有最高优先级的节点（仲裁ID值低）自动获取到总线的访问权限，而低优先级的节点则需要等到高优先级的节点发送完数据后再传输。由上述CAN报文的结构可以看到，CAN消息中并没有包含节点的地址，每个节点发送的消息都会广播到其他所有节点，接收端需要通过仲裁ID来判断是否接收某个数据报文。</p>
<p>由于每个CAN报文实际只有一个字节(8bit)的数据，因此传输速率实际收到了限制。为了应对日益出现的高速数据传输需求，比如诊断数据等，博世(Bosch)基于CAN扩展出了一个新的总线CAN-FD(Flexible Data-rate)协议, 于2012年发布并成为了国际标准（ISO 11898-1）。 CAN-FD将消息的长度扩展到最大支持64bit数据，从而提高了数据传输的速率。有关更多关于CAN-FD的信息可以参考:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/CAN_FD" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/CAN_FD</a></li>
<li><a href="https://www.ni.com/zh-cn/innovations/white-papers/14/understanding-can-with-flexible-data-rate--can-fd-.html" target="_blank" rel="noopener">https://www.ni.com/zh-cn/innovations/white-papers/14/understanding-can-with-flexible-data-rate--can-fd-.html</a></li>
</ul>
<h2 id="FlexRay"><a href="#FlexRay" class="headerlink" title="FlexRay"></a><strong>FlexRay</strong></h2><p><a href="https://en.wikipedia.org/wiki/FlexRay" target="_blank" rel="noopener">FlexRay</a>设计之初的目的在于提供更快，更可靠，更低延迟的ECU数据传输方法。随着汽车电子工业的发展，在2000年，宝马(BMW), 戴姆勒(Daimler)以及博世(Bosch)等厂商组成了<code>FlexRay</code>委员会，为了解决现有CAN总线上的一些缺陷创造一个新的总线协议，这就是FlexRay.:</p>
<ul>
<li>为了确保多个节点之间实现安全，实时实时的通讯，FlexRay中的每个节点都个共享相同的时间基准</li>
<li>FlexRay基于时间触发的消息机制，确保了安全相关的消息传输具有更低的时延</li>
<li>FlexRay通过双通道物理结构提供了更高的可靠性</li>
<li>FlexRay每个通道的最大理论速率能达到10Mb/s，是CAN总线的10倍</li>
</ul>
<p>FlexRay支持多种网络拓扑结构（星形/树状/多种拓扑混合），网络中的每个节点不能同时发送消息，因此需要通过冲突避免(collision avoidance)的方法来避免传输冲突;与CAN通过优先级来仲裁传输的方法不同，FlexRay使用了TDMA(Time Division Multiple Access)的方法来控制各个节点传输数据的顺序，每个节点都遵照事先设定的时序来使用总线。</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/flexray_frame_format.png" alt="Flexray frame format"></p>
<p>FlexRay的消息帧结构主要分为三部分：一个是帧头，一个是数据部分，最后一个是校验值。</p>
<ul>
<li>帧头的状态字(Status Bits): 占5位，每一位分别对应<ul>
<li>第一位保留用于后续使用</li>
<li>Payload Preamble Indicator（数据前导码标识): 区分static segment/dynamic segment</li>
<li>Null Frame Indicator: 表示消息未包含数据，数据位为空</li>
<li>Sync Frame Indicator: 时间同步帧标识</li>
<li>Startup Frame Indicator: 网络启动帧标识，只有被配置为启动(startup)的节点才能发送该消息</li>
</ul>
</li>
<li>Frame ID: 帧ID，表示消息所在的时间槽(slot ID),  与消息中的<code>Cycle</code>一起作为消息的唯一识别码，类似于CAN消息中的冲裁ID</li>
<li>Length: 数据长度</li>
<li>Header CRC: 帧循环冗余校验值</li>
<li>Cycle： 帧传输的周期（占用的时间）</li>
<li>Payload: 消息体</li>
<li>CRC: 消息体对应的校验码</li>
</ul>
<p>更多关于FlexRay的资料可以参考：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/FlexRay" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/FlexRay</a></li>
<li><a href="https://www.ni.com/zh-cn/innovations/white-papers/06/flexray-automotive-communication-bus-overview.html" target="_blank" rel="noopener">https://www.ni.com/zh-cn/innovations/white-papers/06/flexray-automotive-communication-bus-overview.html</a></li>
</ul>
<h2 id="MOST"><a href="#MOST" class="headerlink" title="MOST"></a><strong>MOST</strong></h2><p><a href="https://en.wikipedia.org/wiki/MOST_Bus" target="_blank" rel="noopener">MOST(Media Oriented Serial Transport)</a>, 直译过来就是基于媒体的串行传输总线，从字面意思可以看到，MOST就是为了解决汽车上日益增加的诸如音频/视频等数据传输需求设计的。在上世纪90年代，高端车型逐渐出现了诸如导航，音频，显示等复杂的媒体功能，为了应对这种日益增长娱乐系统需求，Harman (哈曼), BMW, Daimler, and Oasis Silicon Systems (即现在的Microchip Technology)组成了一个专门的合作团队，开发下一代汽车总线。目前MOST已广泛被BMW，Daimler，Volkswagen（大众），Volvo等欧洲豪华品牌采用，日美等汽车厂商则采用了基于UTP（Unshielded Twisted Pair）的MOST总线(MOST50).</p>
<p>想比较CAN与FlexRay等汽车总线，MOST具有如下特点：</p>
<ul>
<li>内置专门的通道用于音频/视频数据传输，更适合影音娱乐应用</li>
<li>最高可达150Mb/s传输速率，远高于CAN/LIN/FlexRay</li>
<li>MOST150支持MEP(Ethernet Packet Channel)用于IP数据的传输</li>
<li>支持光纤传输，可以消除电磁干扰(EMC, Electromagnetic Compatiblitity) ,并天然具备电气隔离能力</li>
</ul>
<p>MOST一般采用环形拓扑网络结构， 有一个主节点(timing master)用于控制所有同步通讯（synchronous communication), 同步帧(synchronous frame)会周期性（频率为48kHz)的从主控节点发送到网络中的各个节点，其他从节点在收到属于同步帧后主动把数据放到该同步帧的后面，继续发送到下一个节点。</p>
<p>对MOST协议来说，每个数据帧都划分为不同的<em>通道</em>(Channels), 每个通道都严格按照时间顺序均匀的传输数据，比如在同步帧中就包含了相同大小的音频数据，这样接收端拿到数据后就可以重新合成一个实时的音频流。下图是MOST150总线的一个数据帧的结构:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/most150_frame_format.png" alt="MOST150 frame format"></p>
<ul>
<li>CC(Control Channel): 控制通道用于协调网络的数据传输以及交换各个节点的状态信息</li>
<li>SYN/ISOC CH: 同步数据通道，该通道会动态的划分为其他通道以便于同时传输音频/视频/立体声等数据</li>
<li>ASYNC: 异步通道用于传输，用于传输事件通知/数据报文，新的协议已经被MEP通道取代</li>
<li>MEP(MOST Ethernet Packets): 在MOST150协议中使用，专门用于传输IP数据包，数据长度类似于以太网数据帧</li>
</ul>
<p>更多关于MOST总线相关的信息可以参考官网文档: <a href="https://www.mostcooperation.com/technology/most-network/" target="_blank" rel="noopener">https://www.mostcooperation.com/technology/most-network/</a></p>
<h2 id="LIN"><a href="#LIN" class="headerlink" title="LIN"></a><strong>LIN</strong></h2><p>在1990年代，BMW，Volvo，Audio等一众厂商发现，虽然CAN极大的改善了整车的布线复杂度与成本，但是在某些场景下还是过度的使用了，比如控制车窗/座椅，并不需要1Mb/s这样的速率以及专门的控制器，因此需要一个适合于低速/低成本场景下的布线方法。这就是LIN(Local Interconnect Network)的由来：</p>
<ul>
<li>LIN采用Master/Slave的网络结构，一个Master节点最多可以控制15个（包括自身则是16个）Slave节点</li>
<li>使用单一连接线，提供最高20kb/s的传输速率</li>
<li>无需专门的控制器(MicroControllers), 实现更为简单</li>
</ul>
<p>LIN网络数据的传输都是有Master节点来控制，主节点内置了一个调度表，用于控制何时传输哪个ID的消息。消息头在主节点产生后，对应ID的从节点收到该消息头就把数据放到消息的对应位置，然后接收节点通过检查消息帧的ID值来选择发送还是接收数据。下图是LIN消息帧的构成，主要包括消息头与响应：</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/lin_frame_format.png" alt="LIN frame format"></p>
<ul>
<li>Break: 帧的开始位，至少为11个连续0,最新的标准使用13个连续位0</li>
<li>SYNC: 为固定值0x55, 交替的0/1信号用于从节点与主节点传输同步</li>
<li>ID: 包含6为ID和2位奇偶校验位，每个节点都通过该值来确定是发送数据还是接收数据</li>
<li>Payload: 8字节数据</li>
<li>CS(Checksum): 数据校验值</li>
</ul>
<p>有关LIN的更多信息可以参考：</p>
<ul>
<li><a href="https://www.ni.com/zh-cn/innovations/white-papers/09/introduction-to-the-local-interconnect-network--lin--bus.html" target="_blank" rel="noopener">https://www.ni.com/zh-cn/innovations/white-papers/09/introduction-to-the-local-interconnect-network--lin--bus.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Local_Interconnect_Network" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Local_Interconnect_Network</a></li>
</ul>
<h2 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a><strong>Ethernet</strong></h2><p>相比较于上述几种汽车网络总线，Ethernet（以太网）可谓后起之秀。实际上，早在1970年代，以太网就随着互联网的诞生一起出现了，其被广泛用于各种终端设备的网络互联，40多年的经验表明以太网具备了很高的可靠性。但为何，持到最近这几年才真正应用到汽车电子领域，并成为一个有望全面取代CAN/LIN/MOST这些总线的绝杀器了？ 主要还是前期以太网在汽车上使用还有几个技术难题没有得到解决，比如电磁干扰，布线成本。2011年博通(Broadcom)公布了一项针对汽车以太网的解决方案<a href="https://en.wikipedia.org/wiki/BroadR-Reach" target="_blank" rel="noopener">BroadR-Reach</a>，汽车以太网（Automative Ethernet)随之遍地开花。目前，NXP，Broadcast，Marvell等汽车电子厂商都有AE相关的产品。</p>
<p>与CAN，MOST等总线相比，AE主要有几大特性：</p>
<ul>
<li>多家厂商支持，产品类别更为丰富，技术体系更为开放完善</li>
<li>广泛应用于局域网，基于TCP/IP协议，能够传输各种音视频数据，是作为汽车中枢网络的节点连接的理想选择</li>
<li>基于UTP双绞线，布线成本低<a href="https://zhuanlan.zhihu.com/p/69275361" target="_blank" rel="noopener">以太网双绞线</a>;基于差分信号，可以较少外界电磁干扰(Electromagnetic interference, EMI)</li>
</ul>
<p>经典以太网都是通过共享介质的方式进行互联，因此需要使用诸如CSMA/CD（Carrier Sense Muliptile Access with Collission Detection)的冲突监测技术来避免传输出错，而汽车以太网则通过点对点的连接实现了全双工通讯(full-duplex），即数据可以同时接收/发送，传输速率可到100Mb/s，下图是一个网络连接拓扑图：</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ae_network_topogy.png" alt="AE network topology"></p>
<p>通过网关，节点之间都是点对点连接，从Port1发送的数据只会发送给Port2，同样从Port0发送的数据不会发送给Port3,因此实现了全双工的通讯。最后来看一看以太网的帧结构：</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ethernet_frame_format.png" alt="Ethernet Frame format"></p>
<ul>
<li>Preamble: 前导码，交替1/0信号，用于同步传输与发送</li>
<li>SOF(Start Of Frame Delimiter): 用于标识帧的开始，分开前导码与帧数据</li>
<li>目标/源地址: SOF之后分别是6个字节的目标MAC/源MAC地址</li>
<li>802.3Q(VLAN/Priority): VLAN标签，在汽车以太网中用于AVB(Audio/Video Bridge)时用于标识包的优先级</li>
<li>TYPE: 以太网协议类型，参考<a href="https://en.wikipedia.org/wiki/EtherType" target="_blank" rel="noopener">EthernetType</a></li>
<li>Data: 数据，最长可以到1500字节（有网络的MTU设置有关）</li>
<li>FCS(Frame Checksum Sequence): 32位的CRC码</li>
</ul>
<p>目前车载以太网多用于仪表显示/自动驾驶等需要高速数据传输的场景。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul>
<li><a href="https://www.can-cia.org/can-knowledge/can/can-history/" target="_blank" rel="noopener">https://www.can-cia.org/can-knowledge/can/can-history/</a></li>
<li><a href="https://en.wikipedia.org/wiki/CAN_bus" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/CAN_bus</a></li>
<li><a href="https://www.ni.com/zh-cn/innovations/white-papers/06/controller-area-network--can--overview.html" target="_blank" rel="noopener">https://www.ni.com/zh-cn/innovations/white-papers/06/controller-area-network--can--overview.html</a></li>
<li><a href="https://www.ni.com/zh-cn/innovations/white-papers/06/flexray-automotive-communication-bus-overview.html" target="_blank" rel="noopener">https://www.ni.com/zh-cn/innovations/white-papers/06/flexray-automotive-communication-bus-overview.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/BroadR-Reach" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/BroadR-Reach</a></li>
<li>Automative Ethernet-Definitive Guide</li>
<li><a href="http://www.ieee802.org/3/1TPCESG/public/BroadR_Reach_Automotive_Spec_V3.0.pdf" target="_blank" rel="noopener">http://www.ieee802.org/3/1TPCESG/public/BroadR_Reach_Automotive_Spec_V3.0.pdf</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/69275361" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/69275361</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 汽车电子 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CAN </tag>
            
            <tag> MOST </tag>
            
            <tag> LIN </tag>
            
            <tag> Ethernet </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux内核中的锁]]></title>
      <url>http://sniffer.site/2020/10/23/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E9%94%81/</url>
      <content type="html"><![CDATA[<p>在看Linux内核代码时，经常会遇到各种锁(lock)的使用。对于像<code>spin_lock_irq</code>/<code>spin_lock_irqsave</code>的区别感到困惑，每次都要重新查一下资料。遂决定写一篇文章记录下内核中使用到的锁，以及使用的场景。</p>
<p>与应用中的锁类似，内核中的锁也只是为了保护某个内核数据结构或者内存区域在多个执行路径时不被破坏，确保数据的一致性。Linux内核作为应用层服务的提供者，一方面要为应用提供系统调用接口(<code>system call</code>)，代表用户进程执行任务,即<a href="https://tldp.org/LDP/LG/issue23/flower/intro.html" target="_blank" rel="noopener">process context</a>;同时与硬件直接交互，要响应硬件中断的请求，处理诸如网卡数据/串口数据等请求，即<a href="https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html" target="_blank" rel="noopener">Interrupt Context</a>. 内核就是在进程上下文/中断上下文直接来回切换，执行相应的任务请求。这就自然产生了数据的并发访问，产生了竞争条件(<code>race condition</code>)。另一方面，目前大多数的系统都是多核CPU的，多个CPU同时访问内核数据也同样会产生竞争条件。</p>
<p>简单来说，内核中锁要做的事情就是确保临界区&lt;<code>critical section</code>&gt;始终只有一个执行路径，就是说在有锁保护的情况下，临界区的执行不会被其他执行路径中断; 接下来，就分别看一看内核中常用的几个锁保护机制&lt;对应的代码实现在<code>/kernel/locking/</code>&gt;：</p>
<ul>
<li>semaphore(信号量）</li>
<li>Spin Lock(自旋锁）</li>
<li>Mutex(互斥锁）</li>
<li>Atomic(原子操作）</li>
</ul>
<h2 id="Semaphore-信号量）"><a href="#Semaphore-信号量）" class="headerlink" title="Semaphore(信号量）"></a><strong>Semaphore(信号量）</strong></h2><p><a href="https://en.wikipedia.org/wiki/Semaphore_(programming" target="_blank" rel="noopener"><code>semaphore</code></a>)是很常见的同步资源访问的方法，可以用于多个资源的访问控制;一般用于多个内核路径试图控制某个数据的并发访问，内核中对应的头文件在<code>linux/semaphore.h</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">  <span class="keyword">raw_spinlock_t</span>		lock;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		count;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述中<code>count</code>就是需要同步访问的资源个数，一般在内核中都设置为<code>1</code>，即等同于互斥锁。<code>semaphore</code>有两个常用的操作方法：</p>
<ul>
<li><code>down</code>: 获取锁，读应可用的资源减少，通常获取锁会将阻塞所执行的路径，让任务进入等待状态; 内核实现了好几种方法供调用：<ul>
<li><code>down</code>:  如果锁已被持有，则执行任务会被阻塞，在内核中不推荐使用该方法</li>
<li><code>down_interruptible</code>： 允许获取锁时被中断，在接收到中断信号后，返回中断错误<code>-EINTR</code></li>
<li><code>down_killable</code>: 执行任务阻塞时如果发生错误，则被中断返回<code>-EINTR</code></li>
<li><code>down_trylock</code>: 尝试获取锁，如果已被占用，则直接返回，该方法支持在中断上下文中使用</li>
<li><code>down_timeout</code>： 设置一个超时时间，超过该等待时间未获取到锁则返回<code>-ETIME</code></li>
</ul>
</li>
<li><code>up</code>: 释放锁，可以在任何执行路径执行该方法，即使未执行过<code>down</code>也可以进行锁的释放</li>
</ul>
<p>互斥锁的使用与<code>semaphore</code>比较类似，具体的使用可以参考源码<code>kernel/mutex.c</code>.</p>
<h2 id="spin-lock-自旋锁"><a href="#spin-lock-自旋锁" class="headerlink" title="spin lock(自旋锁)"></a><strong>spin lock(自旋锁)</strong></h2><p><code>spin lock</code>是内核中最常用的同步方法，通常用于多个CPU执行路径尝试访问同一个内存数据时的同步并且执行任务不能休眠的场景。与其他如<code>semaphore</code>不同的是，<code>spin lock</code>不会让锁等待者进入休眠状态，而是执行一个简单的循环等待，如果此时锁被释放，则会尝试获取锁，这样就避免了上下文切换，从而提升效率。一般如果锁等待的时间如果超过系统上下文切换的时间，使用<code>spin lock</code>则会较少任务的等待时间，改善系统性能。</p>
<p>除此之外，在某些特殊的场景比如在中断上下文与内核执行路径上共享数据时，就不能使用如<code>semaphore</code>这类会时执行任务休眠的同步锁，因为内核一旦在处理中断时，发生进程调度，则可能发生中断无法被处理的情况。同样地，在处理中断时，也不能使用<code>spin lock</code>以防止类似的情况;因此，在中断处理上下文中，使用<code>spin lock</code>时要将本地中断禁止。另外，在可能发生内核抢占(<code>kernel preemption</code>)的时候，如果被抢占任务执有<code>spin lock</code>，就可能导致该锁一直未被释放。总结来说，使用<code>spin lock</code>要注意如下几个原则:</p>
<ul>
<li>内核抢占应该被禁止，以防出现竞争条件</li>
<li>本地中断需要被禁止，防止中断无法处理的情况</li>
<li>持有锁的时间越短越好，避免引起性能问题</li>
</ul>
<p>跟上述几个场景对应，Linux中的<code>spin lock</code>提供了好几个函数来实现不同场景下的同步&lt;<code>linux/spinlock.h</code>&gt;：</p>
<ul>
<li><code>spin_lock</code>: 获取锁，如果锁被持有了，则等待</li>
<li><code>spin_lock_bh</code>： 获取锁，禁止了软中断/本地中断，但可以响应物理中断</li>
<li><code>spin_lock_irq</code>： 获取锁时打开中断</li>
<li><code>spin_lock_irqsave</code>： 获取锁时禁止本地中断</li>
</ul>
<p>上述几个函数的实现都在<code>kernel/locking/spinlock.c</code>中，如果不希望获取锁失败时等待，则可以通过<code>spin_trylock*</code>来实现。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="https://static.lwn.net/images/pdf/LDD3/ch05.pdf" target="_blank" rel="noopener">https://static.lwn.net/images/pdf/LDD3/ch05.pdf</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mutex </tag>
            
            <tag> Spin Lock </tag>
            
            <tag> Kernel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IPV6地址的那些事儿]]></title>
      <url>http://sniffer.site/2020/10/14/IPV6%E5%9C%B0%E5%9D%80%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
      <content type="html"><![CDATA[<p>前阵子在Android下调试一个只有IPv6地址的网络设备时，发现通过<code>ping6</code>来测试网络连通时提示错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ping6 fe80::47af:e871:3c63:a272</span><br><span class="line">connect: Invalid argument</span><br></pre></td></tr></table></figure>
<p><a href="https://stackoverflow.com/questions/44670778/ipv6-ping-connect-invalid-argument-on-android" target="_blank" rel="noopener">stackoverflow上有人说</a>这是一个<code>link-local address</code>本地链路地址，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use the following syntax on Android:</span><br><span class="line"></span><br><span class="line">ping6 fe80::405a:e0a5:e054:cbde%wlan0</span><br><span class="line"></span><br><span class="line">You must add %wlan0 since it is a link-local address, and your android device has multiple interfaces (Wi-Fi and mobile at least), so you need to tell your device the interface/link you want to use with this link-local address.</span><br></pre></td></tr></table></figure>
<p>所以在<code>ping</code>时需要加上端口，或者像这样&lt;亲测，Android设备不支持如下指令&gt;：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ping6 -I wlan0  fe80::47af:e871:3c63:a272</span><br></pre></td></tr></table></figure>
<p>那么，什么是本地链路地址(<code>link-local address</code>)？ 其跟IPv4中的局域网地址有什么不同的地方了？ 这里就来看下IPv6地址的一些细节。</p>
<h2 id="什么是link-local-地址"><a href="#什么是link-local-地址" class="headerlink" title="什么是link-local 地址"></a>什么是link-local 地址</h2><p>按照<a href="https://en.wikipedia.org/wiki/Link-local_address" target="_blank" rel="noopener">维基百科的解释</a>, <code>link-local</code>地址是一个只有在主机当前网段或者广播域才有效的地址。由于本地链路地址一般都是系统自动配置的，因此也被称为自动私有IP寻址(<code>automatic private IP addressing</code>)或者自动IP(<code>auto IP</code>):</p>
<ul>
<li>对IPv4来说，本地链路地址范围为: <code>169.254.0.0/16</code></li>
<li>IPv6的本地链路地址一般为: `fe80::/10</li>
</ul>
<p>在弄清楚IPv6<code>link-local</code>地址是如何自动分配之前，先来看下IPv6地址的格式以及分类。</p>
<h2 id="IPv6地址格式"><a href="#IPv6地址格式" class="headerlink" title="IPv6地址格式"></a>IPv6地址格式</h2><p>相比IPv4地址的32位，IPv6地址扩到了128位，一般有两部分组成：</p>
<ul>
<li>Network Prefix(网络前缀): 占n位，跟IPV4的网络ID类似</li>
<li>Interface ID(网口ID): 占余下的(128 - n)位， 类似于IPV4的主机ID</li>
</ul>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ipv6_address_format.png" alt="IPV6 address format"></p>
<p>IPv6的地址类型有单播(unicast), 组播(anycast), 多播(multicast)三种，而广播地址(broadcast)的功能则由多播地址替代：</p>
<ul>
<li>unicast address: 单播地址对应唯一的一个网口，发送给单播地址的数据包都只会发送到对应的网口上，根据不同的功能需要，单播地址又可以分为如下几个：</li>
</ul>
<table>
<thead>
<tr>
<th>单播地址类型</th>
<th>二进制前缀</th>
<th>IPV6缩写</th>
</tr>
</thead>
<tbody>
<tr>
<td>link-local unicast addresss</td>
<td>1111111010</td>
<td>FE80::/10</td>
</tr>
<tr>
<td>unique local unicast address</td>
<td>1111110</td>
<td>FC00::/7</td>
</tr>
<tr>
<td>loopback address</td>
<td>00…1(128bits)</td>
<td>::1/128</td>
</tr>
<tr>
<td>unspecified address</td>
<td>00..0(128bits)</td>
<td>::/128</td>
</tr>
<tr>
<td>Global unicast adress</td>
<td>其他</td>
</tr>
</tbody>
</table>
<ul>
<li><p>anycast address:  用于标识一组网口（通常属于不同的网络节点），发送给组播地址的数据会发送到该组网络节点中的一个</p>
</li>
<li><p>multicast address: 与anycast address类似，只是发送到该地址的数据会发送给该组所有的网络节点</p>
</li>
</ul>
<p>有关IPv6地址的具体描述，可以参考<a href="https://tools.ietf.org/html/rfc4291" target="_blank" rel="noopener">RFC4291</a></p>
<h2 id="link-local-address是如何生成的"><a href="#link-local-address是如何生成的" class="headerlink" title="link-local address是如何生成的"></a>link-local address是如何生成的</h2><p>对IPv6来说，<code>link-local</code>地址一般通过NDP(Neighbour Discovery Protocol)协议来实现自动配置：IPv6地址在设置之前，系统会先通过NDP协议发送消息确保要配置的IPv6地址在当前链路上具有唯一性，不与其他节点的IP地址发生冲突。</p>
<p>NDP协议类似与IPv4的ARP(Address Resolution Protocol)，不同的是NDP是基于ICMPv6, 更多关于NDP细节可以参考<a href="https://tools.ietf.org/html/rfc4862" target="_blank" rel="noopener">RFC4862</a>; Linux的实现可以参考源码：<code>/net/ipv6/ndisc.c</code></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://tools.ietf.org/html/rfc7404" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7404</a></li>
<li><a href="https://tools.ietf.org/html/rfc4862" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc4862</a></li>
<li><a href="https://en.wikipedia.org/wiki/Link-local_address" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Link-local_address</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 网络协议 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IPv6 </tag>
            
            <tag> ICMP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[由Policy Routing引发的一个奇怪问题]]></title>
      <url>http://sniffer.site/2020/06/03/%E7%94%B1Policy-Routing%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>最近新的项目又开始了, 开始还算顺利, 却不料碰到了一个奇怪的问题. 先来了解下问题的背景. 这个项目里, Android中有两个以太网网口, 一个用于内网通讯<eth0>, 不具备上外网的能力;一个用于外网通讯<eth1>, 使用该网口可以访问互联网. 在网络管理模块的工作完成后, 提交了代码我原本以为可以高枕无忧, 前两天组内的同学跑过来告诉我, 他有个系统服务一直没法通过<eth0>与内网的其他设备上的服务建立TCP链接, 但是网络却一直可以ping通; 而另外的一个开发板上却不存在这个问题. </eth0></eth1></eth0></p>
<p>开始我有点不相信竟然会有这样的问题, 但事实摆在面前, 我也不好抵赖, 于是自己找来一个板子, 看了下, 才逐渐找到答案. 问题的根源在于Android配置的策略路由<policy routing>规则隐含了一个针对系统默认网络的<code>fwmark</code>规则, 要解决问题, 只要我们将包含了<eth0>内网路由表的路由规则的优先级提升到高于Android隐含的这条规则即可. 虽然找到了解决方案, 但是还是决定花点时间把整个事情的来龙去脉都理清楚. </eth0></policy></p>
<p>大致分如下几个部分来讲一讲这个问题:</p>
<ul>
<li>介绍下什么是Policy Routing&lt;策略路由&gt;</li>
<li>分析具体的问题, 并给出方案</li>
<li>从源代码角度来分析下, 为何TCP无法建立, 但ping却可以</li>
</ul>
<h2 id="什么是Policy-Routing"><a href="#什么是Policy-Routing" class="headerlink" title="什么是Policy Routing"></a><strong>什么是Policy Routing</strong></h2><p>我们都知道, 传统的Linux路由都是基于目标IP地址来进行路由设置, 策略路由不同的是, 在原有路由表的基础上, 添加一系列具有优先级的规则, 这些规则可以根据数据包的入口&lt;本地或者lo&gt;, 出口, TOS&lt;<code>Type Of Service</code>&gt;, fwmark标签值, 协议以及端口号等来进行路由表的选择, 所有这些策略规则都放在一个称为<code>routing policy database</code><rpdb>的数据库中. 一般, 一条策略路由规则都由<code>selector</code>(选择器)以及<code>action predicate</code>(需要执行的动作)两部分组成; 通过<code>ip rule</code>指令, 我们可以修改/删除系统中的策略路由规则. 例如, 在Ubuntu系统中, 输入<code>ip rule list</code>, 大致是这样的:</rpdb></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">0</span>:	from all lookup local </span><br><span class="line"><span class="number">32766</span>:	from all lookup main </span><br><span class="line"><span class="number">32767</span>:	from all lookup <span class="keyword">default</span></span><br></pre></td></tr></table></figure>
<p>这些策略路由规则都是内核初始化时默认生成的, 按照规则的优先级大小排列, 数字越小, 优先级越高:</p>
<ul>
<li>优先级<code>0</code>: 会匹配任何数据包, 执行的动作是在<code>local</code>路由表<id 255>查找路由</id></li>
<li>优先级<code>32766</code>: 匹配任何数据包, 执行的动作是在<code>main</code>路由表<id 254>中查找路由</id></li>
<li>优先级<code>32767</code>: 匹配任何数据包, 执行的动作是在<code>default</code>路由表<id 253>中查找路由</id></li>
</ul>
<p>通过<code>man ip rule</code>我们可以查看到更多关于RP规则的信息. 而对于Android来说, 由于需要同时管理多个网络, 并根据网络权限/用户UID等来设置防火墙, 策略路由的规则就复杂了很多, 例如在我的开发板上输入<code>adb shell ip rule list</code>可以看到这么一大串的规则列表:</p>
<p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/android_ip_rules_list.png" alt="Android Ip Rule list examples"></p>
<p>这里, <code>eth0</code>就是用来作内网通讯用的网口, 而<code>usb0</code>是用来连接外网的网口, 当前系统默认的默认网络&lt;具有默认路由&gt;即<code>usb0</code>. Android的Netd(负责网络管理的native进程, 可以参考早前的文章了解更多信息<a href="http://sniffer.site/2018/12/18/Android-netd%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">Android Netd详解</a>)会把每个正常工作的网口都建立一个相应的路由表, 路由表的ID就是对应网络的<code>netID</code>&lt;每个网络在创建后都会分配一个唯一的ID&gt;, 例如通过输入<code>ip route show table usb0</code>查看路由表<code>usb0</code>实际是这样的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">default</span> via <span class="number">192.168</span><span class="number">.225</span><span class="number">.1</span> dev usb0 proto <span class="keyword">static</span> </span><br><span class="line"><span class="number">192.168</span><span class="number">.225</span><span class="number">.0</span>/<span class="number">24</span> dev usb0 proto <span class="keyword">static</span> scope link</span><br></pre></td></tr></table></figure>
<p>这张路由表包含了两个路由规则: 前一个是默认路由, 用于匹配外网数据(非<code>192.168.225.*</code>IP段的都会匹配该路由)的路由；后一个是用于该网卡局域网内IP地址的路由.上图中我们看到的这个RPDB实际是能正常工作的, 就是说通过<code>eth0</code>可以建立TCP连接, ping网络也正常, 后面在分析问题时会再贴出有问题的RPDB.</p>
<h2 id="网络ping通但无法建立TCP的问题"><a href="#网络ping通但无法建立TCP的问题" class="headerlink" title="网络ping通但无法建立TCP的问题"></a><strong>网络ping通但无法建立TCP的问题</strong></h2><p>出问题时的路由表<code>eth0</code>只有一个路由规则:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">172.20</span><span class="number">.1</span><span class="number">.0</span>/<span class="number">24</span> dev eth0 proto <span class="keyword">static</span> scope link</span><br></pre></td></tr></table></figure>
<p>相应的RPDB大致如下, 这里要说明的是<code>21300:    from all lookup main</code>这个查找<code>main</code>路由表的规则是需要自己添加的, Android原生代码已经把<code>main</code>表的查找规则剔除了, 对于同时有对个网卡共存的情况, <code>main</code>表是必须的, 否则基于<code>eth0</code>网口的局域网就无法正常ping通.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">0</span>:	from all lookup local </span><br><span class="line"><span class="number">10000</span>:	from all fwmark <span class="number">0xc0000</span>/<span class="number">0xd0000</span> lookup legacy_system </span><br><span class="line"><span class="number">10500</span>:	from all iif lo oif dummy0 uidrange <span class="number">0</span><span class="number">-0</span> lookup dummy0 </span><br><span class="line"><span class="number">10500</span>:	from all iif lo oif eth0 uidrange <span class="number">0</span><span class="number">-0</span> lookup eth0 </span><br><span class="line"><span class="number">10500</span>:	from all iif lo oif usb0 uidrange <span class="number">0</span><span class="number">-0</span> lookup usb0 </span><br><span class="line"><span class="number">13000</span>:	from all fwmark <span class="number">0x10063</span>/<span class="number">0x1ffff</span> iif lo lookup local_network </span><br><span class="line"><span class="number">13000</span>:	from all fwmark <span class="number">0x10064</span>/<span class="number">0x1ffff</span> iif lo lookup eth0 </span><br><span class="line"><span class="number">13000</span>:	from all fwmark <span class="number">0x10065</span>/<span class="number">0x1ffff</span> iif lo lookup usb0 </span><br><span class="line"><span class="number">14000</span>:	from all iif lo oif dummy0 lookup dummy0 </span><br><span class="line"><span class="number">14000</span>:	from all iif lo oif eth0 lookup eth0 </span><br><span class="line"><span class="number">14000</span>:	from all iif lo oif usb0 lookup usb0 </span><br><span class="line"><span class="number">15000</span>:	from all fwmark <span class="number">0x0</span>/<span class="number">0x10000</span> lookup legacy_system </span><br><span class="line"><span class="number">16000</span>:	from all fwmark <span class="number">0x0</span>/<span class="number">0x10000</span> lookup legacy_network </span><br><span class="line"><span class="number">17000</span>:	from all fwmark <span class="number">0x0</span>/<span class="number">0x10000</span> lookup local_network </span><br><span class="line"><span class="number">19000</span>:	from all fwmark <span class="number">0x64</span>/<span class="number">0x1ffff</span> iif lo lookup eth0 </span><br><span class="line"><span class="number">19000</span>:	from all fwmark <span class="number">0x65</span>/<span class="number">0x1ffff</span> iif lo lookup usb0 </span><br><span class="line"><span class="number">21300</span>:	from all lookup main </span><br><span class="line"><span class="number">22000</span>:	from all fwmark <span class="number">0x0</span>/<span class="number">0xffff</span> iif lo lookup usb0 </span><br><span class="line"><span class="number">32000</span>:	from all unreachable</span><br></pre></td></tr></table></figure>
<p>基于上述RPDB规则, 尝试测试内网某个设备的连通性: <code>ping 172.20.1.55</code>有看到回应, 但是如果通过ssh指令<code>ssh -vvv root@172.20.1.55</code>尝试登录到对端, 就会提示<code>No Route to Host</code>, 其他上层TCP连接也没法正常建立成功. 细心的同学可能已经发现, 在之前讲到的那个正常RPDB与这里的异常的RPDB唯一的区别就是在与<code>main</code>路由表查找规则的优先级, 一个是<code>21300</code>, 一个<code>18300</code>, 那么为什么优先级的差异会导致不一样的结果?</p>
<p>对于一般的TCP连接, 并不会指定连接的网口(通过<code>setsocktopt</code>的<code>SO_BINDTODEVICE</code>选项指定), 所以可以判定那些指定了<code>oif</code>(数据包出口)的<code>ip rule</code>规则应该不会导致问题的发生, 这里我们可以通过<code>ip rule add pref &lt;pref_no&gt; lookup main</code>调整这个规则的优先级, 通过二分查找测试几次就知道了. 在另外一方面, 测试的同学反馈, 如果没有接<code>usb0</code>这个网络设备, 问题就不会存在. 这样这个问题就更清晰了: 跟<code>usb0</code>路由表相关的几条规则是问题的关键. 排除掉指定了<code>oif</code>相关的规则, 只剩下两条:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">13000</span>:	from all fwmark <span class="number">0x10065</span>/<span class="number">0x1ffff</span> iif lo lookup usb0 </span><br><span class="line"><span class="number">19000</span>:	from all fwmark <span class="number">0x65</span>/<span class="number">0x1ffff</span> iif lo lookup usb0</span><br></pre></td></tr></table></figure>
<p>删除掉原有的规则<code>ip rule del pref 21300 lookup main</code>, 然后添加一个优先级高于第一条<code>13000</code>的规则<code>ip rule add pref 12800 lookup main</code>, 试验下发现TCP可以正常建立连接, 问题不存在;再次实验, 先删除<code>main</code>路由表对应的规则, 添加一条<code>ip rule add pref 18300 lookup main</code>的规则, 也可以正常建立TCP连接. 于是, 我们可以断定, 优先级为<code>19000</code>这条规则是罪魁祸首.解决问题的方案就是把原来的<code>main</code>查找的优先级高于<code>19000</code>即可.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ip rule add pref <span class="number">18300</span> lookup main</span><br></pre></td></tr></table></figure>
<p>问题是解决了, 可以为什么会这样了? 这条包含了<code>fwmark</code>的规则为何会让TCP连接没法正常建立而ping又可以了? 还是要<code>read the fucking source code</code>才能找到根本原因了.</p>
<h2 id="看看该死的源代码"><a href="#看看该死的源代码" class="headerlink" title="看看该死的源代码"></a><strong>看看该死的源代码</strong></h2><p>对于Android来说, 无论是Java的网络请求, 还是native的最终都会通过<code>libc</code>的封装的系统调用来完成. 因此, 第一步就来看看<code>libc</code>中对常用socket API的实现逻辑. 对应的源码位于<code>/bionic/libc</code>. 我们知道, 对于TCP客户端来说, 一般先调用<code>socket</code>创建套接字获取到文件描述符后, 会直接调用<code>connect</code>尝试连接到服务端, 由于创建socket不涉及到路由, 因此就来看看<code>connect</code>的具体调用逻辑. 找到<code>connect.cpp</code>, 代码很简单, 只有一行:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr* addr, <span class="keyword">socklen_t</span> addrlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __netdClientDispatch.connect(sockfd, addr, addrlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数直接是调用了<code>__netdClientDispatch</code>对应的实现, 从函数名字来看, 实际应该是把请求转发给<code>Netd</code>, 不妨接续看代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// private/NetdClientDispatch.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetdClientDispatch</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*accept4)(<span class="keyword">int</span>, struct sockaddr*, <span class="keyword">socklen_t</span>*, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*connect)(<span class="keyword">int</span>, <span class="keyword">const</span> struct sockaddr*, <span class="keyword">socklen_t</span>);</span><br><span class="line">    <span class="keyword">int</span> (*socket)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> (*netIdForResolv)(<span class="keyword">unsigned</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// NetdClientDispatch.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __i386__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __socketcall __attribute__((__cdecl__))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __socketcall</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __socketcall <span class="keyword">int</span> __accept4(<span class="keyword">int</span>, sockaddr*, <span class="keyword">socklen_t</span>*, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __socketcall <span class="keyword">int</span> __connect(<span class="keyword">int</span>, <span class="keyword">const</span> sockaddr*, <span class="keyword">socklen_t</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __socketcall <span class="keyword">int</span> __socket(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="title">fallBackNetIdForResolv</span><span class="params">(<span class="keyword">unsigned</span> netId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> netId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This structure is modified only at startup (when libc.so is loaded) and never</span></span><br><span class="line"><span class="comment">// afterwards, so it's okay that it's read later at runtime without a lock.</span></span><br><span class="line">__LIBC_HIDDEN__ NetdClientDispatch __netdClientDispatch __attribute__((aligned(<span class="number">32</span>))) = &#123;</span><br><span class="line">    __accept4,</span><br><span class="line">    __connect,</span><br><span class="line">    __socket,</span><br><span class="line">    fallBackNetIdForResolv,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>__netdClientDispatch</code>实际是封装了几个外部函数而已, 那么<code>__socket/__connect</code>/<code>__accept4</code>这几个函数又在哪里实现的了? 搜索下<code>libc</code>下面的代码, 发现原来在<code>libc</code>初始化的时候, 会加载一个<code>libnetd_client.so</code>的库, 然后把相应的实现加载过来:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// NetdClient.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FunctionType&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">netdClientInitFunction</span><span class="params">(<span class="keyword">void</span>* handle, <span class="keyword">const</span> <span class="keyword">char</span>* symbol, FunctionType* function)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*InitFunctionType)</span><span class="params">(FunctionType*)</span></span>;</span><br><span class="line">    InitFunctionType initFunction = <span class="keyword">reinterpret_cast</span>&lt;InitFunctionType&gt;(dlsym(handle, symbol));</span><br><span class="line">    <span class="keyword">if</span> (initFunction != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        initFunction(function);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">netdClientInitImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* netdClientHandle = dlopen(<span class="string">"libnetd_client.so"</span>, RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (netdClientHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// If the library is not available, it's not an error. We'll just use</span></span><br><span class="line">        <span class="comment">// default implementations of functions that it would've overridden.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    netdClientInitFunction(netdClientHandle, <span class="string">"netdClientInitAccept4"</span>,</span><br><span class="line">                          &amp;__netdClientDispatch.accept4);</span><br><span class="line">    netdClientInitFunction(netdClientHandle, <span class="string">"netdClientInitConnect"</span>,</span><br><span class="line">                          &amp;__netdClientDispatch.connect);</span><br><span class="line">    netdClientInitFunction(netdClientHandle, <span class="string">"netdClientInitNetIdForResolv"</span>,</span><br><span class="line">                          &amp;__netdClientDispatch.netIdForResolv);</span><br><span class="line">    netdClientInitFunction(netdClientHandle, <span class="string">"netdClientInitSocket"</span>, &amp;__netdClientDispatch.socket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> netdClientInitOnce = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __<span class="function">LIBC_HIDDEN__ <span class="keyword">void</span> <span class="title">netdClientInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pthread_once(&amp;netdClientInitOnce, netdClientInitImpl)) &#123;</span><br><span class="line">        async_safe_format_log(ANDROID_LOG_ERROR, <span class="string">"netdClient"</span>, <span class="string">"Failed to initialize netd_client"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有兴趣的可以看看<code>libc</code>具体的初始化流程. 这里, 我们直接跳到<code>libnetd_client.so</code>这个库去看看<code>netdClientInitConnect</code>的实现. 共享库<code>libnetd_client.so</code>的代码位于<code>/system/netd/client</code>目录, 其中有个文件<code>NetdClient.cpp</code>即实现了该函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// NetdClient.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netdClientConnect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr* addr, <span class="keyword">socklen_t</span> addrlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> shouldSetFwmark = (sockfd &gt;= <span class="number">0</span>) &amp;&amp; addr</span><br><span class="line">            &amp;&amp; FwmarkClient::shouldSetFwmark(addr-&gt;sa_family);</span><br><span class="line">    <span class="keyword">if</span> (shouldSetFwmark) &#123;</span><br><span class="line">        FwmarkCommand command = &#123;FwmarkCommand::ON_CONNECT, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">int</span> error = FwmarkClient().send(&amp;command, sockfd, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">            errno = -error;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Latency measurement does not include time of sending commands to Fwmark</span></span><br><span class="line">    Stopwatch s;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ret = libcConnect(sockfd, addr, addrlen);</span><br><span class="line">    <span class="comment">// Save errno so it isn't clobbered by sending ON_CONNECT_COMPLETE</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> connectErrno = errno;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> latencyMs = lround(s.timeTaken());</span><br><span class="line">    <span class="comment">// Send an ON_CONNECT_COMPLETE command that includes sockaddr and connect latency for reporting</span></span><br><span class="line">    <span class="keyword">if</span> (shouldSetFwmark &amp;&amp; FwmarkClient::shouldReportConnectComplete(addr-&gt;sa_family)) &#123;</span><br><span class="line">        <span class="function">FwmarkConnectInfo <span class="title">connectInfo</span><span class="params">(ret == <span class="number">0</span> ? <span class="number">0</span> : connectErrno, latencyMs, addr)</span></span>;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> get the netId from the socket mark once we have continuous benchmark runs</span></span><br><span class="line">        FwmarkCommand command = &#123;FwmarkCommand::ON_CONNECT_COMPLETE, <span class="comment">/* netId (ignored) */</span> <span class="number">0</span>,</span><br><span class="line">                                <span class="comment">/* uid (filled in by the server) */</span> <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// Ignore return value since it's only used for logging</span></span><br><span class="line">        FwmarkClient().send(&amp;command, sockfd, &amp;connectInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = connectErrno;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里的<code>Fwmark</code>等字样, 似乎有点眼熟了, 这个函数的逻辑是, 首先要判断一个socket链接是否要打上防火墙标签(Firewall Mark)<code>shouldSetFwmark</code>, 实际上对于TCP的socket来说, 该函数都返回<code>True</code>, 接着会将对应的socketFd通过一个本地<code>fwmarkd</code>这个socket发送给<code>FwmarkServer</code>, 由其负责将socket打上防火墙标签:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> FwmarkServer::processClient(SocketClient* client, <span class="keyword">int</span>* socketFd) &#123;</span><br><span class="line">    FwmarkCommand command;</span><br><span class="line">    FwmarkConnectInfo connectInfo;</span><br><span class="line"></span><br><span class="line">    iovec iov[<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123; &amp;command, <span class="keyword">sizeof</span>(command) &#125;,</span><br><span class="line">        &#123; &amp;connectInfo, <span class="keyword">sizeof</span>(connectInfo) &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    msghdr message;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;message, <span class="number">0</span>, <span class="keyword">sizeof</span>(message));</span><br><span class="line">    message.msg_iov = iov;</span><br><span class="line">    message.msg_iovlen = ARRAY_SIZE(iov);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        cmsghdr cmh;</span><br><span class="line">        <span class="keyword">char</span> cmsg[CMSG_SPACE(<span class="keyword">sizeof</span>(*socketFd))];</span><br><span class="line">    &#125; cmsgu;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(cmsgu.cmsg, <span class="number">0</span>, <span class="keyword">sizeof</span>(cmsgu.cmsg));</span><br><span class="line">    message.msg_control = cmsgu.cmsg;</span><br><span class="line">    message.msg_controllen = <span class="keyword">sizeof</span>(cmsgu.cmsg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> messageLength = TEMP_FAILURE_RETRY(recvmsg(client-&gt;getSocket(), &amp;message, MSG_CMSG_CLOEXEC));</span><br><span class="line">    <span class="keyword">if</span> (messageLength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!((command.cmdId != FwmarkCommand::ON_CONNECT_COMPLETE &amp;&amp; messageLength == <span class="keyword">sizeof</span>(command))</span><br><span class="line">            || (command.cmdId == FwmarkCommand::ON_CONNECT_COMPLETE</span><br><span class="line">            &amp;&amp; messageLength == <span class="keyword">sizeof</span>(command) + <span class="keyword">sizeof</span>(connectInfo)))) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADMSG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前用户是否有网络访问权限</span></span><br><span class="line">    Permission permission = mNetworkController-&gt;getPermissionForUser(client-&gt;getUid());</span><br><span class="line">    ...</span><br><span class="line">    Fwmark fwmark;</span><br><span class="line">    <span class="keyword">socklen_t</span> fwmarkLen = <span class="keyword">sizeof</span>(fwmark.intValue);</span><br><span class="line">    <span class="comment">// 获取当前socket上的fwmark</span></span><br><span class="line">    <span class="keyword">if</span> (getsockopt(*socketFd, SOL_SOCKET, SO_MARK, &amp;fwmark.intValue, &amp;fwmarkLen) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (command.cmdId) &#123;</span><br><span class="line">        <span class="keyword">case</span> FwmarkCommand::ON_ACCEPT: &#123;</span><br><span class="line">            <span class="comment">// Called after a socket accept(). The kernel would've marked the NetId and necessary</span></span><br><span class="line">            <span class="comment">// permissions bits, so we just add the rest of the user's permissions here.</span></span><br><span class="line">            permission = <span class="keyword">static_cast</span>&lt;Permission&gt;(permission | fwmark.permission);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> FwmarkCommand::ON_CONNECT: &#123;</span><br><span class="line">            <span class="comment">// Called before a socket connect() happens. Set an appropriate NetId into the fwmark so</span></span><br><span class="line">            <span class="comment">// that the socket routes consistently over that network. Do this even if the socket</span></span><br><span class="line">            <span class="comment">// already has a NetId, so that calling connect() multiple times still works.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// But if the explicit bit was set, the existing NetId was explicitly preferred (and not</span></span><br><span class="line">            <span class="comment">// a case of connect() being called multiple times). Don't reset the NetId in that case.</span></span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// 这里explicitlySelected为false, 因此实际会选择默认网络的netId</span></span><br><span class="line">            <span class="keyword">if</span> (!fwmark.explicitlySelected) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fwmark.protectedFromVpn) &#123;</span><br><span class="line">                    fwmark.netId = mNetworkController-&gt;getNetworkForConnect(client-&gt;getUid());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mNetworkController-&gt;isVirtualNetwork(fwmark.netId)) &#123;</span><br><span class="line">                    fwmark.netId = mNetworkController-&gt;getDefaultNetwork();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">    fwmark.permission = permission;</span><br><span class="line">    <span class="comment">// 将该socket打上防火墙的标签, 这个实际就是用来给内核选择路由时用的</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(*socketFd, SOL_SOCKET, SO_MARK, &amp;fwmark.intValue,</span><br><span class="line">                  <span class="keyword">sizeof</span>(fwmark.intValue)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这一步, 我们大概知道, <code>fwmark</code>实际是一个32位的整型数值, 其中网络的<code>netId</code>占了低16位, 网络权限<code>permission</code>占了2位, 这样系统所有的TCP连接都会被打上<code>fwmark</code>. 那么, 内核的RPDB规则又何时被添加过去的了? 我们再来看看<code>Netd</code>的代码.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">union</span> Fwmark &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> intValue;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> netId          : <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">bool</span> explicitlySelected :  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> protectedFromVpn   :  <span class="number">1</span>;</span><br><span class="line">        Permission permission   :  <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">bool</span> uidBillingDone     :  <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    constexpr Fwmark() : intValue(0) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Android对网络路由相关的管理与控制逻辑都放在<code>/system/netd/server/RouteController.cpp</code>中, 找到对应开始引起问题的那个RP规则, 其优先级为<code>19000</code>, 这正好是<code>RULE_PRIORITY_IMPLICIT_NETWORK</code>这个值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19000:	from all fwmark 0x65/0x1ffff iif lo lookup usb0</span><br></pre></td></tr></table></figure>
<p>搜索这个关键字, 可以看到Netd会在创建无需任何权限的<code>PhysicalNetwork</code>对象时, 会根据网络的netId时生成一条隐性的策略路由规则<code>modifyImplicitNetworkRule</code>: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">WARN_UNUSED_RESULT <span class="keyword">int</span> RouteController::modifyPhysicalNetwork(<span class="keyword">unsigned</span> netId, <span class="keyword">const</span> <span class="keyword">char</span>* interface,</span><br><span class="line">                                                              Permission permission, <span class="keyword">bool</span> add) &#123;</span><br><span class="line">  <span class="comment">//if network id has register interface, other interface route add to the table with interface registered by netid</span></span><br><span class="line">  ....</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">int</span> ret = modifyIncomingPacketMark(netId, interface, permission, add)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">int</span> ret = modifyExplicitNetworkRule(netId, table, permission, INVALID_UID, INVALID_UID,</span><br><span class="line">                                            add)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">int</span> ret = modifyOutputInterfaceRules(interface, table, permission, INVALID_UID, INVALID_UID,</span><br><span class="line">                                            add)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only set implicit rules for networks that don't require permissions.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is so that if the default network ceases to be the default network and then switches</span></span><br><span class="line">    <span class="comment">// from requiring no permissions to requiring permissions, we ensure that apps only use the</span></span><br><span class="line">    <span class="comment">// network if they explicitly select it. This is consistent with destroySocketsLackingPermission</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (permission == PERMISSION_NONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> modifyImplicitNetworkRule(netId, table, add);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数会设置一个值为默认网络<code>netId</code>的<code>fwmark</code>, 也就是我们最开始看到的那条优先级为<code>19000</code>的规则, 并通过类型为<code>NETLINK_ROUTE</code>的netlink向内核配置该规则, 内核就会根据这条规则来匹配上对应的TCP包, 因而就会出现我们最开始的那个问题:使用TCP连接会提示<code>No Route to Host</code>, 那为何ping不存在这个问题了? </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">WARN_UNUSED_RESULT <span class="keyword">int</span> <span class="title">modifyImplicitNetworkRule</span><span class="params">(<span class="keyword">unsigned</span> netId, <span class="keyword">uint32_t</span> table, <span class="keyword">bool</span> add)</span> </span>&#123;</span><br><span class="line">    Fwmark fwmark;</span><br><span class="line">    Fwmark mask;</span><br><span class="line"></span><br><span class="line">    fwmark.netId = netId;</span><br><span class="line">    mask.netId = FWMARK_NET_ID_MASK;</span><br><span class="line"></span><br><span class="line">    fwmark.explicitlySelected = <span class="literal">false</span>;</span><br><span class="line">    mask.explicitlySelected = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    fwmark.permission = PERMISSION_NONE;</span><br><span class="line">    mask.permission = PERMISSION_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> modifyIpRule(add ? RTM_NEWRULE : RTM_DELRULE, RULE_PRIORITY_IMPLICIT_NETWORK, table,</span><br><span class="line">                        fwmark.intValue, mask.intValue, IIF_LOOPBACK, OIF_NONE, INVALID_UID,</span><br><span class="line">                        INVALID_UID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们都知道ping一般是基于<code>IPPROTO_ICMP</code>协议, 实际发送ping的<code>ECHO_REQUEST</code>时, 只需要创建一个<code>socket</code>接口, 然后直接通过<code>sendto</code>发送对应的数据报文就好了;从刚开始的代码知道, libc会把socket相关的请求转发给Netd, 我们直接看Netd中<code>NetdClient.cpp</code>的建立socket相关的代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="keyword">atomic_uint</span> <span class="title">netIdForProcess</span><span class="params">(NETID_UNSET)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netdClientSocket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> socketFd = libcSocket(domain, type, protocol);</span><br><span class="line">    <span class="keyword">if</span> (socketFd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> netId = netIdForProcess;</span><br><span class="line">    <span class="keyword">if</span> (netId != NETID_UNSET &amp;&amp; FwmarkClient::shouldSetFwmark(domain)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">int</span> error = setNetworkForSocket(netId, socketFd)) &#123;</span><br><span class="line">            <span class="keyword">return</span> closeFdAndSetErrno(socketFd, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> socketFd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数首先会调用libc创建socket, ping的时候并没有调用<code>setNetworkForProcess</code>指定网络netId, 因此实际路由时会跳过<code>19000</code>这条规则, 使用的是后面<code>21300</code>这个main路由规则来进行路由选择. 至此问题的谜团也算揭开了.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul>
<li><a href="http://linux-ip.net/html/routing-tables.html#list-routing-route-types" target="_blank" rel="noopener">http://linux-ip.net/html/routing-tables.html#list-routing-route-types</a></li>
<li><a href="https://www.man7.org/linux/man-pages/man8/ip-rule.8.html" target="_blank" rel="noopener">https://www.man7.org/linux/man-pages/man8/ip-rule.8.html</a></li>
<li><a href="https://www.drdobbs.com/policy-routing-in-linux/199100936" target="_blank" rel="noopener">https://www.drdobbs.com/policy-routing-in-linux/199100936</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Policy Routing </tag>
            
            <tag> 策略路由 </tag>
            
            <tag> 网络管理 </tag>
            
            <tag> Netd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[软件开发与BUG的那些事儿]]></title>
      <url>http://sniffer.site/2020/05/27/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%8EBUG%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Excellence in any department can be attained only by the labor of a lifetime;it is not to be purchased at a lesser price</p>
<p>Paul Graham</p>
</blockquote>
<p>前段时间, 看新闻说<a href="https://www.ithome.com/0/484/241.htm" target="_blank" rel="noopener">“微软4万多的软件开发工程师, 每天产生进3万个BUG”</a>, 当时感觉有点震惊, 然后就哑然失笑. 震惊的是连微软这样厉害的公司, 工程师应该都很优秀, 人才济济, 为何却会每天产生这么多的BUG了? <a id="more"></a>于是,再想想自己的开发经历, 才恍然明白: 开发人员一旦走进办公室,打开电脑写代码, 就不可避免的要写出BUG来. 与BUG纠缠不清似乎是每个开发人员的宿命.恰逢最近遇到了一个BUG, 让我纠结不已, 痛定思痛, 觉得有必要把自己的开发”心得经验”写下来, 权当是给自己一点警醒, 给自己一点回顾的资料, 分享下自己在开发过程中遇到的困难与挫折, 苦恼与迷惑.</p>
<ul>
<li>对业务理解的越深, 你对可能发生的问题就越透彻；认真思考每个需求/每行代码背后蕴含的业务逻辑, 这对于实现更优秀的方案具有重要的作用. 要对你所负责的业务领域的知识有广泛的把握, 这样也能够帮助你快速深入的进入一个全新的领域.</li>
<li>对于要提交的每个PR(Pull Request), 在提交前自己先过一遍, 检查格式, 检查拼写, 检查PR的描述是否清晰简单明确, 检查功能实现是否与需求一致, 同时还要问问自己这个修改是否有可以优化改进的地方, 是否存在更好的解决策略? 是否有疏漏的地方? 只有完整的走了必须的checklist, 才真正加上代码reviewer.</li>
<li>在每次实现方案, 提交代码时, 首先要摒弃的是”这个实现很完美, 我敢打包票, 毫无疑问没有问题了”类似这种自信爆棚的观念, 首先要正视可能存在的缺陷, 正视自己当前对于问题的认知可能还有不完善的地方, 把可能存在漏洞的地方在代码实现处comment出来, 这样后面再来看代码时可能会有更好的思路.</li>
<li>现代软件项目开发的核心在于高质量且如期交付产品, 而要确保高质量与项目日程预期的达成, 核心在于管控软件开发中的风险点. 因此, 对于大部分公司开发软件来说, 都要有质量/测试/开发多个部门的通力合作才能达成这一目标.对与软件开发工程师而言, 在确保自己提交代码的质量, 减少BUG的数量的同时, 还要关注项目日程安排, 确保修改正常合入到正确的分支, 确保给到用户都是稳定可靠/BUG更少的版本.时刻铭记交付质量对于一个优秀工程师来说至关重要.</li>
<li>产生的任何BUG都要保持警惕, 而不是防御心态: 总觉得这个BUG不是我的责任, 不会是我代码实现产生的问题, 当别人指出来你的错误时, 不是保持开放的思考, 而是一味的浪费时间与人纠缠争吵, 不敢承认自己思维上存在的问题; 一旦确认了BUG, 就要坦然面对, 而不是藏着掩着;诚实的面对自己犯下的错误, 总结经验教训, 这不仅能让你赢得同事的认可与信任, 也能让领导对你放心.</li>
<li>不时的想一想你的客户是谁? 你的客户不仅是产品的使用者, 也是你的上司, 你的同事, 你要确保你的每个产出物都具备高质量, 能让使用者感到舒服, 感到可信赖.要对自己所做的每件事情都负责, 对上司交代的任务要反馈; 对同事的问题要多关心;对产品的质量要严格的把控.</li>
<li>不满足于已有的知识, 不停的学习新的技能, 反复总结打磨自己的知识系统, 长此以往, 你的能力与视野就会得到质的改变；学习的同时, 也要不断的总结, 将所学所思分享给身边的同事, 保持影响力</li>
<li>软件从业人员经常被工作进度压得传不过气来, 时间紧张, 以至于忽略了锻炼身体. 想要平时尽量产生BUG, 保持良好的生活习惯, 必不可少. 这么看起来, 写好代码, 少产生BUG, 不仅仅是一个逻辑问题, 更是一个程序员自我修养与提高的问题</li>
<li>养成良好的工作习惯: 不时的总结些提升工作效率的方法, 比如修改分支代码时, 先同步远端代码<code>git pull --rebase</code>; 修改好的代码要及时保存; 重要的数据要做好备份; 及时的梳理知识结构, 有时间最好将心得总结写下来</li>
<li>遵从项目流程，即便是日程紧急，也要遵守项目规范，确保发出的版本是可靠稳定的;定期发布版本，每个版本都要有对应的release分支(<em>_</em>笑，最近我们有个项目自始至终都只有一个dev分支，项目后期风险不断，时不时的掉坑里）</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 软件工程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件开发 </tag>
            
            <tag> BUG </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 项目管理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从NAPI说一说Linux内核数据的接收流程]]></title>
      <url>http://sniffer.site/2020/05/12/%E4%BB%8ENAPI%E8%AF%B4%E4%B8%80%E8%AF%B4Linux%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/New_API" target="_blank" rel="noopener">NAPI(New API)</a>是Linux内核针对网络数据传输做出的一个优化措施，其目的是在高负载的大数据传输时，驱动收到硬件中断后，通过poll方式将传输过来的数据包统一处理， 通过禁止网络设备中断以减少硬件中断数量((Interrupt Mitigation)，从而实现更高的数据传输。</p>
<p>基于NAPI接口， 一般的网络传输都有如下几个步骤：</p>
<ul>
<li>网络设备驱动加载与初始化（配置IP等）</li>
<li>数据包从网络侧发送到网卡(Network Interface Controller, NIC)</li>
<li>通过<a href="https://en.wikipedia.org/wiki/Direct_memory_access" target="_blank" rel="noopener">DMA(Direct Memory Access)</a>，将数据从网卡拷贝到内存的环形缓冲区(ring buffer)</li>
<li>NIC产生硬件中断告知内核有新的数据包达到了</li>
<li>网卡驱动收到中断后调用NAPI接口开启poll线程（如果当前没有正在执行的线程）(常规数据传输直接处理NIC的中断时中间一般通过调用<code>netif_rx_action</code>来发起数据接收）</li>
<li><code>ksoftirqd</code>（内核启动时每个CPU上都会启动这样一个线程）线程负责调用NAPI的<code>poll</code>接口来获取内存环形缓冲区的数据包</li>
<li>通过DMA传输到内存中的数据包，最终通过<code>sk_buff</code>的形式传递给上层网络协议栈（TCP/IP层)</li>
<li>如果支持数据包转发(packet steering)或者NIC本身支持多个接收队列的话, 从网卡过来的数据会在不同的CPU之间进行分发</li>
<li>网络协议栈处理数据包，并将其发送到对应的<code>socket</code>接收缓冲区</li>
</ul>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/network_recieving_process.png" alt="网络数据接收流程"></p>
<p>下面就结合具体的代码来看看数据是如何一步步接收的（以intel的千兆以太网卡为例<code>kernel/drivers/net/intel/e1000</code>）。</p>
<h2 id="驱动加载与设备初始化"><a href="#驱动加载与设备初始化" class="headerlink" title="驱动加载与设备初始化"></a><strong>驱动加载与设备初始化</strong></h2><p>看<code>e1000_main.c</code>代码，驱动的初始化首先要做的是注册一个<code>pci</code>设备驱动到内核，这样设备枚举的时候会匹配到该网卡</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">e1000_init_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	pr_info(<span class="string">"%s - version %s\n"</span>, e1000_driver_string, e1000_driver_version);</span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">"%s\n"</span>, e1000_copyright);</span><br><span class="line"></span><br><span class="line">	ret = pci_register_driver(&amp;e1000_driver);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(e1000_init_module);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">e1000_driver</span> = &#123;</span></span><br><span class="line">	.name     = e1000_driver_name,</span><br><span class="line">	.id_table = e1000_pci_tbl,</span><br><span class="line">	.probe    = e1000_probe,</span><br><span class="line">	.remove   = e1000_remove,</span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line">	<span class="comment">/* Power Management Hooks */</span></span><br><span class="line">	.suspend  = e1000_suspend,</span><br><span class="line">	.resume   = e1000_resume,</span><br><span class="line">#endif</span><br><span class="line">	.shutdown = e1000_shutdown,</span><br><span class="line">	.err_handler = &amp;e1000_err_handler</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>匹配到网卡后， pci总线会调用驱动的<code>probe</code>函数， 大致会做如下几个事情：</p>
<ul>
<li>调用<code>alloc_etherdev</code> 分配一个网络设备对象，并注册到系统中</li>
<li>通过<code>netif_napi_add</code>添加NAPI的poll接口</li>
<li>设置网卡寄存器IO映射内存区域</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">e1000_probe</span><span class="params">(struct pci_dev *pdev, <span class="keyword">const</span> struct pci_device_id *ent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	....</span><br><span class="line">	err = pci_request_selected_regions(pdev, bars, e1000_driver_name);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_pci_reg;</span><br><span class="line"></span><br><span class="line">	pci_set_master(pdev);</span><br><span class="line">	err = pci_save_state(pdev);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_etherdev;</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	<span class="comment">// 分配以太网网络对象</span></span><br><span class="line">	netdev = alloc_etherdev(<span class="keyword">sizeof</span>(struct e1000_adapter));</span><br><span class="line">	<span class="keyword">if</span> (!netdev)</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_etherdev;</span><br><span class="line"></span><br><span class="line">	SET_NETDEV_DEV(netdev, &amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	pci_set_drvdata(pdev, netdev);</span><br><span class="line">	adapter = netdev_priv(netdev);</span><br><span class="line">	adapter-&gt;netdev = netdev;</span><br><span class="line">	adapter-&gt;pdev = pdev;</span><br><span class="line">	adapter-&gt;msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);</span><br><span class="line">	adapter-&gt;bars = bars;</span><br><span class="line">	adapter-&gt;need_ioport = need_ioport;</span><br><span class="line"></span><br><span class="line">	hw = &amp;adapter-&gt;hw;</span><br><span class="line">	hw-&gt;back = adapter;</span><br><span class="line"></span><br><span class="line">	err = -EIO;</span><br><span class="line">	<span class="comment">// 映射寄存器IO区域</span></span><br><span class="line">	hw-&gt;hw_addr = pci_ioremap_bar(pdev, BAR_0);</span><br><span class="line">	<span class="keyword">if</span> (!hw-&gt;hw_addr)</span><br><span class="line">		<span class="keyword">goto</span> err_ioremap;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (adapter-&gt;need_ioport) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = BAR_1; i &lt;= BAR_5; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pci_resource_len(pdev, i) == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (pci_resource_flags(pdev, i) &amp; IORESOURCE_IO) &#123;</span><br><span class="line">				hw-&gt;io_base = pci_resource_start(pdev, i);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* make ready for any if (hw-&gt;...) below */</span></span><br><span class="line">	err = e1000_init_hw_struct(adapter, hw);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_sw_init;	</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 设置网络设备对象的操作接口</span></span><br><span class="line">	netdev-&gt;netdev_ops = &amp;e1000_netdev_ops;</span><br><span class="line">	e1000_set_ethtool_ops(netdev);</span><br><span class="line">	netdev-&gt;watchdog_timeo = <span class="number">5</span> * HZ;</span><br><span class="line">	<span class="comment">// 添加napi的poll接口</span></span><br><span class="line">	netif_napi_add(netdev, &amp;adapter-&gt;napi, e1000_clean, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strncpy</span>(netdev-&gt;name, pci_name(pdev), <span class="keyword">sizeof</span>(netdev-&gt;name) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	adapter-&gt;bd_number = cards_found;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* setup the private structure */</span></span><br><span class="line"></span><br><span class="line">	err = e1000_sw_init(adapter);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_sw_init;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_valid_ether_addr(netdev-&gt;dev_addr))</span><br><span class="line">		e_err(probe, <span class="string">"Invalid MAC Address\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	INIT_DELAYED_WORK(&amp;adapter-&gt;watchdog_task, e1000_watchdog);</span><br><span class="line">	INIT_DELAYED_WORK(&amp;adapter-&gt;fifo_stall_task,</span><br><span class="line">			  e1000_82547_tx_fifo_stall_task);</span><br><span class="line">	INIT_DELAYED_WORK(&amp;adapter-&gt;phy_info_task, e1000_update_phy_info_task);</span><br><span class="line">	INIT_WORK(&amp;adapter-&gt;reset_task, e1000_reset_task);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize the wol settings based on the eeprom settings */</span></span><br><span class="line">	adapter-&gt;wol = adapter-&gt;eeprom_wol;</span><br><span class="line">	device_set_wakeup_enable(&amp;adapter-&gt;pdev-&gt;dev, adapter-&gt;wol);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Auto detect PHY address */</span></span><br><span class="line">	<span class="keyword">if</span> (hw-&gt;mac_type == e1000_ce4100) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">			hw-&gt;phy_addr = i;</span><br><span class="line">			e1000_read_phy_reg(hw, PHY_ID2, &amp;tmp);</span><br><span class="line">			<span class="keyword">if</span> (tmp == <span class="number">0</span> || tmp == <span class="number">0xFF</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i == <span class="number">31</span>)</span><br><span class="line">					<span class="keyword">goto</span> err_eeprom;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* reset the hardware with the new settings */</span></span><br><span class="line">	e1000_reset(adapter);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置网卡名字，注册网络设备对象</span></span><br><span class="line">	<span class="built_in">strcpy</span>(netdev-&gt;name, <span class="string">"eth%d"</span>);</span><br><span class="line">	err = register_netdev(netdev);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err_register;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/* carrier off reporting is important to ethtool even BEFORE open */</span></span><br><span class="line">	netif_carrier_off(netdev);</span><br><span class="line"></span><br><span class="line">	e_info(probe, <span class="string">"Intel(R) PRO/1000 Network Connection\n"</span>);</span><br><span class="line"></span><br><span class="line">	cards_found++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这一步网卡还不是可用状态，需要通过手动<code>ifconfig eth0 up/ifconfig eth0 &lt;ip&gt;</code>， 设置网卡为<code>UP</code>时，会调用驱动的<code>ndo_open</code>函数：</p>
<ul>
<li>请求硬件中断，并使能该中断</li>
<li><code>napi_enable</code>开启napi</li>
<li>启动网络的发送队列，允许发送数据</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">e1000_open</span><span class="params">(struct net_device *netdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">e1000_adapter</span> *<span class="title">adapter</span> = <span class="title">netdev_priv</span>(<span class="title">netdev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">e1000_hw</span> *<span class="title">hw</span> = &amp;<span class="title">adapter</span>-&gt;<span class="title">hw</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	netif_carrier_off(netdev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate transmit descriptors */</span></span><br><span class="line">	err = e1000_setup_all_tx_resources(adapter);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate receive descriptors */</span></span><br><span class="line">	err = e1000_setup_all_rx_resources(adapter);</span><br><span class="line"></span><br><span class="line">	e1000_power_up_phy(adapter);</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	err = e1000_request_irq(adapter);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* From here on the code is the same as e1000_up() */</span></span><br><span class="line">	clear_bit(__E1000_DOWN, &amp;adapter-&gt;flags);</span><br><span class="line"></span><br><span class="line">	napi_enable(&amp;adapter-&gt;napi);</span><br><span class="line"></span><br><span class="line">	e1000_irq_enable(adapter);</span><br><span class="line"></span><br><span class="line">	netif_start_queue(netdev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fire a link status change interrupt to start the watchdog */</span></span><br><span class="line">	ew32(ICS, E1000_ICS_LSC);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> E1000_SUCCESS;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此时网卡正常工作， 再来看看数据接收的具体流程。</p>
<h2 id="网卡数据接收"><a href="#网卡数据接收" class="headerlink" title="网卡数据接收"></a><strong>网卡数据接收</strong></h2><p>网卡数据的接收大概有三个步骤：</p>
<ul>
<li>网卡发送中断给驱动</li>
<li>驱动处理函数处理中断，并启动一个<code>napi</code>处理任务</li>
<li>发送接收数据的软中断<code>NET_RX_SOFTIRQ</code></li>
<li>内核线程处理网络软中断，将数据包发送给上层协议栈</li>
</ul>
<h3 id="处理网卡中断"><a href="#处理网卡中断" class="headerlink" title="处理网卡中断"></a><strong>处理网卡中断</strong></h3><p>在网卡驱动初始化的过程，我们看到驱动会向内核请求中断, 并注册一个中断处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">e1000_request_irq</span><span class="params">(struct e1000_adapter *adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span> = <span class="title">adapter</span>-&gt;<span class="title">netdev</span>;</span></span><br><span class="line">	<span class="keyword">irq_handler_t</span> handler = e1000_intr;</span><br><span class="line">	<span class="keyword">int</span> irq_flags = IRQF_SHARED;</span><br><span class="line"></span><br><span class="line">	err = request_irq(adapter-&gt;pdev-&gt;irq, handler, irq_flags, netdev-&gt;name,</span><br><span class="line">		          netdev);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当网卡产生数据中断后，调用中断处理函数： 对于napi来说，首先要禁止当前网卡的中断，如果当前没有在运行的napi任务，则调度一个新的napi任务<code>__napi_schedule</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> irqreturn_t <span class="title">e1000_intr</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* disable interrupts, without the synchronize_irq bit */</span></span><br><span class="line">	ew32(IMC, ~<span class="number">0</span>);</span><br><span class="line">	E1000_WRITE_FLUSH();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(napi_schedule_prep(&amp;adapter-&gt;napi))) &#123;</span><br><span class="line">		adapter-&gt;total_tx_bytes = <span class="number">0</span>;</span><br><span class="line">		adapter-&gt;total_tx_packets = <span class="number">0</span>;</span><br><span class="line">		adapter-&gt;total_rx_bytes = <span class="number">0</span>;</span><br><span class="line">		adapter-&gt;total_rx_packets = <span class="number">0</span>;</span><br><span class="line">		__napi_schedule(&amp;adapter-&gt;napi);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* this really should not happen! if it does it is basically a</span></span><br><span class="line"><span class="comment">		 * bug, but not a hard error, so enable ints and continue</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;flags))</span><br><span class="line">			e1000_irq_enable(adapter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动napi任务，发送软中断"><a href="#启动napi任务，发送软中断" class="headerlink" title="启动napi任务，发送软中断"></a><strong>启动napi任务，发送软中断</strong></h3><p><code>__napi_schedule</code>在<code>/kernel/net/core/dev.c</code>中，其实际做了两件事：</p>
<ul>
<li>将<code>napi_struct</code>添加到中断处理CPU的<code>softnet_data</code>对应的poll列表中</li>
<li>发出一个<code>NET_RX_SOFTIRQ</code>的软中断，让内核线程<code>ksoftirqd</code>来处理对应的该<code>softirq</code>软中断</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> __napi_schedule(struct napi_struct *n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	____napi_schedule(this_cpu_ptr(&amp;softnet_data), n);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> ____napi_schedule(struct softnet_data *sd,</span><br><span class="line">				     struct napi_struct *napi)</span><br><span class="line">&#123;</span><br><span class="line">	list_add_tail(&amp;napi-&gt;poll_list, &amp;sd-&gt;poll_list);</span><br><span class="line">	__raise_softirq_irqoff(NET_RX_SOFTIRQ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__raise_softirq_irqoff</code>函数在<code>/kernel/softirq.c</code>中定义，其作用就是将当前CPU对应的<code>softirq</code>状态标记为待运行状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> __raise_softirq_irqoff(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span><br><span class="line">&#123;</span><br><span class="line">	trace_softirq_raise(nr);</span><br><span class="line">	or_softirq_pending(<span class="number">1U</span>L &lt;&lt; nr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理网络软中断"><a href="#处理网络软中断" class="headerlink" title="处理网络软中断"></a><strong>处理网络软中断</strong></h3><p>内核在初始化的时候，每个CPU上都会启动一个专门的<code>ksoftirqd%d</code>（<code>%d</code>对应CPU的ID）内核线程用于处理CPU上的软中断（代码同样在<code>softirq.c</code>)中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">smp_hotplug_thread</span> <span class="title">softirq_threads</span> = &#123;</span></span><br><span class="line">	.store			= &amp;ksoftirqd,</span><br><span class="line">	.thread_should_run	= ksoftirqd_should_run,</span><br><span class="line">	.thread_fn		= run_ksoftirqd,</span><br><span class="line">	.thread_comm		= <span class="string">"ksoftirqd/%u"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="function">init <span class="keyword">int</span> <span class="title">spawn_ksoftirqd</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	register_cpu_notifier(&amp;cpu_nfb);</span><br><span class="line"></span><br><span class="line">	BUG_ON(smpboot_register_percpu_thread(&amp;softirq_threads));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">early_initcall(spawn_ksoftirqd);</span><br></pre></td></tr></table></figure>
<p>每个内核线程<code>ksoftirqd</code>实际一直执行的是<code>run_ksoftirqd</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run_ksoftirqd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	local_irq_disable();</span><br><span class="line">	<span class="keyword">if</span> (local_softirq_pending()) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We can safely run softirq on inline stack, as we are not deep</span></span><br><span class="line"><span class="comment">		 * in the task stack here.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		__do_softirq();</span><br><span class="line">		local_irq_enable();</span><br><span class="line">		cond_resched_rcu_qs();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	local_irq_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>__do_softirq</code>检查当前CPU所有待处理的软中断，并调用对应的处理函数<code>softirq_action</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">asmlinkage __visible <span class="keyword">void</span> __softirq_entry __do_softirq(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">while</span> ((softirq_bit = ffs(pending))) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> vec_nr;</span><br><span class="line">		<span class="keyword">int</span> prev_count;</span><br><span class="line"></span><br><span class="line">		h += softirq_bit - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		vec_nr = h - softirq_vec;</span><br><span class="line">		...</span><br><span class="line">		h-&gt;action(h);</span><br><span class="line">		...</span><br><span class="line">		h++;</span><br><span class="line">		pending &gt;&gt;= softirq_bit;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>softirq_action</code>实际是在网络模块初始化的时候注册的(查看<code>/kernel/net/dev.c</code>)中的函数<code>net_dev_init</code>，通过调用<code>open_softirq</code>告知内核启动网络数据传输的两个软中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">net_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (register_pernet_subsys(&amp;netdev_net_ops))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Initialise the packet receive queues.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(i) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> = &amp;<span class="title">per_cpu</span>(<span class="title">softnet_data</span>, <span class="title">i</span>);</span></span><br><span class="line"></span><br><span class="line">		skb_queue_head_init(&amp;sd-&gt;input_pkt_queue);</span><br><span class="line">		skb_queue_head_init(&amp;sd-&gt;process_queue);</span><br><span class="line">		INIT_LIST_HEAD(&amp;sd-&gt;poll_list);</span><br><span class="line">		sd-&gt;output_queue_tailp = &amp;sd-&gt;output_queue;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RPS</span></span><br><span class="line">		sd-&gt;csd.func = rps_trigger_softirq;</span><br><span class="line">		sd-&gt;csd.info = sd;</span><br><span class="line">		sd-&gt;cpu = i;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		sd-&gt;backlog.poll = process_backlog;</span><br><span class="line">		sd-&gt;backlog.weight = weight_p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	open_softirq(NET_TX_SOFTIRQ, net_tx_action);</span><br><span class="line">	open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span><br><span class="line"></span><br><span class="line">	hotcpu_notifier(dev_cpu_callback, <span class="number">0</span>);</span><br><span class="line">	dst_subsys_init();</span><br><span class="line">	rc = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就说<code>h-&gt;action</code> 调用的实际是<code>net_rx_action</code>函数： 检查当前CPU的<code>softnet_data</code>的<code>poll_list</code>, 取出第一个设备的napi列表, 调用<code>napi_poll</code>获取对应网卡上的数据包，直到到达单个CPU处理的上限或者所有需要poll的设备列表完成处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">net_rx_action</span><span class="params">(struct softirq_action *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> = <span class="title">this_cpu_ptr</span>(&amp;<span class="title">softnet_data</span>);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> time_limit = jiffies +</span><br><span class="line">		usecs_to_jiffies(netdev_budget_usecs);</span><br><span class="line">	<span class="keyword">int</span> budget = netdev_budget;</span><br><span class="line">	LIST_HEAD(<span class="built_in">list</span>);</span><br><span class="line">	LIST_HEAD(repoll);</span><br><span class="line"></span><br><span class="line">	local_irq_disable();</span><br><span class="line">	list_splice_init(&amp;sd-&gt;poll_list, &amp;<span class="built_in">list</span>);</span><br><span class="line">	local_irq_enable();</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span> *<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (list_empty(&amp;<span class="built_in">list</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!sd_has_rps_ipi_waiting(sd) &amp;&amp; list_empty(&amp;repoll))</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		n = list_first_entry(&amp;<span class="built_in">list</span>, struct napi_struct, poll_list);</span><br><span class="line">		budget -= napi_poll(n, &amp;repoll);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If softirq window is exhausted then punt.</span></span><br><span class="line"><span class="comment">		 * Allow this to run for 2 jiffies since which will allow</span></span><br><span class="line"><span class="comment">		 * an average latency of 1.5/HZ.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(budget &lt;= <span class="number">0</span> ||</span><br><span class="line">			     time_after_eq(jiffies, time_limit))) &#123;</span><br><span class="line">			sd-&gt;time_squeeze++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	local_irq_disable();</span><br><span class="line"></span><br><span class="line">	list_splice_tail_init(&amp;sd-&gt;poll_list, &amp;<span class="built_in">list</span>);</span><br><span class="line">	list_splice_tail(&amp;repoll, &amp;<span class="built_in">list</span>);</span><br><span class="line">	list_splice(&amp;<span class="built_in">list</span>, &amp;sd-&gt;poll_list);</span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;sd-&gt;poll_list))</span><br><span class="line">		__raise_softirq_irqoff(NET_RX_SOFTIRQ);</span><br><span class="line"></span><br><span class="line">	net_rps_action_and_irq_enable(sd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>napi_poll</code>则调用最初网卡驱动注册的poll函数<code>e1000_clean</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">napi_poll</span><span class="params">(struct napi_struct *n, struct list_head *repoll)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *have;</span><br><span class="line">	<span class="keyword">int</span> work, weight;</span><br><span class="line"></span><br><span class="line">	list_del_init(&amp;n-&gt;poll_list);</span><br><span class="line"></span><br><span class="line">	have = netpoll_poll_lock(n);</span><br><span class="line"></span><br><span class="line">	weight = n-&gt;weight;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This NAPI_STATE_SCHED test is for avoiding a race</span></span><br><span class="line"><span class="comment">	 * with netpoll's poll_napi().  Only the entity which</span></span><br><span class="line"><span class="comment">	 * obtains the lock and sees NAPI_STATE_SCHED set will</span></span><br><span class="line"><span class="comment">	 * actually make the -&gt;poll() call.  Therefore we avoid</span></span><br><span class="line"><span class="comment">	 * accidentally calling -&gt;poll() when NAPI is not scheduled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	work = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (test_bit(NAPI_STATE_SCHED, &amp;n-&gt;state)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> = <span class="title">this_cpu_ptr</span>(&amp;<span class="title">softnet_data</span>);</span></span><br><span class="line"></span><br><span class="line">		sd-&gt;current_napi = n;</span><br><span class="line">		work = n-&gt;poll(n, weight);</span><br><span class="line">		trace_napi_poll(n);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> work;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>e1000_clean</code>会将当前CPU中接收到的数据包放到<code>skb_buff</code>列表当中，并将数据发送给上层协议栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">e1000_clean</span><span class="params">(struct napi_struct *napi, <span class="keyword">int</span> budget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">e1000_adapter</span> *<span class="title">adapter</span> = <span class="title">container_of</span>(<span class="title">napi</span>, <span class="title">struct</span> <span class="title">e1000_adapter</span>,</span></span><br><span class="line"><span class="class">						     <span class="title">napi</span>);</span></span><br><span class="line">	<span class="keyword">int</span> tx_clean_complete = <span class="number">0</span>, work_done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	tx_clean_complete = e1000_clean_tx_irq(adapter, &amp;adapter-&gt;tx_ring[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	adapter-&gt;clean_rx(adapter, &amp;adapter-&gt;rx_ring[<span class="number">0</span>], &amp;work_done, budget);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tx_clean_complete)</span><br><span class="line">		work_done = budget;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If budget not fully consumed, exit the polling mode */</span></span><br><span class="line">	<span class="keyword">if</span> (work_done &lt; budget) &#123;</span><br><span class="line">		<span class="keyword">if</span> (likely(adapter-&gt;itr_setting &amp; <span class="number">3</span>))</span><br><span class="line">			e1000_set_itr(adapter);</span><br><span class="line">		napi_complete_done(napi, work_done);</span><br><span class="line">		<span class="keyword">if</span> (!test_bit(__E1000_DOWN, &amp;adapter-&gt;flags))</span><br><span class="line">			e1000_irq_enable(adapter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> work_done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将skb-buff-发送给协议栈"><a href="#将skb-buff-发送给协议栈" class="headerlink" title="将skb_buff 发送给协议栈"></a><strong>将<code>skb_buff</code> 发送给协议栈</strong></h3><p><code>e1000_clean_rx_irq</code>不断的从网卡基于DMA地址从对应的内存环形缓冲区中获取网络数据包，并将数据包以<code>sk_buff</code>的形式传给协议栈进行处理. 简单来说, DMA地址就是外设(网卡)映射到内存的一个虚拟地址, 用于直接与内存(RAM)之间传送数据. 一般在驱动初始化的时候, 网卡通过<code>dma_map_single</code>为缓冲区的每个描述结构体中的数据映射到某个DMA地址；然后在收到数据之后再通过<code>dma_unmap_single</code>清除掉这个映射, 把数据交由CPU处理.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">e1000_clean_rx_irq</span><span class="params">(struct e1000_adapter *adapter,</span></span></span><br><span class="line"><span class="function"><span class="params">			       struct e1000_rx_ring *rx_ring,</span></span></span><br><span class="line"><span class="function"><span class="params">			       <span class="keyword">int</span> *work_done, <span class="keyword">int</span> work_to_do)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">netdev</span> = <span class="title">adapter</span>-&gt;<span class="title">netdev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pci_dev</span> *<span class="title">pdev</span> = <span class="title">adapter</span>-&gt;<span class="title">pdev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">e1000_rx_desc</span> *<span class="title">rx_desc</span>, *<span class="title">next_rxd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">e1000_rx_buffer</span> *<span class="title">buffer_info</span>, *<span class="title">next_buffer</span>;</span></span><br><span class="line">	u32 length;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> cleaned_count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> cleaned = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> total_rx_bytes=<span class="number">0</span>, total_rx_packets=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	i = rx_ring-&gt;next_to_clean;</span><br><span class="line">	rx_desc = E1000_RX_DESC(*rx_ring, i);</span><br><span class="line">	buffer_info = &amp;rx_ring-&gt;buffer_info[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (rx_desc-&gt;status &amp; E1000_RXD_STAT_DD) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">		u8 *data;</span><br><span class="line">		u8 status;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (*work_done &gt;= work_to_do)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		(*work_done)++;</span><br><span class="line">		dma_rmb(); <span class="comment">/* read descriptor and rx_buffer_info after status DD */</span></span><br><span class="line"></span><br><span class="line">		status = rx_desc-&gt;status;</span><br><span class="line">		length = le16_to_cpu(rx_desc-&gt;length);</span><br><span class="line"></span><br><span class="line">		data = buffer_info-&gt;rxbuf.data;</span><br><span class="line">		prefetch(data);</span><br><span class="line">		skb = e1000_copybreak(adapter, buffer_info, length, data);</span><br><span class="line">		<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> frag_len = e1000_frag_len(adapter);</span><br><span class="line"></span><br><span class="line">			skb = build_skb(data - E1000_HEADROOM, frag_len);</span><br><span class="line">			<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">				adapter-&gt;alloc_rx_buff_failed++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			skb_reserve(skb, E1000_HEADROOM);</span><br><span class="line">			<span class="comment">// 清除DMA地址的映射, 这时CPU开始接管相应的数据</span></span><br><span class="line">			dma_unmap_single(&amp;pdev-&gt;dev, buffer_info-&gt;dma,</span><br><span class="line">					 adapter-&gt;rx_buffer_len,</span><br><span class="line">					 DMA_FROM_DEVICE);</span><br><span class="line">			buffer_info-&gt;dma = <span class="number">0</span>;</span><br><span class="line">			buffer_info-&gt;rxbuf.data = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (++i == rx_ring-&gt;count) i = <span class="number">0</span>;</span><br><span class="line">		next_rxd = E1000_RX_DESC(*rx_ring, i);</span><br><span class="line">		prefetch(next_rxd);</span><br><span class="line"></span><br><span class="line">		next_buffer = &amp;rx_ring-&gt;buffer_info[i];</span><br><span class="line"></span><br><span class="line">		cleaned = <span class="literal">true</span>;</span><br><span class="line">		cleaned_count++;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* !EOP means multiple descriptors were used to store a single</span></span><br><span class="line"><span class="comment">		 * packet, if thats the case we need to toss it.  In fact, we</span></span><br><span class="line"><span class="comment">		 * to toss every packet with the EOP bit clear and the next</span></span><br><span class="line"><span class="comment">		 * frame that _does_ have the EOP bit set, as it is by</span></span><br><span class="line"><span class="comment">		 * definition only a frame fragment</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!(status &amp; E1000_RXD_STAT_EOP)))</span><br><span class="line">			adapter-&gt;discarding = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (adapter-&gt;discarding) &#123;</span><br><span class="line">			<span class="comment">/* All receives must fit into a single buffer */</span></span><br><span class="line">			netdev_dbg(netdev, <span class="string">"Receive packet consumed multiple buffers\n"</span>);</span><br><span class="line">			dev_kfree_skb(skb);</span><br><span class="line">			<span class="keyword">if</span> (status &amp; E1000_RXD_STAT_EOP)</span><br><span class="line">				adapter-&gt;discarding = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">goto</span> next_desc;</span><br><span class="line">		&#125;</span><br><span class="line">		....</span><br><span class="line"></span><br><span class="line">process_skb:</span><br><span class="line">		total_rx_bytes += (length - <span class="number">4</span>); <span class="comment">/* don't count FCS */</span></span><br><span class="line">		total_rx_packets++;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(!(netdev-&gt;features &amp; NETIF_F_RXFCS)))</span><br><span class="line">			<span class="comment">/* adjust length to remove Ethernet CRC, this must be</span></span><br><span class="line"><span class="comment">			 * done after the TBI_ACCEPT workaround above</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			length -= <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (buffer_info-&gt;rxbuf.data == <span class="literal">NULL</span>)</span><br><span class="line">			skb_put(skb, length);</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">/* copybreak skb */</span></span><br><span class="line">			skb_trim(skb, length);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Receive Checksum Offload */</span></span><br><span class="line">		e1000_rx_checksum(adapter,</span><br><span class="line">				  (u32)(status) |</span><br><span class="line">				  ((u32)(rx_desc-&gt;errors) &lt;&lt; <span class="number">24</span>),</span><br><span class="line">				  le16_to_cpu(rx_desc-&gt;csum), skb);</span><br><span class="line"></span><br><span class="line">		e1000_receive_skb(adapter, status, rx_desc-&gt;special, skb);</span><br><span class="line"></span><br><span class="line">next_desc:</span><br><span class="line">		rx_desc-&gt;status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* return some buffers to hardware, one at a time is too slow */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(cleaned_count &gt;= E1000_RX_BUFFER_WRITE)) &#123;</span><br><span class="line">			adapter-&gt;alloc_rx_buf(adapter, rx_ring, cleaned_count);</span><br><span class="line">			cleaned_count = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* use prefetched values */</span></span><br><span class="line">		rx_desc = next_rxd;</span><br><span class="line">		buffer_info = next_buffer;</span><br><span class="line">	&#125;</span><br><span class="line">	rx_ring-&gt;next_to_clean = i;</span><br><span class="line"></span><br><span class="line">	cleaned_count = E1000_DESC_UNUSED(rx_ring);</span><br><span class="line">	<span class="keyword">if</span> (cleaned_count)</span><br><span class="line">		adapter-&gt;alloc_rx_buf(adapter, rx_ring, cleaned_count);</span><br><span class="line"></span><br><span class="line">	adapter-&gt;total_rx_packets += total_rx_packets;</span><br><span class="line">	adapter-&gt;total_rx_bytes += total_rx_bytes;</span><br><span class="line">	netdev-&gt;stats.rx_bytes += total_rx_bytes;</span><br><span class="line">	netdev-&gt;stats.rx_packets += total_rx_packets;</span><br><span class="line">	<span class="keyword">return</span> cleaned;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>e1000_receive_skb</code>实际调用<code>napi_gro_receive</code>将数据发送出去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">e1000_receive_skb</span><span class="params">(struct e1000_adapter *adapter, u8 status,</span></span></span><br><span class="line"><span class="function"><span class="params">			      __le16 vlan, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	skb-&gt;protocol = eth_type_trans(skb, adapter-&gt;netdev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (status &amp; E1000_RXD_STAT_VP) &#123;</span><br><span class="line">		u16 vid = le16_to_cpu(vlan) &amp; E1000_RXD_SPC_VLAN_MASK;</span><br><span class="line"></span><br><span class="line">		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);</span><br><span class="line">	&#125;</span><br><span class="line">	napi_gro_receive(&amp;adapter-&gt;napi, skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>napi_gro_receive</code>首先会尝试通过<code>GRO</code>（<code>Generic Receive Offload</code>)的方式将数据发送出去，如果网卡本身不支持<code>GRO</code>则会直接将数据报传送给上层协议栈（简单来说GRO就是将数据包累积到一定数量后再传给上层，这样一次性的处理多个数据包从而提升效率，可以参考<a href="https://lwn.net/Articles/358910/)：" target="_blank" rel="noopener">https://lwn.net/Articles/358910/)：</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// kernel/net/dev.c</span></span><br><span class="line"><span class="keyword">gro_result_t</span> napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">	trace_napi_gro_receive_entry(skb);</span><br><span class="line"></span><br><span class="line">	skb_gro_reset_offset(skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> napi_skb_finish(dev_gro_receive(napi, skb), skb);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(napi_gro_receive);</span><br></pre></td></tr></table></figure>
<p>Intel这个网卡没有开启<code>GRO</code>，所以实际<code>dev_gro_receive</code>直接返回了<code>GRO_NORMAL</code>，这样就通过<code>netif_receive_skb_internal</code>处理数据包：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> gro_result_t <span class="title">napi_skb_finish</span><span class="params">(<span class="keyword">gro_result_t</span> ret, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">	<span class="keyword">case</span> GRO_NORMAL:</span><br><span class="line">		<span class="keyword">if</span> (netif_receive_skb_internal(skb))</span><br><span class="line">			ret = GRO_DROP;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> GRO_DROP:</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> GRO_MERGED_FREE:</span><br><span class="line">		<span class="keyword">if</span> (NAPI_GRO_CB(skb)-&gt;<span class="built_in">free</span> == NAPI_GRO_FREE_STOLEN_HEAD)</span><br><span class="line">			napi_skb_free_stolen_head(skb);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			__kfree_skb(skb);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> GRO_HELD:</span><br><span class="line">	<span class="keyword">case</span> GRO_MERGED:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于多核系统来说，一般数据传输处理的CPU跟中断处理的CPU是一致的，后来随着网卡速度的提升，如果把网卡的数据都放到一个CPU处理的话，会导致CPU负载过大进而导致数据传输的延迟，因此有人提出了RPS(<a href="https://lwn.net/Articles/362339/" target="_blank" rel="noopener">Receive packet steering</a>, 就是将数据包的处理任务均衡的分配到各个CPU；要支持该特性，需要打开配置<code>CONFIG_RPS</code>， 同时在内核的配置中<code>/sys/class/net/ethx/queues/rx-0/rps_cpus</code>中将需要处理数据包的CPU设置为<code>1</code>， 这样在处理数据的时候就会将数据包先放到各个CPU的数据队列中进行处理。</p>
<p>这里假定该网卡没有配置RPS，接着会调用<code>__netif_receive_skb</code>处理网络数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">netif_receive_skb_internal</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	net_timestamp_check(netdev_tstamp_prequeue, skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (skb_defer_rx_timestamp(skb))</span><br><span class="line">		<span class="keyword">return</span> NET_RX_SUCCESS;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RPS</span></span><br><span class="line">	<span class="keyword">if</span> (static_key_false(&amp;rps_needed)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rps_dev_flow</span> <span class="title">voidflow</span>, *<span class="title">rflow</span> = &amp;<span class="title">voidflow</span>;</span></span><br><span class="line">		<span class="keyword">int</span> cpu = get_rps_cpu(skb-&gt;dev, skb, &amp;rflow);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (cpu &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			ret = enqueue_to_backlog(skb, cpu, &amp;rflow-&gt;last_qtail);</span><br><span class="line">			rcu_read_unlock();</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	ret = __netif_receive_skb(skb);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__netif_receive_skb</code>实际调用<code>__netif_receive_skb_core</code>处理数据：<code>__netif_receive_skb_core</code>调用内核初始化时注册的协议类型，并调用其回调函数，由相应的协议来处理该数据包</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __netif_receive_skb(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sk_memalloc_socks() &amp;&amp; skb_pfmemalloc(skb)) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> pflags = current-&gt;flags;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * PFMEMALLOC skbs are special, they should</span></span><br><span class="line"><span class="comment">		 * - be delivered to SOCK_MEMALLOC sockets only</span></span><br><span class="line"><span class="comment">		 * - stay away from userspace</span></span><br><span class="line"><span class="comment">		 * - have bounded memory usage</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Use PF_MEMALLOC as this saves us from propagating the allocation</span></span><br><span class="line"><span class="comment">		 * context down to all allocation sites.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		current-&gt;flags |= PF_MEMALLOC;</span><br><span class="line">		ret = __netif_receive_skb_core(skb, <span class="literal">true</span>);</span><br><span class="line">		tsk_restore_flags(current, pflags, PF_MEMALLOC);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		ret = __netif_receive_skb_core(skb, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __netif_receive_skb_core(struct sk_buff *skb, <span class="keyword">bool</span> pfmemalloc)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">packet_type</span> *<span class="title">ptype</span>, *<span class="title">pt_prev</span>;</span></span><br><span class="line">	<span class="keyword">rx_handler_func_t</span> *rx_handler;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">orig_dev</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> deliver_exact = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = NET_RX_DROP;</span><br><span class="line">	__be16 type;</span><br><span class="line"></span><br><span class="line">	net_timestamp_check(!netdev_tstamp_prequeue, skb);</span><br><span class="line"></span><br><span class="line">	trace_netif_receive_skb(skb);</span><br><span class="line"></span><br><span class="line">	orig_dev = skb-&gt;dev;</span><br><span class="line"></span><br><span class="line">	skb_reset_network_header(skb);</span><br><span class="line">	<span class="keyword">if</span> (!skb_transport_header_was_set(skb))</span><br><span class="line">		skb_reset_transport_header(skb);</span><br><span class="line">	skb_reset_mac_len(skb);</span><br><span class="line"></span><br><span class="line">	pt_prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">another_round:</span><br><span class="line">	skb-&gt;skb_iif = skb-&gt;dev-&gt;ifindex;</span><br><span class="line"></span><br><span class="line">	__this_cpu_inc(softnet_data.processed);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;protocol == cpu_to_be16(ETH_P_8021Q) ||</span><br><span class="line">	    skb-&gt;protocol == cpu_to_be16(ETH_P_8021AD)) &#123;</span><br><span class="line">		skb = skb_vlan_untag(skb);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 遍历已注册的协议，并调用其回调函数(一般是libpcap通过`AF_PACKET`传入的)</span></span><br><span class="line">	list_for_each_entry_rcu(ptype, &amp;ptype_all, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pt_prev)</span><br><span class="line">			ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">		pt_prev = ptype;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 协议栈</span></span><br><span class="line">	list_for_each_entry_rcu(ptype, &amp;skb-&gt;dev-&gt;ptype_all, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pt_prev)</span><br><span class="line">			ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">		pt_prev = ptype;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">skip_taps:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NET_INGRESS</span></span><br><span class="line">	<span class="keyword">if</span> (static_key_false(&amp;ingress_needed)) &#123;</span><br><span class="line">		skb = handle_ing(skb, &amp;pt_prev, &amp;ret, orig_dev);</span><br><span class="line">		<span class="keyword">if</span> (!skb)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nf_ingress(skb, &amp;pt_prev, &amp;ret, orig_dev) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回调协议包<code>struct packet_type</code>注册的回调函数，把<code>sk_buff</code>传给该协议层处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">deliver_skb</span><span class="params">(struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct packet_type *pt_prev,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct net_device *orig_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(skb_orphan_frags(skb, GFP_ATOMIC)))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	atomic_inc(&amp;skb-&gt;users);</span><br><span class="line">	<span class="keyword">return</span> pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev, orig_dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有这些<code>struct packet_type</code>实际都是在内核初始化的时候通过<code>dev_add_pack</code>注册的，有兴趣的可以跟踪下对应的代码逻辑。至此, 数据包从设备物理层L0传输到了协议层L3了,传输完成了第一步. </p>
<p>总的说来, NAPI针对高负载的数据通讯做了优化, 减少了物理中断数量, 同时又兼顾了各个物理设备在传输调度上的公平性.</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://lwn.net/Articles/30107/" target="_blank" rel="noopener">Driver porting: Network drivers</a></li>
<li><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#overview" target="_blank" rel="noopener">https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#overview</a></li>
<li><a href="https://lwn.net/Articles/358910/" target="_blank" rel="noopener">Generic Receive Offload</a></li>
<li><a href="https://lwn.net/Articles/362339/" target="_blank" rel="noopener">RPS</a></li>
<li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rps" target="_blank" rel="noopener">Redhat RPS</a></li>
<li><a href="https://blog.csdn.net/lucien_cc/article/details/11731463" target="_blank" rel="noopener">https://blog.csdn.net/lucien_cc/article/details/11731463</a></li>
<li><a href="https://lwn.net/Articles/822521/" target="_blank" rel="noopener">DMA相关的文章</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/DMA-API-HOWTO.txt" target="_blank" rel="noopener">内核DMA API说明</a></li>
<li><a href="https://elinux.org/images/3/32/Pinchart--mastering_the_dma_and_iommu_apis.pdf" target="_blank" rel="noopener">https://elinux.org/images/3/32/Pinchart--mastering_the_dma_and_iommu_apis.pdf</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 网络协议 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> NAPI </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[由新冠病毒想到的一些事情]]></title>
      <url>http://sniffer.site/2020/04/04/%E8%AF%B4%E8%AF%B4%E8%BF%99%E6%AC%A1%E6%96%B0%E5%86%A0%E4%BC%A0%E6%9F%93%E7%97%85%E6%83%B3%E5%88%B0%E7%9A%84%E4%BA%8B%E6%83%85/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Live as everything is a miracle or nothing is miracle</p>
<p>爱因斯坦</p>
</blockquote>
<p>这次新型冠状病毒发展到现在估计已经超出了绝大多数人的预料, 现在国内的疫情基本稳定了, 但国外包括北美, 欧洲大部分国家都处于病毒爆发的高峰期, 截至4月3日全球已经有超过80多万的病毒感染者<a id="more"></a>:</p>
<p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/convid-19_trend.png" alt="新冠病毒确诊人数趋势图"></p>
<p>看这个图, 增长速率丝毫没有减缓的迹象, 新冠病毒的传染能力也可见一斑.那何时又是个头?我们不妨通过简单的数学模型来估算下最终可能感染的人数以及疫情控制的大致时间节点.按照生物学的规律, <a href="https://www.khanacademy.org/science/biology/ecology/population-growth-and-regulation/a/exponential-logistic-growth" target="_blank" rel="noopener">一个生物种群数量的增长都遵循S型曲线的增长</a>:</p>
<p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/s_shaped_curve.png" alt="logistic growth curve"></p>
<p>图中的横轴表示时间, 纵轴表示生物种群的个数, 将上述增长曲线写成对应的公式大致如下:</p>
<p>$$ y(t) = \frac{k}{1 + Ae^{-rt}} $$</p>
<p>这里<code>t</code>是时间, <code>k</code>/<code>A</code>是常数(<code>k</code>的值实际表示了最后可能感染的人数), <code>y(t)</code>即当前感染的人数, <code>r</code>是最大的增长率.参考<a href="https://voice.baidu.com/act/newpneumonia/newpneumonia" target="_blank" rel="noopener">百度疫情</a>给出的数据, 为了简化计算, 从历史数据中大概计算了感染人数的增长率为<code>15%</code>(实际最大的增长率已经超过<code>20%</code>, 这里取了一个中间值);分别取了<code>2020/02/20</code>/<code>2020/04/03</code>两天的的数据, 得到<code>k</code>的值大约为<code>2332345.16</code>, 也就是说最后大概总共有200万左右的感染人数, 据此可以得到一个如下的简单感染人数模型:</p>
<p>$$ y(t) = \frac{2332345.16}{1 + 2172.67e^{-0.15t}} $$</p>
<p>画成图形可能看得比较直观, 下图中时间<code>0</code>对应<code>2020/02/20</code>, 从图上来看要等90天之后, 也就是<code>2020/5/20</code>左右疫情才能真正稳定下来, 当然后续控制力度加强可能这个时间会提前.</p>
<p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/prediction_of_infected_persons.png" alt="病毒感染人数预测"></p>
<p>在全球化的今天, 这次疫情对每个人来说都有着重大的影响, 对那些因为病毒感染失去亲人朋友的人来说, 更是如此. 还记得当时跟同事讨论这个病毒, 病人的症状跟非典(SARS)很相似, 但官方却迟迟没有给出明确的结论是否存在比较强的感染, 还是含糊其词的说”有限人传人”, 直到后来包不住火了, 才实施封城, 最后还是比病毒的传播慢了半拍.</p>
<p>从湖北考察回来的管轶教授, 上来就说这次很失望, 很麻烦, 比SARS那会要严重很多, 感染人数至少10倍起, 当时很多人不以为然, 还质疑管教授的立场, 以为他是危言耸听, 出于报复心理才这么说的.但凡真的看过管教授履历的人都知道, 他本人是国际知名的传染病科学家,在这样影响大的传染病面前, 作为一个科学家, 他断不会因为一己之心而放弃对真相与道义的坚守.事情事实上比他预想的还要糟糕.面对这么一个局面, 不得不让人感慨深思.</p>
<p>自工业革命以来, 人类开始了轰轰烈烈的自然改造, 地上跑的有火车/汽车, 天上有飞机/火箭, 同时还把触角伸向了宇宙, 人类的成功恐怕让人自己都难以不陶醉. 人的权能感也达到了新的高度, 以至于都忘记了自己只是生活在一个小小的星球上的生物而已. 人类虽说成了地球生物的主宰, 活在生物链的最顶端, 享尽了自然的馈赠, 但却少了一份对自然的敬畏之心. 病毒其实早在人类诞生之前就存在了, 时间退回到第一个细胞出现的那一刻, 人和病毒其实都来自于同一个祖先, 只是病毒走了另外一条道路, 而进化成生物体的细胞走了另外一条叉路而已, 恐怕从生物学的角度, 病毒要比人类更了解人类自己, 也更聪明.病毒可以欺骗人类的免疫细胞, 然后自我繁殖变异, 通过人与人的传播, 这种独特的生存方式, 人类估计要花很长的时间精力才能真正研究清楚.</p>
<p>而再看看这次我们对待新冠病毒的方式, 就知道人类赖以生存的复杂社会体系其实有多么的脆弱.官僚体系的迟钝, 组织机构把个人生命安危置若罔闻, 发生重大危机时, 开始时没有百姓的声音, 最后收场时, 却是那些官员们领取功劳, 宣扬成就的表演, 也无法听到普通人的真实声音. 百姓仿佛一只猴子一般被玩弄于手掌. 如今这样的社会体系中, 政府与组织的权力触角实际已经够大够深了, 个人的空间被压缩挤占, 再这样下去, 实际上每个人都会被裹挟者往前走.难道,我们真的要把所有的隐私与权力都要让度于政府或组织吗? 在集体控制与个人权利之间如何才能达成平衡? 个人又要如何在这样的体系结构下生存?</p>
<p>从大的方面来讲, 在全球化的今天, 面对这样的危机, 个人是否还能明哲保身? 恐怕很难. 我们都没有机会从这种灾难中挣脱出来, 每个人的生活都与这种全球性的危难紧密相关;人与人之间, 国与国之间只有共同合作与互相帮助才能从危机中走过来, 人类能从进化中胜出, 依靠的也是这种团结与协作.最近, 浏览新闻, 时不时有人在兴高采烈的想着: 这次疫情, 美国估计抗不住了, 我们恐怕要赢了；有人也一直在宣扬, 新冠病毒乃美国的阴谋, 实际疫情在美国老早就发生了, 我们压根就不应该帮助美国.这些怪异的言论, 说的头头是道, 却是毫无道义与来由的说辞.不论新冠病毒来自何方, 但目前从发生的时间来看, 就是从武汉传染出去的, 这个毋庸置疑, 如今病毒扩散的其他国家, 我们作为负责任的大国, 理应尽力去帮助其他国家共同抵抗疫情的进一步恶化. 这首先是出于道义, 然则是出于经济发展与社会稳定的考虑.如果此时不去积极帮助美国在内的国家抗击病毒, 我们的国家形象只会变得更加矮小;而其他国家一日不稳定下来, 依靠出口的企业就难以维系, 社会经济压力就会越大.这样的时刻, 只有合作与协作才有利于彼此, 而不是只考虑到眼前的一己之利.</p>
<p>再具体到个人, 想要在这样的全球性危机中安稳的过渡, 首先还是要积蓄能量, 不论是学习, 提升个人能力还是锻炼身体都不能落下, 同时还要多做些资金的储备, 不要乱花钱. 这样等疫情缓过来后, 方能找到机会去改变与突破. </p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.khanacademy.org/science/biology/ecology/population-growth-and-regulation/a/exponential-logistic-growth" target="_blank" rel="noopener">https://www.khanacademy.org/science/biology/ecology/population-growth-and-regulation/a/exponential-logistic-growth</a></li>
<li><a href="https://voice.baidu.com/act/newpneumonia/newpneumonia" target="_blank" rel="noopener">https://voice.baidu.com/act/newpneumonia/newpneumonia</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 社会万象 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 哲学 </tag>
            
            <tag> 社会 </tag>
            
            <tag> 思考 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android是如何实现流量统计的?]]></title>
      <url>http://sniffer.site/2020/04/01/%E8%AF%B4%E8%AF%B4Android%E4%B8%AD%E7%9A%84%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1/</url>
      <content type="html"><![CDATA[<p>使用Android手机时, 我们不仅可以看到当前系统的流量使用情况, 还可以查看每个应用消耗了多少流量, 借此我们可以发现有那些流氓APP在偷偷在背后消耗流量.那么, Android是具体如何实现流量统计的? 又是如何对每个应用的流量使用进行监控? 这篇文章我们就来看看Android流量统计的具体实现原理.</p>
<p>大致说来, Android从如何几个方面进行流量统计:</p>
<ul>
<li>统计每个网口当前发送/接收的流量数据</li>
<li>监控每个应用(对应唯一的UID)所消耗的流量</li>
<li>支持对总的流量配额进行限制, 如达到一定的流量阈值后, 会对网络进行限制</li>
</ul>
<p>而具体到每个应用(比如system应用, UID=1000), Android还支持对应用内的每个socket进行标记(tag), 用于区分每个应用(UID)内部具体使用了那些流量.后面, 我们会讲到如何通过标签来区分UID内部的流量.</p>
<p>下图是Android流量统计的原理框图: 为了实现流量统计, Android在Linux内核增加了一个netfilter模块: <code>xt_qtaguid</code>(源码可以在<code>kernel/net/netfilter</code>中找到), 用于统计当前系统所有流量, 该模块初始化时, 会初始化一个<code>/proc/net/xt_qtaguid</code>目录供用户空间的进程使用;<code>NetworkStatsService</code>系统服务就是周期性的读取该目录的数据来获取当前系统消耗的实时流量的;而如果要对某个特定的<code>socket</code>打上标签, 则需要通过JNI接口调用,然后发请求给<code>netd</code>将该<code>socket</code>标签信息通过接口<code>/proc/net/xt_qtaguid/ctrl</code>写入内核.</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/Android%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="Android流量统计原理图"></p>
<p>接下来就一起看下Android具体是如何进行流量统计的.</p>
<h2 id="Android流量统计实现"><a href="#Android流量统计实现" class="headerlink" title="Android流量统计实现"></a><strong>Android流量统计实现</strong></h2><p>Android有一个系统服务<code>NetworkStatsService</code>来负责流量统计管理. 在系统启动的时候会创建该服务, 对其进行初始化: 创建一个<code>NetworkStatsService</code>, 并返回给<code>SystemServer</code>, 服务内有一个线程用于数据统计业务的处理.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NetworkStatsService <span class="title">create</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">            INetworkManagementService networkManager)</span> </span>&#123;</span><br><span class="line">    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</span><br><span class="line">    PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);</span><br><span class="line">    PowerManager.WakeLock wakeLock =</span><br><span class="line">            powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);</span><br><span class="line"></span><br><span class="line">    NetworkStatsService service = <span class="keyword">new</span> NetworkStatsService(context, networkManager, alarmManager,</span><br><span class="line">            wakeLock, getDefaultClock(), TelephonyManager.getDefault(),</span><br><span class="line">            <span class="keyword">new</span> DefaultNetworkStatsSettings(context), <span class="keyword">new</span> NetworkStatsObservers(),</span><br><span class="line">            getDefaultSystemDir(), getDefaultBaseDir());</span><br><span class="line"></span><br><span class="line">    HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(TAG);</span><br><span class="line">    Handler.Callback callback = <span class="keyword">new</span> HandlerCallback(service);</span><br><span class="line">    handlerThread.start();</span><br><span class="line">    Handler handler = <span class="keyword">new</span> Handler(handlerThread.getLooper(), callback);</span><br><span class="line">    service.setHandler(handler, callback);</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等到<code>SystemServer</code>完成对系统服务的初始化后, 会调用<code>NetworkStatsService.systemReady()</code>, 告诉服务可以正常启动了, 启动时<code>NetworkStatsService</code>需要做如下几件事情:</p>
<ul>
<li>创建四个流量统计的类型, 实际对应放在<code>/data/system/netstats</code>目录的四个类型的文件而已, 分别用于统计每个网口的消耗的流量(<code>PREFIX_DEV</code>), 视频通话以及热点分享所消耗的流量(<code>PREFIX_XT</code>), 每个用户所消耗的流量(<code>PREFXI_UID</code>)以及每个用户对应的每个标签所消耗的流量(<code>PREFIX_UID_TAG</code>)</li>
<li>更新每个流量统计数据写入的阈值: 即流量消耗达到某个阈值后, 需要将当前统计数据写入磁盘, 目前默认统一使用的是<code>2MB</code>；接着还要看下是否需要从早前版本中把老的流量统计数据迁移过来</li>
<li>注册并监听系统广播, 比如定时从系统拉取流量统计数据(<code>ACTION_NETWORK_STATS_POLL</code>), Android默认30分钟拉取一次; 系统用户增加与删除的广播;关机的广播等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mSystemReady = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mStatsLock) &#123;</span><br><span class="line">        <span class="comment">// create data recorders along with historical rotators</span></span><br><span class="line">        mDevRecorder = buildRecorder(PREFIX_DEV, mSettings.getDevConfig(), <span class="keyword">false</span>);</span><br><span class="line">        mXtRecorder = buildRecorder(PREFIX_XT, mSettings.getXtConfig(), <span class="keyword">false</span>);</span><br><span class="line">        mUidRecorder = buildRecorder(PREFIX_UID, mSettings.getUidConfig(), <span class="keyword">false</span>);</span><br><span class="line">        mUidTagRecorder = buildRecorder(PREFIX_UID_TAG, mSettings.getUidTagConfig(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        updatePersistThresholdsLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// upgrade any legacy stats, migrating them to rotated files</span></span><br><span class="line">        maybeUpgradeLegacyStatsLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read historical network stats from disk, since policy service</span></span><br><span class="line">        <span class="comment">// might need them right away.</span></span><br><span class="line">        mXtStatsCached = mXtRecorder.getOrLoadCompleteLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bootstrap initial stats to prevent double-counting later</span></span><br><span class="line">        bootstrapStatsLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// watch for tethering changes</span></span><br><span class="line">    <span class="keyword">final</span> IntentFilter tetherFilter = <span class="keyword">new</span> IntentFilter(ACTION_TETHER_STATE_CHANGED);</span><br><span class="line">    mContext.registerReceiver(mTetherReceiver, tetherFilter, <span class="keyword">null</span>, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen for periodic polling events</span></span><br><span class="line">    <span class="keyword">final</span> IntentFilter pollFilter = <span class="keyword">new</span> IntentFilter(ACTION_NETWORK_STATS_POLL);</span><br><span class="line">    mContext.registerReceiver(mPollReceiver, pollFilter, READ_NETWORK_USAGE_HISTORY, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen for uid removal to clean stats</span></span><br><span class="line">    <span class="keyword">final</span> IntentFilter removedFilter = <span class="keyword">new</span> IntentFilter(ACTION_UID_REMOVED);</span><br><span class="line">    mContext.registerReceiver(mRemovedReceiver, removedFilter, <span class="keyword">null</span>, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen for user changes to clean stats</span></span><br><span class="line">    <span class="keyword">final</span> IntentFilter userFilter = <span class="keyword">new</span> IntentFilter(ACTION_USER_REMOVED);</span><br><span class="line">    mContext.registerReceiver(mUserReceiver, userFilter, <span class="keyword">null</span>, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// persist stats during clean shutdown</span></span><br><span class="line">    <span class="keyword">final</span> IntentFilter shutdownFilter = <span class="keyword">new</span> IntentFilter(ACTION_SHUTDOWN);</span><br><span class="line">    mContext.registerReceiver(mShutdownReceiver, shutdownFilter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mNetworkManager.registerObserver(mAlertObserver);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// ignored; service lives in system_server</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    registerPollAlarmLocked();</span><br><span class="line">    registerGlobalAlert();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NetworkStatsService</code>启动后, 注册了一个定时广播<code>com.android.server.action.NETWORK_STATS_POLL</code>, 每隔一段时间就会定时拉取当前系统消耗的流量统计数据, 收到该广播后, 系统会尝试将统计数据写入到磁盘永久保存下来:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> BroadcastReceiver mPollReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// on background handler thread, and verified UPDATE_DEVICE_STATS</span></span><br><span class="line">        <span class="comment">// permission above.</span></span><br><span class="line">        performPoll(FLAG_PERSIST_ALL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// verify that we're watching global alert</span></span><br><span class="line">        registerGlobalAlert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拉取当前流量数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPoll</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mStatsLock) &#123;</span><br><span class="line">        mWakeLock.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            performPollLocked(flags);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mWakeLock.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法<code>performPollLocked</code>首先会获取当前的统计数据快照, 然后将其自动写入到磁盘<code>/data/system/netstats</code>目录:</p>
<ul>
<li><code>recordSnapShotLocked()</code>实际通过<code>NetworkManagementService</code>提供的接口从<code>/proc/net/xt_qtaguid</code>这个目录读取当前的历史统计数据并将其保存到<code>mDevRecorder</code>/<code>mXtRecorder</code>/<code>mUidRecorder</code>中</li>
<li>根据传入的标志位, 来确定各个<code>NetworkStatsRecorder</code>是否将数据写入磁盘: 可以强制写入(<code>forcePersistLocked</code>), 也可以等到消耗流量达到阈值(就是之前说的<code>2MB</code>)之后再写入(<code>maybePersistLocked</code>)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPollLocked</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSystemReady) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> persistNetwork = (flags &amp; FLAG_PERSIST_NETWORK) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> persistUid = (flags &amp; FLAG_PERSIST_UID) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> persistForce = (flags &amp; FLAG_PERSIST_FORCE) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> consider marking "untrusted" times in historical stats</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentTime = mClock.millis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        recordSnapshotLocked(currentTime);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">"problem reading network stats"</span>, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// ignored; service lives in system_server</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// persist any pending data depending on requested flags</span></span><br><span class="line">    <span class="keyword">if</span> (persistForce) &#123;</span><br><span class="line">        mDevRecorder.forcePersistLocked(currentTime);</span><br><span class="line">        mXtRecorder.forcePersistLocked(currentTime);</span><br><span class="line">        mUidRecorder.forcePersistLocked(currentTime);</span><br><span class="line">        mUidTagRecorder.forcePersistLocked(currentTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (persistNetwork) &#123;</span><br><span class="line">            mDevRecorder.maybePersistLocked(currentTime);</span><br><span class="line">            mXtRecorder.maybePersistLocked(currentTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (persistUid) &#123;</span><br><span class="line">            mUidRecorder.maybePersistLocked(currentTime);</span><br><span class="line">            mUidTagRecorder.maybePersistLocked(currentTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后, 我们来看看流量统计的数据是如何写入磁盘, 又如何从磁盘读取的. Android将系统消耗的流量按照时间切割成一段段固定时间长度的统计值(<code>NetworkStatsHistory</code>), 并将其与<code>NetworkIdentitySet</code>(表示一个网口集合)组成一个统计的哈希列表(<code>NetworkStatsCollection</code>), 然后每次更新当前消耗的流量时, <code>NetworkStatsRecorder</code>都会不断的将数据写入到磁盘:</p>
<ul>
<li><code>NetworkStatsRecorder</code>中包含了两个流量统计数据: 当前未写入磁盘的数据(<code>pending</code>)以及开机以来的统计数据(<code>mSinceBoot</code>)</li>
<li><code>FileRotator</code>负责将<code>NetworkStatsRecorder</code>中的数据定时写入到磁盘, 并按照一定的老化时间来创建新的统计文件, 而且每个统计文件在达到一定的生命周期后, 会自动被删除</li>
</ul>
<p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/%E6%B5%81%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%BB%E5%86%99.png" alt="流量统计数据的读写"></p>
<h2 id="利用标签来统计特定Socket流量"><a href="#利用标签来统计特定Socket流量" class="headerlink" title="利用标签来统计特定Socket流量"></a><strong>利用标签来统计特定Socket流量</strong></h2><p><code>TrafficStats</code>中提供了接口, 可以在特定的socket(也可以使用socket对应的文件描述符)上打上标签,从而实现对每个应用你内部的流量消耗进行细分.Android系统已经定义了部分的TAG值, 比如用户DHCP协议的数据(<code>TAG_SYSTEM_DHCP</code>), 用于获取NTP网络时间的流量(<code>TAG_SYSTEM_NTP</code>), 用于探测网络的流量(<code>TAG_SYSTEM_PROBE</code>).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrafficStats</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default tag value for &#123;<span class="doctag">@link</span> DownloadManager&#125; traffic.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_DOWNLOAD = <span class="number">0xFFFFFF01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default tag value for &#123;<span class="doctag">@link</span> MediaPlayer&#125; traffic.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_MEDIA = <span class="number">0xFFFFFF02</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default tag value for &#123;<span class="doctag">@link</span> BackupManager&#125; backup traffic; that is,</span></span><br><span class="line"><span class="comment">    * traffic from the device to the storage backend.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_BACKUP = <span class="number">0xFFFFFF03</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default tag value for &#123;<span class="doctag">@link</span> BackupManager&#125; restore traffic; that is,</span></span><br><span class="line"><span class="comment">    * app data retrieved from the storage backend at install time.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_RESTORE = <span class="number">0xFFFFFF04</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default tag value for code (typically APKs) downloaded by an app store on</span></span><br><span class="line"><span class="comment">    * behalf of the app, such as updates.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_APP = <span class="number">0xFFFFFF05</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_DHCP = <span class="number">0xFFFFFF40</span>;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_NTP = <span class="number">0xFFFFFF41</span>;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_PROBE = <span class="number">0xFFFFFF42</span>;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_NEIGHBOR = <span class="number">0xFFFFFF43</span>;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_GPS = <span class="number">0xFFFFFF44</span>;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_SYSTEM_PAC = <span class="number">0xFFFFFF45</span>;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set active tag to use when accounting &#123;<span class="doctag">@link</span> Socket&#125; traffic originating</span></span><br><span class="line"><span class="comment">    * from the current thread. Only one active tag per thread is supported.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Changes only take effect during subsequent calls to</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #tagSocket(Socket)&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Tags between &#123;<span class="doctag">@code</span> 0xFFFFFF00&#125; and &#123;<span class="doctag">@code</span> 0xFFFFFFFF&#125; are reserved and</span></span><br><span class="line"><span class="comment">    * used internally by system services like &#123;<span class="doctag">@link</span> DownloadManager&#125; when</span></span><br><span class="line"><span class="comment">    * performing traffic on behalf of an application.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #clearThreadStatsTag()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setThreadStatsTag</span><span class="params">(<span class="keyword">int</span> tag)</span> </span>&#123;</span><br><span class="line">        NetworkManagementSocketTagger.setThreadSocketStatsTag(tag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set active tag to use when accounting &#123;<span class="doctag">@link</span> Socket&#125; traffic originating</span></span><br><span class="line"><span class="comment">    * from the current thread. Only one active tag per thread is supported.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Changes only take effect during subsequent calls to</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #tagSocket(Socket)&#125;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Tags between &#123;<span class="doctag">@code</span> 0xFFFFFF00&#125; and &#123;<span class="doctag">@code</span> 0xFFFFFFFF&#125; are reserved and</span></span><br><span class="line"><span class="comment">    * used internally by system services like &#123;<span class="doctag">@link</span> DownloadManager&#125; when</span></span><br><span class="line"><span class="comment">    * performing traffic on behalf of an application.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the current tag for the calling thread, which can be used to</span></span><br><span class="line"><span class="comment">    *         restore any existing values after a nested operation is finished</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAndSetThreadStatsTag</span><span class="params">(<span class="keyword">int</span> tag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NetworkManagementSocketTagger.setThreadSocketStatsTag(tag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Tag the given &#123;<span class="doctag">@link</span> Socket&#125; with any statistics parameters active for</span></span><br><span class="line"><span class="comment">   * the current thread. Subsequent calls always replace any existing</span></span><br><span class="line"><span class="comment">   * parameters. When finished, call &#123;<span class="doctag">@link</span> #untagSocket(Socket)&#125; to remove</span></span><br><span class="line"><span class="comment">   * statistics parameters.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> #setThreadStatsTag(int)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tagSocket</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">      SocketTagger.get().tag(socket);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove any statistics parameters from the given &#123;<span class="doctag">@link</span> Socket&#125;.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * In Android 8.1 (API level 27) and lower, a socket is automatically</span></span><br><span class="line"><span class="comment">   * untagged when it's sent to another process using binder IPC with a</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> ParcelFileDescriptor&#125; container. In Android 9.0 (API level 28)</span></span><br><span class="line"><span class="comment">   * and higher, the socket tag is kept when the socket is sent to another</span></span><br><span class="line"><span class="comment">   * process using binder IPC. You can mimic the previous behavior by</span></span><br><span class="line"><span class="comment">   * calling &#123;<span class="doctag">@code</span> untagSocket()&#125; before sending the socket to another</span></span><br><span class="line"><span class="comment">   * process.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">untagSocket</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">      SocketTagger.get().untag(socket);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>要使用一个socket的标签其实很简单, 只要在创建通讯的socket的连接后, 主动调用<code>setThreadStatsTag</code>就可以了, 来看一个示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupSocket</span><span class="params">(<span class="keyword">int</span> sockType, <span class="keyword">int</span> prot, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> writeTimeout, <span class="keyword">long</span> readTimeout, <span class="keyword">int</span> destPort)</span> <span class="keyword">throws</span> ErrnoException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前socket打上PROBE标签</span></span><br><span class="line">    <span class="keyword">int</span> oldTag = TrafficStats.getAndSetThreadStatsTag(TrafficStats.TAG_SYSTEM_PROBE);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mFd = Os.socket(mAddrFamily, sockType, prot);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        TrafficStats.setThreadStatsTag(oldTag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Os.setsockoptTimeval(mFd, SOL_SOCKET, SO_SNDTIMEO, StructTimeval.fromMillis(writeTimeout));</span><br><span class="line">    Os.setsockoptTimeval(mFd, SOL_SOCKET, SO_RCVTIMEO, StructTimeval.fromMillis(readTimeout));</span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(mIface)) &#123;</span><br><span class="line">        Os.setsockoptIfreq(mFd, SOL_SOCKET, SO_BINDTODEVICE, mIface);</span><br><span class="line">    &#125;</span><br><span class="line">    Os.connect(mFd, mTarget, destPort);</span><br><span class="line"></span><br><span class="line">    mSockAddr = Os.getsockname(mFd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要获取某个UID对应的标签数据, 只要调用<code>NetworkStatsManager.java</code>的<code>queryDetailsForUid</code>接口, 传入对应的开始/结束时间就可以了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Query network usage statistics details for a given uid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * #see queryDetailsForUidTagState(int, String, long, long, int, int, int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkStats <span class="title">queryDetailsForUid</span><span class="params">(<span class="keyword">int</span> networkType, String subscriberId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> startTime, <span class="keyword">long</span> endTime, <span class="keyword">int</span> uid)</span> <span class="keyword">throws</span> SecurityException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queryDetailsForUidTagState(networkType, subscriberId, startTime, endTime, uid,</span><br><span class="line">        NetworkStats.Bucket.TAG_NONE, NetworkStats.Bucket.STATE_ALL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Query network usage statistics details for a given uid and tag.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * #see queryDetailsForUidTagState(int, String, long, long, int, int, int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkStats <span class="title">queryDetailsForUidTag</span><span class="params">(<span class="keyword">int</span> networkType, String subscriberId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> startTime, <span class="keyword">long</span> endTime, <span class="keyword">int</span> uid, <span class="keyword">int</span> tag)</span> <span class="keyword">throws</span> SecurityException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queryDetailsForUidTagState(networkType, subscriberId, startTime, endTime, uid,</span><br><span class="line">        tag, NetworkStats.Bucket.STATE_ALL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Android流量统计在9.0还是基于<code>xt_qtaguid</code>来实现的, 后面实际会通过<code>BPF</code>来做(参考文章<a href="http://sniffer.site/2019/11/07/BPF%E4%B8%8EeBPF/">BPF与eBPF</a>).</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络管理 </tag>
            
            <tag> 流量统计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用SSH隧道访问局域网]]></title>
      <url>http://sniffer.site/2020/02/24/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8SSH%E9%9A%A7%E9%81%93%E8%AE%BF%E9%97%AE%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
      <content type="html"><![CDATA[<p>SSH(<a href="https://en.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">Secure SHell</a>)是一种基于加密算法的网络安全协议, 其在TCP/IP协议的基础上通过<a href="https://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="noopener">非对称公钥算法</a>对用户身份进行验证. SSH在网络中有广泛的应用, 比如平常在远程登录时就会用到SSH, Github的代码仓库提交也会基于SSH协议来验证提交者的合法性, 而对常年生活在局域网内的人来说, SSH更多的用途则是搭建穿越防火墙的VPN实现网络自由.</p>
<p>一台服务器如果有公共域名或者IP地址, 只需要事先将客户端的公钥放到服务器上就可以正常登录, 但如果服务器本身位于防火墙之外(比如某个端口被禁)或者位于NAT(<a href="https://en.wikipedia.org/wiki/Network_address_translation" target="_blank" rel="noopener">Network Address Translation</a>)网关之后, 这个方法就不起作用了. 用过VPN的同志应该比较清楚, 穿透防火墙或者某个局域网的NAT网关, 一般要用到SSH隧道技术(<a href="https://www.ssh.com/ssh/tunneling" target="_blank" rel="noopener">SSH tunneling</a>);SSH隧道技术也被称为端口转发(port forwarding).简单来说, 建立SSH隧道大致有两个流程:</p>
<ul>
<li>由位于局域网的设备A向服务器PC发起SSH连接, 建立一个安全加密的通信通道, 并基于该通道监听某个特定的端口</li>
<li>接着, 服务器基于已有的加密通道再建立一个SSH通信链路,基于这个通道服务器就可以登录到大屏, 执行交互指令</li>
</ul>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ssh_login.png" alt="SSH login"></p>
<blockquote>
<p>SSH隧道技术的端口转发具体说有两种, 一种叫本地端口转发(local port forwarding), 就是在客户端做端口转发;一种叫远端端口转发(remote port forwarding), 就是在服务端做端口的数据转发, 这篇文章用到的技术是后一种.</p>
</blockquote>
<p>这里就来看看如何通过SSH隧道技术来实现对局域网内某个服务器的登录: 局域网内有一台设备A(服务端), 只有私有IP地址, 通过NAT网关访问外部网络, 设备B(客户端)是外部网络的一个PC, 现在要通过该PC(设备B)正常登录到设备A. </p>
<h2 id="实现SSH隧道功能"><a href="#实现SSH隧道功能" class="headerlink" title="实现SSH隧道功能"></a><strong>实现SSH隧道功能</strong></h2><p>在开启SSH隧道功能之前, 确保客户端/服务器都正常配置了ssh(SSH的客户端程序)/sshd(SSH守护进程):</p>
<ul>
<li>ssh: ssh登录的客户端, 负责发起ssh登录请求, 其配置一般放在<code>/etc/ssh/ssh_config</code></li>
<li><p>sshd: sshd是服务端的守护进程, 负责监听来自客户端的请求, 其配置放在<code>/etc/ssh/sshd_config</code></p>
<p>为了确保ssh可以正常进行端口转发, 需要打开<code>AllowTcpForwarding</code>:</p>
</li>
<li><p>设置<code>AllowTcpForwarding</code>为<code>yes</code>, 确保能够使用端口转发功能</p>
</li>
</ul>
<p>另外SSH密钥交换时要用到主机的密钥(host key), 可以通过<code>ssh-keygen</code>产生, 对于Ubuntu系统来说, 主机密钥一般放在<code>/etc/ssh</code>目录下. </p>
<p>为了避免每次ssh登录都要输入密码, 可以事先分别在客户端/服务器产生一个rsa密钥对, 并将公钥放到服务器/客户端的<code>/.ssh/authorized_keys</code>中保存下来, 并在执行ssh指令时指定对应的私钥文件, 这样身份验证就会在密钥验证阶段完成无需再输入用户密码了.</p>
<h3 id="启动sshd"><a href="#启动sshd" class="headerlink" title="启动sshd"></a><strong>启动sshd</strong></h3><p>配置完成后, 如果没有<code>sshd</code>进程, 需要在设备A(服务端)/设备B(用户端)都启动sshd:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sshd -ddd -h /etc/ssh/ssh_host_rsa_key -f /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<p>其中参数<code>-ddd</code>用于输出调试信息, <code>-h</code>指定host密钥文件, <code>-f</code>指定<code>sshd</code>的配置;启动完成后, 设备就可以正常收到来其他ssh客户端的请求了.</p>
<h3 id="启动ssh远程登录"><a href="#启动ssh远程登录" class="headerlink" title="启动ssh远程登录"></a><strong>启动ssh远程登录</strong></h3><p>在大屏输入如下指令, 尝试与设备A(客户端)建立SSH链接:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -vvv -TN -i &lt;identity_file&gt; -R 8989:localhost:22 user_name@remote_host</span><br></pre></td></tr></table></figure>
<p><code>-vvv</code>参数用于输出debug信息, <code></code>-TN<code>告诉ssh在登录后不要开启终端执行指令而是监听某个指定的端口, -i</code>制定身份验证的密钥文件目录, 参数<code>-R</code>指定了远端转发端口的规则: 将来自远端<code>8989</code>的数据都转发到本地的<code>22</code>端口; 执行该命令后, 身份验证通过, 可能会输入服务器密码, 然后我们就可以看到ssh会一直在监听<code>8989</code>这个端口, 接着在设备A(服务器)输入指令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -vvv -i &lt;identity_file&gt;  -p 8989 root@localhost</span><br></pre></td></tr></table></figure>
<p>身份认证完成后, 就可以看到一个输入shell指令的命令窗口, 就算登录完成了.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul>
<li><a href="https://www.ssh.com/ssh/tunneling" target="_blank" rel="noopener">https://www.ssh.com/ssh/tunneling</a></li>
<li><a href="https://www.booleanworld.com/guide-ssh-port-forwarding-tunnelling/" target="_blank" rel="noopener">https://www.booleanworld.com/guide-ssh-port-forwarding-tunnelling/</a></li>
<li><a href="http://arondight.me/2016/02/17/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" target="_blank" rel="noopener">http://arondight.me/2016/02/17/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Secure_Shell</a></li>
<li><a href="https://tools.ietf.org/html/rfc4251" target="_blank" rel="noopener">The Secure Shell (SSH) Protocol Architecture</a></li>
<li><code>man ssh/sshd/sshd_config</code></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 网络协议 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SSH </tag>
            
            <tag> 远程登录 </tag>
            
            <tag> 反向隧道 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Recovery模式如何支持ADB]]></title>
      <url>http://sniffer.site/2019/12/31/Recovery%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81ADB/</url>
      <content type="html"><![CDATA[<p>这两天顺着recovery模式下一个网络需求, 为了便于调试又在recovery下做了ADB功能. 在Android早期的如4.4版本, recovery模式下支持ADB配置起来比较简单(支持<code>adb devices</code>/<code>adb reboot</code>/<code>adb pull/push</code>等常用指令), 但在Android 9.0下USB辅助设备一般都通过<code>configfs</code>的方式来配置了, 因此相对来说要适配的东西就多一些, 如果额外要适配<code>adb shell</code>命令, 则要修改<code>adbd</code>的源代码了.这篇文章就来看看如何在Recovery模式下解决这几个问题.</p>
<p>在进入正题之前, 先了解下USB相关的基础知识.</p>
<p>USB全称是<a href="https://en.wikipedia.org/wiki/USB" target="_blank" rel="noopener"><code>Universal Serial Bus</code></a>, 是一种广泛用于主机与外设之间的连接的串行总线.USB设备使用的是一种层级的结构, 最多可支持多达127个设备, 每个USB设备对应一个功能(<code>function</code>), 比如USB打印机提供了打印服务; 存储设备则提供了存储数据的功能.</p>
<p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/usb_system_architecture.png" alt="USB system architecture"></p>
<p>Android中的USB支持<a href="https://en.wikipedia.org/wiki/USB_On-The-Go" target="_blank" rel="noopener">OTG(On The Go)</a>, 因此有两种模式, 一种是Android自身作为host,可以接入其他USB设备;一种是Android作为peripheral设备, Android可以连接到PC端, 比如要查看Android设备的存储内容时, 使用ADB时都必须将Android设置为<code>peripheral</code>模式.ADB是Android中用于开发调试的一个工具, 更详细的说明可以参考官网的说明<a href="https://developer.android.com/studio/command-line/adb" target="_blank" rel="noopener">Android Debuge Bridge</a>.</p>
<h2 id="Recovery下的ADB"><a href="#Recovery下的ADB" class="headerlink" title="Recovery下的ADB"></a>Recovery下的ADB</h2><p>适配的第一步是首先看看源码. 进入Recovery的代码<code>/bootable/recovery</code>下面有一个<code>README.md</code>的文档, 里边有大致说明了如何在recovery下使用ADB. 对<code>USESRDEBUG/ENG</code>版本, 默认是启动了<code>adbd</code>, 并且对于<code>recovery</code>模式通过<code>adb devices</code>看到的是一个如下设备:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">1234567890abcdef    recovery</span><br></pre></td></tr></table></figure>
<p>还需要明确的一点是, 在recovery模式下, 只有部分adb指令可用, 比如<code>adb root</code>/<code>adb push/pull</code>, 如果要使用<code>adb shell</code>需要把<code>/system</code>分区挂载上来.看起来一切都比较简单了, 可通过<code>adb reboot recovery</code>之后却无法找到设备, 在PC端查看<code>dmesg</code>也没有任何USB设备枚举上来. </p>
<p>继续看文档, 上面说到, 如果设备使用了<code>configfs</code>这个配置文件系统的话, 需要设置相关的配置.那问题可能就出在这里: 使用了<code>configfs</code>来配置USB设备, 但是在recovery模式没有正常配置.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">If device is using [configfs](https://www.kernel.org/doc/Documentation/usb/gadget_configfs.txt),</span><br><span class="line">check if configfs has been properly set up in init rc scripts. See the [example</span><br><span class="line">configuration](https://android.googlesource.com/device/google/wahoo/+/master/init.recovery.hardware.rc)</span><br><span class="line">for Pixel 2 devices. Note that the flag set via sysfs (i.e. the one above) is no-op when using</span><br><span class="line">configfs.</span><br></pre></td></tr></table></figure>
<p>简单来说, 在Linux中, <code>USB Gadget</code>是一个具有UDC(<code>USB Device Controller</code>)的可以连接到一个USB Host的设备, 其通常具有串口通讯/数据存储的功能.而对于Host来说, 一个<code>USB Gadget</code>就是一个配置的集合而已, 每个配置包含很多接口, 也被称为功能(functions). 目前Linux已经包含了很多功能供<code>USB Gadgets</code>使用, 具体可以参看Linux的源码<code>/kernel/drivers/usb/gadget</code>. </p>
<p>那么具体来说ADB适配要经历哪几个步骤了? 接下来就来看一看recovery下适配ADB需要做的事情.</p>
<h2 id="Recovery下的ADB适配"><a href="#Recovery下的ADB适配" class="headerlink" title="Recovery下的ADB适配"></a>Recovery下的ADB适配</h2><ul>
<li><strong>挂载FunctionFs将USB用于ADB通信</strong></li>
</ul>
<p>在recovery代码目录<code>/bootable/recovery/etc/init.rc</code>中对ADB对应的<code>FunctionFs</code>做了配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">on fs</span><br><span class="line">    write /sys/class/android_usb/android0/f_ffs/aliases adb</span><br><span class="line">    mkdir /dev/usb-ffs 0770 shell shell</span><br><span class="line">    mkdir /dev/usb-ffs/adb 0770 shell shell</span><br><span class="line">    mount functionfs adb /dev/usb-ffs/adb uid=2000,gid=2000</span><br></pre></td></tr></table></figure>
<p>这个有什么用了?看ADB的源码(<code>/system/core/daemon</code>), 大致可以看到, 只有挂载了<code>functionfs</code>, ADB才能基于USB的<code>ep0</code>端口进行通讯:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// /dev/usb-ffs/adb/ep0 (main.cpp)</span></span><br><span class="line"><span class="keyword">if</span> (access(USB_FFS_ADB_EP0, F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Listen on USB.</span></span><br><span class="line">    usb_init();</span><br><span class="line">    is_usb = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usb.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usb_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dummy_fd = adb_open(<span class="string">"/dev/null"</span>, O_WRONLY);</span><br><span class="line">  CHECK_NE(dummy_fd, <span class="number">-1</span>);</span><br><span class="line">  usb_ffs_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usb.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usb_ffs_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D(<span class="string">"[ usb_init - using FunctionFS ]"</span>);</span><br><span class="line"></span><br><span class="line">    usb_handle* h = <span class="keyword">new</span> usb_handle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (android::base::GetBoolProperty(<span class="string">"sys.usb.ffs.aio_compat"</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// Devices on older kernels (&lt; 3.18) will not have aio support for ffs</span></span><br><span class="line">        <span class="comment">// unless backported. Fall back on the non-aio functions instead.</span></span><br><span class="line">        h-&gt;write = usb_ffs_write;</span><br><span class="line">        h-&gt;read = usb_ffs_read;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        h-&gt;write = usb_ffs_aio_write;</span><br><span class="line">        h-&gt;read = usb_ffs_aio_read;</span><br><span class="line">        aio_block_init(&amp;h-&gt;read_aiob);</span><br><span class="line">        aio_block_init(&amp;h-&gt;write_aiob);</span><br><span class="line">    &#125;</span><br><span class="line">    h-&gt;kick = usb_ffs_kick;</span><br><span class="line">    h-&gt;close = usb_ffs_close;</span><br><span class="line"></span><br><span class="line">    D(<span class="string">"[ usb_init - starting thread ]"</span>);</span><br><span class="line">    <span class="built_in">std</span>::thread(usb_ffs_open_thread, h).detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要了解USB<code>FunctionFs</code>的同学可以参考Linux的文档<code>https://www.kernel.org/doc/Documentation/usb/functionfs.txt</code>.</p>
<ul>
<li><strong>创建ADB相关的功能配置</strong></li>
</ul>
<p>挂载<code>configfs</code>到某个目录, 并生成ADB相关的配置, 主要是USB的ProductID/VendorID以及设备序列号等信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">on init</span><br><span class="line">    mount configfs none /config</span><br><span class="line">    mkdir /config/usb_gadget/g1 0770 shell shell</span><br><span class="line">    write /config/usb_gadget/g1/idVendor &lt;youre_usb_vendor_id&gt;</span><br><span class="line">    write /config/usb_gadget/g1/idProduct &lt;youre_usb_product_id&gt;</span><br><span class="line">    mkdir /config/usb_gadget/g1/strings/0x409 0770</span><br><span class="line">    write /config/usb_gadget/g1/strings/0x409/serialnumber $&#123;ro.serialno&#125;</span><br><span class="line">    write /config/usb_gadget/g1/strings/0x409/manufacturer $&#123;ro.product.manufacturer&#125;</span><br><span class="line">    write /config/usb_gadget/g1/strings/0x409/product $&#123;ro.product.model&#125;</span><br><span class="line">    mkdir /config/usb_gadget/g1/functions/ffs.adb</span><br><span class="line">    write /config/usb_gadget/g1/os_desc/use 1</span><br><span class="line">    setprop sys.usb.configfs 1</span><br></pre></td></tr></table></figure>
<p>配置完成后, <code>/config/usb_gadget/g1</code>目录下大致如下:</p>
<p><img src="https://md-files.oss-cn-shenzhen.aliyuncs.com/usb_gadgets_configfs.png" alt="usb gadget configfs"></p>
<ul>
<li><strong>使能对应的USB Gadgets</strong></li>
</ul>
<p>在Android设备文件目录<code>/sys/class/udc</code>找到对应USB设备控制器的名称, 将其写入到对应的配置, 从而使得USB主机端可以正常枚举到该USB设备:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">on property:sys.usb.ffs.ready=1</span><br><span class="line">    mkdir /config/usb_gadget/g1/configs/b.1 0777 shell shell</span><br><span class="line">    symlink /config/usb_gadget/g1/configs/b.1 /config/usb_gadget/g1/os_desc/b.1</span><br><span class="line">    mkdir /config/usb_gadget/g1/configs/b.1/strings/0x409 0770 shell shell</span><br><span class="line">    write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration &quot;adb&quot;</span><br><span class="line">    symlink /config/usb_gadget/g1/functions/ffs.adb /config/usb_gadget/g1/configs/b.1/f1</span><br><span class="line">    write /config/usb_gadget/g1/UDC &quot;a800000.dwc3&quot;  # 这里写入对应的UDC名字</span><br></pre></td></tr></table></figure>
<p>配置完成后, 重新打包下BOOT分区, 刷写后, 输入<code>adb devices</code>可以看到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List of devices attached </span><br><span class="line">1297270a	recovery</span><br></pre></td></tr></table></figure>
<p>说明修改起作用了, 但目前输入<code>adb shell</code>还是会提示<code>/system/bin/sh</code>目前找不到的错误, 原因是recovery并没有正常挂载<code>system</code>分区, 那么有没有可能不挂载<code>system</code>分区同时又能使用<code>adb shell</code>了? 看<code>/bootable/recovery/etc/init.rc</code>, recovery下实际有集成了一个命令工具集合<code>busybox</code>, 通过<code>busybox</code>我们应该也可以实现类似与正常模式下<code>/system/bin/sh</code>的功能, 这就需要修改Android中ADBD的源码了, 具体可以看下<code>/system/core/adb/shell_serivce.cpp</code>中的代码逻辑.</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://www.linux-usb.org/" target="_blank" rel="noopener">Linux USB相关的资料文档</a></li>
<li><a href="https://www.beyondlogic.org/usbnutshell/usb3.shtml#USBFunctions" target="_blank" rel="noopener">USB Nutshell</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/usb/gadget_configfs.txt" target="_blank" rel="noopener">USB Gadget Configfs</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/usb/functionfs.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/usb/functionfs.txt</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> ADB </tag>
            
            <tag> Recovery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SELinux在Android中的应用]]></title>
      <url>http://sniffer.site/2019/12/07/Selinux%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>SELinux(<a href="https://en.wikipedia.org/wiki/Security-Enhanced_Linux" target="_blank" rel="noopener">Security Enhanced Linux</a>)是Linux下的安全控制机制, 为进程访问系统资源提供了访问控制(access control)策略. 早期, Linux基于用户身份/用户组的DAC(<a href="https://en.wikipedia.org/wiki/Discretionary_access_control" target="_blank" rel="noopener">Discretionary Access Control</a>作为访问控制策略: 每个进程都有所属的UID, 每个文件都有所属的UID/GID以及文件模式(读写执行等), 一个进程是否可以访问某个文件就是基于UID/GID/文件模式来管理的.换句话说,只要某个资源序属于该用于或该用户组, 则该用户对该资源具有绝对控制权力, 这样一旦用户获得了root权限, 那么整个系统就成了肉鸡. 可见, DAC的安全控制策略比较粗放.</p>
<p>SELinux最初是由美国Utah大学与NSA(National Security Agency)的安全小组研究出来的<a href="http://freecomputerbooks.com/books/The_SELinux_Notebook-4th_Edition.pdf" target="_blank" rel="noopener">安全框架FLASK</a>演变而来, 后被合入到Linux 2.6版本.相较于DAC, SELinux采用的是更细粒度的MAC(<a href="https://en.wikipedia.org/wiki/Mandatory_access_control" target="_blank" rel="noopener">Mandatory Access Control</a>).对于DAC而言, 资源的权限是由每个用户自己控制的, 而MAC则将所有的权限收拢, 由一个统一的管理者(SELinux)统一来分配所有的资源权限, 如果访问者没有事先分配到某个资源的权限, 则不会允许访问.这样即使是root用户也要收到安全策略的约束. Android在4.3开始引入SELinux, 到了5.0版本之后, 则开始全面支持了.</p>
<p>在SELinux机制下, Android中所有的对象(进程/文件/socket/property)都打上了标签(label), 进程访问对象时, SELinux根据事先配置好的安全策略(security policy)判断访问者是否有权限. </p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/selinux_policy_concepts.png" alt="selinux policy concepts"></p>
<p>另外, Android系统是同时支持DAC与SELinux的, 就是说, 在一个进程访问某个资源时,会按照如下规则进行权限控制:</p>
<ul>
<li>首先根据DAC规则, 检查进程权限, 是否具有对应资源的读写/执行权限, 如果没有则拒绝执行;</li>
<li>如果DAC规则检查通过, 则执行SELinux安全规则的检查, 如果不通过,则拒绝访问.</li>
</ul>
<h2 id="初识SELinux"><a href="#初识SELinux" class="headerlink" title="初识SELinux"></a><strong>初识SELinux</strong></h2><p>SELinux的首要原则是: 任何未被声明允许执行的都会被拒绝, 其有两种运行模式:</p>
<ul>
<li><code>Permissive</code>模式: 访问控制的策略不会强制执行, 但是会被日志记录下来</li>
<li><code>Enforcing</code>模式: 访问控制策略会被强制执行并被记录下来</li>
</ul>
<p>在Android下可以通过 <code>adb getenforce</code>来查看当前SELinux处于何种模式, 也可以通过<code>adb setenforce</code>来设置SELinux的模式(USER版本默认是<code>enforcing</code>, USERDEBUG/ENG可以设置模式):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">adb setenforce 0 // permissive模式</span><br><span class="line">adb setenforce 1 // enforcing模式</span><br></pre></td></tr></table></figure>
<p>在SELinux中, 主要有Subject/Object/Object Manager/Security Server等几个核心的组成部分(见下图):</p>
<ul>
<li><code>Subject</code>: 在SELinux中, <code>Subject</code>是一个进程, 每个<code>Subject</code>都有与之关联的一个安全上下文(<code>security context</code>); <code>Subject</code>负责发起访问某个对象的请求,比如读文件/建立socket链接</li>
<li><code>Object</code>: 一个对象就是一个资源, 比如文件, socket, pipes以及网络接口；每个对象都由一个类型标识其用途(file, socket), 并且与一个权限(permissions)集合关联, 该权限集合描述了对象能提供什么样的服务(比如read/write/send等)</li>
<li><code>Object Manager</code>: 对象管理者负责管理所有对象以及这些对象上能够执行的动作</li>
<li><code>Access Vecctor Cache</code>: 用于缓存Security Server的访问决策,以改善系统性能</li>
<li><code>Security Server</code>: 安全服务器根据安全策略来决定某个对象上的动作是否被执行</li>
<li><code>Security Policy</code>: 用于描述SELinux的访问规则</li>
</ul>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/selinux_core_components.png" alt="SELinux components"></p>
<p>接下来我们看看SELinux具体是如何给每个对象打标签以及实现安全策略规则的.</p>
<h3 id="标签-label-与策略规则"><a href="#标签-label-与策略规则" class="headerlink" title="标签(label)与策略规则"></a><strong>标签(label)与策略规则</strong></h3><p>SELinux是通过标签(label)来匹配执行动作以及策略的.标签决定了何种动作是允许被执行的, socket/文件/进程都有自己的标签. SELinux的访问控制就是根据各个对象上的的标签来决定的, 而策略文件则定义了这些对象是如何相互交互的.</p>
<p>一个标签通常有如下的形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">user:role:type:mls_level</span><br></pre></td></tr></table></figure>
<p>这样一个标签也通常被成为<code>Security Context</code>. 在Android中, 通常不用关心<code>user</code>/<code>role</code>/<code>msl_level</code>, <code>user</code>一般只有<code>u</code>, <code>role</code>对于进程来说是<code>r</code>, 对其他对象是<code>object_r</code>, <code>msl_level</code>是<code>s0</code>, 而<code>type</code>则用来标识对象的类型, 其决定了该对象的所具备的能力, 因此Android中的SELinux又称为基于TE(<code>Type Enforcement</code>)的安全机制, 在Android中, 所有的SELinux策略文件都以<code>te</code>结尾.</p>
<p>通过<code>ls/ps</code>指令中加入<code>-Z</code>参数, 可以查看文件/进程的SELinux状态, 如输入<code>ls -aZ /init*</code>查看<code>init</code>文件夹的标签:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ls_z_file_context.png" alt="ls -z示例"></p>
<p>上图中的<code>init</code>可执行程序以及文件夹都是在<code>/system/sepolicy/private/file_contexts</code>中定义的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Data files</span><br><span class="line">/adb_keys           u:object_r:adb_keys_file:s0</span><br><span class="line">/build\.prop        u:object_r:rootfs:s0</span><br><span class="line">/default\.prop      u:object_r:rootfs:s0</span><br><span class="line">/fstab\..*          u:object_r:rootfs:s0</span><br><span class="line">/init\..*           u:object_r:rootfs:s0</span><br><span class="line">/res(/.*)?          u:object_r:rootfs:s0</span><br><span class="line">/selinux_version    u:object_r:rootfs:s0</span><br><span class="line">/ueventd\..*        u:object_r:rootfs:s0</span><br><span class="line">/verity_key         u:object_r:rootfs:s0</span><br><span class="line"></span><br><span class="line"># Executables</span><br><span class="line">/charger            u:object_r:rootfs:s0</span><br><span class="line">/init               u:object_r:init_exec:s0</span><br><span class="line">/sbin(/.*)?         u:object_r:rootfs:s0</span><br></pre></td></tr></table></figure>
<p>同样输入<code>ps -Z</code>可以查看进程的标签:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ps_z_security_context.png" alt="ps -Z"></p>
<p>策略规则(policy rules)决定了进程是如何访问对象的, 其通常是如下格式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">allow domains types:classes permissions</span><br></pre></td></tr></table></figure>
<p>这里, </p>
<ul>
<li><code>Domain</code>: 域是一个进程或一组进程的标签,也被成为域类型</li>
<li><code>Type</code>: 对象的标签(如file/socket等)或者一个对象集合</li>
<li><code>Class</code>: 访问对象的类型</li>
<li><code>Permission</code>: 请求的权限(read/write)</li>
</ul>
<p>举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">allow appdomain app_data_file:file rw_file_perms;</span><br></pre></td></tr></table></figure>
<p>这个规则的意思是允许所有应用域的进程访问标签为<code>app_data_file</code>的文件. 所有这些规则需要依赖于<code>global_macros</code>/<code>te_macros</code>的宏定义(位于<code>/system/sepolicy</code>目录下). 除了像上面的规则指定某个特定的域或类型, 也可以通过指定一个属性(<code>attribute</code>)来表示一组域或类型;当通过一个规则有属性时, 会被自动扩展成为了相应的域或类型. 按照上述方式写成的规则如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RULE_VARIANT SOURCE_TYPES TARGET_TYPES: CLASSES PERMISSIONS</span><br></pre></td></tr></table></figure>
<p>在这个规则下, 只要一个<code>Subject</code>标识了<code>SOURCE_TYPES</code>就可以有权在类型为<code>CLASSES</code>/标签为<code>TAEGET_TYPES</code>的对象上执行任何在<code>PERMISSONS</code>中声明的操作.例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">allow domain null_device:chr_file &#123; getattr open read ioctl write&#125;;</span><br></pre></td></tr></table></figure>
<p>这个条规则意思是允许任何有<code>domain</code>域的进程访问<code>null_device</code>类型(对应<code>/dev/null</code>)的字符设备.最后我们来看下Android是如何应用SELinux的.</p>
<h2 id="SELiunx在Android中的应用"><a href="#SELiunx在Android中的应用" class="headerlink" title="SELiunx在Android中的应用"></a><strong>SELiunx在Android中的应用</strong></h2><p>Android的SELinux配置(以下均以Android P 9.0的代码为例)在Android源码中有两个目录: </p>
<ul>
<li><code>/system/sepolicy</code></li>
<li><code>/device/&lt;manufactory&gt;/&lt;device-name&gt;/sepolicy</code></li>
</ul>
<p>而<code>/system/sepolicy</code>主要是Android原生已有的SELinux文件, 包括所有SELinux标签以及策略文件<code>.te</code>的定义, 一般不做修改;<code>/device</code>目录下的SELinux配置通过编译宏<code>BOARD_SEPOLICY_DIRS</code>引入, 所有SELinux相关的编译都要依靠<code>/system/sepolicy/Android.mk</code>这个makefile. 具体来说, SELinux的配置大致有如下几个部分:</p>
<table>
<thead>
<tr>
<th>配置目录</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/system/sepolicy/public</td>
<td>包含了系统sepolicy相关的API</td>
</tr>
<tr>
<td>/system/sepolicy/private</td>
<td>包含了系统sepolicy的具体实现(与vendor无关)</td>
</tr>
<tr>
<td>/system/sepolicy/vendor</td>
<td>提供给厂商(vendor)自由实现的配置</td>
</tr>
<tr>
<td>BOARD_SEPOLICY_DIRS</td>
<td>包含厂商sepolicy的定制化配置</td>
</tr>
</tbody>
</table>
<p>所有以<code>.te</code>结尾的都是安全策略文件, 其定义了对象的域(domain)和类型(types); 而SELinux标签文件(也称为SELinux context文件), 大致有<a href="https://source.android.com/security/selinux/implement.html#key_files" target="_blank" rel="noopener">如下几种</a>:</p>
<ul>
<li><code>file_contexts</code>: 为用户空间的文件分配标签</li>
<li><code>genfs_contexts</code>: 为不支持扩展属性的文件分配标签(如<code>proc</code>/<code>vfat</code>)</li>
<li><code>property_contexts</code>: 为Android所有属性分配标签,<code>init</code>进程在初始化时会读取该配置 </li>
<li><code>service_contexts</code>: 为Android所有binder服务分配标签, 用于控制哪些进程可以注册/查找这些服务</li>
<li><code>seapp_contexts</code>: 为<code>/data/data</code>目录下的应用分配标签, 应用启动时<code>zygote</code>进程以及在应用安装时<code>installd</code>都会读取该配置</li>
<li><code>mac_permissions.xml</code>: 根据应用的签名(也可能包括包名)分配<code>seinfo tag</code>;<code>seinfo tag</code>在<code>seapp_contexts</code>文件中可以当作一个密钥用于分配特定的标签给所有的应用. 该配置在<code>system_sever</code>启动时会被读取</li>
</ul>
<p>那么, 这些SELinux的标签配置以及策略文件是如何编译的? 大致有两个编译路径,所有的<code>file_contexts</code>标签文件都会编译生成一个<code>file_contexts.bin</code>;而其他的如<code>security_classes</code>/<code>*.te</code>/<code>genfs_contexts</code>/<code>port_contexts</code>等文件都会编译生成一个<code>sepolicy</code>的二进制文件, 整体的编译逻辑如下图所示:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/selinux_android_build.png" alt="SELinux build logic"></p>
<p>有关SELinux在Android的编译可以参考<a href="https://source.android.com/security/selinux/build" target="_blank" rel="noopener">https://source.android.com/security/selinux/build</a>. </p>
<p>有了SELinux的基础知识, 要如何修改或者添加SELinux规则? 一般, 通过<code>dmesg | grep avc</code>或则<code>logcat | grep avc</code>查看系统当前的SELinux访问的记录, 如果出现<code>avc: denied</code>等字样, 说明有进程违反了安全策略, 举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[   42.357295] selinux: avc:  denied  &#123; set &#125; for property=net.usb0.dns1 pid=473 uid=0 gid=0 scontext=u:r:network_manager:s0 tcontext=u:object_r:system_prop:s0 tclass=proper1</span><br></pre></td></tr></table></figure>
<p>这个访问拒绝的提示说明, 进程<code>473</code>(network_manager)的标签<code>u:r:network_manager:s0</code>不具备访问标签为<code>u:object_r:system_prop:s0</code>, 类型为<code>system_prop</code>的属性值, 需要添加安全规则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">set_prop(network_manager, system_prop)</span><br></pre></td></tr></table></figure>
<p>再次编译验证后就不会出现访问拒绝的日志了.</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://source.android.com/security/selinux/images/SELinux_Treble.pdf" target="_blank" rel="noopener">SELinux for Android</a></li>
<li><a href="https://source.android.com/security/selinux/build" target="_blank" rel="noopener">SEAndroid的介绍</a></li>
<li><a href="http://freecomputerbooks.com/books/The_SELinux_Notebook-4th_Edition.pdf" target="_blank" rel="noopener">SELinux NoteBook</a></li>
<li><a href="http://www.cs.columbia.edu/~lierranli/coms6998-7Spring2014/papers/SEAndroid-NDSS2013.pdf" target="_blank" rel="noopener">SELinux在Android应用的挑战与问题</a></li>
<li><a href="https://wiki.gentoo.org/wiki/SELinux/Quick_introduction#SELinux_policy" target="_blank" rel="noopener">Introduction to SELinux</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
            <category> Security </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> SELinux </tag>
            
            <tag> Security </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BPF与eBPF]]></title>
      <url>http://sniffer.site/2019/11/07/BPF%E4%B8%8EeBPF/</url>
      <content type="html"><![CDATA[<p>最近了解Linux的性能优化时, 偶然接触到了BPF(<a href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter" target="_blank" rel="noopener">Berkeley Packet Filter</a>)。很有意思也很强大的功能;想把学到的一些基本原理与知识记录下来, 算是一个初步的总结. 这篇文章主要从如下几个方面介绍下BPF <a id="more"></a>:</p>
<ul>
<li>BPF的原理</li>
<li>什么是eBPF</li>
<li>如何在Linux中使用BPF</li>
</ul>
<p>用过<code>tcpdump</code>的同学应该都了解<code>pcap</code>, 实际上<code>pcap</code>就是基于BPF来实现网络数据包的过滤的. <code>tcpdump</code>的原理如下图所示: <code>tcpdump</code>将包过滤的表达式, 如查看某个网口所有udp包, 输入<code>tcpdump -n -i eth0 udp</code>, 这个表达式通过PCAP库编译成伪机器字节码后, 通过系统调用发送给内核(内核中有对应的机器码解释器)解释执行, 这样只要系统有udp包, 内核都会过滤出来转发给用户进程<code>tcpdump</code>:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcpdump%E5%8E%9F%E7%90%86.png" alt="how tcpdump works"></p>
<p>BPF全称Berkeley Packet Filters, 最初是Steven MaCanne, Van Jacobson在文章<a href="http://www.tcpdump.org/papers/bpf-usenix93.pdf" target="_blank" rel="noopener">‘The BSD Packet Filter: A New Architecture for User-level Packet Capture’</a>中提出的一种基于BSD Unix操作系统的包过滤器, 其原理是将包过滤的表达式编译成特定伪机器码后, 由Kernel中的虚拟机执行; 每当网卡中有数据包过来时, 将其拷贝发送给BPF模块, 由BPF根据对应的过滤条件将过滤后的包发送给用户进程:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/how_bpf_works.png" alt="how BPF works"></p>
<blockquote>
<p>针对tcpdump, linux有专门用于包过滤的表达式, 参考<code>pcap-filter</code></p>
</blockquote>
<p>BPF在Linux中的发展大致经历三个阶段: </p>
<ul>
<li>Linux 2.1.75最初的实现基于原有的socket接口, 被称为<a href="https://www.kernel.org/doc/Documentation/networking/filter.txt" target="_blank" rel="noopener"><code>Linux Socket Filter</code></a>(LSF)</li>
<li>Linux 3.0版本中,在BPF中加入JIT(<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="noopener"><code>Just-In-Time Compiler</code></a>), 提升BPF的性能与速度 </li>
<li>Linux 3.15开始将BPF扩展成为通用的模块, BPF不仅可用于数据包过滤, 也可以用来进行内核事件跟踪/应用性能调优/流量控制(Traffic Control)等, 代码也统一整合到了<code>/kernel/bpf</code>, 这也是目前被称为eBPF(extended BPF)的原因, 而早前的BPF实现则被称为cBPF(classic BPF).</li>
</ul>
<p>首先来看下传统的cBPF是如何实现的.</p>
<h2 id="cBPF"><a href="#cBPF" class="headerlink" title="cBPF"></a><strong>cBPF</strong></h2><p>BPF最初的BSD实现方案是通过打开一个字符设备<code>/dev/bpf*</code>(<code>/dev/bpf0</code>, <code>/dev/bpf1</code> etc), 再通过<code>ioctl</code>来控制该设备, 而Linux内核则基于现有的<code>socket</code>接口加入新的选项<code>SO_ATTACH_FILTER/SO_DETACH_FILTER</code>来执行系统调用, 具体的代码实现在<a href="https://elixir.bootlin.com/linux/v3.10.107/source/net/core/filter.c" target="_blank" rel="noopener"><code>/net/core/filter.c</code></a>. 通过一个简单的示例来看下cBPF是如何工作的.</p>
<ul>
<li>首先通过<code>tcpdump</code>指令来产生数据包的过滤代码: <code>tcpdump dst port 53 -dd</code>(这里过滤所有目标端口为53的数据包)</li>
<li>然后创建一个<code>AF_PACKET</code>(用于接收所有的数据包)的<code>socket</code>用于向kernel传递过滤代码, 并接收过滤后的数据包</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// tcpdump dst port 53 -dd</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter_code</span>[] = &#123;</span></span><br><span class="line">    &#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000c</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0x000086dd</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x30</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000014</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0x00000084</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x00000006</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">17</span>, <span class="number">0x00000011</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000036</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">0x00000035</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000038</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">0x00000035</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">0x00000800</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x30</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000017</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0x00000084</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x00000006</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0x00000011</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000014</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x45</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0x00001fff</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0xb1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000e</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x48</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000e</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0x00000035</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x48</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000010</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x00000035</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00040000</span> &#125;,</span><br><span class="line">    &#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000000</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">bpf</span> = &#123;</span></span><br><span class="line">    .len = <span class="keyword">sizeof</span>(filter_code)/(<span class="keyword">sizeof</span>(struct sock_filter)),</span><br><span class="line">    .filter = filter_code,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock_fd, bytes;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip_header</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> src_addr[INET_ADDRSTRLEN], dst_addr[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">char</span> *iface_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s iface_name\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. create socket</span></span><br><span class="line">    sock_fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line">    <span class="keyword">if</span> (sock_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket created failure"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    iface_name = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sll_ifindex = if_nametoindex(iface_name);</span><br><span class="line">    addr.sll_family = AF_PACKET;</span><br><span class="line">    addr.sll_protocol = htons(ETH_P_ALL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. attach filter (no need to call bind)</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sock_fd, SOL_SOCKET, SO_ATTACH_FILTER, &amp;bpf, <span class="keyword">sizeof</span>(bpf)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"attaching filter failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bytes = recv(sock_fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytes &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"received data failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ip_header = (struct iphdr *) (buf + <span class="keyword">sizeof</span>(struct ether_header));</span><br><span class="line">        inet_ntop(AF_INET, &amp;ip_header-&gt;saddr, src_addr, <span class="keyword">sizeof</span>(src_addr));</span><br><span class="line">        inet_ntop(AF_INET, &amp;ip_header-&gt;daddr, dst_addr, <span class="keyword">sizeof</span>(dst_addr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"IPv%d proto=%d src=%s dest=%s\n"</span>, </span><br><span class="line">                ip_header-&gt;version, ip_header-&gt;protocol, src_addr, dst_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刚才说到在Linux 3.0版本中BPF加入了JIT; JIT能够提升伪机器码的执行效率. 从执行流程来说, 主要区别在于传入内核的<code>socket_filter</code>伪机器代码都会通过<code>bpf_jit_compile</code>进行优化处理, 然后再通过字节码解释器执行. 具体来说, 不同的平台<a href="https://elixir.bootlin.com/linux/v3.10.107/ident/bpf_jit_compile" target="_blank" rel="noopener"><code>bpf_jit_compile</code></a>的实现不一样, 内核中的代码路径位于<code>arch/&lt;platform&gt;/net/</code>, 感兴趣的可以跳转到<a href="https://elixir.bootlin.com/linux/v3.10.107/ident/bpf_jit_compile" target="_blank" rel="noopener">这里</a>看下.</p>
<h2 id="eBPF"><a href="#eBPF" class="headerlink" title="eBPF"></a><strong>eBPF</strong></h2><p><code>eBPF</code>即<a href="https://lwn.net/Articles/603983/" target="_blank" rel="noopener"><code>extended BPF</code></a>, 顾名思义是对原有BPF进行了扩展, 这样不仅BPF可以用来过滤网络数据包(tcpdump/XDP), 也可以用于性能分析, 将BPF代码插入到内核的跟踪点(<code>tracepoints</code>), <code>kprobes</code>, <code>perf</code>事件, 收集相应的数据.除了扩展了cBPF的功能外, eBPF另一个不同于cBPF的地方在于调用的方式: eBPF提供了一个统一的<code>bpf()</code>系统调用来执行相应的操作,同时应用与内核的数据传递也统一通过<code>map</code>这种数据结构来进行. 比如用<code>BPF_MAP_CREATE</code>命令来创建一个eBPF的map对象(不同的内核事件对应的map类型不同):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure>
<p>我们可以通过<a href="http://man7.org/linux/man-pages/man2/bpf.2.html" target="_blank" rel="noopener"><code>man bpf</code></a>来查看<code>bpf</code>系统调用的具体用法. eBPF对于内核的开发, 以及性能分析无疑是一大利器, 先通过具体的实例来看一看如何使用eBPF(Linux源码中有很多示例<a href="https://elixir.bootlin.com/linux/latest/source/samples/bpf" target="_blank" rel="noopener"><code>samples/bpf</code></a>):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_sock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sock = <span class="number">-1</span>, map_fd, prog_fd, i, key;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">0</span>, tcp_cnt, udp_cnt, icmp_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个bpf的array map用于保存结果</span></span><br><span class="line">  map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(key), <span class="keyword">sizeof</span>(value), <span class="number">256</span>);</span><br><span class="line">  <span class="keyword">if</span> (map_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"failed to create map '%s'\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// eBPF对应的伪机器码</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] = &#123;</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),</span><br><span class="line">    BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr, protocol) <span class="comment">/* R0 = ip-&gt;proto */</span>),</span><br><span class="line">    BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, <span class="number">-4</span>), <span class="comment">/* *(u32 *)(fp - 4) = r0 */</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>), <span class="comment">/* r2 = fp - 4 */</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_1, map_fd),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem),</span><br><span class="line">    BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, <span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_1, <span class="number">1</span>), <span class="comment">/* r1 = 1 */</span></span><br><span class="line">    BPF_RAW_INSN(BPF_STX | BPF_XADD | BPF_DW, BPF_REG_0, BPF_REG_1, <span class="number">0</span>, <span class="number">0</span>), <span class="comment">/* xadd r0 += r1 */</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>), <span class="comment">/* r0 = 0 */</span></span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载eBPF伪机器码到内核</span></span><br><span class="line">  prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog, <span class="keyword">sizeof</span>(prog),</span><br><span class="line">        <span class="string">"GPL"</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (prog_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"failed to load prog '%s'\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sock = open_raw_sock(<span class="string">"lo"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将该eBPF的伪代码绑定到某个socket上</span></span><br><span class="line">  <span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd,</span><br><span class="line">          <span class="keyword">sizeof</span>(prog_fd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查询过滤得到的结果</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    key = IPPROTO_TCP;</span><br><span class="line">    assert(bpf_lookup_elem(map_fd, &amp;key, &amp;tcp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_UDP;</span><br><span class="line">    assert(bpf_lookup_elem(map_fd, &amp;key, &amp;udp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_ICMP;</span><br><span class="line">    assert(bpf_lookup_elem(map_fd, &amp;key, &amp;icmp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"TCP %lld UDP %lld ICMP %lld packets\n"</span>,</span><br><span class="line">          tcp_cnt, udp_cnt, icmp_cnt);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">  <span class="comment">/* maps, programs, raw sockets will auto cleanup on process exit */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到,对于eBPF而言, 大概有如下几个执行步骤:</p>
<ul>
<li>编写ePBF伪机器代码</li>
<li>调用<code>bpf</code>创建对应的map对象, 并将伪机器码加载到内核</li>
<li>内核对加载得到伪机器码进行优化/校验, 验证其是否合法(是否有非法指令等)</li>
<li>用户程序通过<code>bpf</code>的接口读取内核事件的结果</li>
</ul>
<p>这个例子用的是类似汇编语言的方式来实现eBPF伪机器代码, 这个对于非专业的开发者来说实在有点痛苦. 那么, 能否通过其他高级语言来编写eBPF的代码了? 这就要用到专门的编译器<a href="https://en.wikipedia.org/wiki/LLVM" target="_blank" rel="noopener"><code>LLVM</code>(Lower Level Virtual Machine)</a>了.通过<code>LLVM</code>, 我们只需要将需要执行的eBPF代码用C语言编写好后, 将其编译成<code>elf</code>格式的镜像(image)文件, 然后通过<code>libelf</code>库加载解析后, 装载到内核中执行. 如果去看<a href="https://elixir.bootlin.com/linux/latest/source/samples/bpf" target="_blank" rel="noopener"><code>samples/bpf</code></a>中的其他示例, 都是通过类似的方式实现的.</p>
<p>了解了eBPF大致的执行流程, 我们一起来看下eBPF原理的框架简图(eBPF涉及的内核知识比较多, 刚开始建立一个整体的框架有助于理解):</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ebpf_architecture.png" alt="eBPF architecture"></p>
<h2 id="BCC"><a href="#BCC" class="headerlink" title="BCC"></a><strong>BCC</strong></h2><p>即使有现成的编译工具LLVM, 有加载解析elf的库, 但对大部分开发者来说, 日常并没有太多时间精力一步步来开发这些eBPF工具与代码. 于是, 一些大牛们便搞出了一套<a href="https://github.com/iovisor/bcc" target="_blank" rel="noopener">BCC(BPF Compilation Collection)</a>的eBPF工具集合, 这个工具集合把所有eBPF内核代码编写/编译以及错误处理的流程都封装好了, 使用时只需通过python/Lua等脚本语言进行调用,这里从BCC的示例中选出一个简单的例子, 可以看到BCC极大的简化了eBPF的开发与使用流程:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Copyright (c) PLUMgrid, Inc.</span></span><br><span class="line"><span class="comment"># Licensed under the Apache License, Version 2.0 (the "License")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run in project examples directory with:</span></span><br><span class="line"><span class="comment"># sudo ./hello_world.py"</span></span><br><span class="line"><span class="comment"># see trace_fields.py for a longer example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每当发生`clone`系统调用时, 该脚本都会打印`hello world`</span></span><br><span class="line"><span class="comment"># This may not work for 4.17 on x64, you need replace kprobe__sys_clone with kprobe____x64_sys_clone</span></span><br><span class="line">BPF(text=<span class="string">'int kprobe__sys_clone(void *ctx) &#123; bpf_trace_printk("Hello, World!\\n"); return 0; &#125;'</span>).trace_print()</span><br></pre></td></tr></table></figure>
<p>如果Linux内核版本在4.4以上(如Ubuntu 16.04等), 可以通过如下指令安装BCC使用:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># echo "deb [trusted=yes] https://repo.iovisor.org/apt/xenial xenial-nightly main" | \</span></span><br><span class="line">    sudo tee /etc/apt/sources.list.d/iovisor.list</span><br><span class="line"><span class="comment"># sudo apt-get update</span></span><br><span class="line"><span class="comment"># sudo apt-get install bpfcc-tools	# or the old package name: bcc-tools</span></span><br></pre></td></tr></table></figure>
<p>相应的, BCC的工具会安装到<code>/usr/share/bcc/tools</code>下面.更多BCC功能的解锁说明可以参考<a href="http://www.brendangregg.com/ebpf.html" target="_blank" rel="noopener">Brendan D.Gregg性能优化大牛的eBPF介绍</a>以及BCC的[官网]<a href="https://github.com/iovisor/bcc)" target="_blank" rel="noopener">https://github.com/iovisor/bcc)</a>. 安装完成后, 无论是对CPU, 内存, 磁盘I/O还是网络数据的传输都可以利用这一套工具进行监控了.</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html" target="_blank" rel="noopener">Breadan Gregg大牛的博客, 性能优化的大牛</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/bpf.2.html" target="_blank" rel="noopener">BPF系统调用的说明</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html" target="_blank" rel="noopener">BPF的很详尽的介绍资料</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/networking/filter.txt" target="_blank" rel="noopener">Linux BPF实现的说明</a></li>
<li><a href="https://llvm.org/" target="_blank" rel="noopener">LLVM开源项目的官网</a></li>
<li><a href="https://github.com/iovisor/bcc" target="_blank" rel="noopener">BCC Github主页, 如何使用/安装/开发资料很全面</a></li>
<li><a href="https://lwn.net/Articles/742082/" target="_blank" rel="noopener">BCC入门级介绍</a></li>
<li><a href="https://github.com/zoidbergwill/awesome-ebpf" target="_blank" rel="noopener">收集了很多eBPF相关的资料</a></li>
<li><a href="https://qmonnet.github.io/whirl-offload/2016/09/01/dive-into-bpf/" target="_blank" rel="noopener">BPF资料合集</a></li>
<li><a href="https://blogs.oracle.com/linux/notes-on-bpf-1" target="_blank" rel="noopener">Oracle技术博客上有关BPF的系列文章</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 网络协议 </category>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Berkeley Packet Filters </tag>
            
            <tag> extended Berkeley Packet Filters </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[说说Process.waitfor()引起的进程阻塞问题]]></title>
      <url>http://sniffer.site/2019/09/04/%E8%AF%B4%E8%AF%B4Process-waitfor-%E5%BC%95%E8%B5%B7%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>最近碰到一个看似很怪异的问题, 在两个APP上调用同样的本地指令得到的结果却大相径庭; 看源代码, 这个本地进程做的事情其实并不复杂:</p>
<ul>
<li>从一个串口<code>/dev/ttyUSBX</code>读取数据</li>
<li>将数据写入到本地目录(读缓存大小为1KB)</li>
</ul>
<p>本地进程的代码逻辑其实相当简单: 主线程起来后主动创建一个负责读/写的子线程, 然后通过<code>pthread_join</code>主动等待子线程完成后退出.</p>
<p>问题是, 应用A调用的时保存的日志大小雷打不动的停留在不到4M就停止了, 而应用B可以一直写数据. 看应用A调用时, 通过<code>debuggerd -b &lt;tid&gt;</code>查看本地进程的堆栈, 大概是这样的:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/process_stack.jpg" alt="process stack"></p>
<p>说明此时本地进程一直在”卡”在写数据上了, 那到底卡在哪里了? 查看<code>cat /proc/&lt;pid&gt;/wchan</code>(也可以通过<code>strace -p &lt;pid&gt;</code>来查看目前进程所调用的系统调用), 就是本地进程的正在执行的系统调用, 发现是<code>pipe_wait</code>, 这个是怎么回事? 本地进程本身并不会用到pipe来进行数据的传输, 那很可能是Java父进程与本地进程之间的数据通信管道了. </p>
<p>回到最开始的问题, 为何两个APP调用同样的指令会有如此大的差异了? 我们再来看看应用A与应用B之间执行的代码到底有多少的差异?</p>
<ul>
<li>应用A的调用逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">Process process = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    process = Runtime.getRuntime().exec(COMMAND);</span><br><span class="line">    process.waitFor();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(process != <span class="keyword">null</span>) &#123;</span><br><span class="line">        process.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>应用B的调用逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Process process = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    process = Runtime.getRuntime().exec(COMMAND);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(process != <span class="keyword">null</span>) &#123;</span><br><span class="line">        process.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么一对比, 看起来问题是出在<code>Process.waitfor()</code>上了, 看了网上一个类似的案例<code>https://www.cnblogs.com/embedded-linux/p/6986525.html</code>, 顿时觉得豁然开朗, 这个不就是我碰到问题末!  看 <code>java.lang.Process</code>的文档说明(这里只拿了最关键的一段话): </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">By default, the created process does not have its own terminal</span><br><span class="line">or console.  All its standard I/O (i.e. stdin, stdout, stderr)</span><br><span class="line">operations will be redirected to the parent process, where they can</span><br><span class="line">be accessed via the streams obtained using the methods</span><br><span class="line">&#123;@link #getOutputStream()&#125;,</span><br><span class="line">&#123;@link #getInputStream()&#125;, and</span><br><span class="line"> &#123;@link #getErrorStream()&#125;.</span><br><span class="line">The parent process uses these streams to feed input to and get output</span><br><span class="line">from the process.  Because some native platforms only provide</span><br><span class="line">limited buffer size for standard input and output streams, failure</span><br><span class="line">to promptly write the input stream or read the output stream of</span><br><span class="line">the process may cause the process to block, or even deadlock.</span><br></pre></td></tr></table></figure>
<p>这段话的大概意思是, 通过Java创建的本地子进程本身是没有标准输入/输出以及错误流的, 这三个流都会被重定向到父进程; 父进程则通过<code>Process.getInputStream()/getOutputStream</code>等来获取子进程的流, 而如果父进程如果一直不读取子进程的输出流, 由于平台本身的输入输出流的缓冲大小是有限的, 此时子进程就可能阻塞, 甚至死锁(如果父进程也在等待子进程的话). 这样看起来, 问题的原因就很明显了:  应用A没有处理子进程的输出流, 且调用了<code>Process.waitfor()</code>, 由于本地进程一直在打印输出日志, 导致输出缓冲区满了之后发生阻塞, 而父进程并不知道子进程发生了阻塞, 一直傻傻的等.现在看来, 调用任何接口之前看<strong>看文档</strong>总是有益的, 至少在定位分析问题的时候可以少走弯路.</p>
<p>我们先来看下Java调用本地进程的整个处理流程, 再来看具体如何解决这个问题.  调用<code>Runtime.exec(cmd)</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String prog)</span> <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> exec(prog, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String prog, String[] envp, File directory)</span> <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line"><span class="comment">// Sanity checks</span></span><br><span class="line"><span class="keyword">if</span> (prog == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"prog == null"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (prog.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"prog is empty"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Break down into tokens, as described in Java docs</span></span><br><span class="line">StringTokenizer tokenizer = <span class="keyword">new</span> StringTokenizer(prog);</span><br><span class="line"><span class="keyword">int</span> length = tokenizer.countTokens();</span><br><span class="line">String[] progArray = <span class="keyword">new</span> String[length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    progArray[i] = tokenizer.nextToken();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delegate</span></span><br><span class="line"><span class="keyword">return</span> exec(progArray, envp, directory);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String[] progArray, String[] envp, File directory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// ProcessManager is responsible for all argument checking.</span></span><br><span class="line">      <span class="keyword">return</span> ProcessManager.getInstance().exec(progArray, envp, directory, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>接着调用<code>ProcessManager.getInstance().exec()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes a process and returns an object representing it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Process <span class="title">exec</span><span class="params">(String[] taintedCommand, String[] taintedEnvironment, File workingDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> redirectErrorStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure we throw the same exceptions as the RI.</span></span><br><span class="line">    <span class="keyword">if</span> (taintedCommand == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"taintedCommand == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (taintedCommand.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"taintedCommand.length == 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle security and safety by copying mutable inputs and checking them.</span></span><br><span class="line">    String[] command = taintedCommand.clone();</span><br><span class="line">    String[] environment = taintedEnvironment != <span class="keyword">null</span> ? taintedEnvironment.clone() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check we're not passing null Strings to the native exec.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; command.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (command[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"taintedCommand["</span> + i + <span class="string">"] == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The environment is allowed to be null or empty, but no element may be null.</span></span><br><span class="line">    <span class="keyword">if</span> (environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; environment.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (environment[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"taintedEnvironment["</span> + i + <span class="string">"] == null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FileDescriptor in = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    FileDescriptor out = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">    FileDescriptor err = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line"></span><br><span class="line">    String workingPath = (workingDirectory == <span class="keyword">null</span>)</span><br><span class="line">            ? <span class="keyword">null</span></span><br><span class="line">            : workingDirectory.getPath();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure onExit() doesn't access the process map before we add our</span></span><br><span class="line">    <span class="comment">// entry.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (processReferences) &#123;</span><br><span class="line">        <span class="keyword">int</span> pid;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用JNI方法, 创建一个子进程, 并返回对应的PID</span></span><br><span class="line">            pid = exec(command, environment, workingPath, in, out, err, redirectErrorStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            IOException wrapper = <span class="keyword">new</span> IOException(<span class="string">"Error running exec()."</span></span><br><span class="line">                    + <span class="string">" Command: "</span> + Arrays.toString(command)</span><br><span class="line">                    + <span class="string">" Working Directory: "</span> + workingDirectory</span><br><span class="line">                    + <span class="string">" Environment: "</span> + Arrays.toString(environment));</span><br><span class="line">            wrapper.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> wrapper;</span><br><span class="line">        &#125;</span><br><span class="line">        ProcessImpl process = <span class="keyword">new</span> ProcessImpl(pid, in, out, err);</span><br><span class="line">        ProcessReference processReference = <span class="keyword">new</span> ProcessReference(process, referenceQueue);</span><br><span class="line">        processReferences.put(pid, processReference);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This will wake up the child monitor thread in case there</span></span><br><span class="line"><span class="comment">         * weren't previously any children to wait on.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        processReferences.notifyAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> process;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在看下对应的JNI方法<code>java_lang_ProcessManager.cpp</code>,  看到<code>ExecuteProcess</code>中将子进程的输入输出以及错误流均重定向到pipe的一端, 而pipe的另一端则对应着父进程的输出输入以及错误流, 这样一看子进程所阻塞的函数<code>pipe_wait</code>正是因为输出流缓冲满了, 无法再继续写了(那么, 可能还有疑问? 为何本地进程一直要写pipe了, 手动输入命令调用下就知道, 这个本地进程一直变态的在打印自己写入数据的文件名到标准输出).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ProcessManager_exec</span><span class="params">(JNIEnv* env, jclass, jobjectArray javaCommands,</span></span></span><br><span class="line"><span class="function"><span class="params">	                         jobjectArray javaEnvironment, jstring javaWorkingDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">	                         jobject inDescriptor, jobject outDescriptor, jobject errDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">	                         jboolean redirectErrorStream)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">ExecStrings <span class="title">commands</span><span class="params">(env, javaCommands)</span></span>;</span><br><span class="line">  <span class="function">ExecStrings <span class="title">environment</span><span class="params">(env, javaEnvironment)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Extract working directory string.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* workingDirectory = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (javaWorkingDirectory != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    workingDirectory = env-&gt;GetStringUTFChars(javaWorkingDirectory, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pid_t</span> result = ExecuteProcess(env, commands.get(), environment.get(), workingDirectory,</span><br><span class="line">	                        inDescriptor, outDescriptor, errDescriptor, redirectErrorStream);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clean up working directory string.</span></span><br><span class="line">  <span class="keyword">if</span> (javaWorkingDirectory != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(javaWorkingDirectory, workingDirectory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Executes a command in a child process. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ExecuteProcess</span><span class="params">(JNIEnv* env, <span class="keyword">char</span>** commands, <span class="keyword">char</span>** environment,</span></span></span><br><span class="line"><span class="function"><span class="params">	                    <span class="keyword">const</span> <span class="keyword">char</span>* workingDirectory, jobject inDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">	                    jobject outDescriptor, jobject errDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">	                    jboolean redirectErrorStream)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create 4 pipes: stdin, stdout, stderr, and an exec() status pipe.</span></span><br><span class="line">  <span class="keyword">int</span> pipes[PIPE_COUNT * <span class="number">2</span>] = &#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_COUNT; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipes + i * <span class="number">2</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      jniThrowIOException(env, errno);</span><br><span class="line">      ClosePipes(pipes, <span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> stdinIn = pipes[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> stdinOut = pipes[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> stdoutIn = pipes[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">int</span> stdoutOut = pipes[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">int</span> stderrIn = pipes[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span> stderrOut = pipes[<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">int</span> statusIn = pipes[<span class="number">6</span>];</span><br><span class="line">  <span class="keyword">int</span> statusOut = pipes[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pid_t</span> childPid = fork();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If fork() failed...</span></span><br><span class="line">  <span class="keyword">if</span> (childPid == <span class="number">-1</span>) &#123;</span><br><span class="line">    jniThrowIOException(env, errno);</span><br><span class="line">    ClosePipes(pipes, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is the child process...</span></span><br><span class="line">  <span class="keyword">if</span> (childPid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Note: We cannot malloc(3) or free(3) after this point!</span></span><br><span class="line">    <span class="comment">// A thread in the parent that no longer exists in the child may have held the heap lock</span></span><br><span class="line">    <span class="comment">// when we forked, so an attempt to malloc(3) or free(3) would result in deadlock.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace stdin, out, and err with pipes.</span></span><br><span class="line">    dup2(stdinIn, <span class="number">0</span>);</span><br><span class="line">    dup2(stdoutOut, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (redirectErrorStream) &#123;</span><br><span class="line">      dup2(stdoutOut, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dup2(stderrOut, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close all but statusOut. This saves some work in the next step.</span></span><br><span class="line">    ClosePipes(pipes, statusOut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make statusOut automatically close if execvp() succeeds.</span></span><br><span class="line">    fcntl(statusOut, F_SETFD, FD_CLOEXEC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close remaining unwanted open fds.</span></span><br><span class="line">    CloseNonStandardFds(statusOut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch to working directory.</span></span><br><span class="line">    <span class="keyword">if</span> (workingDirectory != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (chdir(workingDirectory) == <span class="number">-1</span>) &#123;</span><br><span class="line">	AbortChild(statusOut);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up environment.</span></span><br><span class="line">    <span class="keyword">if</span> (environment != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">extern</span> <span class="keyword">char</span>** environ; <span class="comment">// Standard, but not in any header file.</span></span><br><span class="line">      environ = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute process. By convention, the first argument in the arg array</span></span><br><span class="line">    <span class="comment">// should be the command itself.</span></span><br><span class="line">    execvp(commands[<span class="number">0</span>], commands);</span><br><span class="line">    AbortChild(statusOut);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is the parent process.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Close child's pipe ends.</span></span><br><span class="line">  close(stdinIn);</span><br><span class="line">  close(stdoutOut);</span><br><span class="line">  close(stderrOut);</span><br><span class="line">  close(statusOut);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check status pipe for an error code. If execvp(2) succeeds, the other</span></span><br><span class="line">  <span class="comment">// end of the pipe should automatically close, in which case, we'll read</span></span><br><span class="line">  <span class="comment">// nothing.</span></span><br><span class="line">  <span class="keyword">int</span> child_errno;</span><br><span class="line">  <span class="keyword">ssize_t</span> count = TEMP_FAILURE_RETRY(read(statusIn, &amp;child_errno, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">  close(statusIn);</span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// chdir(2) or execvp(2) in the child failed.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> track which so we can be more specific in the detail message.</span></span><br><span class="line">    jniThrowIOException(env, child_errno);</span><br><span class="line"></span><br><span class="line">    close(stdoutIn);</span><br><span class="line">    close(stdinOut);</span><br><span class="line">    close(stderrIn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reap our zombie child right away.</span></span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> rc = TEMP_FAILURE_RETRY(waitpid(childPid, &amp;status, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">-1</span>) &#123;</span><br><span class="line">      ALOGW(<span class="string">"waitpid on failed exec failed: %s"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill in file descriptor wrappers.</span></span><br><span class="line">  jniSetFileDescriptorOfFD(env, inDescriptor, stdoutIn);</span><br><span class="line">  jniSetFileDescriptorOfFD(env, outDescriptor, stdinOut);</span><br><span class="line">  jniSetFileDescriptorOfFD(env, errDescriptor, stderrIn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> childPid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有兴趣还可以继续看下kernel的代码<code>fs/pipe.c</code>是如何实现<code>pipe_write/pipe_read</code>以及<code>pipe_wait</code>是如何发生的.</p>
<p>这么一看代码流程, 如何解决这个问题的思路也有了, 大致有这么几种:</p>
<ul>
<li>直接在Java代码中去掉<code>Process.waitfor()</code>, 这个方法可能还是会有导致子进程阻塞的风险, 虽然不会死锁</li>
<li>在新的线程中读取子线程的输出流:<code>Process.getInputStream()</code>, 这样确保子进程不会被阻塞</li>
<li>直接将子进程的流全部丢弃(如果本身不感兴趣的话)</li>
<li>要写本地进程的人把所有这些不必要的打印全部去掉(这个最好不要当作终极解决方案)</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Process </tag>
            
            <tag> waitfor </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[聊一聊TCP协议]]></title>
      <url>http://sniffer.site/2019/07/30/%E8%81%8A%E4%B8%80%E8%81%8ATCP%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<p>TCP(<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener">Transmission Control Protocol</a>)即传输控制协议, 位于TCP/IP协议栈的第三层传输层, 与UDP不同的是, TCP号称提供有链接的(connection-oriented), 可靠的(reliable)字节流服务, 很多其他应用层协议如HTTP/SMTP/MQTT都是基于TCP协议实现.</p>
<p>这篇文章我们就从定义的角度来看一看TCP协议的具体工作原理. 首先看下有链接的(<code>connection-oriented</code>)具体含义.</p>
<p>TCP在发送数据之前, 第一件事情就是要在通信的双方建立一个通信的链路, 这个有点像日常生活中的打电话: A向B发起通话请求, B确认后双方建立通信链接才能正式通话. TCP也一样, 在发送任何数据之前必须要建立链接(connection), 这个建立通信链接的过程就是我们常说的”三次握手”；同样, 如果要想结束通信, 也需要有一个挥手的过程(四次挥手).有关TCP链接的建立与关闭可以参考之前的一篇文章(<a href="http://sniffer.site/2019/07/15/TCP%E9%93%BE%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB/">TCP的链接建立与状态迁移</a>). 那么, TCP建立链接主要完成哪几件事情了?</p>
<ul>
<li>交换双方的ISN(Initial Sequence Number): ISN的作用(后面在讲重传时会再讲到)是用来确保每个TCP数据包都是唯一的, 接收端如果收到了重复包可以根据每个包的序列号来实现去重</li>
<li>确认发送数据的MSS(Maximum Segment Size): MSS是TCP能发送的数据的最大值, 通过TCP头中的<code>options</code>交换, 默认值是536, 一般是当前系统MTU(Maximum Transmission Unit)的值减去TCP/IP协议头的大小之和(40byte), 其与MTU关系如下图所示</li>
</ul>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcp-mss.png" alt="MSS vs MTU"></p>
<ul>
<li>接收窗口的大小: 在TCP头中有一个<code>window</code>选项, 用来告诉对端自己接收缓冲区的大小, 这个窗口在拥塞与流量控制中扮演着十分重要的角色, 用于告诉发送方最大可以发送的数据大小</li>
</ul>
<p>通信双方在三次握手完成之后, 都知道了对方的初始序列号(<code>ISN</code>), 接收窗口大小以及MSS, 这样发送方就可以开始愉快的发送数据了. 接着讲第二个方面: TCP是如何做到要数据的可靠(<code>reliable</code>)传输的? 为了实现这一目标,TCP需要解决很多问题: </p>
<ol>
<li><p>数据在网络上丢包了如何办? TCP对于每个数据包都有个定时器, 如果接收方长时间没有回应, 在定时器超是后就会发起重传, 那么如何选择这个定时器的时长? 重传时间(Retransmission Timeout, RTO)太长, 导致数据传输效率太低; RTO太短, 则可能导致重传的数据包太多, 引发更大的网络拥堵.</p>
</li>
<li><p>发送方如何来控制自己数据的发送速率, 确保接收方能够处理的过来. 发送方不能不顾一切的发送数据, 而不管接收方是否有足够的空间来接受数据. 因此, TCP在接收方忙/没有足够空间接收数据时都会主动降低发送速度, 让接收方可以有机会及时恢复.这个是TCP流量控制(<code>flow control</code>)需要做的事情.</p>
</li>
<li><p>如果网络发生拥塞, TCP应该如何处理?发送端不能不顾及网络带宽以及拥堵状态而只管发送数据包, 进而影响其他用户正常使用网络.为了体现网络使用的公平性, 确保不同用户能够都能均衡的使用网络, 减少用户之间的相互干扰, TCP通过多种拥塞控制(<code>Congestion Control</code>)手段来减少网络拥堵, 并且在发生拥堵时尝试尽快恢复.</p>
</li>
</ol>
<p>具体说来TCP主要通过如下几个方式来解决上述几个问题:</p>
<ul>
<li>重传时间的计算: 如何实时调整RTO(<code>retransmission timeout</code>)的大小, 确保重传的频率在合适的范围</li>
<li>流量控制(<code>flow control</code>): 通过滑动窗口(<code>sliding window</code>)机制来实现数据发送的流量控制</li>
<li>拥塞控制(<code>Congestion Control</code>): 拥塞控制主要有 (1) 慢启动 ; (2) 拥塞避免； (3) 拥塞发生； (4) 快速恢复. 在后面会一一介绍这几个算法的原理.</li>
</ul>
<h2 id="何时重传"><a href="#何时重传" class="headerlink" title="何时重传"></a>何时重传</h2><p>为了确保数据的可靠传达, TCP每发送一个数据包, 接收方都要回应一个ACK包, 发送方在发送完一个数据包后就会启动一个重传定时器(<code>retransmission timer</code>), 如果在定时器超时后都未能收到对方的ACK包, 就会重传. 那么如何发送方如何知道重传的超时时间(<code>Retransmission Timeout</code>, RTO)? (在TCP的标准协议文档<a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC793</a>中给出了一个低通滤波的计算方式, 式中<code>alpha</code>一般为0.9, <code>RTT</code>(Round Trip Time)表示测量得到的返程时间, <code>R</code>表示平滑后的RTT:  $$ R = \alpha R + (1 - \alpha) RTT$$</p>
<p>而RTO是在平滑后的RTT乘以一个系数<code>beta</code>(一般取值为2)得到:</p>
<p>$$ RTO = \beta R $$</p>
<p>按照上述的计算得到RTO, 由于采用低通滤波,因而没有考虑到在网络发生波动(比如网络拥堵, 路由故障等)等情况下RTT变大的情况, 导致不必要的重传, 反而带来更大的网络负载, 导致网络陷入持久的拥堵.针对该问题, Jacobson在1988年提出了一个改进的RTO计算方法(<a href="https://ee.lbl.gov/papers/congavoid.pdf" target="_blank" rel="noopener">链接</a>, 该算法考虑到了由于网络波动导致的延迟, 因此可以更准确的反映网络拥塞状态:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/how_rto_calculated.png" alt="rto"></p>
<p>上述公式, <code>MRTT</code>代表实际测量得到的RTT, <code>SRTT</code>表示平滑后的RTT值, D实际表示的是RTT的平均方差(不是平方差), <code>g</code>一般设为1/8(0.125), 而<code>h</code>设为0.25.对于发生了重传的情况, RTO一般会通过<a href="https://en.wikipedia.org/wiki/Exponential_backoff" target="_blank" rel="noopener">指数回退</a>的方式进行倍乘(Karn and Partridge 1987).</p>
<h2 id="流量控制-如何控制发送速率"><a href="#流量控制-如何控制发送速率" class="headerlink" title="流量控制: 如何控制发送速率"></a><strong>流量控制: 如何控制发送速率</strong></h2><p>收发数据的两端常常在网络带宽以及性能上都存在差异, (快的)发送方如果不控制发送的速度, 可能会让处在慢速网络中的接收方不知所措.因此, 为了实现数据的可靠传输, TCP需要根据接收方的信息及时调整发送速率, 这个控制发送流量的技术就是著名的滑动窗口(<code>sliding window</code>)协议.简单地讲, 滑动窗口是要根据接收方的可用<code>window</code>(TCP缓存)的大小来达到调整接收方流量大小的目的, 下图是一个滑动窗口示意图(图片来自<a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-7.htm" target="_blank" rel="noopener">TCP/IP Guide</a>):</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcpswwindows.png" alt="TCP sliding window"></p>
<p>图中的数据主要分为4个部分:</p>
<ul>
<li>‘#1’: 表示已经发送的数据, 并且收到了ACK</li>
<li>‘#2’: 表示发送了的数据, 但是没有收到ACK确认</li>
<li>‘#3’: 尚未发送的数据(接收方还有空间)</li>
<li>‘#4’: 不可发送的数据(接收方没有足够空间, 无能为力)</li>
</ul>
<p>当发送了部分<code>#3</code>的数据更新后的滑动窗口如下图所示(图片来自<a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-7.htm" target="_blank" rel="noopener">TCPIP Guide</a>):</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcpswaftersendnow.png" alt="TCP after sliding window"></p>
<p>可以看到此时<code>可用的部分窗口</code>大小变成了0, 后续要等到接收方确认了<code>#2</code>部分的数据后, 窗口才会继续往前滑动.那么TCP协议是如何在数据传输过程中调整窗口大小(<code>window size</code>)的了? 了解TCP协议的人应该记得, 在TCP协议头有一个专门的字段<code>window</code>用于通信的两端来告知对方当前窗口的大小(能接收多少数据), 而通过<code>socket</code>的<code>SO_RCVBUF</code>参数可以来设置通信时接收缓冲区的大小(<a href="http://man7.org/linux/man-pages/man7/socket.7.html" target="_blank" rel="noopener">socket(7)</a>). 下图是一个接发数据过程通信两端TCP窗口大小的更新过程:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcpswflow.png" alt="TCP window size update"></p>
<ul>
<li>在发送数据的开始, 接收端会在三次握手时告知发送端自己的<code>window size</code>(图中为360)</li>
<li>随着发送端不断发送数据, 接收端的<code>window</code>会逐渐减少, 直到为0, 此时发送端会暂停发送数据</li>
</ul>
<p>问题来了, 如果接收方的<code>window</code>为0, 要如何处理?对于接收端, 在接收缓冲区可用后(如应用从读取了部分数据), 会发送一个<code>window update</code>的ACK包, 那万一这个ACK在传输过程中丢失了怎么办? 这样就会导致发送端的TCP无法正常关闭, 因此需要通过在发送端每隔一段时间就发送一个<code>Zero Window Probe</code>的探测包, 来获取接收端窗口的状态, 关于ZWP的说明可以参考(<a href="https://tools.ietf.org/html/rfc1122#page-92" target="_blank" rel="noopener">RFC1122</a>)的讨论.</p>
<h3 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a><strong>Silly Window Syndrome</strong></h3><p>Silly Window Syndrome(中译为<code>糊涂窗口综合症</code>)的意思是, 接收端的应用可能每次都只拿走很少的一部分(比如几个字节)的数据, 因此每次<code>window update</code>后发送端也只会发送几个字节的数据, 而我们知道, 光TCP+IP两个协议头都需要40个字节的空间,这样的传输效率看起来太低了.针对该问题, 有两种策略:</p>
<ul>
<li><p>如果问题发生在接收端(接收端处理太慢等), 则可以在<code>window</code>小于某个值时, 直接向发送端ACK一个<code>window=0</code>的包, 告诉发送端暂停发送, 等<code>window</code>大于某个值(比如<code>MSS/2</code>)时再发送<code>window update</code>包让发送方继续发送数据;</p>
</li>
<li><p>而如果问题发生在发送方,则可以考虑Nagle在1984年提出的<code>Nagle Algorithm</code><a href="https://tools.ietf.org/html/rfc896" target="_blank" rel="noopener">RFC896</a>: 对于一个TCP连接, 只要还有一个数据包的没有被确认, 就将应用发送的数据缓存下来, 直到接收到该数据包的ACK之后才允许发送新的数据.这样TCP就尽可能的发送”大”的数据包, 而不是发送多个小包, 导致效率降低. 但对于某些交互式应用如<code>Telenet/SSH/Rlogin</code>, 为了避免延时带来的交互延时, 通常需要关闭<code>Nagle</code>算法, 可以通过socket的选项参数<code>TCP_NODELAY</code>来关闭该算法, 从而提升交互体验.</p>
</li>
</ul>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><strong>拥塞控制</strong></h2><p>TCP的滑动窗口很好的控制了接收端与发送端的包速率,  但并没有考虑到中间网络如路由器/交换机拥塞/故障引发的网络拥堵, 为了避免网络拥塞引起网络瘫痪(<code>congestion collapse</code>), TCP需要对网络的拥塞信号做出反应(发生丢包/包乱序等). 总的说来, TCP的拥塞控制(<code>congestion control</code>)是为了: </p>
<ul>
<li>(1) 尽可能减少拥塞导致的网络瘫痪(如某个路由节点由于不堪重负崩溃或者卡死)；</li>
<li>(2) 网络使用的公平性(<code>faireness</code>): TCP的目标是尽可能使每个网络的使用者都达到比较好的体验, 避免某一个发送端或者接收端过度的占用网络带宽. </li>
</ul>
<p>在RFC5681(<a href="https://tools.ietf.org/html/rfc5681" target="_blank" rel="noopener"><code>TCP Congestion Control</code></a>)中总结了四个拥塞控制算法:</p>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a><strong>慢启动</strong></h3><p>TCP慢启动(<code>slow start</code>)的意思是开始发送数据时, 尽量逐步增加发送的数据量, 而不是最开始就发送一个大的数据包, 这样试探性的发送数据可以减少网络拥塞.为了实现慢启动以及拥塞避免(与慢启动配套的算法, 接下来会讲到), 需要引入两个状态变量: (1) 拥塞窗口(<code>congestion window</code>) <code>cwnd</code>; (2) 慢启动阈值(<code>slow start threshold</code>) <code>ssthresh</code>, 这个阈值用于慢启动与拥塞避免两个算法之间的切换.</p>
<p>慢启动算法的大致步骤如下:</p>
<ol>
<li>将<code>cwnd</code>设为1, 表示一个MSS大小(<a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf" target="_blank" rel="noopener">目前一般Linux系统都按照Google的建议</a>将该值设为10)</li>
<li>每次接收到一个ACK后, <code>cwnd += 1</code></li>
</ol>
<p>这样收到一个ACK后,<code>cwnd</code>变为2,接着会发出两个MSS的数据包, ACK会变成4, 最终发送的包数量呈指数上升.等到<code>cwnd &gt; ssthresh</code>, 则进入拥塞避免阶段, TCP会根据收发包的丢包重传的情况, 适当调整<code>cwnd</code>的值, 确保不要让网络变得过度拥堵.</p>
<h2 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a><strong>拥塞避免</strong></h2><p>当<code>cwnd &gt; ssthresh</code>时, TCP进入拥塞避免(<code>congestion avoidance</code>), 此时<code>cwnd</code>会进入线性调整阶段:</p>
<ol>
<li><code>sshthresh</code>的值大小一般初始化为65535(<code>0x7ffffff</code>)</li>
<li>cwnd += 1/cwnd(参考[<a href="https://tools.ietf.org/html/rfc5681]" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc5681]</a></li>
<li>每过一个RTT, 则<code>cwnd = cwnd + 1</code></li>
</ol>
<p>当发生RTO重传时, 需要减少<code>sshthresh</code>的值, 同时减少<code>cwnd</code>的值: </p>
<ul>
<li><code>sshthresh = max(FlightSize/2, 2*MSS)</code></li>
<li><code>cwnd = 1</code></li>
</ul>
<p>这样在重传之后TCP又进入了慢启动模式, 逐步增加发送数据包的速率.</p>
<h2 id="快速重传与快速恢复"><a href="#快速重传与快速恢复" class="headerlink" title="快速重传与快速恢复"></a><strong>快速重传与快速恢复</strong></h2><p>先来了解下快速重传(<code>fast restransmition</code>)与快速恢复(<code>fast recovery</code>)的具体含义:</p>
<ul>
<li>快速重传: 在TCP接收到连续3次DACK(<code>duplicate ACK</code>)后, 主动重传丢失的数据包, 而不是等到RTO超时</li>
<li>快速恢复: 当TCP完成快速重传后, 会进入拥塞避免而不是慢启动, 这样确保发送的流量在适当的拥塞之后保持稳定</li>
</ul>
<p>一般来说, 快速重传与快速恢复是同一起实现的, 具体的流程如下:</p>
<ul>
<li>如果连续收到三个DACk包, 则重传丢失的数据包</li>
<li>更新拥塞窗口以及慢启动阈值: <code>sshthresh = max(FlightSize/2, 2*MSS)</code> 以及<code>cwnd = ssthresh + 3 * MSS</code></li>
<li>后续每收到一个DACK, 将拥塞窗口加一: <code>cwnd = cwnd + 1</code></li>
<li>如果收到ACK, 则<code>cwnd = sshthresh</code>, 这样TCP会再次进入拥塞控制</li>
</ul>
<p>实际TCP针对丢包与重传的情况还有很多改善型算法, 详细可以参考<a href="https://tools.ietf.org/html/rfc5681" target="_blank" rel="noopener">RFC5681</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://www.tcpipguide.com/free/t_TCPWindowSizeAdjustmentandFlowControl-2.htm" target="_blank" rel="noopener">TCP流量控制</a></li>
<li><a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo.htm" target="_blank" rel="noopener">TCP滑动窗口</a></li>
<li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">TCP的那些事情, 耗子叔的力作</a></li>
<li><a href="https://tools.ietf.org/html/rfc2914" target="_blank" rel="noopener">Congestion Control Principles</a></li>
<li><a href="https://tools.ietf.org/html/rfc7414" target="_blank" rel="noopener">TCP roadmap</a></li>
<li><a href="https://tools.ietf.org/html/rfc5681" target="_blank" rel="noopener">TCP congestion control</a></li>
<li><a href="https://tools.ietf.org/html/rfc1122" target="_blank" rel="noopener">TCP/IP协议的各种问题的总结</a></li>
<li><a href="https://draveness.me/whys-the-design-tcp-performance/" target="_blank" rel="noopener">TCP为什么有性能问题</a></li>
<li><a href="https://hpbn.co/building-blocks-of-tcp/" target="_blank" rel="noopener">https://hpbn.co/building-blocks-of-tcp/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 网络协议 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 拥塞控制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP链接建立与状态迁移]]></title>
      <url>http://sniffer.site/2019/07/15/TCP%E9%93%BE%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB/</url>
      <content type="html"><![CDATA[<p>学习TCP协议的第一步是要了解熟悉TCP的三次握手/四次挥手以及状态迁移图. 这篇文章用三个图展示TCP链接的建立与关闭以及状态的迁移.</p>
<h2 id="TCP状态迁移"><a href="#TCP状态迁移" class="headerlink" title="TCP状态迁移"></a><strong>TCP状态迁移</strong></h2><p>根据TCP协议的文档<a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC793</a>, 一个TCP链接有下图中的几个状态(图中实粗线为Client端的正常情况下状态迁移图, 虚线为Server端正常情况下的状态迁移图):</p>
<ul>
<li><code>CLOSED</code>: TCP链接的初始状态, 表示没有任何链接</li>
<li><code>LISTEN</code>: (服务端)等待来自远程客户端的请求</li>
<li><code>SYN_SENT</code>: 发送了一个建立TCP链接的SYN请求, 等待对端返回结果</li>
<li><code>SYN_RCVD</code>: 收到了TCP建立链接的SYN包, 等待对方的回应(ACK)</li>
<li><code>ESTABLISHED</code>: TCP链接建立成功, 从这里开始可以交换数据包了</li>
<li><code>FIN_WAIT1</code>: 应用进程关闭了TCP链接(发送FIN包), 并等待对端的响应</li>
<li><code>FIN_WAIT2</code>: 接收到关闭回应后, 等待对端结束TCP链接(等待FIN包)</li>
<li><code>CLOSING</code>: 如果两端同时接收到了FIN包, 则进入该状态</li>
<li><code>CLOSE_WAIT</code>:处于被动关闭一端接受到FIN请求后, 等待本地进程的关闭TCP链接</li>
<li><code>LAST_ACK</code>: 服务端本地进程关闭TCP链接后, 发送FIN包, 等待回应</li>
<li><code>TIME_WAIT</code>: 等待2*MSL(Maximum Segment Lifetime, TCP包的最大存活时间)后关闭该TCP链接, 等待足够长的时间是为了确保最后关闭链接的ACK包有足够长的时间达到对端, 如果对端未能收到该包, 则会重传FIN包, 这样对端也可以重传ACK包, 一般MSL为60s</li>
</ul>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/TCP_state_transition.png" alt="TCP state transition"></p>
<h2 id="TCP三次握手与四次挥手"><a href="#TCP三次握手与四次挥手" class="headerlink" title="TCP三次握手与四次挥手"></a><strong>TCP三次握手与四次挥手</strong></h2><p>正常情况下, TCP的三次握手与四次挥手如下图所示:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcp_three_way_handeshake.png" alt="TCP connection establish/close"></p>
<h2 id="同时关闭时的TCP状态变化"><a href="#同时关闭时的TCP状态变化" class="headerlink" title="同时关闭时的TCP状态变化"></a><strong>同时关闭时的TCP状态变化</strong></h2><p>如果TCP通信的两端同时请求关闭链接, 流程如下图所示:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcp_simutaneous_close.png" alt="TCP simutaneous close"></p>
<p>关于TCP协议的参考资料:</p>
<ul>
<li>RFC793: 这是有关TCP协议的标准文本, 信息的源头</li>
<li>&lt;TCP/IP详解 卷1&gt;: W. Richard Stevens的经典, 必看</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 网络协议 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 三次握手 </tag>
            
            <tag> 四次挥手 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PPP拨号时拿到错误DNS的问题解析]]></title>
      <url>http://sniffer.site/2019/07/05/PPP%E6%8B%A8%E5%8F%B7%E6%97%B6%E6%8B%BF%E5%88%B0%E9%94%99%E8%AF%AFDNS%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>最近碰到一个PPP拨号拿到了假的DNS地址<code>10.11.12.13/14</code>, 之前也发生过一次, 但是一直没有有效的日志, 所以就简单粗暴的做了一个方案: 在PPP拨号进行网络参数协商时, 如果发现拿到了<code>10.11.12.13/14</code>这样的DNS地址就修改为指定的运营商DNS地址. 本来以为万事大吉了, 没想到运营商DNS一改, 问题又暴露了, 好在重现抓到了现场日志, 终于找到了原因. 网上看有原来也有不少人碰到了类似现象(<a href="https://bugzilla.redhat.com/show_bug.cgi?id=467004#c31)" target="_blank" rel="noopener">https://bugzilla.redhat.com/show_bug.cgi?id=467004#c31)</a>, 在这里简要的描述下整个问题的来龙去脉并给出几种可能的解决方案.</p>
<p>在介绍这个问题的根因之前, 先来了解下PPP协议的一些基本概念.</p>
<h2 id="PPP协议介绍"><a href="#PPP协议介绍" class="headerlink" title="PPP协议介绍"></a><strong>PPP协议介绍</strong></h2><p>PPP(Point-to-Point Protocol)是在SLIP(Serial Line Internet Protocol)的基础上发展而来, 其通过在终端与远端(remote peer)之间建立一个IPPP数据链路, 将终端设备接入网络. 早些年上网的时候, 把一个<a href="https://en.wikipedia.org/wiki/Asymmetric_digital_subscriber_line" target="_blank" rel="noopener">ADSL</a> modem跟电脑连接后, 拿着运营商给的用户名与密码, 然后拨号接入互联网,这里边用到的协议就是<a href="https://en.wikipedia.org/wiki/Point-to-Point_Protocol_over_Ethernet" target="_blank" rel="noopener">PPP</a>.</p>
<p>PPP协议位于TCP/IP协议栈的第二层-数据链路层(见下图), 其主要有三个部分组成:</p>
<ul>
<li>包封装: 如何将网络报文如IP报文封装成类似与HDLC的格式</li>
<li>LCP协议: Link Control Protocol, 负责建立数据链路, 验证用户身份以及测试链路的连通状态</li>
<li>NCP协议: Network Control Protocol, 负责适配其他协议, 如针对IP协议有IPCP协议, 该协议的功能是从网络侧拿到IP地址以及DNS地址 </li>
</ul>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/PPP_stack.png" alt="PPP in TCP/IP stack"></p>
<p>一般来说, PPP拨号上网有如下几个阶段:</p>
<ul>
<li>链路建立阶段(Establish): LCP协议负责建立数据链路, 建立链路过程主要是协商数据的压缩格式以及最大传输单元MRU(Maximum Receive Unit, 类似于MTU)</li>
<li>身份验证阶段(Authenticate): 主要是通过PAP/CHAP等协议验证用户的身份(用户名与密码)</li>
<li>网络阶段(Network): 协商网络参数, 如IP地址, DNS地址等. 网络阶段完成后, 就可以真正进行数据报文的接发了.</li>
</ul>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/PPP_phase_diagram.jpg" alt="PPP phone diagram"></p>
<p>在NCP阶段, PPP拨号进行参数协商过程中一般都有如下几个指令: <code>Configure-Request</code>(发起参数协商), <code>Configure-Ack</code>(如果同意该参数则发送ACK给对端), <code>Configure-Nak</code>(如果参数合法, 但是有不同意对方的某些参数, 则发送NAK给对端), <code>Configure-Reject</code>(如果不同意对方发送过来的参数, 则直接发送Reject), 具体可以参考RFC1661的文档(<a href="https://tools.ietf.org/html/rfc1661" target="_blank" rel="noopener">rfc1661</a>).下图是一个完整基于IPCP协议的消息交换过程:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ipcp_process.png" alt="IPCP process"></p>
<p>有了这些知识背景, 就来看下具体的问题是怎么样的.</p>
<h2 id="假DNS问题的来由"><a href="#假DNS问题的来由" class="headerlink" title="假DNS问题的来由"></a><strong>假DNS问题的来由</strong></h2><p>问题发生终端大致的网络架构如下图所示:终端通过modem与运营商的LNS节点建立一个PPP的链路, 然后通过该链路接入私有网络:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ppp_mobile_network_architecture.png" alt="ppp network architecture"></p>
<blockquote>
<p>图中的<code>LAC</code>/<code>LNS</code>分别指<code>L2TP Access Concentrator</code>/<code>L2TP Network Server</code>， 参考<a href="https://en.wikipedia.org/wiki/Layer_2_Tunneling_Protocol" target="_blank" rel="noopener">Wikipedia</a></p>
</blockquote>
<p>这里系统使用的是高通的modem, 在LTE网络下使用PPP拨号从运营商网关拿IP/DNS地址. PPP拨号时, 实际已经通过了身份验证, 但在IPCP协议进行参数协商时, 前面一直拿到了<code>10.11.12.13/14</code>这样的DNS地址, 后面运营商下发了正确的DNS地址, modem也未能把正确的DNS地址发送过来, PPPD拨号的过程日志如下, </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.024</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : <span class="keyword">using</span> channel <span class="number">3</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.024</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [LCP ConfReq id=<span class="number">0x1</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;magic <span class="number">0x6c3c9df8</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.024</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [LCP ConfReq id=<span class="number">0x3</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;auth pap&gt; &lt;magic <span class="number">0xf2cb3c8d</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.024</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [LCP ConfAck id=<span class="number">0x3</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;auth pap&gt; &lt;magic <span class="number">0xf2cb3c8d</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.024</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [LCP ConfAck id=<span class="number">0x1</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;magic <span class="number">0x6c3c9df8</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [LCP DiscReq id=<span class="number">0x4</span> magic=<span class="number">0xf2cb3c8d</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [PAP AuthAck id=<span class="number">0x1</span> <span class="string">""</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> I pppd    : PAP authentication succeeded</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [CCP ConfReq id=<span class="number">0x1</span> &lt;deflate <span class="number">15</span>&gt; &lt;deflate(old#) <span class="number">15</span>&gt; &lt;bsd v1 <span class="number">15</span>&gt;]</span><br><span class="line"><span class="comment">// IPCP开始协商IP地址, DNS地址等参数</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x1</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns3 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">37.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [LCP ProtRej id=<span class="number">0x5</span> <span class="number">80</span> fd <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0f</span> <span class="number">1</span>a <span class="number">04</span> <span class="number">78</span> <span class="number">00</span> <span class="number">18</span> <span class="number">04</span> <span class="number">78</span> <span class="number">00</span> <span class="number">15</span> <span class="number">03</span> <span class="number">2f</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">38.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x1</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">38.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x2</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">39.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x2</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">39.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x3</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">40.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x3</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">40.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x4</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">41.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x4</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">41.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x5</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">42.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x5</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">42.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x6</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">43.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x6</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">43.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x7</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">44.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x7</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">44.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x8</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x8</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.044</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x9</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="comment">// 到现在才收到远端(remote peer)的IP协商请求</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfReq id=<span class="number">0x2</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfNak id=<span class="number">0x2</span> &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfRej id=<span class="number">0x9</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0xa</span> &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfReq id=<span class="number">0x3</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfAck id=<span class="number">0x3</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0xa</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0xb</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfAck id=<span class="number">0xb</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.644</span>  <span class="number">3183</span>  <span class="number">3183</span> W pppd    : Could <span class="keyword">not</span> determine remote IP address: defaulting to <span class="number">10.64</span><span class="number">.64</span><span class="number">.64</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.654</span>  <span class="number">3183</span>  <span class="number">3183</span> I pppd    : local  IP address <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.654</span>  <span class="number">3183</span>  <span class="number">3183</span> I pppd    : remote IP address <span class="number">10.64</span><span class="number">.64</span><span class="number">.64</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.654</span>  <span class="number">3183</span>  <span class="number">3183</span> I pppd    : primary   DNS address <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.654</span>  <span class="number">3183</span>  <span class="number">3183</span> I pppd    : secondary DNS address <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.654</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : Script /etc/ppp/ip-up started (pid <span class="number">3229</span>)</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">45.714</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : Script /etc/ppp/ip-up finished (pid <span class="number">3229</span>), status = <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>可以看到在第一次PPP参数协商时, PPPD就收到了这样的配置, 这里<code>ms-wins</code>参数是针对微软的客户端产生的配置(在Linux系统下并没有什么作用):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">38.034</span>  <span class="number">3183</span>  <span class="number">3183</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x1</span> &lt;ms-dns1 <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-dns3 <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.13</span>&gt; &lt;ms-wins <span class="number">10.11</span><span class="number">.12</span><span class="number">.14</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>再来对比下正常的PPPD拨号的情况, PPPD拨号时首先很快就收到了<code>IPCP ConfReq id=0x0</code>的请求, 这个请求是告诉客户端可以发起IP地址的协商了, 于是客户端就发了<code>NAK</code>包告诉服务端自己的IP地址是空的<code>sent [IPCP ConfNak id=0x0 &lt;addr 0.0.0.0&gt;]</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : <span class="keyword">using</span> channel <span class="number">1</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [LCP ConfReq id=<span class="number">0x1</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;magic <span class="number">0x2d6bff1</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [LCP ConfReq id=<span class="number">0x0</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;auth pap&gt; &lt;magic <span class="number">0xf2cab769</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [LCP ConfAck id=<span class="number">0x0</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;auth pap&gt; &lt;magic <span class="number">0xf2cab769</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [LCP ConfAck id=<span class="number">0x1</span> &lt;asyncmap <span class="number">0x0</span>&gt; &lt;magic <span class="number">0x2d6bff1</span>&gt; &lt;pcomp&gt; &lt;accomp&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [LCP DiscReq id=<span class="number">0x1</span> magic=<span class="number">0xf2cab769</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [PAP AuthAck id=<span class="number">0x1</span> <span class="string">""</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> I pppd    : PAP authentication succeeded</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [CCP ConfReq id=<span class="number">0x1</span> &lt;deflate <span class="number">15</span>&gt; &lt;deflate(old#) <span class="number">15</span>&gt; &lt;bsd v1 <span class="number">15</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x1</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt; &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns3 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.510</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [LCP ProtRej id=<span class="number">0x2</span> <span class="number">80</span> fd <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">0f</span> <span class="number">1</span>a <span class="number">04</span> <span class="number">78</span> <span class="number">00</span> <span class="number">18</span> <span class="number">04</span> <span class="number">78</span> <span class="number">00</span> <span class="number">15</span> <span class="number">03</span> <span class="number">2f</span>]</span><br><span class="line"><span class="comment">// 很快收到IP地址协商请求</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [IPCP ConfReq id=<span class="number">0x0</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [IPCP ConfNak id=<span class="number">0x0</span> &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [IPCP ConfRej id=<span class="number">0x1</span> &lt;compress VJ <span class="number">0f</span> <span class="number">01</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x2</span> &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns3 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [IPCP ConfReq id=<span class="number">0x1</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [IPCP ConfAck id=<span class="number">0x1</span>]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [IPCP ConfNak id=<span class="number">0x2</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : sent [IPCP ConfReq id=<span class="number">0x3</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : rcvd [IPCP ConfAck id=<span class="number">0x3</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.970</span>  <span class="number">1643</span>  <span class="number">1643</span> W pppd    : Could <span class="keyword">not</span> determine remote IP address: defaulting to <span class="number">10.64</span><span class="number">.64</span><span class="number">.64</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.980</span>  <span class="number">1643</span>  <span class="number">1643</span> I pppd    : local  IP address <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.980</span>  <span class="number">1643</span>  <span class="number">1643</span> I pppd    : remote IP address <span class="number">10.64</span><span class="number">.64</span><span class="number">.64</span></span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.980</span>  <span class="number">1643</span>  <span class="number">1643</span> I pppd    : primary   DNS address <span class="number">211.</span>xxx.xxx.xxx</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.980</span>  <span class="number">1643</span>  <span class="number">1643</span> I pppd    : secondary DNS address <span class="number">211.</span>xxx.xxx.xxx</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">01.980</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : Script /etc/ppp/ip-up started (pid <span class="number">1682</span>)</span><br><span class="line"><span class="number">07</span><span class="number">-02</span> <span class="number">20</span>:<span class="number">40</span>:<span class="number">02.060</span>  <span class="number">1643</span>  <span class="number">1643</span> D pppd    : Script /etc/ppp/ip-up finished (pid <span class="number">1682</span>), status = <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>接着又发了一个地址配置的请求, 在收到服务端的配置后,并相互确认后最终拿到了正确的IP地址/DNS地址:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sent [IPCP ConfReq id=<span class="number">0x2</span> &lt;addr <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns1 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt; &lt;ms-dns3 <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>&gt;]</span><br><span class="line">rcvd [IPCP ConfNak id=<span class="number">0x2</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br><span class="line">sent [IPCP ConfReq id=<span class="number">0x3</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br><span class="line">rcvd [IPCP ConfAck id=<span class="number">0x3</span> &lt;addr <span class="number">10.200</span><span class="number">.16</span><span class="number">.23</span>&gt; &lt;ms-dns1 <span class="number">211.</span>xxx.xxx.xxx&gt; &lt;ms-dns3 <span class="number">211.</span>xxx.xxx.xxx&gt;]</span><br></pre></td></tr></table></figure>
<p>单纯从PPPD拨号的LOG来看, 流程上就有不小的差异: 异常情况迟迟收不到远端(这里就是运营商的服务器)的IP地址协商的请求<code>ConfReq</code>, 而发出去的<code>IPCP ConfReq</code>参数协商请求一直拿到了假的DNS地址<code>10.11.12.13/14</code>(这个地址实际是modem产生的不是来自网络), 对端回过来的地址一直都是全零<code>0.0.0.0</code>, 导致客户端一直发送<code>ConfReq</code>,直到远端(remote peer)的<code>NAK</code>超过最大的次数(PPPD代码默认是5)后,才停止DNS的协商过程(看pppd的代码是默认关闭了对DNS的协商请求).</p>
<p>那么问题的根源在哪里了? 抓了modem的日志给供应商分析才发现, 本端(local peer)在PDN(Packet Data Network)数据链接尚未建立的情况下(相当于终端与运营商还没有建立物理上的通路)就去发起IPCP参数协商了, 此时modem还没有拿到IP地址和DNS地址, 因此就给了一个假的DNS地址了. 等到几秒钟后PDN建立成功, 运营商网络正常下发分配的IP地址与DNS地址后, modem却没有主动下发正确的DNS地址, 而本端的pppd也没有再次请求DNS地址, 这样到了PPP拨号完成本地拿到的始终是一个假的DNS地址.</p>
<p>找到了问题的原因之后, 解决问题就好办了. 大概有这么几个解决方案:</p>
<ol>
<li>在modem侧修改: 如果PDN链接建立成功后, 主动下发正确的DNS地址(运营商给的DNS地址)</li>
<li>在本端的PPPD中修改: 如果发现拿到的DNS地址为<code>10.11.12.13/14</code>, 则在接收到远端的<code>NAK</code>时将该地址拒绝, 并且在下次参数协商时主动告诉远端自己没有拿到DNS地址, 这样远端会在下一个<code>NAK</code>中主动将正确的DNS发送过来(如果已经有了的话)</li>
<li>在PPPD拨号时将参数<code>connect-delay</code>设置为<code>5000</code>(5s, 默认是<code>1000</code>), 这个相当于尽量等待PDN的链接, 等成功后再进行参数协商. 这个方案只能在一定程度上缓解问题发生的概率, 并不能从根本上解决问题.</li>
<li>如果收到假的DNS地址<code>10.11.12.13/14</code>, 则强制修改为正确的运营商DNS地址(如果运营商DNS地址发生变化, 又会出问题, 不是终极解决方案)</li>
</ol>
<p>目前采用了方案二, 初步验证可以拿到正确的DNS地址.</p>
]]></content>
      
        <categories>
            
            <category> 网络协议 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PPP </tag>
            
            <tag> DNS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何在Android Studio中添加自定义framework.jar?]]></title>
      <url>http://sniffer.site/2019/02/26/%E5%9C%A8Android-Studio%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89framework-jar/</url>
      <content type="html"><![CDATA[<p>这两天有一个新的功能需求要实现, 要在Android原生代码的<code>Settings</code>(代码目录<code>android/frameworks/base/core/java/android/provider</code>)数据库添加一个新的数据项, 一个系统应用(独立于Android系统源码编译)需要引用该数据项. 那么, 怎么将新的数据项引用到系统应用中了? &lt;! – more –&gt;</p>
<blockquote>
<p>备注: 以下所有的示例都基于Android Studio 3.2/操作系统Ubuntu 18.04.1</p>
</blockquote>
<p>首先, 在Android源码中修改完成后, 执行本地编译, 在<code>/android/out</code>目录下, 找到编译产生的新的<code>framework</code>模块的<code>jar</code>包:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes-full-debug.jar</span><br></pre></td></tr></table></figure>
<p>最开始, 打开该<code>jar</code>包, 将<code>/android/provider/</code>目录下的所有<code>class</code>文件复制到<code>Android Studio</code>中的SDK的<code>platforms/android-23</code>, 重新<code>clean/build</code>一次, 项目中对新建的数据项的符号引用立刻就正常了.但一提交到远程服务器, 后台编译出错, 提示找不到符号了~~~what!</p>
<p>马上就要发布版本了, 怎么办?只好硬着头皮找其他法子了…参考了网上已有的很多文档, 编译一直报错. 不得已开始想着要通过广播的形式来替换掉现有的通过<code>ContentProvider</code>的方式, 这样就避开修改Android SDK了, 但广播存在这么几个问题:</p>
<ul>
<li>任何人都可以监听接收该广播, 安全性与性能都大打折扣;</li>
<li>如果接收方线程阻塞, 会导致广播超时, 造成应用ANR</li>
</ul>
<p>整个需求的方案已经定了, 再去该明显会被打回的, 而且就该功能的实现而言, 只有在某个状态变化时, 才要求告知上层, 这个正是<code>ContentProvider</code>可以达成的逻辑. 转了一圈, 只好又回到原来的方案. 跟同事沟通了配置的方法, 编译终于通过, 但是验证测试时又碰到了问题….这里记录下来整个过程, 也算是为后来的Android SDK定制积攒点经验.</p>
<h2 id="添加framework-jar到AS"><a href="#添加framework-jar到AS" class="headerlink" title="添加framework.jar到AS"></a><strong>添加framework.jar到AS</strong></h2><p>将编译好的Android框架层jar包<code>framework.jar</code>放到<code>/app/libs/</code>下面, 然后在应用<code>app</code>的配置<code>build.gradle</code>下面添加一个依赖项, 这里的<code>provided</code>表示该依赖只在编译时起作用, 不会把对应的jar文件编译到最终的APK中去:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    provided files(&apos;libs/framework.jar&apos;)</span><br><span class="line">    //compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将framework-jar设置为bootclass"><a href="#将framework-jar设置为bootclass" class="headerlink" title="将framework.jar设置为bootclass"></a><strong>将framework.jar设置为bootclass</strong></h2><p>为了让库生效, 需要在编译开始时, 将<code>framework.jar</code>设置为当前所有子项目的启动文件(boot class):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">	jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 设置为bootclass</span><br><span class="line">    gradle.projectsEvaluated &#123;</span><br><span class="line">	tasks.withType(JavaCompile) &#123;</span><br><span class="line">	    options.compilerArgs &lt;&lt; &apos;-Xbootclasspath/p:app/libs/framework.jar&apos;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时, 还需要在<code>app/build.gradle</code>中添加一个编译的类路径(class path):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">project.afterEvaluate &#123;</span><br><span class="line">    JavaCompile javaTask = project.tasks.compileDebugAndroidTestJavaWithJavac</span><br><span class="line">    if (javaTask) &#123;</span><br><span class="line">	FileCollection dependentFiles = javaTask.getClasspath()</span><br><span class="line">	dependentFiles = dependentFiles.plus(project.files(&apos;libs/framework.jar&apos;))</span><br><span class="line">	javaTask.setClasspath(dependentFiles)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>网上的大部分资料都说到了这一步就好了, 但是这时看引用的Java文件中, 仍然提示找不到新的符号, 重新看了下网络上的教程, 原来还需要更改下<code>app.iml</code>中的引用先后顺序.</p>
<h2 id="修改app-iml中的库引用顺序"><a href="#修改app-iml中的库引用顺序" class="headerlink" title="修改app.iml中的库引用顺序"></a><strong>修改app.iml中的库引用顺序</strong></h2><p><code>app.iml</code>包含了某个项目的信息以及依赖状态, 找到<code>framework.jar</code>以及<code>Android SDK</code>对应的<code>&lt;orderEntry&gt;</code>, 将<code>framework.jar</code>对应的调整到<code>Android SDK</code>之前就可以了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;orderEntry type=&quot;sourceFolder&quot; forTests=&quot;false&quot; /&gt;</span><br><span class="line">&lt;orderEntry type=&quot;library&quot; exported=&quot;&quot; name=&quot;app/libs/framework.jar:unspecified@jar&quot; level=&quot;project&quot; /&gt;</span><br><span class="line">....</span><br><span class="line">&lt;orderEntry type=&quot;module&quot; module-name=&quot;lib_config&quot; exported=&quot;&quot; /&gt;</span><br><span class="line">&lt;orderEntry type=&quot;jdk&quot; jdkName=&quot;Android API 23 Platform&quot; jdkType=&quot;Android SDK&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>在实际操作过程, 注意不要在<code>app/build.gradle</code>中添加如下两个配置, 不然编译虽然可以通过, 但是执行时会出现异常:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    provided files(&apos;libs/framework.jar&apos;)</span><br><span class="line">    //compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul>
<li><a href="https://developer.android.com/studio/build/gradle-tips" target="_blank" rel="noopener">https://developer.android.com/studio/build/gradle-tips</a></li>
<li><a href="http://google.github.io/android-gradle-dsl/" target="_blank" rel="noopener">http://google.github.io/android-gradle-dsl/</a></li>
<li><a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="noopener">https://docs.gradle.org/current/dsl/</a></li>
<li><a href="https://docs.gradle.org/current/userguide/userguide_single.html" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/userguide_single.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android studio </tag>
            
            <tag> Android framework </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux下常用网络工具使用总结]]></title>
      <url>http://sniffer.site/2019/01/17/Linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>平时在Android/Ubuntu这样的Linux系统中, 经常跟网络打交道, 不可避免的要使用网络工具来定位问题；这里对Linux常用的网络工具进行简单的总结, 方便后续查阅使用. 主要看看以下几个常用的网络工具 <a id="more"></a>:</p>
<ul>
<li><strong>ping</strong>: 基于ICMP协议, 发送ICMP数据包用于测试网络连通状态</li>
<li><strong>traceroute</strong>: 基于UDP/ICMP/TCP协议用于跟踪网络连通状态, 打印达到目标地址的路由信息</li>
<li><strong>tcpdump</strong> : 用于抓取tcp/ip包, 分析网络问题的必需神器</li>
<li><strong>iproute2</strong> : 查看/添加/删除当前路由信息</li>
<li><strong>netstat</strong>: 查看网络状态</li>
<li><strong>netcfg</strong>: 配置网口(使能网口以及配置IP等)</li>
<li><strong>iptables</strong>: 网络数据包的过滤以及防火墙策略配置</li>
<li><strong>netcat</strong>: 用于快速建立TCP/UDP链接,检测网络的连通性</li>
<li><strong>iPerf</strong>: 网络性能测试工具, 用来衡量网络吞吐量/带宽</li>
<li><strong>tc</strong>: Traffic Control, 用于显示/修改网卡配置的工具</li>
<li><strong>curl</strong>: 基于<a href="https://curl.haxx.se/libcurl/" target="_blank" rel="noopener">libcurl</a>的数据传输工具, 支持HTTP/HTTPS/FTP/RTMP/RTSP/SCP等常见协议</li>
<li><strong>iw</strong>: 用于显示/设置WiFi设备接口的工具, 比如展示当前设备WiFi热点信息, 主动扫描周围WiFi热点等</li>
</ul>
<h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a><strong>ping</strong></h2><p>ping通过向目标节点发送ICMP的<code>ECHO_REQUEST</code>包来测试目标地址的可达性与连通性；向目标地址发送<code>ECHO_REQUEST</code>包后, 如果正常接收到<code>ECHO_RESPONSE</code>, 则说明网络是连通的; 但如果没有接收到任何回应,并不能说明网络的不通, 有可能是请求或者响应在某个地方丢失了.通过ping的洪峰测试模式, 持续发包到目标地址, 也可以查看当前网络状态, 如RTT(Round-trip time)时间, 网络的丢包率等信息.</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ping_usage.png" alt="ping usage"></p>
<p>一般测试中常用的参数有如下几个:</p>
<ul>
<li><code>-c</code>: 设置发多少个<code>ECHO_REQUEST</code>包</li>
<li><code>-i</code>: 两个包之间的时间间隔, 默认是1s</li>
<li><code>-I</code>: 指定数据包出去的端口</li>
<li><code>-w</code>: ping测试的超时时间, 多久结束</li>
<li><code>-f</code>: 洪峰测试, 持续(两个包的时间间隔为0)向目标主机发送数据包</li>
<li><code>-s</code>: 指定发送数据包的大小</li>
<li><code>-M</code>: 选择Path MTU发现策略， 有三个选择： <code>do</code>代表不要对数据包进行分片， <code>want</code>表示执行PMTU发现， 但是可以在本地进行数据包的分片，<pre><code>`dont`表示不要设置分片标志位（可以分片）
</code></pre></li>
</ul>
<p>示例: 向某个域名发送10包,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ping -c 10 www.google.com</span><br></pre></td></tr></table></figure>
<p>持续向某个主机连续20s发送数据包, 并指定出口为<code>wlp5s0</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ping -f -w 20 -I wlp5s0 www.google.com</span><br></pre></td></tr></table></figure>
<p>通过指定包大小以及PMTU的策略，可以用来发现某个路径上最大的MTU大概是多少：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ping -v -w 20 -M do -s 1460 www.baidu.com</span><br></pre></td></tr></table></figure>
<p>一般, ping测试完成后, 会打印发生了多少个包, 接收的包个数以及丢包率, 总的测试时间以及RTT:</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ping_output.png" alt="ping output"></p>
<h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a><strong>traceroute</strong></h2><p>traceroute能够跟踪打印通往某个网络主机的路由信息, 用于定位网络不通时,在哪个路由节点发生的异常. traceroute利用的是IP协议中的包的TTL(Time-To-Live)字段不断发送”探针”包;其首先会向网络发送一个TTL为1的包, 返回后接着向网络发送一个TTL为2的包, 以此持续发送, 直到最后到达目标主机或者超时为止.traceroute的参数较多, 可以通过<code>man traceroute</code>或者<code>traceroute --help</code>查看具体的用法.</p>
<p>示例, 查找到达<code>www.google.com</code>的路由:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">traceroute www.google.com</span><br></pre></td></tr></table></figure>
<h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a><strong>tcpdump</strong></h2><p>tcpdump用于抓取网络数据包的利器, 最初的版本是由Van Jacobson, Sally Floyd, Vern Paxson在1988年编码, 后来在各种操作系统中都得到了广泛的使用, 更多详细信息可以参考<a href="https://www.tcpdump.org/" target="_blank" rel="noopener">https://www.tcpdump.org/</a>；如果你使用的是Linux系统, 可以通过<code>man tcpdump</code>来查看tcpdump的具体使用信息. 这里来看下Linux下的tcpdump工具具体如何使用.</p>
<p>以Ubuntu系统为例, tcpdump有很多参数:</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tcpdump_synopsis.png" alt="Tcpdump命令参数"> </p>
<p>常用的参数主要有如下几个:</p>
<ul>
<li><code>-i *interface*/--interface=*interface*</code>: 设置需要抓包的网口, 在Ubuntu系统可以通过<code>ifconfig</code>查看每个网络接口信息; 在Android下可以通过<code>busybox ifconfig</code>查看;</li>
<li><code>-n</code>: 不要将IP地址转换成域名;</li>
<li><code>-s *snaplen*/ --snapshot--length=*snaplen*</code>: 为了保持兼容性, 一般将该值设为0;</li>
<li><code>-w *file*</code>: 保存网络数据包到某个文件;</li>
<li><code>expression</code>: 表达式,  由于网络数据包的过滤, 关于表达式的语法格式可以参考<code>man pcap-filter</code>;</li>
</ul>
<p>示例: 比如我要抓取某个端口<code>wlp5s0</code>上的所有数据包, 可以使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tcpdump -i wlp5s0 -s 0 -n -w ~/all.pcap</span><br></pre></td></tr></table></figure>
<p>如果只是想看某个端口指定一个协议, 如tcp的数据包, 则可以:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tcpdump -i wlp5s0 -s 0 -w ip proto \\tcp</span><br></pre></td></tr></table></figure>
<p>这里<code>ip proto \\tcp</code>就是包过滤的表达式, 具体的写法可以参考<code>man pcap-filter</code>或者<a href="http://alumni.cs.ucr.edu/~marios/ethereal-tcpdump.pdf" target="_blank" rel="noopener">http://alumni.cs.ucr.edu/~marios/ethereal-tcpdump.pdf</a></p>
<h2 id="iproute2"><a href="#iproute2" class="headerlink" title="iproute2"></a><strong>iproute2</strong></h2><p>看名字大概也知道<a href="https://en.wikipedia.org/wiki/Iproute2" target="_blank" rel="noopener"><code>iproute2</code></a>这个是用来管理linux系统路由表的, 但在这个工具系列中其实也集成了其他有用的功能, 比如地址/链路的管理, 查看ARP信息, 配置网络接口信息以及配置策略路由(policy routing)等(<code>man ip</code>查看对应信息), 对于Ubuntu系统可以通过<code>man ip-route</code>来查看如何使用<code>iproute</code>:</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ip-route-usage.png" alt="ip-route usage"> </p>
<p>示例: 想看下系统的路由表, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ip route  # 等价于 ip route show default</span><br></pre></td></tr></table></figure>
<p>如果想要看某个具体的路由表信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ip route show table main  # local, main, or all</span><br></pre></td></tr></table></figure>
<p>那么, 如果要在某个路由表中添加一项路由信息, 如何操作?假定现在, 需要在<code>main</code>路由表中对应的端口<code>ppp0</code>中添加一个目标ip为<code>211.137.20.302</code>的路由:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ip route add table main scope link dev ppp0 211.137.20.302</span><br></pre></td></tr></table></figure>
<p>想要删除路由表中的某一项, 语法跟路由表添加很相似:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ip route del table main scope link dev ppp0 211.137.20.302</span><br></pre></td></tr></table></figure>
<p>在某个网口上添加默认路由:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add default proto static scope link dev wlp5s0</span><br></pre></td></tr></table></figure>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a><strong>netstat</strong></h2><p>netstat主要用来看路由表, 当前网络链接状态以及网络数据统计等,  最新的Linux系统已经使用<code>ip</code>(<code>man ip</code>)来替代(具体的信息可以通过<code>man netstat</code>查看).不过在Android的busybox中仍然可以发挥作用:</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/netstat_usage.png" alt="netstat usage"> </p>
<p>例如输入<code>adb shell busybox netstat -rn</code>显示路由表:</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/netstat_routing_table.png" alt="netstat routing table"></p>
<h2 id="netcfg"><a href="#netcfg" class="headerlink" title="netcfg"></a><strong>netcfg</strong></h2><p>在Ubuntu系统中并没有看到<code>netcfg</code>工具, Android里边有一个<code>netcfg</code>工具用于配置网口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">usage: netcfg [&lt;interface&gt; &#123;dhcp|up|down&#125;]</span><br></pre></td></tr></table></figure>
<p>通过ADB命令<code>adb shell netcfg</code>可以查看当前网口的配置:</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/netcfg_output.png" alt="netcfg output"> </p>
<p>如果要在Android中配置一个以太网口(Ethernet), 确保驱动加载完成后, 输入以下指令即可:</p>
<ol>
<li>使能网口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">netcfg &lt;interface&gt; up</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>通过DHCP获取IP地址</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">netcfg &lt;interface&gt; dhcp</span><br></pre></td></tr></table></figure>
<h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a><strong>iptables</strong></h2><p>iptables是netfilter(<a href="https://www.netfilter.org/)在用户空间的工具" target="_blank" rel="noopener">https://www.netfilter.org/)在用户空间的工具</a>, 可以用来读网络数据包进行转发, 拦截, 过滤以及修改. 简单说来, netfilter是在tcp/ip的内核传输路径添加各种hooks函数,如PREROUTING, INPUT, FORWARD, OUTPUT, POSTROUTING; 这些hooks函数负责将数据包发送个各个队列(tables), 示意图如下: </p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/Iptables_packet_flow.png" alt="iptables-netfilter flow"></p>
<p>在Linux中内置的tables有如下几个:</p>
<ul>
<li><strong>Filter</strong>: 用于数据包过滤(接收或者丢弃)</li>
<li><strong>Nat</strong>: IP地址转换, 有源地址(snat), 目标地址(dnat)以及masquerade(装饰)三种</li>
<li><strong>Managle</strong>: 修改数据包的头(ttl/tos等)</li>
<li><strong>Raw</strong>: 主要用于配置链接跟踪(connection tracking)</li>
</ul>
<p>在Ubuntu系统中, 输入<code>man iptables</code>可以查看iptables的具体用法:</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/iptables-usage.png" alt="iptables usage"></p>
<p>比如要查看当前iptables规则, 可以通过<code>iptables --list</code>; 一般<code>iptables</code>命令有如下几个部分组成:</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/iptables_general_structure.png" alt="iptables command structure"></p>
<p>假定你现在需要拦截所有来自某个IP地址的数据包, 可以这样操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">iptables -A INPUT -s 182.23.23.23 -i wlp5s0 -j DROP</span><br></pre></td></tr></table></figure>
<p>如果只是想丢弃某种协议的数据包, 比如UDP, 则可以指定协议类型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">iptables -A INPUT -s 182.23.23.23 -i wlp5s0 -j DROP -p udp</span><br></pre></td></tr></table></figure>
<p>查看当前规则的流量使用情况可以使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">iptables -L -v -n</span><br></pre></td></tr></table></figure>
<p>通过iptables的规则链条, 我们可以很方便的构造一系列防火墙规则, 看起来是非常强大的一个工具了. 很值得学习~</p>
<h2 id="netcat"><a href="#netcat" class="headerlink" title="netcat"></a><strong>netcat</strong></h2><p><code>netcat</code>通常简写成<code>nc</code>, 是一个用于建立TCP/UDP连接的小工具, 在Linux下<code>netcat -h</code>或者<code>nc -h</code>都可以查看其使用说明；Android也包含了一个缩减版的<code>netcat</code>, 可以通过<code>nc -h</code>查看. 以Ubuntu为例, 通常<code>nc</code>有如下几个参数:</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/nc_usage.png" alt="netcat usage"></p>
<p>比如要测试下跟google的TCP连接是否正常(设置<code>-v</code>可以输出连接的状态信息):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nc -v www.google.com 80</span><br></pre></td></tr></table></figure>
<p>类似的, 也可以建立一个UDP连接:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -v -u www.google.com 80</span><br></pre></td></tr></table></figure>
<p><code>netcat</code>有个比较有用的功能就是扫描某个主机给定范围的端口是否正常可连接: 如下这个指令用来查看网关<code>192.168.225.1</code>上<code>1-10000</code>的端口是否可用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nc -v -z 192.168.225.1 1-10000</span><br></pre></td></tr></table></figure>
<p>如果我们想要测试两个主机给定端口的连通性,可以按照如下步骤操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#在HOST1监听2323这个端口</span><br><span class="line">nc -v -l -p 2323 </span><br><span class="line"></span><br><span class="line">#在HOST2上主动连接2323这个端口</span><br><span class="line">nc -v -X connect 192.168.225.1 2323</span><br></pre></td></tr></table></figure>
<p>关于<code>nc</code>更多有趣的应用, 可以到官网上查看 <a href="http://nc110.sourceforge.net/" target="_blank" rel="noopener">http://nc110.sourceforge.net/</a>.</p>
<h2 id="iPerf"><a href="#iPerf" class="headerlink" title="iPerf"></a><strong>iPerf</strong></h2><p>iPerf是一个基于TCP/UPD协议的网络测试工具, 常用来测试网络吞吐量以及带宽. 在测试时需要客户端与服务端都支持. 目前有iperf3/iperf2两个版本, 相关文档参考<a href="https://iperf.fr/iperf-doc.php" target="_blank" rel="noopener">https://iperf.fr/iperf-doc.php</a>. 这里我们基于iperf2介绍下如何来使用iperf.</p>
<p>iPerf的参数主要分为三类, 一类是通用参数, 如参数格式, 多线程测试等；一类是客户端使用的参数, 如目标地址；一类是服务端的参数, 如基于UDP或者通过Daemon进程执行等.</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/iperf_usage.png" alt="iperf usage"></p>
<p>比如简单来测试下网络带宽(<code>ping.online.net</code>是免费用来测试网络的服务器):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">iperf -f M -m -c ping.online.net</span><br></pre></td></tr></table></figure>
<p>测试完成后, 会输出如下信息:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/iperf_test_result.png" alt="iperf test output"></p>
<p>这里只是简单引出iperf的使用方法, 更多使用场景可以到官网上看看文档<a href="https://iperf.fr/" target="_blank" rel="noopener">https://iperf.fr/</a>.</p>
<h2 id="tc"><a href="#tc" class="headerlink" title="tc"></a><strong>tc</strong></h2><p>tc即<code>Traffic Control</code>, 可以显示/修改网卡的配置, 如设置网卡的延时, 传输速率, 控制包的传输顺序等, 在linux上输入<code>man tc</code>可以查看具体的使用说明:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/tc_synopsis.png" alt="tc usage"></p>
<p>比如要看下当前网卡队列的状态, 可以输入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tc -s qdisc show dev eth0</span><br></pre></td></tr></table></figure>
<h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a><strong>curl</strong></h2><p><code>curl</code>一般用于客户端数据的下载传输, 目前支持Web协议如HTTP(S)/FTP到视频流传输协议如RTMP/RTSP等, 其使用起来也非常简单:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl [options...] &lt;url&gt;</span><br></pre></td></tr></table></figure>
<p>比如要尝试下载某个网页:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">curl -v www.baidu.com</span><br></pre></td></tr></table></figure>
<p>这里<code>-v</code>会输出更多的过程信息:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/curl_examples.png" alt="curl examples result"></p>
<h2 id="iw"><a href="#iw" class="headerlink" title="iw"></a><strong>iw</strong></h2><p><code>iw</code>常用于WiFi设备的管理, 配置, 通过<code>man iw</code>可以看到相关的使用说明:</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/iw_usage.png" alt="iw usage"></p>
<p>要查看所有相关命令的使用可以输入<code>iw help</code>.如要查看当前设备WiFi信息, 可以输入<code>iw dev</code>. 通过:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">iw &lt;wlan_interface&gt; info</span><br></pre></td></tr></table></figure>
<p>可以查看到当前连接的WiFi热点信息, 如果要扫描附近的WiFi热点, 可以通过<code>iw &lt;wlan_interface&gt; scan</code>, 这样会得到一个完整的热点列表.</p>
<p>以上便是常用几个网络工具的总结了, 大家有什么好的Linux工具可以推荐下~以后持续更新</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="http://stud.netgroup.uniroma2.it/cgrl/2018/slides/5-netfilter.pdf" target="_blank" rel="noopener">http://stud.netgroup.uniroma2.it/cgrl/2018/slides/5-netfilter.pdf</a></li>
<li><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Netfilter</a></li>
<li><a href="https://iperf.fr/(iPerf官网)" target="_blank" rel="noopener">https://iperf.fr/(iPerf官网)</a></li>
<li><a href="http://linux-ip.net/html/tools-ip-route.html" target="_blank" rel="noopener">http://linux-ip.net/html/tools-ip-route.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Iptables" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Iptables</a></li>
<li><a href="https://linux.die.net/man/8/tc" target="_blank" rel="noopener">https://linux.die.net/man/8/tc</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network tools </tag>
            
            <tag> ip route </tag>
            
            <tag> tcpdump </tag>
            
            <tag> iptables </tag>
            
            <tag> iperf </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[成王败寇与丛林法则-看纪录片<英国史>有感]]></title>
      <url>http://sniffer.site/2019/01/04/%E6%88%90%E7%8E%8B%E8%B4%A5%E5%AF%87%E4%B8%8E%E4%B8%9B%E6%9E%97%E6%B3%95%E5%88%99-%E7%9C%8B%E7%BA%AA%E5%BD%95%E7%89%87-%E8%8B%B1%E5%9B%BD%E5%8F%B2-%E6%9C%89%E6%84%9F/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>People donot see; they only recognize. And what they donot recognize remains invisible to them</p>
<p>Simon Leys</p>
</blockquote>
<p>最近断断续续的看完了BBC的《英国史》(<a href="https://open.163.com/movie/2016/2/S/O/MBF6MO64J_MBF6NAPSO.html" target="_blank" rel="noopener">网易公开课链接</a>)，从史前文明讲到宗教改革;从罗马帝国的征服讲到光荣革命, 加上醇厚的英式英语, 整个纪录片看起来十分的有趣而汤气回肠。在英国人看来，国王只是上帝在人间的代表，执行着上帝的意志，而不是独揽大权的独裁者。纵然，英国历史上也出现过暴君，但最终并没有什么好下场，弄不好还被送上断头台，掉了脑袋。<a id="more"></a>印象深刻的是，在英国内战期间，当乡绅<a href="https://zh.wikipedia.org/wiki/%E5%A5%A5%E5%88%A9%E5%BC%97%C2%B7%E5%85%8B%E4%BC%A6%E5%A8%81%E5%B0%94" target="_blank" rel="noopener">克伦威尔</a>赶走暴君，掌握军权之后，并没有依靠独裁加冕成为国王，而是给自己冠上了护国公。这就告诉人民，国王是上帝的代表，是荣誉与信仰的象征，有血统而赋有担当与责任，并不是每个出生草莽之辈能戴上王冠，纵使像克伦威尔这样的乡绅也不能。这种贵族式的统治，加上议会这种代表民主与自由的分权机构，英国终于成为了欧洲乃至世界近代历史的领头羊，将人类文明带入新的高度。</p>
<p>再对比中国历史上的权力游戏，却是截然不同的画面。当秦朝末年，人民被折腾的苦不堪言时，陈胜吴广说的是“王侯将相宁有种乎”，他秦始皇能做一国之君，我陈胜吴广为何不能？陈胜吴广起义也绝非为了执行上帝的意志，消除社会不公平，而是挣脱套牢在他们自己身上的枷锁。这个即便是到了近代的太平天国起义也是如此。他们揭竿而起并不是为了某种上帝的意志与信念而战，也不是为了某种信仰而赴汤蹈火，而是做另一个秦始皇，在万人之上，成为人人害怕而崇拜的对象，成为坐拥万千宾妃的皇上。这里，看不到任何关于荣誉与尊严，看不到任何对于自由与民主的追求，有的只是对成王败寇的推崇，以及“宁可我负天下人，不可天下人负我”的自私与偏狭。从这个角度看，五千年历史一直上演的都是弱肉强食，适者生存的丛林游戏。没有对人的荣誉与尊严的保护，没有对社会不公制度性的建设，没有对自由与人性的追求,野蛮从未消失过。</p>
<p>记得小时候长辈劝年轻人要努力读书时, 常会说一句”吃得苦中苦, 方为人上人”.我们读书学习, 只是成为”人上人”而已, 所谓”学而优则仕”, 一切的努力付出都只是为了成为”统治阶层”的一员.这种功利与对权力的极力推崇的态度在当今的社会依然屡见不鲜.可回顾下人类文明的发展历程, 所有的社会或文化的变革最终都指向一个目标:把人类自身从各种束缚中解脱出来, 解放人性,让人可以发挥自己的创造潜能.文艺复兴也好, 工业革命与信息技术革命, 再到影响了千千万万国人的改革开放而言, 都是为了去除套牢在人心上的枷锁,解放压抑沉闷的人性, 让每个个体都有机会发挥自身的才能与智慧.到今天, 中国进行改革开放40年来, 经济一直在高速发展, 可是社会的发展却相对停滞, 人们讨论最多的是如何挣钱, 如何谋取财富;大部分人满足于吃喝玩乐, 对于社会公平与精神追求要么无所追求, 要么有心无力.在发生问题时, 小到个人, 大到一个企业或者组织, 再到政府,都在极力推卸责任;不管是立法, 司法还是执法, 整个社会对于个体权利的保护都远远不够, 在遇到实际的法律问题时常常只能依靠道德来衡量, 显得十分捉襟见肘.</p>
<p>历经40年的发展, 普遍程度上, 我们的生活水平都有了质的提高,工业化建设也有了长足的进步.如果我们的社会想要进一步发展, 想要涌现更大的活力, 我们的古老的文明想要焕发更多的生命力, 整个国家从上至下都必须进行一次思想观念的解放:不能再仅仅满足于口号上的民族复兴/伟大使命, 而是要实实在在的作出变革, 放开对个人的束缚, 放开对自由的限制,更多的激发个人的活力.不过, 从目前来看, 我们的最高领导者似乎还在老路上沉浸不可自拔, 所谓的变革实际上显得困难重重.历史再一次将中国摆在了有趣的十字路口, 如何选择是每一个中国人都要思考的问题.</p>
]]></content>
      
        <categories>
            
            <category> 思考 </category>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 英国史 </tag>
            
            <tag> 丛林法则 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android netd工作原理详解]]></title>
      <url>http://sniffer.site/2018/12/18/Android-netd%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>NETD是Android一个专门管理网络链接, 路由/带宽/防火墙策略以及iptables的系统Daemon进程, 其在Anroid系统启动时加载 <a id="more"></a>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">service netd /system/bin/netd</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">netd</span> <span class="title">stream</span> 0660 <span class="title">root</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">dnsproxyd</span> <span class="title">stream</span> 0660 <span class="title">root</span> <span class="title">inet</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">mdns</span> <span class="title">stream</span> 0660 <span class="title">root</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">fwmarkd</span> <span class="title">stream</span> 0660 <span class="title">root</span> <span class="title">inet</span></span></span><br></pre></td></tr></table></figure>
<p>启动netd时, 会创建四个socket,用于其他进程与netd进行通信:</p>
<ul>
<li><code>netd</code>: 主要与Framework的<code>NetworkManagementService</code>交互, 用于控制网口状态, 路由表</li>
<li><code>dnsproxyd</code>: DNS代理的控制与配置，用于私有DNS（DNS Over TLS)的请求转发</li>
<li><code>mdns</code>: 多播DNS（Multicast DNS，参考RFC<a href="https://tools.ietf.org/html/rfc6762" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6762</a>), 用于基于WIFI连接的服务发现（NSD, Network Service Discovery)</li>
<li><code>fwmarkd</code>: iptables的(fwmark)策略路由的配置(<a href="http://www.policyrouting.org/PolicyRoutingBook/ONLINE/CH06.web.html" target="_blank" rel="noopener">策略路由</a>, 如设置网络权限， 连接打标签等</li>
</ul>
<p>总的说来, netd进程在Android中间层服务<code>NetworkManagementService</code>以及内核之间建立了一个沟通的桥梁:</p>
<ul>
<li>对Java层系统服务<code>NetworkManagementService</code>,<code>netd</code>通过socket接口为其提供了控制指令的通道</li>
<li>对内核, <code>netd</code>通过netlink socket与内核进行数据/指令的收发, 并将来自内核的消息发送给上层</li>
<li>从Android 8.0开始， Netd同时提供了一个HAL Binder的接口提供给其他进程调用<code>INetd.aidl</code></li>
</ul>
<p>接下来, 本文从三个方面来看下<code>netd</code>的具体工作原理与实现.</p>
<ul>
<li><code>netd</code>的初始化与启动</li>
<li><code>NetworkManagementService</code>与<code>netd</code>的交互</li>
<li><code>netd</code>与内核的交互</li>
</ul>
<blockquote>
<p>关于netlink socket可以参考: <a href="http://qos.ittc.ku.edu/netlink/html/node4.html" target="_blank" rel="noopener">http://qos.ittc.ku.edu/netlink/html/node4.html</a></p>
</blockquote>
<h2 id="netd的启动与初始化"><a href="#netd的启动与初始化" class="headerlink" title="netd的启动与初始化"></a><strong>netd的启动与初始化</strong></h2><p>netd进程启动时, 主要处理做以下事情:</p>
<ul>
<li>创建一个<code>NetlinkManager</code>, 用于管理与内核通信的netlink连接</li>
<li>初始化网络控制类, 如路由控制<code>RouteController</code>, 带宽控制<code>BandwidthController</code></li>
<li>启动各类事件监听类: <code>DnsProxyListener</code>监听DNS代理; <code>CommandListener</code>监听来自<code>NetworkManagement</code>的指令</li>
<li>启动NetdHwService, 为HAL层提供接口</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> android::net::gCtls;</span><br><span class="line">    Stopwatch s;</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"Netd 1.0 starting"</span>);</span><br><span class="line"></span><br><span class="line">    blockSigpipe();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    NetlinkManager *nm = NetlinkManager::Instance();</span><br><span class="line">    <span class="keyword">if</span> (nm == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">	ALOGE(<span class="string">"Unable to create NetlinkManager"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gCtls = <span class="keyword">new</span> android::net::Controllers();</span><br><span class="line">    gCtls-&gt;init();</span><br><span class="line"></span><br><span class="line">    CommandListener cl;</span><br><span class="line">    nm-&gt;setBroadcaster((SocketListener *) &amp;cl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nm-&gt;start()) &#123;</span><br><span class="line">		ALOGE(<span class="string">"Unable to start NetlinkManager (%s)"</span>, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;NFLogListener&gt; logListener;</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">auto</span> result = makeNFLogListener();</span><br><span class="line">	<span class="keyword">if</span> (!isOk(result)) &#123;</span><br><span class="line">	    ALOGE(<span class="string">"Unable to create NFLogListener: %s"</span>, toString(result).c_str());</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	logListener = <span class="built_in">std</span>::move(result.value());</span><br><span class="line">	<span class="keyword">auto</span> status = gCtls-&gt;wakeupCtrl.init(logListener.get());</span><br><span class="line">	<span class="keyword">if</span> (!isOk(result)) &#123;</span><br><span class="line">	    ALOGE(<span class="string">"Unable to init WakeupController: %s"</span>, toString(result).c_str());</span><br><span class="line">	    <span class="comment">// We can still continue without wakeup packet logging.</span></span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set local DNS mode, to prevent bionic from proxying</span></span><br><span class="line">    <span class="comment">// back to this service, recursively.</span></span><br><span class="line">    setenv(<span class="string">"ANDROID_DNS_MODE"</span>, <span class="string">"local"</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="function">DnsProxyListener <span class="title">dpl</span><span class="params">(&amp;gCtls-&gt;netCtrl, &amp;gCtls-&gt;eventReporter)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (dpl.startListener()) &#123;</span><br><span class="line">		ALOGE(<span class="string">"Unable to start DnsProxyListener (%s)"</span>, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MDnsSdListener mdnsl;</span><br><span class="line">    <span class="keyword">if</span> (mdnsl.startListener()) &#123;</span><br><span class="line">		ALOGE(<span class="string">"Unable to start MDnsSdListener (%s)"</span>, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">FwmarkServer <span class="title">fwmarkServer</span><span class="params">(&amp;gCtls-&gt;netCtrl, &amp;gCtls-&gt;eventReporter)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (fwmarkServer.startListener()) &#123;</span><br><span class="line">		ALOGE(<span class="string">"Unable to start FwmarkServer (%s)"</span>, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stopwatch subTime;</span><br><span class="line">    <span class="keyword">status_t</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = NetdNativeService::start()) != android::OK) &#123;</span><br><span class="line">		ALOGE(<span class="string">"Unable to start NetdNativeService: %d"</span>, ret);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGI(<span class="string">"Registering NetdNativeService: %.1fms"</span>, subTime.getTimeAndReset());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now that we're up, we can respond to commands. Starting the listener also tells</span></span><br><span class="line"><span class="comment">     * NetworkManagementService that we are up and that our binder interface is ready.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (cl.startListener()) &#123;</span><br><span class="line">		ALOGE(<span class="string">"Unable to start CommandListener (%s)"</span>, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGI(<span class="string">"Starting CommandListener: %.1fms"</span>, subTime.getTimeAndReset());</span><br><span class="line"></span><br><span class="line">    write_pid_file();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that netd is ready to process commands, advertise service</span></span><br><span class="line">    <span class="comment">// availability for HAL clients.</span></span><br><span class="line">    NetdHwService mHwSvc;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mHwSvc.start()) != android::OK) &#123;</span><br><span class="line">		ALOGE(<span class="string">"Unable to start NetdHwService: %d"</span>, ret);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGI(<span class="string">"Registering NetdHwService: %.1fms"</span>, subTime.getTimeAndReset());</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"Netd started in %dms"</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s.timeTaken()));</span><br><span class="line"></span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"Netd exiting"</span>);</span><br><span class="line"></span><br><span class="line">    remove_pid_file();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CommandListener</code>用于接收处理来自上层<code>NetworkManagementService</code>指令, 在<code>netd</code>启动时, 会监听<code>netd</code>这个socket, 并允许最多4个客户端请求的处理:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> SocketListener::startListener() &#123;</span><br><span class="line">    <span class="keyword">return</span> startListener(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SocketListener::startListener(<span class="keyword">int</span> backlog) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mSocketName &amp;&amp; mSock == <span class="number">-1</span>) &#123;</span><br><span class="line">		SLOGE(<span class="string">"Failed to start unbound listener"</span>);</span><br><span class="line">		errno = EINVAL;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSocketName) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((mSock = android_get_control_socket(mSocketName)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			SLOGE(<span class="string">"Obtaining file descriptor socket '%s' failed: %s"</span>,</span><br><span class="line">				mSocketName, strerror(errno));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		SLOGV(<span class="string">"got mSock = %d for %s"</span>, mSock, mSocketName);</span><br><span class="line">		fcntl(mSock, F_SETFD, FD_CLOEXEC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mListen &amp;&amp; listen(mSock, backlog) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		SLOGE(<span class="string">"Unable to listen on socket (%s)"</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mListen)</span><br><span class="line">		mClients-&gt;push_back(<span class="keyword">new</span> SocketClient(mSock, <span class="literal">false</span>, mUseCmdNum));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(mCtrlPipe)) &#123;</span><br><span class="line">		SLOGE(<span class="string">"pipe failed (%s)"</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;mThread, <span class="literal">NULL</span>, SocketListener::threadStart, <span class="keyword">this</span>)) &#123;</span><br><span class="line">		SLOGE(<span class="string">"pthread_create (%s)"</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个专门的线程用于处理来自上层客户端的命令请求:</p>
<ul>
<li>检查控制pipe的数据,是否有必要停止监听;</li>
<li>监听来自客户端的请求, 如果有, 则新建一个<code>SocketClient</code>保存下来</li>
<li>从已有的<code>SocketClient</code>中检查是否有可用的数据, 如果有则通过<code>onDataAvailable</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> *SocketListener::threadStart(<span class="keyword">void</span> *obj) &#123;</span><br><span class="line">    SocketListener *me = <span class="keyword">reinterpret_cast</span>&lt;SocketListener *&gt;(obj);</span><br><span class="line"></span><br><span class="line">    me-&gt;runListener();</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SocketListener::runListener() &#123;</span><br><span class="line"></span><br><span class="line">    SocketClientCollection pendingList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">	SocketClientCollection::iterator it;</span><br><span class="line">	fd_set read_fds;</span><br><span class="line">	<span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	FD_ZERO(&amp;read_fds);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mListen) &#123;</span><br><span class="line">	    max = mSock;</span><br><span class="line">	    FD_SET(mSock, &amp;read_fds);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FD_SET(mCtrlPipe[<span class="number">0</span>], &amp;read_fds);</span><br><span class="line">	<span class="keyword">if</span> (mCtrlPipe[<span class="number">0</span>] &gt; max)</span><br><span class="line">	    max = mCtrlPipe[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;mClientsLock);</span><br><span class="line">	<span class="keyword">for</span> (it = mClients-&gt;begin(); it != mClients-&gt;end(); ++it) &#123;</span><br><span class="line">	    <span class="comment">// NB: calling out to an other object with mClientsLock held (safe)</span></span><br><span class="line">	    <span class="keyword">int</span> fd = (*it)-&gt;getSocket();</span><br><span class="line">	    FD_SET(fd, &amp;read_fds);</span><br><span class="line">	    <span class="keyword">if</span> (fd &gt; max) &#123;</span><br><span class="line">	        max = fd;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;mClientsLock);</span><br><span class="line">	SLOGV(<span class="string">"mListen=%d, max=%d, mSocketName=%s"</span>, mListen, max, mSocketName);</span><br><span class="line">	<span class="keyword">if</span> ((rc = select(max + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">	        <span class="keyword">continue</span>;</span><br><span class="line">	    SLOGE(<span class="string">"select failed (%s) mListen=%d, max=%d"</span>, strerror(errno), mListen, max);</span><br><span class="line">	    sleep(<span class="number">1</span>);</span><br><span class="line">	    <span class="keyword">continue</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!rc)</span><br><span class="line">	    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (FD_ISSET(mCtrlPipe[<span class="number">0</span>], &amp;read_fds)) &#123;</span><br><span class="line">	    <span class="keyword">char</span> c = CtrlPipe_Shutdown;</span><br><span class="line">	    TEMP_FAILURE_RETRY(read(mCtrlPipe[<span class="number">0</span>], &amp;c, <span class="number">1</span>));</span><br><span class="line">	    <span class="keyword">if</span> (c == CtrlPipe_Shutdown) &#123;</span><br><span class="line">	        <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mListen &amp;&amp; FD_ISSET(mSock, &amp;read_fds)) &#123;</span><br><span class="line">	    <span class="keyword">int</span> c = TEMP_FAILURE_RETRY(accept4(mSock, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, SOCK_CLOEXEC));</span><br><span class="line">	    <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	        SLOGE(<span class="string">"accept failed (%s)"</span>, strerror(errno));</span><br><span class="line">	        sleep(<span class="number">1</span>);</span><br><span class="line">	        <span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    pthread_mutex_lock(&amp;mClientsLock);</span><br><span class="line">	    mClients-&gt;push_back(<span class="keyword">new</span> SocketClient(c, <span class="literal">true</span>, mUseCmdNum));</span><br><span class="line">	    pthread_mutex_unlock(&amp;mClientsLock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add all active clients to the pending list first */</span></span><br><span class="line">	pendingList.clear();</span><br><span class="line">	pthread_mutex_lock(&amp;mClientsLock);</span><br><span class="line">	<span class="keyword">for</span> (it = mClients-&gt;begin(); it != mClients-&gt;end(); ++it) &#123;</span><br><span class="line">	    SocketClient* c = *it;</span><br><span class="line">	    <span class="comment">// NB: calling out to an other object with mClientsLock held (safe)</span></span><br><span class="line">	    <span class="keyword">int</span> fd = c-&gt;getSocket();</span><br><span class="line">	    <span class="keyword">if</span> (FD_ISSET(fd, &amp;read_fds)) &#123;</span><br><span class="line">	        pendingList.push_back(c);</span><br><span class="line">	        c-&gt;incRef();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;mClientsLock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Process the pending list, since it is owned by the thread,</span></span><br><span class="line"><span class="comment">	 * there is no need to lock it */</span></span><br><span class="line">	<span class="keyword">while</span> (!pendingList.empty()) &#123;</span><br><span class="line">	    <span class="comment">/* Pop the first item from the list */</span></span><br><span class="line">	    it = pendingList.begin();</span><br><span class="line">	    SocketClient* c = *it;</span><br><span class="line">	    pendingList.erase(it);</span><br><span class="line">	    <span class="comment">/* Process it, if false is returned, remove from list */</span></span><br><span class="line">	    <span class="keyword">if</span> (!onDataAvailable(c)) &#123;</span><br><span class="line">	        release(c, <span class="literal">false</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    c-&gt;decRef();</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>netd启动完成后, 就可以处理来自中间层的指令请求以及与内核进行交互了.</p>
<h2 id="netd与NetworkManagerService的交互"><a href="#netd与NetworkManagerService的交互" class="headerlink" title="netd与NetworkManagerService的交互"></a><strong>netd与NetworkManagerService的交互</strong></h2><p><code>SystemServer</code>进程启动时,  创建<code>NetworkManagementService</code>(以下简称(<code>NMS</code>)),  此时<code>NMS</code>会主动与<code>netd</code>建立socket链接:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// SystemServer.java</span></span><br><span class="line">       <span class="keyword">if</span> (!disableNetwork) &#123;</span><br><span class="line">           traceBeginAndSlog(<span class="string">"StartNetworkManagementService"</span>);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               networkManagement = NetworkManagementService.create(context);</span><br><span class="line">               ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               reportWtf(<span class="string">"starting NetworkManagement Service"</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">           traceEnd();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>创建NMS时, 启动一个新的线程用于与netd通信,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> NetworkManagementService <span class="title">create</span><span class="params">(Context context, String socket)</span></span></span><br><span class="line"><span class="function">	    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> NetworkManagementService service = <span class="keyword">new</span> NetworkManagementService(context, socket);</span><br><span class="line">	<span class="keyword">final</span> CountDownLatch connectedSignal = service.mConnectedSignal;</span><br><span class="line">	<span class="keyword">if</span> (DBG) Slog.d(TAG, <span class="string">"Creating NetworkManagementService"</span>);</span><br><span class="line">	service.mThread.start();</span><br><span class="line">	<span class="keyword">if</span> (DBG) Slog.d(TAG, <span class="string">"Awaiting socket connection"</span>);</span><br><span class="line">	connectedSignal.await();</span><br><span class="line">	service.connectNativeNetdService();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">NetworkManagementService</span><span class="params">(Context context, String socket)</span> </span>&#123;</span><br><span class="line">	mContext = context;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// make sure this is on the same looper as our NativeDaemonConnector for sync purposes</span></span><br><span class="line">	mFgHandler = <span class="keyword">new</span> Handler(FgThread.get().getLooper());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Don't need this wake lock, since we now have a time stamp for when</span></span><br><span class="line">	<span class="comment">// the network actually went inactive.  (It might be nice to still do this,</span></span><br><span class="line">	<span class="comment">// but I don't want to do it through the power manager because that pollutes the</span></span><br><span class="line">	<span class="comment">// battery stats history with pointless noise.)</span></span><br><span class="line">	<span class="comment">//PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);</span></span><br><span class="line">	PowerManager.WakeLock wl = <span class="keyword">null</span>; <span class="comment">//pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, NETD_TAG);</span></span><br><span class="line"></span><br><span class="line">	mConnector = <span class="keyword">new</span> NativeDaemonConnector(</span><br><span class="line">		<span class="keyword">new</span> NetdCallbackReceiver(), socket, <span class="number">10</span>, NETD_TAG, <span class="number">160</span>, wl,</span><br><span class="line">		FgThread.get().getLooper());</span><br><span class="line">	mThread = <span class="keyword">new</span> Thread(mConnector, NETD_TAG);</span><br><span class="line"></span><br><span class="line">	mDaemonHandler = <span class="keyword">new</span> Handler(FgThread.get().getLooper());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add ourself to the Watchdog monitors.</span></span><br><span class="line">	Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	LocalServices.addService(NetworkManagementInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">synchronized</span> (mTetheringStatsProviders) &#123;</span><br><span class="line">	    mTetheringStatsProviders.put(<span class="keyword">new</span> NetdTetheringStatsProvider(), <span class="string">"netd"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NMS通过<code>NativeDaemonConnector</code>与<code>netd</code>建立socket通信, <code>NativeDaemonConnector</code>主要做两个事情:</p>
<ul>
<li>与<code>netd</code>建立一个数据链接</li>
<li>不断读取socket中的数据流: 一种是<code>netd</code>主动上报的命令, 一种是NMS发送给<code>netd</code>后的指令的响应</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    mCallbackHandler = new Handler(mLooper, this);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            listenToSocket();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            loge(&quot;Error in NativeDaemonConnector: &quot; + e);</span><br><span class="line">            SystemClock.sleep(5000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void listenToSocket() throws IOException &#123;</span><br><span class="line">    LocalSocket socket = null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        socket = new LocalSocket();</span><br><span class="line">        LocalSocketAddress address = determineSocketAddress();</span><br><span class="line"></span><br><span class="line">        socket.connect(address);</span><br><span class="line"></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        synchronized (mDaemonLock) &#123;</span><br><span class="line">            mOutputStream = socket.getOutputStream();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCallbacks.onDaemonConnected();</span><br><span class="line"></span><br><span class="line">        FileDescriptor[] fdList = null;</span><br><span class="line">        byte[] buffer = new byte[BUFFER_SIZE];</span><br><span class="line">        int start = 0;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            int count = inputStream.read(buffer, start, BUFFER_SIZE - start);</span><br><span class="line">            if (count &lt; 0) &#123;</span><br><span class="line">                loge(&quot;got &quot; + count + &quot; reading with start = &quot; + start);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            fdList = socket.getAncillaryFileDescriptors();</span><br><span class="line"></span><br><span class="line">            // Add our starting point to the count and reset the start.</span><br><span class="line">            count += start;</span><br><span class="line">            start = 0;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                if (buffer[i] == 0) &#123;</span><br><span class="line">                    // Note - do not log this raw message since it may contain</span><br><span class="line">                    // sensitive data</span><br><span class="line">                    final String rawEvent = new String(</span><br><span class="line">                            buffer, start, i - start, StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">                    boolean releaseWl = false;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        final NativeDaemonEvent event =</span><br><span class="line">                                NativeDaemonEvent.parseRawEvent(rawEvent, fdList);</span><br><span class="line"></span><br><span class="line">                        log(&quot;RCV &lt;- &#123;&quot; + event + &quot;&#125;&quot;);</span><br><span class="line"></span><br><span class="line">                        if (event.isClassUnsolicited()) &#123;</span><br><span class="line">                            Message msg = mCallbackHandler.obtainMessage(</span><br><span class="line">                                    event.getCode(), uptimeMillisInt(), 0, event.getRawEvent());</span><br><span class="line">                            if (mCallbackHandler.sendMessage(msg)) &#123;</span><br><span class="line">                                releaseWl = false;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            mResponseQueue.add(event.getCmdNumber(), event);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">                        log(&quot;Problem parsing message &quot; + e);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        if (releaseWl) &#123;</span><br><span class="line">                            mWakeLock.release();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    start = i + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // We should end at the amount we read. If not, compact then</span><br><span class="line">            // buffer and read again.</span><br><span class="line">            if (start != count) &#123;</span><br><span class="line">                final int remaining = BUFFER_SIZE - start;</span><br><span class="line">                System.arraycopy(buffer, start, buffer, 0, remaining);</span><br><span class="line">                start = remaining;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                start = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        loge(&quot;Communications error: &quot; + ex);</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        synchronized (mDaemonLock) &#123;</span><br><span class="line">            if (mOutputStream != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    loge(&quot;closing stream for &quot; + mSocket);</span><br><span class="line">                    mOutputStream.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    loge(&quot;Failed closing output stream: &quot; + e);</span><br><span class="line">                &#125;</span><br><span class="line">                mOutputStream = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (socket != null) &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            loge(&quot;Failed closing socket: &quot; + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>socket链接建立完成之后, NMS与<code>netd</code>可以相互通信, 发送指令与数据了. NMS通过<code>NativeDaemonConnector</code>执行相应的指令, 比如NMS设置网络接口的配置(打开/关闭网口):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterfaceConfig</span><span class="params">(String iface, InterfaceConfiguration cfg)</span> </span>&#123;</span><br><span class="line">    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);</span><br><span class="line">    LinkAddress linkAddr = cfg.getLinkAddress();</span><br><span class="line">    <span class="keyword">if</span> (linkAddr == <span class="keyword">null</span> || linkAddr.getAddress() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Null LinkAddress given"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Command cmd = <span class="keyword">new</span> Command(<span class="string">"interface"</span>, <span class="string">"setcfg"</span>, iface,</span><br><span class="line">            linkAddr.getAddress().getHostAddress(),</span><br><span class="line">            linkAddr.getPrefixLength());</span><br><span class="line">    <span class="keyword">for</span> (String flag : cfg.getFlags()) &#123;</span><br><span class="line">        cmd.appendArg(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mConnector.execute(cmd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NativeDaemonConnectorException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowAsParcelableException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NativeDaemonConnector</code>会将每个指令都指定一个唯一的序列, 并将其响应放到一个阻塞队列, 等待<code>netd</code>返回指令的结果, 如果超过指定的超时时间, 则抛出一个超时的异常.</p>
<p>在第一部分时, 讲到<code>SocketListener</code>拿到上层发过来的指令后, 会将其分发给对应的指令类进行处理(看<code>SocketListener</code>的子类<code>FrameworkListener</code>):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">bool</span> FrameworkListener::onDataAvailable(SocketClient *c) &#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[CMD_BUF_SIZE];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = TEMP_FAILURE_RETRY(read(c-&gt;getSocket(), buffer, <span class="keyword">sizeof</span>(buffer)));</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	SLOGE(<span class="string">"read() failed (%s)"</span>, strerror(errno));</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!len) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer[len<span class="number">-1</span>] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">	SLOGW(<span class="string">"String is not zero-terminated"</span>);</span><br><span class="line">	android_errorWriteLog(<span class="number">0x534e4554</span>, <span class="string">"29831647"</span>);</span><br><span class="line">	c-&gt;sendMsg(<span class="number">500</span>, <span class="string">"Command too large for buffer"</span>, <span class="literal">false</span>);</span><br><span class="line">	mSkipToNextNullByte = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (buffer[i] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">	    <span class="comment">/* IMPORTANT: dispatchCommand() expects a zero-terminated string */</span></span><br><span class="line">	    <span class="keyword">if</span> (mSkipToNextNullByte) &#123;</span><br><span class="line">	        mSkipToNextNullByte = <span class="literal">false</span>;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        dispatchCommand(c, buffer + offset);</span><br><span class="line">	    &#125;</span><br><span class="line">	    offset = i + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mSkipToNextNullByte = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>dispatchCommmand</code>会检查所有指令处理类, 匹配相应的类去执行指令:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> FrameworkListener::dispatchCommand(SocketClient *cli, <span class="keyword">char</span> *data) &#123;</span><br><span class="line">    FrameworkCommandCollection::iterator i;</span><br><span class="line">    <span class="keyword">int</span> argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *argv[FrameworkListener::CMD_ARGS_MAX];</span><br><span class="line">    <span class="keyword">char</span> tmp[CMD_BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *p = data;</span><br><span class="line">    <span class="keyword">char</span> *q = tmp;</span><br><span class="line">    <span class="keyword">char</span> *qlimit = tmp + <span class="keyword">sizeof</span>(tmp) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> esc = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> quote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> haveCmdNum = !mWithSeq;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(argv, <span class="number">0</span>, <span class="keyword">sizeof</span>(argv));</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    ...</span><br><span class="line">    *q = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= CMD_ARGS_MAX)</span><br><span class="line">	<span class="keyword">goto</span> overflow;</span><br><span class="line">    argv[argc++] = strdup(tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (quote) &#123;</span><br><span class="line">	cli-&gt;sendMsg(<span class="number">500</span>, <span class="string">"Unclosed quotes error"</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errorRate &amp;&amp; (++mCommandCount % errorRate == <span class="number">0</span>)) &#123;</span><br><span class="line">	<span class="comment">/* ignore this command - let the timeout handler handle it */</span></span><br><span class="line">	SLOGE(<span class="string">"Faking a timeout"</span>);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = mCommands-&gt;begin(); i != mCommands-&gt;end(); ++i) &#123;</span><br><span class="line">	FrameworkCommand *c = *i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], c-&gt;getCommand())) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (c-&gt;runCommand(cli, argc, argv)) &#123;</span><br><span class="line">	        SLOGW(<span class="string">"Handler '%s' error (%s)"</span>, c-&gt;getCommand(), strerror(errno));</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cli-&gt;sendMsg(<span class="number">500</span>, <span class="string">"Command not recognized"</span>, <span class="literal">false</span>);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++)</span><br><span class="line">	<span class="built_in">free</span>(argv[j]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">overflow:</span><br><span class="line">    cli-&gt;sendMsg(<span class="number">500</span>, <span class="string">"Command too long"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如这里执行的是, 网络接口相关的设置, 因此会调用<code>InterfaceCmd</code>来执行该指令.</p>
<h2 id="NETD与内核进行交互"><a href="#NETD与内核进行交互" class="headerlink" title="NETD与内核进行交互"></a><strong>NETD与内核进行交互</strong></h2><p>NETD通过<code>netlink</code>事件与内核进行消息的交换.在第一部分时看到, <code>netd</code>启动时, 会配置socket与内核进行通信:</p>
<ul>
<li>netlink事件<code>NETLINK_KOBJECT_UEVENT</code>: 用于内核向<code>netd</code>发生消息, 如网口的状态变化;</li>
<li>netlink事件<code>NETLINK_ROUTE</code>:用于接收路由信息, 如路由表的更新与删除;</li>
<li>netlink事件<code>NETLINK_NFLOG</code>:用于接收数据流量使用配额的消息, 如数据使用超限;</li>
<li>netlink事件<code>NETLINK_NETFILTER</code>用于接收包过滤(netfilter)的消息;</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> NetlinkManager::start() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((mUeventHandler = setupSocket(&amp;mUeventSock, NETLINK_KOBJECT_UEVENT,</span><br><span class="line">	 <span class="number">0xffffffff</span>, NetlinkListener::NETLINK_FORMAT_ASCII, <span class="literal">false</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mRouteHandler = setupSocket(&amp;mRouteSock, NETLINK_ROUTE,</span><br><span class="line">	                             RTMGRP_LINK |</span><br><span class="line">	                             RTMGRP_IPV4_IFADDR |</span><br><span class="line">	                             RTMGRP_IPV6_IFADDR |</span><br><span class="line">	                             RTMGRP_IPV6_ROUTE |</span><br><span class="line">	                             (<span class="number">1</span> &lt;&lt; (RTNLGRP_ND_USEROPT - <span class="number">1</span>)),</span><br><span class="line">	 NetlinkListener::NETLINK_FORMAT_BINARY, <span class="literal">false</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mQuotaHandler = setupSocket(&amp;mQuotaSock, NETLINK_NFLOG,</span><br><span class="line">	    NFLOG_QUOTA_GROUP, NetlinkListener::NETLINK_FORMAT_BINARY, <span class="literal">false</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	ALOGW(<span class="string">"Unable to open qlog quota socket, check if xt_quota2 can send via UeventHandler"</span>);</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> return -1 once the emulator gets a new kernel.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mStrictHandler = setupSocket(&amp;mStrictSock, NETLINK_NETFILTER,</span><br><span class="line">	    <span class="number">0</span>, NetlinkListener::NETLINK_FORMAT_BINARY_UNICAST, <span class="literal">true</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	ALOGE(<span class="string">"Unable to open strict socket"</span>);</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> return -1 once the emulator gets a new kernel.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个netlink的socket都会新建一个<code>NetlinkHandler</code>, 用于处理内核的消息, 并将该消息广播给上层:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> NetlinkHandler::onEvent(NetlinkEvent *evt) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *subsys = evt-&gt;getSubsystem();</span><br><span class="line">    <span class="keyword">if</span> (!subsys) &#123;</span><br><span class="line">	ALOGW(<span class="string">"No subsystem found in netlink event"</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(subsys, <span class="string">"net"</span>)) &#123;</span><br><span class="line">	NetlinkEvent::Action action = evt-&gt;getAction();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *iface = evt-&gt;findParam(<span class="string">"INTERFACE"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (action == NetlinkEvent::Action::kAdd) &#123;</span><br><span class="line">	    notifyInterfaceAdded(iface);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == NetlinkEvent::Action::kRemove) &#123;</span><br><span class="line">	    notifyInterfaceRemoved(iface);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == NetlinkEvent::Action::kChange) &#123;</span><br><span class="line">	    evt-&gt;dump();</span><br><span class="line">	    notifyInterfaceChanged(<span class="string">"nana"</span>, <span class="literal">true</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == NetlinkEvent::Action::kLinkUp) &#123;</span><br><span class="line">	    notifyInterfaceLinkChanged(iface, <span class="literal">true</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == NetlinkEvent::Action::kLinkDown) &#123;</span><br><span class="line">	    notifyInterfaceLinkChanged(iface, <span class="literal">false</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == NetlinkEvent::Action::kAddressUpdated ||</span><br><span class="line">	           action == NetlinkEvent::Action::kAddressRemoved) &#123;</span><br><span class="line">	    <span class="keyword">const</span> <span class="keyword">char</span> *address = evt-&gt;findParam(<span class="string">"ADDRESS"</span>);</span><br><span class="line">	    <span class="keyword">const</span> <span class="keyword">char</span> *flags = evt-&gt;findParam(<span class="string">"FLAGS"</span>);</span><br><span class="line">	    <span class="keyword">const</span> <span class="keyword">char</span> *scope = evt-&gt;findParam(<span class="string">"SCOPE"</span>);</span><br><span class="line">	    <span class="keyword">if</span> (action == NetlinkEvent::Action::kAddressRemoved &amp;&amp; iface &amp;&amp; address) &#123;</span><br><span class="line">	        <span class="comment">// Note: if this interface was deleted, iface is "" and we don't notify.</span></span><br><span class="line">	        SockDiag sd;</span><br><span class="line">	        <span class="keyword">if</span> (sd.open()) &#123;</span><br><span class="line">	            <span class="keyword">char</span> addrstr[INET6_ADDRSTRLEN];</span><br><span class="line">	            <span class="built_in">strncpy</span>(addrstr, address, <span class="keyword">sizeof</span>(addrstr));</span><br><span class="line">	            <span class="keyword">char</span> *slash = <span class="built_in">strchr</span>(addrstr, <span class="string">'/'</span>);</span><br><span class="line">	            <span class="keyword">if</span> (slash) &#123;</span><br><span class="line">	                *slash = <span class="string">'\0'</span>;</span><br><span class="line">	            &#125;</span><br><span class="line"></span><br><span class="line">	            <span class="keyword">int</span> ret = sd.destroySockets(addrstr);</span><br><span class="line">	            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	                ALOGE(<span class="string">"Error destroying sockets: %s"</span>, strerror(ret));</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	            ALOGE(<span class="string">"Error opening NETLINK_SOCK_DIAG socket: %s"</span>, strerror(errno));</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (iface &amp;&amp; iface[<span class="number">0</span>] &amp;&amp; address &amp;&amp; flags &amp;&amp; scope) &#123;</span><br><span class="line">	        notifyAddressChanged(action, address, iface, flags, scope);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == NetlinkEvent::Action::kRdnss) &#123;</span><br><span class="line">	    <span class="keyword">const</span> <span class="keyword">char</span> *lifetime = evt-&gt;findParam(<span class="string">"LIFETIME"</span>);</span><br><span class="line">	    <span class="keyword">const</span> <span class="keyword">char</span> *servers = evt-&gt;findParam(<span class="string">"SERVERS"</span>);</span><br><span class="line">	    <span class="keyword">if</span> (lifetime &amp;&amp; servers) &#123;</span><br><span class="line">	        notifyInterfaceDnsServers(iface, lifetime, servers);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == NetlinkEvent::Action::kRouteUpdated ||</span><br><span class="line">	           action == NetlinkEvent::Action::kRouteRemoved) &#123;</span><br><span class="line">	    <span class="keyword">const</span> <span class="keyword">char</span> *route = evt-&gt;findParam(<span class="string">"ROUTE"</span>);</span><br><span class="line">	    <span class="keyword">const</span> <span class="keyword">char</span> *gateway = evt-&gt;findParam(<span class="string">"GATEWAY"</span>);</span><br><span class="line">	    <span class="keyword">const</span> <span class="keyword">char</span> *iface = evt-&gt;findParam(<span class="string">"INTERFACE"</span>);</span><br><span class="line">	    <span class="keyword">if</span> (route &amp;&amp; (gateway || iface)) &#123;</span><br><span class="line">	        notifyRouteChange(action, route, gateway, iface);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(subsys, <span class="string">"qlog"</span>) || !<span class="built_in">strcmp</span>(subsys, <span class="string">"xt_quota2"</span>)) &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *alertName = evt-&gt;findParam(<span class="string">"ALERT_NAME"</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *iface = evt-&gt;findParam(<span class="string">"INTERFACE"</span>);</span><br><span class="line">	notifyQuotaLimitReached(alertName, iface);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(subsys, <span class="string">"strict"</span>)) &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *uid = evt-&gt;findParam(<span class="string">"UID"</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *hex = evt-&gt;findParam(<span class="string">"HEX"</span>);</span><br><span class="line">	notifyStrictCleartext(uid, hex);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(subsys, <span class="string">"xt_idletimer"</span>)) &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *label = evt-&gt;findParam(<span class="string">"INTERFACE"</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *state = evt-&gt;findParam(<span class="string">"STATE"</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *timestamp = evt-&gt;findParam(<span class="string">"TIME_NS"</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *uid = evt-&gt;findParam(<span class="string">"UID"</span>);</span><br><span class="line">	<span class="keyword">if</span> (state)</span><br><span class="line">	    notifyInterfaceClassActivity(label, !<span class="built_in">strcmp</span>(<span class="string">"active"</span>, state),</span><br><span class="line">	                                 timestamp, uid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此， Netd的介绍就结束了。 总的说来， Netd服务是Android网络管理的核心进程之一， 对于了解Android网络管理很有帮助， 看下其实现细节对于掌握网络相关的问题至关重要。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://linux-ip.net/html/index.html" target="_blank" rel="noopener">http://linux-ip.net/html/index.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Netfilter</a></li>
<li><a href="http://people.netfilter.org/pablo/docs/login.pdf" target="_blank" rel="noopener">netfilter connection tracking system</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> netd </tag>
            
            <tag> NetworkManagerService </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[正则表达式及其应用]]></title>
      <url>http://sniffer.site/2018/11/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>正则表达式(<em>regular expression</em>)是指一种操作字符串的搜索模式/模板(<code>Pattern Template</code>)，可用于文本的搜索、编辑等操作。如下是一个正则表达式：</p>
<pre><code>^[0-9]
</code></pre><p>其定义了一个搜索非数字字符的模式。正则表达式在如Shell(sed/gawk)/Python/Java等语言中都有广泛的应用.</p>
<h2 id="正则表达式规则"><a href="#正则表达式规则" class="headerlink" title="正则表达式规则"></a><strong>正则表达式规则</strong></h2><h3 id="字符匹配符"><a href="#字符匹配符" class="headerlink" title="字符匹配符"></a><strong>字符匹配符</strong></h3><p>下表是常用的字符匹配符：</p>
<blockquote>
<p><strong>表1 字符匹配符</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>匹配任意字符</td>
</tr>
<tr>
<td><code>^</code></td>
<td>一行的开始</td>
</tr>
<tr>
<td><code>$</code></td>
<td>是否一行的末尾</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>匹配在<code>[ch]</code>中的任意一个字符</td>
</tr>
<tr>
<td><code>()</code></td>
<td>从正则表达式匹配结果中产生子字符串, <code>ma(tri)?x</code>匹配<code>max</code>或者<code>matrix</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td><code>Oct (1st / 2nd)</code>匹配 <code>Oct 1st</code>或者<code>Oct 2nd</code></td>
</tr>
<tr>
<td><code>\</code></td>
<td>转义字符, 将特殊字符转义, 如<code>a\.b</code>匹配的是<code>a.b</code>而不是<code>ajb</code></td>
</tr>
<tr>
<td><code>^regex</code></td>
<td>在一行的开始出匹配regex</td>
</tr>
<tr>
<td><code>regex$</code></td>
<td>在一行的末尾匹配regex</td>
</tr>
<tr>
<td><code>[abc]</code></td>
<td>匹配字符a或b或c</td>
</tr>
<tr>
<td><code>[abc][vz]</code></td>
<td>匹配a/b/c后跟v/z的字符串</td>
</tr>
<tr>
<td><code>[^abc]</code></td>
<td>匹配除了a/b/c之外的任意字符</td>
</tr>
<tr>
<td><code>[a-d]</code></td>
<td>匹配a到d之间的字符</td>
</tr>
<tr>
<td><code>[0-8]</code></td>
<td>匹配0到8之间的数字</td>
</tr>
<tr>
<td><code>XZ</code></td>
<td>搜索 XZ</td>
</tr>
<tr>
<td><code>x/z</code></td>
<td>搜索 X 或者 Z</td>
</tr>
</tbody>
</table>
<blockquote>
<p>由于hexo排版的原因, 上表中<code>/</code>实际为 <code>|</code></p>
</blockquote>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a><strong>元字符</strong></h3><p>为了简化表达式规则，正则表达式提供了几种元字符(<em>meta characters</em>)：</p>
<blockquote>
<p><strong>表2 元字符</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\d</code></td>
<td>任意数字,<code>[0-9]</code>的简写</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>非数字匹配，<code>[^0-9]</code>的简写</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>空白字符，<code>[ \t\n\x0b\r\f]</code>的简写</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>非空白字符，<code>[^\s]</code>的简写</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>单词匹配符，<code>[a-zA-Z_0-9]</code>的简写</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>非单词匹配符，<code>[^\w]</code>的简写</td>
</tr>
<tr>
<td><code>\S+</code></td>
<td>多个非空白字符</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>单词<code>[a-zA-Z0-9_]</code>边界字符匹配</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车符</td>
</tr>
</tbody>
</table>
<h3 id="数量匹配符"><a href="#数量匹配符" class="headerlink" title="数量匹配符"></a><strong>数量匹配符</strong></h3><p>另外，正则表达式还提供了<em>数量匹配符</em>(<em>Quantifier</em>),用于标识一个元素出现的频次，主要有以下几种：</p>
<blockquote>
<p><strong>表3 数量匹配符</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>出现次数 &gt;= 0,等同<code>{0,}</code></td>
<td><code>x*</code> 查找零个或者多个字符x; <code>.*</code>匹配任意字符串</td>
</tr>
<tr>
<td><code>+</code></td>
<td>出现次数 &gt;= 1,等同 <code>{1,}</code></td>
<td><code>x+</code> 匹配出现次数大于1的字符x</td>
</tr>
<tr>
<td><code>?</code></td>
<td>出现次数不多于1次，等同<code>{0,1}</code></td>
<td><code>x?</code> 查找出现次数不大于1次的字符x</td>
</tr>
<tr>
<td><code>{n}</code></td>
<td>出现次数为 n</td>
<td><code>\d{3}</code> 搜索长度为3的数字字符串</td>
</tr>
<tr>
<td><code>{n1,n2}</code></td>
<td>出现次数在 n1 与 n2 之间</td>
<td><code>\d{1,4}</code> 数字字符长度在1 ~ 4之间的字符串</td>
</tr>
<tr>
<td><code>*?</code></td>
<td><code>?</code>放在一个数量匹配符的后面时，定义为一个“懒惰数量匹配符” (<em>reluctant/lazy quantifier</em>),该匹配符找到最小的一个匹配，然后搜索到第一个匹配字符时，即不再搜索</td>
<td><code>s.*?o</code> 匹配 <code>*stacko*verflow</code>, 而<code>s.*o</code>匹配的是<code>*stackoverflo*w</code></td>
</tr>
</tbody>
</table>
<h3 id="给定正则表达式的模式"><a href="#给定正则表达式的模式" class="headerlink" title="给定正则表达式的模式"></a><strong>给定正则表达式的模式</strong></h3><p>可以在一个正则表达式的开始给定一个模式修改符(<em>mode modifiers</em>):</p>
<ul>
<li><code>(?i)</code> 使正则表达式不区分大小写</li>
<li><code>(?s)</code> 单行模式,匹配包括换行符在内的所有字符(<em>makes the dot match all characters, including line breaks</em>)</li>
<li><code>(?m)</code> 多行模式(<em>makes the caret and dollar match at the start and end of each line in the subject string.</em>)</li>
</ul>
<blockquote>
<p>若需要指定多种模式，则将其组合在一起即可: <code>(?ism)</code></p>
</blockquote>
<h2 id="正则表达式的应用"><a href="#正则表达式的应用" class="headerlink" title="正则表达式的应用"></a><strong>正则表达式的应用</strong></h2><h3 id="在shell脚本中使用正则表达式"><a href="#在shell脚本中使用正则表达式" class="headerlink" title="在shell脚本中使用正则表达式"></a><strong>在shell脚本中使用正则表达式</strong></h3><p>在shell脚本命令<code>find</code>, <code>grep</code>中, 经常需要使用正则表达式来查找字符:</p>
<p>比如在ifconfig中查找ip地址:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ifconfig | grep -E "[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;"</span><br></pre></td></tr></table></figure>
<p>在tcpdump中过滤IP地址:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tcpdump | grep -E "[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;"</span><br></pre></td></tr></table></figure>
<p>在某个文件中查找所有单词:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat xxx.log | grep -E &quot;[a-zA-Z+]</span><br></pre></td></tr></table></figure>
<h3 id="在Java中使用正则表达式"><a href="#在Java中使用正则表达式" class="headerlink" title="在Java中使用正则表达式"></a><strong>在Java中使用正则表达式</strong></h3><p>Java中的 <code>String</code> 支持正则表达式来操作字符串，这给文本操作带来了很大的方便：</p>
<blockquote>
<p><strong>表4 String中的正则表达式方法</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>str.matches(&quot;regex&quot;)</code></td>
<td>判断字符串<code>str</code>是否与<code>regex</code>相匹配</td>
</tr>
<tr>
<td><code>str.split(&quot;regex&quot;)</code></td>
<td>通过<code>regex</code>分割字符串<code>str</code></td>
</tr>
<tr>
<td><code>str.replaceFirst(&quot;regex&quot;,&quot;replacement&quot;)</code></td>
<td>用<code>replacement</code>替换字符串中第一次出现 <code>regex</code>的字符串</td>
</tr>
<tr>
<td><code>str.replaceAll(&quot;regex&quot;,&quot;replacement&quot;)</code></td>
<td>用于<code>replacement</code>替换所有匹配<code>regex</code>的字符串</td>
</tr>
</tbody>
</table>
<p><strong>参考示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">package</span> de.vogella.regex.test;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexTestStrings</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXAMPLE_TEST = <span class="string">"This is my small example "</span></span><br><span class="line">    	+ <span class="string">"string which I'm going to "</span> + <span class="string">"use for pattern matching."</span>;</span><br><span class="line">  </span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  	System.out.println(EXAMPLE_TEST.matches(<span class="string">"\\w.*"</span>));</span><br><span class="line">  	String[] splitString = (EXAMPLE_TEST.split(<span class="string">"\\s+"</span>));</span><br><span class="line">System.out.println(splitString.length);<span class="comment">// should be 14</span></span><br><span class="line">   <span class="keyword">for</span> (String string : splitString) &#123;</span><br><span class="line">     System.out.println(string);</span><br><span class="line">   &#125;</span><br><span class="line">  	<span class="comment">// replace all whitespace with tabs</span></span><br><span class="line">  	System.out.println(EXAMPLE_TEST.replaceAll(<span class="string">"\\s+"</span>, <span class="string">"\t"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>: 在Java中斜杠<code>\</code>是一个转义字符，因此为了得到单个的斜杠字符，需要用<code>\\</code>来实现</p>
</blockquote>
<h3 id="Pattern-Matcher"><a href="#Pattern-Matcher" class="headerlink" title="Pattern/Matcher"></a><strong>Pattern/Matcher</strong></h3><p>对于更高级的应用，Java提供了两个类<strong>Pattern</strong>(<em>java.util.regex.Pattern</em>) 和 <strong>Matcher</strong> (<em>java.util.regex.Matcher</em>): </p>
<ol>
<li>首先，使用 <strong>Pattern</strong> 得到对应的正则表达式；</li>
<li>然后，利用 <strong>Matcher</strong> 来操作相应的字符串</li>
</ol>
<p><strong>参考示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegularExpression</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String regx = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> Pattern pattern = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> Matcher matcher = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;		</span><br><span class="line">		<span class="comment">// regular expression test</span></span><br><span class="line">		String input =  <span class="keyword">new</span> String(<span class="string">"here 2016, now we encounter very confusing things. On the one hand, we human beings feel "</span></span><br><span class="line">				+ <span class="string">"very confident, but on the other hand, we are so fucking lost in our self-built world! we do waste our energy"</span></span><br><span class="line">				+ <span class="string">"and time  on useless things. We are totally lost."</span>);</span><br><span class="line">		</span><br><span class="line">		String regDigit = <span class="keyword">new</span> String(<span class="string">"\\d"</span>);</span><br><span class="line">		String regChars = <span class="keyword">new</span> String(<span class="string">"hand|useless"</span>);</span><br><span class="line">		String regWild = <span class="keyword">new</span> String(<span class="string">"[^af]"</span>);</span><br><span class="line">		String regWord = <span class="keyword">new</span> String(<span class="string">"\\w"</span>);</span><br><span class="line">		String regTimes = <span class="keyword">new</span> String(<span class="string">"[a-z]&#123;5&#125;"</span>);</span><br><span class="line">		</span><br><span class="line">		RegularExpression reg = <span class="keyword">new</span> RegularExpression(regDigit);</span><br><span class="line">		reg.getMatcherResult(input);</span><br><span class="line">		</span><br><span class="line">		reg.setRegx(regChars);</span><br><span class="line">		reg.getMatcherResult(input);</span><br><span class="line">		</span><br><span class="line">		reg.setRegx(regWild);</span><br><span class="line">		reg.getMatcherResult(input);</span><br><span class="line">		</span><br><span class="line">		reg.setRegx(regWord);</span><br><span class="line">		reg.getMatcherResult(input);</span><br><span class="line">		</span><br><span class="line">		reg.setRegx(regTimes);</span><br><span class="line">		reg.getMatcherResult(input);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RegularExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RegularExpression</span><span class="params">(String reg)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.regx = reg;</span><br><span class="line">		<span class="keyword">this</span>.pattern = Pattern.compile(regx);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMatcherResult</span><span class="params">(String in)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"current regression expression is "</span> + regx);</span><br><span class="line">		<span class="keyword">this</span>.matcher = pattern.matcher(in);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">			System.out.println(matcher.group());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegx</span><span class="params">(String regx)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.regx = regx;</span><br><span class="line">		<span class="keyword">this</span>.pattern = Pattern.compile(regx);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式注意事项"><a href="#正则表达式注意事项" class="headerlink" title="正则表达式注意事项"></a>正则表达式注意事项</h2><ul>
<li>正则表达式区分大小写</li>
<li>正则表达式模式会匹配数据流中文本的任何位置, 因此要注意模式的开头与结尾</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><strong>参考文章</strong></h2><ul>
<li><a href="http://www.vogella.com/tutorials/JavaRegularExpressions/article.html" target="_blank" rel="noopener">http://www.vogella.com/tutorials/JavaRegularExpressions/article.html</a></li>
<li><a href="http://www.ntu.edu.sg/home/ehchua/programming/howto/regexe.html" target="_blank" rel="noopener">http://www.ntu.edu.sg/home/ehchua/programming/howto/regexe.html</a></li>
<li><a href="https://www.regular-expressions.info/repeat.html" target="_blank" rel="noopener">https://www.regular-expressions.info/repeat.html</a></li>
<li><a href="https://www.gnu.org/software/gawk/manual/gawk.html" target="_blank" rel="noopener">GAWK manual</a></li>
<li><a href="https://www.gnu.org/software/sed/manual/sed.html" target="_blank" rel="noopener">Sed manual</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Regular Expression </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 正则表达式 </tag>
            
            <tag> Regular Expression </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[socket编程与IO multiplexing]]></title>
      <url>http://sniffer.site/2018/07/21/socket%E7%BC%96%E7%A8%8B%E4%B8%8EIO%E5%A4%8D%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>socket通常用于跨进程通信(Inter-Process Communication,IPC)，由于其最早BSD Unix发行版中使用，因此也叫做<a href="https://en.wikipedia.org/wiki/Berkeley_sockets" target="_blank" rel="noopener">Barkeley sockets</a>。socket封装了底层网络通信协议细节，为上层应用提供了一个统一的接口，按照使用的“域”不同，又分为用于网络通信的internet socket以及用于本地进程通信的Unix domain socket<a id="more"></a>。</p>
<p>那么，如何利用socket实现IPC通信了？在多个客户端的情况下，服务端要如何实现同时响应多个客户请求了，即如何实现多个IO端口的监听(I/O multiplex)？这篇文章，就来看看这两个问题。首先，来看下socket编程的一些基本知识。</p>
<h2 id="socket编程基础"><a href="#socket编程基础" class="headerlink" title="socket编程基础"></a><strong>socket编程基础</strong></h2><p>一个socket由三个元素唯一确定：</p>
<ul>
<li>internet地址(如果是Unix domain socket,则对应一个本地文件名)</li>
<li>端到端的协议类型(面向连接的TCP或者无连接的UDP）</li>
<li>用于确定传送数据应用的端口号（port）</li>
</ul>
<p>在使用socket前，首先需要通过系统调用<code>socket</code>创建一个socket对象，并返回该socket对应的文件描述符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建一个socket需要指定三个参数:</p>
<ul>
<li>通信域，确定协议族，比如<code>AF_UNIX/AF_LOCAL</code>用于本地通信；<code>AF_INET/AF_INET6</code>基于TCP/IP协议族，用于网络通信;<code>AF_NETLINK</code>用于进程与内核通信；<code>AF_APPLETALK</code>用于AppleTalk通信</li>
<li>socket类型：<code>SOCK_STREAM</code>提供了序列化、可靠、全双工的字节流通信；<code>SOCK_DGRAM</code>提供了无连接、不可靠的数据报文通信</li>
<li>协议：指定使用的协议类型，比如是TCP（<code>IPPROTO_TCP</code>)还是UDP(<code>IPPROTO_UDP</code>)，其在<code>sys/un.h</code>中定义；</li>
</ul>
<p>| 有关socket参数的具体说明，可参考<a href="http://www.man7.org/linux/man-pages/man2/socket.2.html" target="_blank" rel="noopener">http://www.man7.org/linux/man-pages/man2/socket.2.html</a></p>
<p>下图是一个基于TCP协议的socket通信流程图(包括握手与挥手流程，这里只说明三次握手流程）：</p>
<ul>
<li>对于客户端与服务端进程，都需要通过<code>socket(int, int, int)</code>来创建一个socket，得到一个socket文件描述符用于后续的通信；</li>
<li>在服务端，首先要将创建的socket文件描述符与本的某个地址进行绑定，并监听该地址对应的文件，并通过<code>accept</code>接口准备接受来自客户端的通信请求；</li>
<li>在客户端，通过调用<code>connect</code>尝试与服务端建立通信链路，在此过程中，客户端与服务端会进行三次握手来建立一个连接；</li>
<li>至此，一个全双工的通信链接就建立完成了，客户端与服务端都可以同时向对方发送数据了</li>
</ul>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/socketflow.png" alt="SocketFlow"></p>
<p>按照上述流程，来看看一个client/server的socket通信示例: 客户端不断发送消息给服务端，服务端接受到消息后，原封不动的将其发送给客户端</p>
<ul>
<li>客户端代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">char</span>* SERVER_ADDR = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_BUF_SIZE = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> socket_fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage: %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">	<span class="comment">/** 1. create a TCP based socket */</span></span><br><span class="line">    socket_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"cannot create socket"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">	<span class="comment">/** 2. set network address of the server */</span></span><br><span class="line">    sa.sin_family = AF_INET; <span class="comment">/* address familiy*/</span></span><br><span class="line">    sa.sin_port = htons(atoi(argv[<span class="number">1</span>])); <span class="comment">/* address port */</span></span><br><span class="line">    sa.sin_addr.s_addr = inet_addr(SERVER_ADDR); <span class="comment">/* internet address */</span></span><br><span class="line">	<span class="comment">/** 3. try to connect server */</span></span><br><span class="line">    <span class="keyword">if</span> (connect(socket_fd, (struct sockaddr*) &amp;sa, <span class="keyword">sizeof</span>(sa)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"connect failure"</span>);</span><br><span class="line">		close(socket_fd);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Client: server is connected\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[MAX_BUF_SIZE]; </span><br><span class="line">    <span class="comment">/* keep sending message to server */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		fgets(buf, MAX_BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, <span class="string">"quit"</span>, <span class="number">4</span>) == <span class="number">0</span> || <span class="built_in">strncmp</span>(buf, <span class="string">"q"</span>, <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"quit\n"</span>);</span><br><span class="line">			write(socket_fd, <span class="string">"quit"</span>, <span class="number">4</span>);</span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Client: %s\n"</span>, buf);</span><br><span class="line">			<span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">			<span class="keyword">if</span> (send(socket_fd, buf, len, <span class="number">0</span>) != len) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"client: send message error\n"</span>);</span><br><span class="line">				<span class="keyword">break</span>; </span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">memset</span>(buf, <span class="number">0</span>, MAX_BUF_SIZE);</span><br><span class="line">			<span class="keyword">if</span> (recv(socket_fd, buf, MAX_BUF_SIZE, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"fail to receive message from server\n"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Server:%s"</span>, buf);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(socket_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>服务端代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> SERVER_PORT = <span class="number">2100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PENDING = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_RCV_BUF = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buf[MAX_RCV_BUF];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> socket_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((socket_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fail to create socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sa.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">/** htonl/htons 将host字节序转为network字节序 */</span></span><br><span class="line">    sa.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">/* INADDR_ANY表示该端口可接受任何入境消息 */</span></span><br><span class="line">    sa.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将socket与地址进行绑定*/</span></span><br><span class="line">    <span class="keyword">if</span> (bind(socket_fd, (struct sockaddr*) &amp;sa, <span class="keyword">sizeof</span>(sa)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fail to bind socket address\n"</span>);   </span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 监听socket */</span></span><br><span class="line">    <span class="keyword">if</span> (listen(socket_fd, MAX_PENDING) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fail to listen port\n"</span>);  </span><br><span class="line">        <span class="keyword">goto</span> errout; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"server is started\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; ;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* accept any requests from clients */</span></span><br><span class="line">        <span class="keyword">int</span> connect_fd = accept(socket_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (connect_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"fail to accept"</span>);</span><br><span class="line">            <span class="keyword">goto</span> errout;      </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* keep receving message from client */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(connect_fd, buf, MAX_RCV_BUF) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"fail to read"</span>);  </span><br><span class="line">                <span class="keyword">break</span>;         </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf)] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Client: %s\n"</span>, buf);</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (write(connect_fd, buf, <span class="built_in">strlen</span>(buf)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"fail to send to client\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf, <span class="string">"quit"</span>, <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"talk is done*_*\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(connect_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">errout:</span><br><span class="line">    close(socket_fd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在服务端，如果等待请求队列中有client的请求，则<code>accept</code>返回一个新的fd用于数据的读写；如果没有，则阻塞当前进程直到有客户请求为止。因此，上述服务端是无法同时响应多个客户请求的。如果服务端需要同时响应多个客户请求，不阻塞当前进程，则需要使用<code>select</code>或者<code>poll/epoll</code>来监听socket，如果有客户请求，kernel会及时通知用户进程；对每个客户请求，服务端可通过启动新的进程与线程来处理。作为演示，这里使用下面的方法来解决进程阻塞以及多个客户请求的问题：</p>
<ul>
<li>服务端进程同时监听多个端口，客户端可通过不同的端口向服务端发送数据</li>
<li>分别使用<code>select</code>或者<code>poll/epoll</code>来监听这些端口，对于每个请求都启动一个新的线程进行处理</li>
</ul>
<h2 id="IO复用：服务端如何同时处理多个客户请求"><a href="#IO复用：服务端如何同时处理多个客户请求" class="headerlink" title="IO复用：服务端如何同时处理多个客户请求"></a>IO复用：服务端如何同时处理多个客户请求</h2><p>目前在Linux下，常见的IO复用(I/O multiplexing)方式有:</p>
<ul>
<li><code>select</code>: 可监听的文件描述符(fd)最大不超过1024(由<code>_SC_OPEN_MAX</code>确定）；</li>
<li><code>poll</code>:对监听的fd个数没有限制，但是随着fd数目的增加，性能也会随着下降，因为每次收到有可用fd事件时，poll都需要遍历整个监听集合；</li>
<li><code>epoll</code>: 对监听的fd个数无限制，不同与poll的地方时，epoll监听返回的是一个可用fd的集合，而不是整个监听fd的集合，因此效率上比poll更高；</li>
</ul>
<p>接下来，就具体看看这种IO复用方式如何处理服务端的请求。</p>
<p>为了监听多个端口，需要在服务端进程启动时，创建多个socket:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Usage %s &lt;port_1&gt; &lt;port_2&gt; ... \n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* io multiplex */</span></span><br><span class="line">    fd_set sockset;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    <span class="comment">/* is server running */</span></span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* max file descriptors of socket */</span></span><br><span class="line">    <span class="keyword">int</span> maxFd = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">int</span>* serverSock;</span><br><span class="line">    <span class="keyword">int</span> portNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    serverSock = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((argc - <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> port = atoi(argv[i]);</span><br><span class="line">		serverSock[portNum++] = createServerSocket(port);</span><br><span class="line">		maxFd = serverSock[portNum<span class="number">-1</span>] &gt; maxFd ? serverSock[portNum<span class="number">-1</span>] : maxFd;</span><br><span class="line">    &#125;</span><br><span class="line">   ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，利用<code>select</code>或者<code>poll</code>或者<code>epoll</code>来实现上述端口的监听：</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a><strong><code>select</code></strong></h3><p>使用<code>select</code>需要做以下几个事情：</p>
<ul>
<li>创建一个fd集合: <code>fd_set sockset;</code></li>
<li>每次使用前都需要将其清空:<code>FD_ZERO(&amp;sockset);</code></li>
<li>将所要监听的fd保存到<code>sockset</code>中: <code>FD_SET(serverSock[p], &amp;sockset);</code></li>
<li>设置监听的超时时间，监听对应的fd集合：<code>select(maxFd + 1, &amp;sockset, NULL, NULL, &amp;timeout)</code>,如果该调用返回-1则意味着超时，否则表示有新的IO事件了，可通过<code>FD_ISSET(serverSock[p], &amp;sockset)</code>来检查对应的fd是否处于可读写的状态</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span>(running) &#123;</span><br><span class="line">	<span class="comment">/* this must be reset for every time select() is called */</span></span><br><span class="line">	FD_ZERO(&amp;sockset);</span><br><span class="line">	FD_SET(STDIN_FILENO, &amp;sockset);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; portNum; ++p) &#123;</span><br><span class="line">	    FD_SET(serverSock[p], &amp;sockset);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* timeout for select IO */</span></span><br><span class="line">	<span class="comment">/* must be called every time select() is called */</span></span><br><span class="line">	timeout.tv_sec = DEFAULT_TIMEOUT;</span><br><span class="line">	timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (select(maxFd + <span class="number">1</span>, &amp;sockset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"fail to get ready fd for %d seconds, waiting...again"</span>, DEFAULT_TIMEOUT);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;sockset)) &#123;</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"server is gonna to shut down\n"</span>);</span><br><span class="line">	        running = <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; portNum; ++p) &#123;</span><br><span class="line">	        <span class="keyword">if</span> (FD_ISSET(serverSock[p], &amp;sockset)) &#123;</span><br><span class="line">	            <span class="keyword">pthread_t</span> tid;</span><br><span class="line">	            <span class="keyword">int</span> clientFd = acceptConnection(serverSock[p]);</span><br><span class="line">	            <span class="comment">/* create pthread to handle client request */</span></span><br><span class="line">	            pthread_create(&amp;tid, <span class="literal">NULL</span>, (<span class="keyword">void</span>*)handleRequest, (<span class="keyword">void</span>*)&amp;clientFd);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>| select linux man page: <a href="http://man7.org/linux/man-pages/man2/select.2.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man2/select.2.html</a></p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a><strong><code>poll</code></strong></h3><p>poll有一个专门的数据结构<code>pollfd</code>来记录监听的fd: 其由三部分组成，一个是监听的fd，一个是需要监听的事件，比如<code>POLLIN/POLLPRI</code>；一个监听返回的事件，比如‵POLLOUT/POLLERR/POLLHUP`，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">	<span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">	<span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>利用poll来监听多个IO事件，需要：</p>
<ul>
<li>创建一个<code>pollfd</code>数组用于保存监听的fd集合: <code>struct pollfd pollFds[MAX_PORTS];</code></li>
<li><p>将需要监听的fd添加到该集合:</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">pollFds[i].fd = createServerSocket(atoi(argv[i]));</span><br><span class="line">pollFds[i].events = POLLIN;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定超时时间，监听fd集合: <code>int ready = poll(pollFds, maxFds, MAX_POLL_TIMEOUT);</code>, 如果返回小于0的值，则表示出现了错误；如果返回值为0，则表示超时，返回一个大于0的值，表示当前可用的fd的个数</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (running) &#123;</span><br><span class="line">    <span class="keyword">int</span> ready = poll(pollFds, maxFds, MAX_POLL_TIMEOUT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ready &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fail to poll"</span>);</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ready == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//printf("timeout\n");</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, MAX_BUF_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxFds; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pollFds[i].fd &gt; <span class="number">0</span> &amp;&amp; (pollFds[i].events &amp; POLLIN)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pollFds[i].fd == STDIN_FILENO) &#123;</span><br><span class="line">                    <span class="comment">// read from stdin stream</span></span><br><span class="line">                    <span class="keyword">if</span> (fgets(buf, MAX_BUF_SIZE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        perror(<span class="string">"fail to read stdin"</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">                    <span class="keyword">if</span> (send(pollFds[i].fd, buf, len , <span class="number">0</span>) != len) &#123;</span><br><span class="line">                        perror(<span class="string">"fail to send data"</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> fd = acceptConnection(pollFds[i].fd);</span><br><span class="line">                    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        perror(<span class="string">"fail to accept connection"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">                        <span class="keyword">if</span> (pthread_create(&amp;tid, <span class="literal">NULL</span>, handleRequst, (<span class="keyword">void</span>*)&amp;fd) != <span class="number">0</span>) &#123;</span><br><span class="line">                            perror(<span class="string">"fail to create handle thread"</span>);</span><br><span class="line">                            close(fd);</span><br><span class="line">                            <span class="keyword">goto</span> errout;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>| poll man page： <a href="http://man7.org/linux/man-pages/man2/poll.2.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man2/poll.2.html</a></p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><strong><code>epoll</code></strong></h3><p>epoll使用一个数据结构<code>epoll_event</code>来描述所监听的fd集合:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">            <span class="keyword">void</span>    *ptr;</span><br><span class="line">            <span class="keyword">int</span>      fd;</span><br><span class="line">            <span class="keyword">uint32_t</span> u32;</span><br><span class="line">            <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        &#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">            <span class="keyword">uint32_t</span>     events;    <span class="comment">/* Epoll events */</span></span><br><span class="line">            <span class="keyword">epoll_data_t</span> data;      <span class="comment">/* User data variable */</span></span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>这里的<code>events</code>表示所发生的事件类型，有<code>EPOLLIN/EPOLLOUT/EPOLLHUP</code>，这里的取值跟poll中的事件基本一致。使用epoll的步骤:</p>
<ul>
<li>声明两个epoll_event集合,一个用于监听，一个用于监听返回: <code>struct epoll_event polledEv[MAX_PORTS], readyEv[MAX_PORTS];</code></li>
<li>在kernel创建一个epoll的fd: <code>int epollFd = epoll_create1(0);</code></li>
<li>将需要监听的fd保存到epoll_event中：<code>epoll_ctl(epollFd, EPOLL_CTL_ADD, sockFd, &amp;polledEv[i])</code></li>
<li>等待可用的集合: <code>int ready = epoll_wait(epollFd, readyEv, MAX_PORTS, 5);</code>， 返回小于零表示出现错误；返回0表示超时；返回大于0，表示当前有多少个可用的文件描述符。相应的集合保存到<code>readyEv</code>中，因此只需要遍历这个子集即可得到对应可用的fd</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">polledEv</span>[<span class="title">MAX_PORTS</span>], <span class="title">readyEv</span>[<span class="title">MAX_PORTS</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">polledEv[i].data.fd = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> epollFd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (epollFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">"fail to create epoll for stdin"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  polledEv[<span class="number">0</span>].data.fd = STDIN_FILENO;</span><br><span class="line">  polledEv[<span class="number">0</span>].events = EPOLLIN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (epoll_ctl(epollFd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;polledEv[<span class="number">0</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">"epoll_ctl: stdin"</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> sockFd = createServerSocket(atoi(argv[i]));</span><br><span class="line"><span class="keyword">if</span> (sockFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"fail to create socket"</span>);</span><br><span class="line">	<span class="keyword">continue</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">polledEv[i].data.fd = sockFd;</span><br><span class="line">polledEv[i].events = EPOLLIN;</span><br><span class="line"><span class="keyword">if</span> (epoll_ctl(epollFd, EPOLL_CTL_ADD, sockFd, &amp;polledEv[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"epoll_ctl"</span>);</span><br><span class="line">	close(sockFd);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line"><span class="keyword">int</span> ready = epoll_wait(epollFd, readyEv, MAX_PORTS, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (ready &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"epoll_wait:"</span>);</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ready == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//printf("timeout\n")</span></span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ready; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> fd = acceptConnecton(readyEv[i].data.fd);</span><br><span class="line">		<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			perror(<span class="string">"fail to accept request"</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">pthread_t</span> tid;</span><br><span class="line">		<span class="keyword">if</span> (pthread_create(&amp;tid, <span class="literal">NULL</span>, handleRequest, (<span class="keyword">void</span>*)&amp;fd) != <span class="number">0</span>) &#123;</span><br><span class="line">			perror(<span class="string">"fail to create handle thread"</span>);</span><br><span class="line">			close(fd);</span><br><span class="line">			<span class="keyword">goto</span> errout;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>| epoll man page: <a href="http://man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man7/epoll.7.html</a></p>
<p>最后，对于每个客户请求，都创建一个新的线程来处理请求：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = *((<span class="keyword">int</span>*)args);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"handleRequest(): from fd=%d\n"</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[MAX_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (recv(fd, buf, MAX_BUF_SIZE, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"fail to receive message from client\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Client(%d): %s\n"</span>, fd, buf);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">		buf[len] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (send(fd, buf, len, <span class="number">0</span>) != len) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"fail to echo"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里分别采用<code>select</code>，<code>poll</code>以及<code>epoll</code>在服务端监听客户IO事件，只是作为演示学习用，实际服务器端使用的是更为复杂的IO复用模型，更多相关的资料可参考C10K: <a href="http://www.kegel.com/c10k.html。" target="_blank" rel="noopener">http://www.kegel.com/c10k.html。</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_71/rzab6/howdosockets.htm" target="_blank" rel="noopener">https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_71/rzab6/howdosockets.htm</a></li>
<li><a href="http://beej.us/guide/bgipc/html/multi/index.html" target="_blank" rel="noopener">http://beej.us/guide/bgipc/html/multi/index.html</a></li>
<li><a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">http://www.kegel.com/c10k.html</a></li>
<li><a href="https://lwn.net/Articles/13918/" target="_blank" rel="noopener">LWN email list: epoll as a system call</a></li>
<li><a href="https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html" target="_blank" rel="noopener">https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html</a></li>
<li><a href="https://lwn.net/Articles/14168/" target="_blank" rel="noopener">https://lwn.net/Articles/14168/</a></li>
<li><a href="https://www.programering.com/a/MzN4IDMwATM.html" target="_blank" rel="noopener">https://www.programering.com/a/MzN4IDMwATM.html</a></li>
<li><a href="https://notes.shichao.io/unp/ch6/" target="_blank" rel="noopener">https://notes.shichao.io/unp/ch6/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> socket programming </tag>
            
            <tag> I/O multiplexing </tag>
            
            <tag> network programming </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于技术发展的一些思考]]></title>
      <url>http://sniffer.site/2018/06/22/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>社会或法律就是这样或者应当这样起源的。它们给弱者新的桎梏， 给富人以新的力量。</p>
<p>   卢梭</p>
</blockquote>
<p>最近一年，在智能终端出现的第十一个年头，有关5G/物联网/车联网，人工智能/深度学习方面的消息层出不穷，一场新的技术变革正在悄然来临，人们的生活方式与思维方式也如智能终端出现时那样注定要被深刻的被影响与改变。<a id="more"></a></p>
<p>在Android终端做了将近四年的开发，对移动通信行业有了一定的了解。从2G到3G再到4G(<a href="https://en.wikipedia.org/wiki/LTE_(telecommunication" target="_blank" rel="noopener">LTE</a>))，移动通信技术正在加速变化。未来，随着<a href="https://en.wikipedia.org/wiki/5G" target="_blank" rel="noopener">5G</a>的大规模商用，传统的CS(<a href="http://sniffer.site/2017/11/20/Circuit-Switching-Packet-Switching/">Circuit Switching</a>)网络业务终将告别历史舞台，我们所熟知的2G/3G网络将不可避免的被抛弃，而终端所有的通讯应用，无论是打电话，发短信等传统业务，还是像IMS/VOLTE等视频业务都会统一到一个通信方式上来:PS(<a href="http://sniffer.site/2017/11/20/Circuit-Switching-Packet-Switching/">Packet Switching</a>)。LTE（4G)与5G本质上都只有PS一种数据传输模式了，但LTE为了支持CS语音通话，还会支持CSFB，SRVCC以实现LTE网络与CS网络的平滑过渡。那么，为何5G能够带来如此多的话题与想象了?4G与5G又有那些根本上的差异？相比LTE网络，5G速度更快（峰值速度可达100Mbit/s),延时更小（数据建立过程只需1ms左右），单位面积可接入的设备密度更高(每平方公里可达10<sup>6</sup>接入设备), 移动性更强（移动速度最高可到500km/h仍然可以保证通信质量）。</p>
<p>具体来说, 5G提供了比4G更丰富的应用场景:</p>
<ul>
<li>eMBB(enhanced Mobile Broadband): 提供更快速的连接, 更高的吞吐量, 更大的容量. 适用于大量用户集中的场景, 比如大型活动场所(体育馆/演唱会等)</li>
<li>URLLC(Ultra Reliable Low Latency Communications): 提供低于10ms延迟的链接, 适用于需要低延迟的场景, 如自动驾驶</li>
<li>mMTC(Massive Machine-Type Communications): 大规模低功耗设备的互联, 适用于大量IoT设备的相互通讯</li>
</ul>
<p>5G的到来，让智能终端与设备链接有了更多的想象空间：</p>
<ul>
<li>物联网（Internet of Things): 有了5G ， 万物皆可连接网络，成为产生数据的节点，也有了消费数据的能力；</li>
<li>智能家居成为每个家庭的标配，让人们的生活更加方便舒适；</li>
<li>车联网(Internet of Vehicle): 汽车不再仅仅是一个出行工具，还是网络的一部分，为人们的出行做出优化，为用户带来更多的便捷；借助自动驾驶，长途自驾出行不再是件痛苦的事情；</li>
<li>在高铁上，不用担心没有网络了，5G网络在终端高速移动的情况下仍然可以保持良好的服务与体验；</li>
<li>工业生产设备也可以通过5G网络连接上网络，把采集到的数据采集到数据中心节点上，为工业生产流程优化提供决策支持；</li>
</ul>
<p>无论是芯片厂商还是网络设备厂商，都对5G的商用做了诸多的畅想：</p>
<ul>
<li><a href="https://www.ericsson.com/en/5g" target="_blank" rel="noopener">Ericsson</a> </li>
<li><a href="https://www.qualcomm.com/invention/5g" target="_blank" rel="noopener">Qualcomm</a> </li>
<li><a href="http://www.huawei.com/minisite/5g/en/" target="_blank" rel="noopener">Huawei</a> </li>
</ul>
<p>大量的设备链接意味着产生的数据量也会成倍的增加。有了海量的数据我们可以做些什么了？通过数据，个人与企业都可以对自己的决策做出更多的优化。个人可以通过追踪身体指标来把握自己的身体健康状态，保持自己与家庭设备时刻连接的状态；互联网企业通过深度学习与大规模数据的挖掘来发掘用户行为，为企业决策提供更多支持；工业企业通过大数据可以控制与优化生产流程，提升效益，创造更多的价值。未来，无疑是一个数据流与信息流的社会。人们的生活依赖于数据的支撑，也离不开数据。</p>
<p>对于大部分个人与中小企业而言，数据的存放与挖掘都需要依赖于大企业提供服务。很多的基础功能与服务都可以通过<a href="https://en.wikipedia.org/wiki/Cloud_computing" target="_blank" rel="noopener">云计算</a> 来实现。今天，人们已经可以通过云端来部署诸如数据存储，网页托管，内容分发以及视频直播，未来，很多常见的智能设备所拥有的功能都可能通过云化来实现；人们不再需要一个“笨重”的移动设备，而是一个很“轻”的终端，这个终端只是一个服务的入口，所有的应用甚至操作系统都放在云端，核心的计算与功能都通过云端来实现，人们实际操作的是一个虚拟的云端设备。这有点类似于今天的浏览器，人们通过浏览器可以得到各种各样的服务，而无须安装其他的应用软件。云无处不在，成为像水、电一样的基础设施服务。</p>
<p>可以想见，在不远的未来，5G与物联网， 云，大数据以及人工智能将成为科技发展的引擎，在更深程度的影响与改变人类的生活与思维方式。</p>
]]></content>
      
        <categories>
            
            <category> 思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 5G </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HAL binder工作流程-以RILJ/RILD通信为例]]></title>
      <url>http://sniffer.site/2018/06/17/HAL-binder%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-%E4%BB%A5RILJ-RILD%E9%80%9A%E4%BF%A1%E4%B8%BA%E4%BE%8B/</url>
      <content type="html"><![CDATA[<p><code>Telephony</code>(RIL Java,以下简称RILJ）与RILD(RIL Daemon)的通信在Android OO8.0以前都是基于socket通信，而Android 8.0则是基于HAL binder进行IPC的数据交换。有关RILJ与RILD的工作原理可以参考之前的两篇文章：<a href="http://sniffer.site/2016/11/19/Android-RIL%E6%A6%82%E8%BF%B0/">Android RIL概述</a>以及<a href="http://sniffer.site/2016/11/29/Android-RILD%E8%AF%A6%E8%A7%A3/" title="RILD详解">RILD详解</a>。这篇文章主要分析RILJ与RILD是如何通过HAL Binder进行通信。</p>
<p>RILJ与RILD的通信，服务端是<code>RILD</code>,客户端是<code>RILJ</code>。对于RILD而言，其对应的HAL接口是<code>/android/hardware/interfaces/radio/1.0/IRadio.hal</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This interface is used by telephony &amp; telecom to talk to cellular radio.</span></span><br><span class="line"><span class="comment"> * All the functions have minimum one parameter:</span></span><br><span class="line"><span class="comment"> * serial: which corresponds to serial no. of request. Serial numbers must only be memorized for the</span></span><br><span class="line"><span class="comment"> * duration of a method call. If clients provide colliding serials (including passing the same</span></span><br><span class="line"><span class="comment"> * serial to different methods), multiple responses (one for each method call) must still be served.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">interface IRadio &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set response functions for radio requests &amp; radio indications.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param radioResponse Object containing response functions</span></span><br><span class="line"><span class="comment">     * @param radioIndication Object containing radio indications</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    setResponseFunctions(IRadioResponse radioResponse,</span><br><span class="line">            IRadioIndication radioIndication);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Requests status of the ICC card</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param serial Serial number of request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Response function is IRadioResponse.getIccCardStatusResponse()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">oneway <span class="title">getIccCardStatus</span><span class="params">(<span class="keyword">int32_t</span> serial)</span></span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而RILJ对应的回调接口有两个：<code>/android/hardware/interfaces/radio/1.0/IRadioResponse.hal</code>(RILJ发送给RILD的请求响应）; <code>/android/hardware/interfaces/radio/1.0/IRadioIndication.hal</code>（RILD主动上班的事件）：</p>
<ul>
<li><code>IRadioResponse.hal</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface declaring response functions to solicited radio requests.</span></span><br><span class="line"><span class="comment"> * Response functions defined in this interface are as per following convention:</span></span><br><span class="line"><span class="comment"> * &lt;xyz&gt;Response is response to IRadio.&lt;xyz&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">interface IRadioResponse &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param info Response info struct containing response type, serial no. and error</span></span><br><span class="line"><span class="comment">     * @param cardStatus ICC card status as defined by CardStatus in types.hal</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Valid errors returned:</span></span><br><span class="line"><span class="comment">     *   RadioError:NONE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">oneway <span class="title">getIccCardStatusResponse</span><span class="params">(RadioResponseInfo info, CardStatus cardStatus)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param info Response info struct containing response type, serial no. and error</span></span><br><span class="line"><span class="comment">     * @param remainingRetries Number of retries remaining, must be equal to -1 if unknown.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Valid errors returned:</span></span><br><span class="line"><span class="comment">     *   RadioError:NONE</span></span><br><span class="line"><span class="comment">     *   RadioError:RADIO_NOT_AVAILABLE (radio resetting)</span></span><br><span class="line"><span class="comment">     *   RadioError:PASSWORD_INCORRECT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">oneway <span class="title">supplyIccPinForAppResponse</span><span class="params">(RadioResponseInfo info, <span class="keyword">int32_t</span> remainingRetries)</span></span>;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>IRadioIndication.hal</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface declaring unsolicited radio indications.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">interface IRadioIndication &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates when radio state changes.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param type Type of radio indication</span></span><br><span class="line"><span class="comment">     * @param radioState Current radio state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">oneway <span class="title">radioStateChanged</span><span class="params">(RadioIndicationType type, RadioState radioState)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates when call state has changed.</span></span><br><span class="line"><span class="comment">     * Callee must invoke IRadio.getCurrentCalls()</span></span><br><span class="line"><span class="comment">     * Must be invoked on, for example,</span></span><br><span class="line"><span class="comment">     * "RING", "BUSY", "NO CARRIER", and also call state</span></span><br><span class="line"><span class="comment">     * transitions (DIALING-&gt;ALERTING ALERTING-&gt;ACTIVE)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Redundent or extraneous invocations are tolerated</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param type Type of radio indication</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">oneway <span class="title">callStateChanged</span><span class="params">(RadioIndicationType type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates when voice or data network state changed</span></span><br><span class="line"><span class="comment">     * Callee must invoke IRadio.getVoiceRegistrationState(), IRadio.getDataRegistrationState(),</span></span><br><span class="line"><span class="comment">     * and IRadio.getOperator()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param type Type of radio indication</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">oneway <span class="title">networkStateChanged</span><span class="params">(RadioIndicationType type)</span></span>;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RILJ与RILD的通信大致要经历三个步骤：</p>
<ul>
<li>RILD启动后，向<code>HwServiceManager</code>注册服务<code>slot1</code>(第二个RILD对应<code>slot2</code>);</li>
<li>RILJ启动后，从<code>HwServiceManager</code>获取RILD服务，并且注册两个回调函数: <code>IRadioRepsone.java</code>以及<code>IRadioIndication.java</code>分别用于接收来自RILD的消息；</li>
<li>RILD收到来自RILJ的回调注册后，注册一个RILJ的死亡通知对象，并且发送消息告知RILJ链接建立成功。</li>
</ul>
<h2 id="注册RILD服务"><a href="#注册RILD服务" class="headerlink" title="注册RILD服务"></a><strong>注册RILD服务</strong></h2><p>在RILD启动后，加载完vendor RIL之后，vendor RIL注册一个回调函数<code>RIL_RadioFunctions</code>:</p>
<blockquote>
<p> 关于RILD的详细介绍可以参考</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ril_service.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">void</span></span><br><span class="line">RIL_register (<span class="keyword">const</span> RIL_RadioFunctions *callbacks) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">    RLOGI(<span class="string">"SIM_COUNT: %d"</span>, SIM_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callbacks == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        RLOGE(<span class="string">"RIL_register: RIL_RadioFunctions * null"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RLOGE(<span class="string">"RIL_register: RIL version %d"</span>, callbacks-&gt;version);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s_registerCalled &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        RLOGE(<span class="string">"RIL_register has been called more than once. "</span></span><br><span class="line">                <span class="string">"Subsequent call ignored"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;s_callbacks, callbacks, <span class="keyword">sizeof</span> (RIL_RadioFunctions));</span><br><span class="line"></span><br><span class="line">    s_registerCalled = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    RLOGI(<span class="string">"s_registerCalled flag set, %d"</span>, s_started);</span><br><span class="line">    <span class="comment">// Little self-check</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)NUM_ELEMS(s_commands); i++) &#123;</span><br><span class="line">        assert(i == s_commands[i].requestNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)NUM_ELEMS(s_unsolResponses); i++) &#123;</span><br><span class="line">        assert(i + RIL_UNSOL_RESPONSE_BASE</span><br><span class="line">                == s_unsolResponses[i].requestNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册RILD服务</span></span><br><span class="line">    radio::registerService(&amp;s_callbacks, s_commands);</span><br><span class="line">    RLOGI(<span class="string">"RILHIDL called registerService"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册RILD服务:(1) 启动RILD服务所需的HAL binder线程池，线程数目为1；（2）将RIL服务<code>RadioImpl</code>注册为系统服务，供客户端调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> radio::registerService(RIL_RadioFunctions *callbacks, CommandInfo *commands) &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> android::hardware;</span><br><span class="line">    <span class="keyword">int</span> simCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *serviceNames[] = &#123;</span><br><span class="line">            android::RIL_getServiceName()</span><br><span class="line">            #<span class="keyword">if</span> (SIM_COUNT &gt;= <span class="number">2</span>)</span><br><span class="line">            , RIL2_SERVICE_NAME</span><br><span class="line">            #<span class="keyword">if</span> (SIM_COUNT &gt;= <span class="number">3</span>)</span><br><span class="line">            , RIL3_SERVICE_NAME</span><br><span class="line">            #<span class="keyword">if</span> (SIM_COUNT &gt;= <span class="number">4</span>)</span><br><span class="line">            , RIL4_SERVICE_NAME</span><br><span class="line">            #endif</span><br><span class="line">            #endif</span><br><span class="line">            #endif</span><br><span class="line">            &#125;;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> (SIM_COUNT &gt;= 2)</span></span><br><span class="line">    simCount = SIM_COUNT;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    configureRpcThreadpool(<span class="number">1</span>, <span class="literal">true</span> <span class="comment">/* callerWillJoin */</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; simCount; i++) &#123;</span><br><span class="line">        <span class="keyword">pthread_rwlock_t</span> *radioServiceRwlockPtr = getRadioServiceRwlock(i);</span><br><span class="line">        <span class="keyword">int</span> ret = pthread_rwlock_wrlock(radioServiceRwlockPtr);</span><br><span class="line">        assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        radioService[i] = <span class="keyword">new</span> RadioImpl;</span><br><span class="line">        radioService[i]-&gt;mSlotId = i;</span><br><span class="line">        oemHookService[i] = <span class="keyword">new</span> OemHookImpl;</span><br><span class="line">        oemHookService[i]-&gt;mSlotId = i;</span><br><span class="line">        RLOGD(<span class="string">"registerService: starting IRadio %s"</span>, serviceNames[i]);</span><br><span class="line">        android::<span class="keyword">status_t</span> status = radioService[i]-&gt;registerAsService(serviceNames[i]);</span><br><span class="line">        status = oemHookService[i]-&gt;registerAsService(serviceNames[i]);</span><br><span class="line"></span><br><span class="line">        ret = pthread_rwlock_unlock(radioServiceRwlockPtr);</span><br><span class="line">        assert(ret == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s_vendorFunctions = callbacks;</span><br><span class="line">    s_commands = commands;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RadioImpl</code>实际继承了<code>IRadio.hal</code>中定义的接口，这个接口在编译时，Android利用HIDL的工具<code>hidl-gen</code>来产生对应的客户端代理Proxy对象以及服务端存根Stub对象，但<code>IRadio.hal</code>中并没有声明<code>registerAsService</code>接口，那么这个接口是从何而来了？猜测应该是由HIDL工具主动生成的接口。不妨看看<code>hidl-gen</code>的代码<code>/android/system/tools/hidl/</code>。找到相应的<code>main</code>函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> outputPath;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; packageRootPaths;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; packageRoots;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *me = argv[<span class="number">0</span>];</span><br><span class="line">    OutputHandler *outputFormat = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">while</span> ((res = getopt(argc, argv, <span class="string">"ho:r:L:"</span>)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                outputPath = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">val</span><span class="params">(optarg)</span></span>;</span><br><span class="line">                <span class="keyword">auto</span> index = val.find_first_of(<span class="string">':'</span>);</span><br><span class="line">                CHECK(index != <span class="built_in">std</span>::<span class="built_in">string</span>::npos);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> package = val.substr(<span class="number">0</span>, index);</span><br><span class="line">                <span class="keyword">auto</span> path = val.substr(index + <span class="number">1</span>);</span><br><span class="line">                packageRootPaths.push_back(path);</span><br><span class="line">                packageRoots.push_back(package);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                CHECK(outputFormat == <span class="literal">nullptr</span>) &lt;&lt; <span class="string">"Only one -L option allowed."</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : formats) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.mKey == optarg) &#123;</span><br><span class="line">                        outputFormat = &amp;e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                CHECK(outputFormat != <span class="literal">nullptr</span>) &lt;&lt; <span class="string">"Output format not recognized."</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'?'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                usage(me);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    argc -= optind;</span><br><span class="line">    argv += optind;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负责产生.hal接口的头文件，源文件</span></span><br><span class="line">    <span class="function">Coordinator <span class="title">coordinator</span><span class="params">(packageRootPaths, packageRoots)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        <span class="function">FQName <span class="title">fqName</span><span class="params">(argv[i])</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!fqName.isValid()) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">                    <span class="string">"ERROR: Invalid fully-qualified name.\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OutputHandler::ValRes valid =</span><br><span class="line">            outputFormat-&gt;validate(fqName, outputFormat-&gt;mKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (valid == OutputHandler::FAILED) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">                    <span class="string">"ERROR: output handler failed.\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 产生对应的代理与存根文件</span></span><br><span class="line">        <span class="keyword">status_t</span> err =</span><br><span class="line">            outputFormat-&gt;generate(fqName, me, &amp;coordinator, outputPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hidl-gen</code>大致包含了以下几个参数:</p>
<ul>
<li>输出路径；</li>
<li>产生的语言类型,C++还是Java还是头文件;</li>
<li>接口所在的根目录；</li>
<li>接口的全限定名(Full qulified name);</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">hidl-gen -o output-path -<span class="function">L <span class="title">language</span> <span class="params">(-r interface-root)</span> fqname</span></span><br></pre></td></tr></table></figure>
<p>对于RILD服务来说，其生成的指令如下(参考对应接口目录的<code>Android.bp</code>脚本）:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">hidl-gen -o $(genDir) -Lc++-sources -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport android.hardware.radio@<span class="number">1.0</span><span class="string">",</span></span><br></pre></td></tr></table></figure>
<p>对于C++源文件，最后会调用<code>generatedCpp.cpp</code>中的<code>generateCppSources</code>函数产生接口对应的Proxy/Stub代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> AST::generateCppSources(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;outputPath) <span class="keyword">const</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> path = outputPath;</span><br><span class="line">    path.append(mCoordinator-&gt;convertPackageRootToPath(mPackage));</span><br><span class="line">    path.append(mCoordinator-&gt;getPackagePath(mPackage, <span class="literal">true</span> <span class="comment">/* relative */</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ifaceName;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> baseName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Interface *iface = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">bool</span> isInterface;</span><br><span class="line">    <span class="keyword">if</span> (!AST::isInterface(&amp;ifaceName)) &#123;</span><br><span class="line">        baseName = <span class="string">"types"</span>;</span><br><span class="line">        isInterface = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        iface = mRootScope-&gt;getInterface();</span><br><span class="line">        baseName = iface-&gt;getBaseName();</span><br><span class="line">        isInterface = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path.append(baseName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (baseName != <span class="string">"types"</span>) &#123;</span><br><span class="line">        path.append(<span class="string">"All"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path.append(<span class="string">".cpp"</span>);</span><br><span class="line"></span><br><span class="line">    CHECK(Coordinator::MakeParentHierarchy(path));</span><br><span class="line">    FILE *file = fopen(path.c_str(), <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Formatter <span class="title">out</span><span class="params">(file)</span></span>;</span><br><span class="line"></span><br><span class="line">    out &lt;&lt; <span class="string">"#include &lt;android/log.h&gt;\n"</span>;</span><br><span class="line">    out &lt;&lt; <span class="string">"#include &lt;cutils/trace.h&gt;\n"</span>;</span><br><span class="line">    out &lt;&lt; <span class="string">"#include &lt;hidl/HidlTransportSupport.h&gt;\n\n"</span>;</span><br><span class="line">    <span class="keyword">if</span> (isInterface) &#123;</span><br><span class="line">        <span class="comment">// This is a no-op for IServiceManager itself.</span></span><br><span class="line">        out &lt;&lt; <span class="string">"#include &lt;android/hidl/manager/1.0/IServiceManager.h&gt;\n"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO(b/34274385) remove this</span></span><br><span class="line">        out &lt;&lt; <span class="string">"#include &lt;hidl/LegacySupport.h&gt;\n"</span>;</span><br><span class="line"></span><br><span class="line">        generateCppPackageInclude(out, mPackage, iface-&gt;getProxyName());</span><br><span class="line">        generateCppPackageInclude(out, mPackage, iface-&gt;getStubName());</span><br><span class="line">        generateCppPackageInclude(out, mPackage, iface-&gt;getPassthroughName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> Interface *superType : iface-&gt;superTypeChain()) &#123;</span><br><span class="line">            generateCppPackageInclude(out,</span><br><span class="line">                                      superType-&gt;fqName(),</span><br><span class="line">                                      superType-&gt;fqName().getInterfaceProxyName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out &lt;&lt; <span class="string">"#include &lt;hidl/ServiceManagement.h&gt;\n"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        generateCppPackageInclude(out, mPackage, <span class="string">"types"</span>);</span><br><span class="line">        generateCppPackageInclude(out, mPackage, <span class="string">"hwtypes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">if</span> (err == OK &amp;&amp; isInterface) &#123;</span><br><span class="line">        <span class="keyword">const</span> Interface *iface = mRootScope-&gt;getInterface();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// need to be put here, generateStubSource is using this.</span></span><br><span class="line">        out &lt;&lt; <span class="string">"const char* "</span></span><br><span class="line">            &lt;&lt; iface-&gt;localName()</span><br><span class="line">            &lt;&lt; <span class="string">"::descriptor(\""</span></span><br><span class="line">            &lt;&lt; iface-&gt;fqName().<span class="built_in">string</span>()</span><br><span class="line">            &lt;&lt; <span class="string">"\");\n\n"</span>;</span><br><span class="line">        out &lt;&lt; <span class="string">"__attribute__((constructor))"</span>;</span><br><span class="line">        out &lt;&lt; <span class="string">"static void static_constructor() &#123;\n"</span>;</span><br><span class="line">        out.indent([&amp;] &#123;</span><br><span class="line">            out &lt;&lt; <span class="string">"::android::hardware::details::gBnConstructorMap.set("</span></span><br><span class="line">                &lt;&lt; iface-&gt;localName()</span><br><span class="line">                &lt;&lt; <span class="string">"::descriptor,\n"</span>;</span><br><span class="line">            out.indent(<span class="number">2</span>, [&amp;] &#123;</span><br><span class="line">                out &lt;&lt; <span class="string">"[](void *iIntf) -&gt; ::android::sp&lt;::android::hardware::IBinder&gt; &#123;\n"</span>;</span><br><span class="line">                out.indent([&amp;] &#123;</span><br><span class="line">                    out &lt;&lt; <span class="string">"return new "</span></span><br><span class="line">                        &lt;&lt; iface-&gt;getStubName()</span><br><span class="line">                        &lt;&lt; <span class="string">"(static_cast&lt;"</span></span><br><span class="line">                        &lt;&lt; iface-&gt;localName()</span><br><span class="line">                        &lt;&lt; <span class="string">" *&gt;(iIntf));\n"</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">                out &lt;&lt; <span class="string">"&#125;);\n"</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            out &lt;&lt; <span class="string">"::android::hardware::details::gBsConstructorMap.set("</span></span><br><span class="line">                &lt;&lt; iface-&gt;localName()</span><br><span class="line">                &lt;&lt; <span class="string">"::descriptor,\n"</span>;</span><br><span class="line">            out.indent(<span class="number">2</span>, [&amp;] &#123;</span><br><span class="line">                out &lt;&lt; <span class="string">"[](void *iIntf) -&gt; ::android::sp&lt;"</span></span><br><span class="line">                    &lt;&lt; gIBaseFqName.cppName()</span><br><span class="line">                    &lt;&lt; <span class="string">"&gt; &#123;\n"</span>;</span><br><span class="line">                out.indent([&amp;] &#123;</span><br><span class="line">                    out &lt;&lt; <span class="string">"return new "</span></span><br><span class="line">                        &lt;&lt; iface-&gt;getPassthroughName()</span><br><span class="line">                        &lt;&lt; <span class="string">"(static_cast&lt;"</span></span><br><span class="line">                        &lt;&lt; iface-&gt;localName()</span><br><span class="line">                        &lt;&lt; <span class="string">" *&gt;(iIntf));\n"</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">                out &lt;&lt; <span class="string">"&#125;);\n"</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        out &lt;&lt; <span class="string">"&#125;;\n\n"</span>;</span><br><span class="line">        out &lt;&lt; <span class="string">"__attribute__((destructor))"</span>;</span><br><span class="line">        out &lt;&lt; <span class="string">"static void static_destructor() &#123;\n"</span>;</span><br><span class="line">        out.indent([&amp;] &#123;</span><br><span class="line">            out &lt;&lt; <span class="string">"::android::hardware::details::gBnConstructorMap.erase("</span></span><br><span class="line">                &lt;&lt; iface-&gt;localName()</span><br><span class="line">                &lt;&lt; <span class="string">"::descriptor);\n"</span>;</span><br><span class="line">            out &lt;&lt; <span class="string">"::android::hardware::details::gBsConstructorMap.erase("</span></span><br><span class="line">                &lt;&lt; iface-&gt;localName()</span><br><span class="line">                &lt;&lt; <span class="string">"::descriptor);\n"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        out &lt;&lt; <span class="string">"&#125;;\n\n"</span>;</span><br><span class="line"></span><br><span class="line">        err = generateInterfaceSource(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == OK &amp;&amp; isInterface) &#123;</span><br><span class="line">        err = generateProxySource(out, iface-&gt;fqName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == OK &amp;&amp; isInterface) &#123;</span><br><span class="line">        err = generateStubSource(out, iface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == OK &amp;&amp; isInterface) &#123;</span><br><span class="line">        err = generatePassthroughSource(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == OK &amp;&amp; isInterface) &#123;</span><br><span class="line">        <span class="keyword">const</span> Interface *iface = mRootScope-&gt;getInterface();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isIBase()) &#123;</span><br><span class="line">            out &lt;&lt; <span class="string">"// skipped getService, registerAsService, registerForNotifications\n"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> package = iface-&gt;fqName().package()</span><br><span class="line">                    + iface-&gt;fqName().atVersion();</span><br><span class="line">                    </span><br><span class="line">            implementServiceManagerInteractions(out, iface-&gt;fqName(), package);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正是在<code>implementServiceManagerInteractions</code>这个函数里，对于<code>IRadio.hal</code>接口生成了获取服务<code>getService</code>以及注册服务的<code>registerAsService</code>的接口。可以看到，<code>registerAsService</code>利用了<code>defaultServiceManager()</code>来调用<code>IServiceManager</code>进行服务注册。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">implementServiceManagerInteractions</span><span class="params">(Formatter &amp;out,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> FQName &amp;fqName, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;package)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> interfaceName = fqName.getInterfaceName();</span><br><span class="line"></span><br><span class="line">    implementGetService(out, fqName, <span class="literal">true</span> <span class="comment">/* isTry */</span>);</span><br><span class="line">    implementGetService(out, fqName, <span class="literal">false</span> <span class="comment">/* isTry */</span>);</span><br><span class="line"></span><br><span class="line">    out &lt;&lt; <span class="string">"::android::status_t "</span> &lt;&lt; interfaceName &lt;&lt; <span class="string">"::registerAsService("</span></span><br><span class="line">        &lt;&lt; <span class="string">"const std::string &amp;serviceName) "</span>;</span><br><span class="line">    out.block([&amp;] &#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"::android::hardware::details::onRegistration(\""</span></span><br><span class="line">            &lt;&lt; fqName.getPackageAndVersion().<span class="built_in">string</span>() &lt;&lt; <span class="string">"\", \""</span></span><br><span class="line">            &lt;&lt; interfaceName</span><br><span class="line">            &lt;&lt; <span class="string">"\", serviceName);\n\n"</span>;</span><br><span class="line">        out &lt;&lt; <span class="string">"const ::android::sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm\n"</span>;</span><br><span class="line">        out.indent(<span class="number">2</span>, [&amp;] &#123;</span><br><span class="line">            out &lt;&lt; <span class="string">"= ::android::hardware::defaultServiceManager();\n"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        out.sIf(<span class="string">"sm == nullptr"</span>, [&amp;] &#123;</span><br><span class="line">            out &lt;&lt; <span class="string">"return ::android::INVALID_OPERATION;\n"</span>;</span><br><span class="line">        &#125;).<span class="built_in">endl</span>();</span><br><span class="line">        out &lt;&lt; <span class="string">"::android::hardware::Return&lt;bool&gt; ret = "</span></span><br><span class="line">            &lt;&lt; <span class="string">"sm-&gt;add(serviceName.c_str(), this);\n"</span></span><br><span class="line">            &lt;&lt; <span class="string">"return ret.isOk() &amp;&amp; ret ? ::android::OK : ::android::UNKNOWN_ERROR;\n"</span>;</span><br><span class="line">    &#125;).<span class="built_in">endl</span>().<span class="built_in">endl</span>();</span><br><span class="line"></span><br><span class="line">    out &lt;&lt; <span class="string">"bool "</span> &lt;&lt; interfaceName &lt;&lt; <span class="string">"::registerForNotifications(\n"</span>;</span><br><span class="line">    out.indent(<span class="number">2</span>, [&amp;] &#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"const std::string &amp;serviceName,\n"</span></span><br><span class="line">            &lt;&lt; <span class="string">"const ::android::sp&lt;::android::hidl::manager::V1_0::IServiceNotification&gt; "</span></span><br><span class="line">            &lt;&lt; <span class="string">"&amp;notification) "</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    out.block([&amp;] &#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"const ::android::sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm\n"</span>;</span><br><span class="line">        out.indent(<span class="number">2</span>, [&amp;] &#123;</span><br><span class="line">            out &lt;&lt; <span class="string">"= ::android::hardware::defaultServiceManager();\n"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        out.sIf(<span class="string">"sm == nullptr"</span>, [&amp;] &#123;</span><br><span class="line">            out &lt;&lt; <span class="string">"return false;\n"</span>;</span><br><span class="line">        &#125;).<span class="built_in">endl</span>();</span><br><span class="line">        out &lt;&lt; <span class="string">"::android::hardware::Return&lt;bool&gt; success =\n"</span>;</span><br><span class="line">        out.indent(<span class="number">2</span>, [&amp;] &#123;</span><br><span class="line">            out &lt;&lt; <span class="string">"sm-&gt;registerForNotifications(\""</span> &lt;&lt; package &lt;&lt; <span class="string">"::"</span> &lt;&lt; interfaceName &lt;&lt; <span class="string">"\",\n"</span>;</span><br><span class="line">            out.indent(<span class="number">2</span>, [&amp;] &#123;</span><br><span class="line">                out &lt;&lt; <span class="string">"serviceName, notification);\n"</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        out &lt;&lt; <span class="string">"return success.isOk() &amp;&amp; success;\n"</span>;</span><br><span class="line">    &#125;).<span class="built_in">endl</span>().<span class="built_in">endl</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>defaultServiceManager</code>在<code>ServiceManagement.cpp</code>中定义,HAL服务管家<code>HwServiceManager</code>初始化完成后，会设置属性值<code>hwservicemanager.ready</code>;这样<code>defaultServiceManager</code>实际返回的是一个强引用的变量<code>gDefaultServiceManager</code>:</p>
<blockquote>
<p>代码路径<code>/android/system/libhidl/transport/ServiceManagement.cpp</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sp&lt;IServiceManager&gt; defaultServiceManager() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(details::gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">if</span> (details::gDefaultServiceManager != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> details::gDefaultServiceManager;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (access(<span class="string">"/dev/hwbinder"</span>, F_OK|R_OK|W_OK) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// HwBinder not available on this device or not accessible to</span></span><br><span class="line">            <span class="comment">// this process.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        waitForHwServiceManager();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (details::gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            details::gDefaultServiceManager =</span><br><span class="line">                    fromBinder&lt;IServiceManager, BpHwServiceManager, BnHwServiceManager&gt;(</span><br><span class="line">                        ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br><span class="line">            <span class="keyword">if</span> (details::gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">"Waited for hwservicemanager, but got nullptr."</span>;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> details::gDefaultServiceManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待hwservicemanager启动完成</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitForHwServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::literals::chrono_literals::<span class="keyword">operator</span><span class="string">""</span>s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!WaitForProperty(kHwServicemanagerReadyProperty, <span class="string">"true"</span>, <span class="number">1</span>s)) &#123;</span><br><span class="line">        LOG(WARNING) &lt;&lt; <span class="string">"Waited for hwservicemanager.ready for a second, waiting another..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，<code>gDefaultServiceManager</code>又是什么东东了？先来看看<code>ProcessState::self()-&gt;getContextObject(NULL)</code>得到的是一个什么对象:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to create a new BpHwBinder if there isn't currently one, OR we</span></span><br><span class="line">        <span class="comment">// are unable to acquire a weak reference on this current one.  See comment</span></span><br><span class="line">        <span class="comment">// in getWeakProxyForHandle() for more info about this.</span></span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            b = <span class="keyword">new</span> BpHwBinder(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码不难看出，<code>ProcessState::self()-&gt;getContextObject(NULL)</code>实际返回的是一个<code>BpHwBinder(0)</code>的Binder代理对象，函数<code>fromBinder</code>会根据这个Binder对象转换成相应的<code>IServiceManager</code>: <code>BpHwServerceManager(BpHwBinder(0))</code>,<code>BpHwServerceManager</code>实际上也是根据接口<code>IServiceManager.hal</code>通过<code>generatedCpp.cpp</code>中的函数生成的代理对象，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IType, <span class="keyword">typename</span> ProxyType, <span class="keyword">typename</span> StubType&gt;</span><br><span class="line">sp&lt;IType&gt; fromBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binderIface) &#123;</span><br><span class="line">    <span class="keyword">using</span> ::android::hidl::base::V1_0::IBase;</span><br><span class="line">    <span class="keyword">using</span> ::android::hidl::base::V1_0::BnHwBase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binderIface.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 代理对象，本地binder为空</span></span><br><span class="line">    <span class="keyword">if</span> (binderIface-&gt;localBinder() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProxyType(binderIface);</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;IBase&gt; base = <span class="keyword">static_cast</span>&lt;BnHwBase*&gt;(binderIface.get())-&gt;getImpl();</span><br><span class="line">    <span class="keyword">if</span> (details::canCastInterface(base.get(), IType::descriptor)) &#123;</span><br><span class="line">        StubType* stub = <span class="keyword">static_cast</span>&lt;StubType*&gt;(binderIface.get());</span><br><span class="line">        <span class="keyword">return</span> stub-&gt;getImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样<code>HwServiceManager</code>的在客户端的代理对象<code>BpHwServerceManager</code>将客户端请求发送给HAL Binder驱动；HAL Binder驱动则将请求发送给HAL服务管家的stub对象<code>BnHwServiceManager</code>（<code>BnHwServiceManager</code>在何时成为HAL服务上下文管家的，可以看看上一篇文章“Android HAL binder详解”)来完成服务的注册。</p>
<h2 id="获取RILD服务"><a href="#获取RILD服务" class="headerlink" title="获取RILD服务"></a><strong>获取RILD服务</strong></h2><p>RILD HAL服务注册完成之后，RILJ是如何获取到服务的了？Phone进程启动后，对RILJ进行初始化，这时RILJ会去获取RILD服务，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RIL</span><span class="params">(Context context, <span class="keyword">int</span> preferredNetworkType, <span class="keyword">int</span> cdmaSubscription)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, preferredNetworkType, cdmaSubscription, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RIL</span><span class="params">(Context context, <span class="keyword">int</span> preferredNetworkType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> cdmaSubscription, Integer instanceId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">    </span><br><span class="line">    mContext = context;</span><br><span class="line">    mPreferredNetworkType = preferredNetworkType;</span><br><span class="line">    mPhoneType = RILConstants.NO_PHONE;</span><br><span class="line">    mPhoneId = instanceId;</span><br><span class="line">    </span><br><span class="line">    ConnectivityManager cm = (ConnectivityManager)context.getSystemService(</span><br><span class="line">            Context.CONNECTIVITY_SERVICE);</span><br><span class="line">    mIsMobileNetworkSupported = cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新建response,indication，用于接收RILD的消息</span></span><br><span class="line">    mRadioResponse = <span class="keyword">new</span> RadioResponse(<span class="keyword">this</span>);</span><br><span class="line">    mRadioIndication = <span class="keyword">new</span> RadioIndication(<span class="keyword">this</span>);</span><br><span class="line">    mOemHookResponse = <span class="keyword">new</span> OemHookResponse(<span class="keyword">this</span>);</span><br><span class="line">    mOemHookIndication = <span class="keyword">new</span> OemHookIndication(<span class="keyword">this</span>);</span><br><span class="line">    mRilHandler = <span class="keyword">new</span> RilHandler();</span><br><span class="line">    mRadioProxyDeathRecipient = <span class="keyword">new</span> RadioProxyDeathRecipient();</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 获取RILD HAL服务</span></span><br><span class="line">    getRadioProxy(<span class="keyword">null</span>);</span><br><span class="line">    getOemHookProxy(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getRadioProxy</code>首先判断终端是否支持移动数据，如果没有移动数据（没有modem），则直接返回空；如果已经获取到了，则返回之前获取到的代理对象<code>mRadioProxy</code>。如果都不是，通过<code>IRadio.getService</code>来获取RILD服务的代理对象，接着向RILD注册回调函数<code>mRadioResponse</code>以及<code>mRadioIndication</code>,同时还需要注册RILD服务的死亡注册通知接收器，以便RILD异常退出后，RILJ能够收到该信息做相应的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IRadio <span class="title">getRadioProxy</span><span class="params">(Message result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mIsMobileNetworkSupported) &#123;</span><br><span class="line">        <span class="keyword">if</span> (RILJ_LOGV) riljLog(<span class="string">"getRadioProxy: Not calling getService(): wifi-only"</span>);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AsyncResult.forMessage(result, <span class="keyword">null</span>,</span><br><span class="line">                    CommandException.fromRilErrno(RADIO_NOT_AVAILABLE));</span><br><span class="line">            result.sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRadioProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mRadioProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mRadioProxy = IRadio.getService(HIDL_SERVICE_NAME[mPhoneId == <span class="keyword">null</span> ? <span class="number">0</span> : mPhoneId]);</span><br><span class="line">        <span class="keyword">if</span> (mRadioProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mRadioProxy.linkToDeath(mRadioProxyDeathRecipient,</span><br><span class="line">                    mRadioProxyCookie.incrementAndGet());</span><br><span class="line">            mRadioProxy.setResponseFunctions(mRadioResponse, mRadioIndication);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            riljLoge(<span class="string">"getRadioProxy: mRadioProxy == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException | RuntimeException e) &#123;</span><br><span class="line">        mRadioProxy = <span class="keyword">null</span>;</span><br><span class="line">        riljLoge(<span class="string">"RadioProxy getService/setResponseFunctions: "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRadioProxy == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AsyncResult.forMessage(result, <span class="keyword">null</span>,</span><br><span class="line">                    CommandException.fromRilErrno(RADIO_NOT_AVAILABLE));</span><br><span class="line">            result.sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时RILD服务还无法获取到，则延迟几秒再次获取</span></span><br><span class="line">        mRilHandler.sendMessageDelayed(</span><br><span class="line">                mRilHandler.obtainMessage(EVENT_RADIO_PROXY_DEAD,</span><br><span class="line">                        mRadioProxyCookie.incrementAndGet()),</span><br><span class="line">                IRADIO_GET_SERVICE_DELAY_MILLIS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mRadioProxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个问题，搜索Android源码并没有<code>IRadio.java</code>类，那么只能说同之前<code>HwServiceMananger</code>一样，这个类也是通过<code>hidl-gen</code>来产生的。看下<code>IRadio.hal</code>对应目录的<code>Android.bp</code>并没有定义生成规则，是不是在<code>Android.mk</code>里边了？搜了下，果然在：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#</span><br><span class="line"># Build IRadio.hal</span><br><span class="line">#</span><br><span class="line">GEN := $(intermediates)/android/hardware/radio/V1_0/IRadio.java</span><br><span class="line">$(GEN): $(HIDL)</span><br><span class="line">$(GEN): PRIVATE_HIDL := $(HIDL)</span><br><span class="line">$(GEN): PRIVATE_DEPS := $(LOCAL_PATH)/IRadio.hal</span><br><span class="line">$(GEN): PRIVATE_DEPS += $(LOCAL_PATH)/IRadioIndication.hal</span><br><span class="line">$(GEN): $(LOCAL_PATH)/IRadioIndication.hal</span><br><span class="line">$(GEN): PRIVATE_DEPS += $(LOCAL_PATH)/IRadioResponse.hal</span><br><span class="line">$(GEN): $(LOCAL_PATH)/IRadioResponse.hal</span><br><span class="line">$(GEN): PRIVATE_DEPS += $(LOCAL_PATH)/types.hal</span><br><span class="line">$(GEN): $(LOCAL_PATH)/types.hal</span><br><span class="line">$(GEN): PRIVATE_OUTPUT_DIR := $(intermediates)</span><br><span class="line">$(GEN): PRIVATE_CUSTOM_TOOL = \</span><br><span class="line">        $(PRIVATE_HIDL) -o $(PRIVATE_OUTPUT_DIR) \</span><br><span class="line">        -Ljava \</span><br><span class="line">        -randroid.hardware:hardware/interfaces \</span><br><span class="line">        -randroid.hidl:system/libhidl/transport \</span><br><span class="line">        android.hardware.radio@<span class="number">1.0</span>::IRadio</span><br><span class="line"></span><br><span class="line">$(GEN): $(LOCAL_PATH)/IRadio.hal</span><br><span class="line">    $(transform-generated-source)</span><br><span class="line">LOCAL_GENERATED_SOURCES += $(GEN)</span><br></pre></td></tr></table></figure>
<p>可以简单的写成如下这个指令，其作用是生成一个Java层的类用于获取RILD的服务。</p>
<blockquote>
<p><code>hidl-gen</code>利用<code>generateJava.cpp</code>中的函数<code>generateJava</code>来自动生成对应的类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">hidl-gen -o $(PRIVATE_OUTPUT_DIR) -LJava -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport `</span><br></pre></td></tr></table></figure>
<p><code>generateJava.cpp</code>生成的<code>IRadio.java</code>大致结构如下（只写了几个关键函数）。绕来绕去，<code>IRadio.getService(&quot;slot1&quot;)</code>实际返回的是一个由<code>HwBinder.getService</code>返回的<code>IHwBinder</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> android.hardware.radio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRaio</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IHwInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String kInterfaceName = <span class="string">"android.hardware.radio::IRadio"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">asInterface</span><span class="params">(android.os.IHwBinder binder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (binder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        android.os.IHwInterface iface = binder.queryLocalInterface(kInterfaceName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iface != <span class="keyword">null</span> &amp;&amp; iface <span class="keyword">instanceof</span> IRaio) &#123;</span><br><span class="line">            <span class="keyword">return</span> (IRadio)iface;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IRadio proxy = <span class="keyword">new</span> IRadio.Proxy(binder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String descriptor : proxy.interfaceChain()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (descriptor.equals(kInterfaceName)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> proxy;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (android.os.RemoteException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getService</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> IRadio.asInterface(android.os.HwBinder.getService(</span><br><span class="line">                android.hardware.radio@<span class="number">1.0</span>::IRadio, serviceName));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">IRadio</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IHwBinder mRemote;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(android.os.IHwBinder remote)</span> </span>&#123;</span><br><span class="line">                mRemote = java.util.Objects.requireNonNull(remote);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IHwBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看看<code>HwBinder.getService</code>返回的是什么东东？原来是一个native函数调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HwBinder</span> <span class="keyword">implements</span> <span class="title">IHwBinder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"HwBinder"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NativeAllocationRegistry sNativeRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HwBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        native_setup();</span><br><span class="line"></span><br><span class="line">        sNativeRegistry.registerNativeAllocation(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                mNativeContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> code, HwParcel request, HwParcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> code, HwParcel request, HwParcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// native接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">final</span> IHwBinder <span class="title">getService</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            String iface,</span></span></span><br><span class="line"><span class="function"><span class="params">            String serviceName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException, NoSuchElementException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns address of the "freeFunction".</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">native_init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">native_setup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> freeFunction = native_init();</span><br><span class="line"></span><br><span class="line">        sNativeRegistry = <span class="keyword">new</span> NativeAllocationRegistry(</span><br><span class="line">                HwBinder.class.getClassLoader(),</span><br><span class="line">                freeFunction,</span><br><span class="line">                <span class="number">128</span> <span class="comment">/* size */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mNativeContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>native层获取HAL服务，仍然是通过<code>defaultServiceManager</code>来获取服务的代理对象，从上面获取上下文服务<code>ServiceManager</code>的过程不难看出<code>hardware::defaultServiceManager()-&gt;get(&quot;android.hardware.radio@1.0::IRadio&quot;, &quot;slot1&quot;)</code>返回的实际上是一个与RILD服务binder代理对象<code>BpHwBinder(handle)</code>（handle由注册服务时binder驱动自动生成）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">JHwBinder_native_getService</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv *env,</span></span></span><br><span class="line"><span class="function"><span class="params">        jclass <span class="comment">/* clazzObj */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jstring ifaceNameObj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jstring serviceNameObj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ::android::hidl::base::V1_0::IBase;</span><br><span class="line">    <span class="keyword">using</span> ::android::hidl::manager::V1_0::IServiceManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ifaceNameObj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/NullPointerException"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (serviceNameObj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/NullPointerException"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> manager = hardware::defaultServiceManager();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (manager == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Could not get hwservicemanager."</span>;</span><br><span class="line">        signalExceptionForError(env, UNKNOWN_ERROR, <span class="literal">true</span> <span class="comment">/* canThrowRemoteException */</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ifaceNameCStr = env-&gt;GetStringUTFChars(ifaceNameObj, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ifaceNameCStr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// XXX exception already pending?</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">ifaceName</span><span class="params">(ifaceNameCStr)</span></span>;</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(ifaceNameObj, ifaceNameCStr);</span><br><span class="line">    ::android::hardware::hidl_string ifaceNameHStr;</span><br><span class="line">    ifaceNameHStr.setToExternal(ifaceName.c_str(), ifaceName.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *serviceNameCStr = env-&gt;GetStringUTFChars(serviceNameObj, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (serviceNameCStr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// XXX exception already pending?</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">serviceName</span><span class="params">(serviceNameCStr)</span></span>;</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(serviceNameObj, serviceNameCStr);</span><br><span class="line">    ::android::hardware::hidl_string serviceNameHStr;</span><br><span class="line">    serviceNameHStr.setToExternal(serviceName.c_str(), serviceName.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前service是直通式（C/S在同一进程）还是跨进程的binder类型</span></span><br><span class="line">    Return&lt;IServiceManager::Transport&gt; transportRet =</span><br><span class="line">            manager-&gt;getTransport(ifaceNameHStr, serviceNameHStr);</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    IServiceManager::Transport transport = transportRet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transport != IServiceManager::Transport::HWBINDER &amp;&amp; !vintfLegacy) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"service "</span> &lt;&lt; ifaceName &lt;&lt; <span class="string">" declares transport method "</span></span><br><span class="line">                   &lt;&lt; toString(transport) &lt;&lt; <span class="string">" but framework expects hwbinder."</span>;</span><br><span class="line">        signalExceptionForError(env, UNKNOWN_ERROR, <span class="literal">true</span> <span class="comment">/* canThrowRemoteException */</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个BpHwBinder(handle)对象</span></span><br><span class="line">    Return&lt;sp&lt;hidl::base::V1_0::IBase&gt;&gt; ret = manager-&gt;get(ifaceNameHStr, serviceNameHStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ret.isOk()) &#123;</span><br><span class="line">        signalExceptionForError(env, UNKNOWN_ERROR, <span class="literal">true</span> <span class="comment">/* canThrowRemoteException */</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于远程代理对象，toBinder返回的是一个downcast后的`IBinder`对象（BpHwBinder)</span></span><br><span class="line">    sp&lt;hardware::IBinder&gt; service = hardware::toBinder&lt;</span><br><span class="line">            hidl::base::V1_0::IBase, hidl::base::V1_0::BpHwBase&gt;(ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (service == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        signalExceptionForError(env, NAME_NOT_FOUND);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"Starting thread pool."</span>;</span><br><span class="line">    ::android::hardware::ProcessState::self()-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个HwRemoteBinder(BpHwBinder(handle))</span></span><br><span class="line">    <span class="keyword">return</span> JHwRemoteBinder::NewObject(env, service);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static</span></span><br><span class="line">jobject JHwRemoteBinder::NewObject(</span><br><span class="line">        JNIEnv *env, <span class="keyword">const</span> sp&lt;hardware::IBinder&gt; &amp;binder) &#123;</span><br><span class="line">    ScopedLocalRef&lt;jclass&gt; clazz(env, FindClassOrDie(env, CLASS_PATH));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX Have to look up the constructor here because otherwise that static</span></span><br><span class="line">    <span class="comment">// class initializer isn't called and gProxyOffsets.constructID is undefined :(</span></span><br><span class="line"></span><br><span class="line">    jmethodID constructID = GetMethodIDOrDie(env, clazz.get(), <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</span><br><span class="line"></span><br><span class="line">    jobject obj = env-&gt;NewObject(clazz.get(), constructID);</span><br><span class="line">    JHwRemoteBinder::GetNativeContext(env, obj)-&gt;setBinder(binder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>native层得到RILD服务的<code>IBinder</code>对象后，将其保存到native对象<code>JHwRemoteBinder</code>(其对应的Java对象是<code>HwRemoteBinder.java</code>)，这样Java层代码binder就可以通过native接口来实现binder通信了。回到最开始调用的地方，至此我们知道，实际<code>RILJ</code>通过调用<code>IRadio.getService</code>得到的是一个私有变量<code>mRemote=HwRemoteBinder</code>的<code>Proxy</code>代理对象。这样RILJ就可以通过该代理对象与RILD进行通信了。大功告成。RILJ跟RILD的通信还差最后一步：RILJ向RILD注册回调。</p>
<blockquote>
<p>HAL服务的类型（直通或者binder类型）是由各个厂商定义的，配置文件<code>manifest.xml</code>放在<code>/android/device/</code>目录下，其基本结构如下:</p>
</blockquote>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">version</span>=<span class="string">"1.0"</span> <span class="attr">type</span>=<span class="string">"device"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hal</span> <span class="attr">format</span>=<span class="string">"hidl"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>android.hardware.radio<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">transport</span>&gt;</span>hwbinder<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">name</span>&gt;</span>IRadio<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">instance</span>&gt;</span>slot1<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">instance</span>&gt;</span>slot2<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">name</span>&gt;</span>ISap<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">instance</span>&gt;</span>slot1<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">instance</span>&gt;</span>slot2<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">hal</span> <span class="attr">format</span>=<span class="string">"hidl"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>android.hardware.radio.deprecated<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">transport</span>&gt;</span>hwbinder<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">name</span>&gt;</span>IOemHook<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">instance</span>&gt;</span>slot1<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">instance</span>&gt;</span>slot2<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="RILJ注册回调，通信建立完成"><a href="#RILJ注册回调，通信建立完成" class="headerlink" title="RILJ注册回调，通信建立完成"></a><strong>RILJ注册回调，通信建立完成</strong></h2><p>RILJ获取到RILD的代理对象后，就可以通过远程调用向RILD发送请求了。但在建立最后的通信，还需要做三件事情：</p>
<ul>
<li><p>RILJ向RILD注册一个死亡通知: 当RILD异常退出后，通过该接收者来接受死亡消息</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">mRadioProxy.linkToDeath(mRadioProxyDeathReceipent, mRadioProxyCookie.incrementAndGet());</span><br></pre></td></tr></table></figure>
</li>
<li><p>RILJ向RILD注册回调，RILD可通过该回调向RILJ发送消息：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Return&lt;<span class="keyword">void</span>&gt; RadioImpl::setResponseFunctions(</span><br><span class="line">        <span class="keyword">const</span> ::android::sp&lt;IRadioResponse&gt;&amp; radioResponseParam,</span><br><span class="line">        <span class="keyword">const</span> ::android::sp&lt;IRadioIndication&gt;&amp; radioIndicationParam) &#123;</span><br><span class="line">    RLOGD(<span class="string">"setResponseFunctions"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_rwlock_t</span> *radioServiceRwlockPtr = radio::getRadioServiceRwlock(mSlotId);</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_rwlock_wrlock(radioServiceRwlockPtr);</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    mRadioResponse = radioResponseParam;</span><br><span class="line">    mRadioIndication = radioIndicationParam;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&lt; RNTFIX::</span></span><br><span class="line">    mSecRadioResponse = <span class="literal">NULL</span>;</span><br><span class="line">    mSecRadioIndication = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//&gt; RNTFIX</span></span><br><span class="line"></span><br><span class="line">    mCounterRadio[mSlotId]++;</span><br><span class="line"></span><br><span class="line">    ret = pthread_rwlock_unlock(radioServiceRwlockPtr);</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// client is connected. Send initial indications.</span></span><br><span class="line">    android::onNewCommandConnect((RIL_SOCKET_ID) mSlotId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Void();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RILD发送消息告知RILJ通信建立成功：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onNewCommandConnect</span><span class="params">(RIL_SOCKET_ID socket_id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Inform we are connected and the ril version</span></span><br><span class="line">    <span class="keyword">int</span> rilVer = s_callbacks.version;</span><br><span class="line">    RIL_UNSOL_RESPONSE(RIL_UNSOL_RIL_CONNECTED,</span><br><span class="line">                                    &amp;rilVer, <span class="keyword">sizeof</span>(rilVer), socket_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// implicit radio state changed</span></span><br><span class="line">    RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED,</span><br><span class="line">                                    <span class="literal">NULL</span>, <span class="number">0</span>, socket_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send last NITZ time data, in case it was missed</span></span><br><span class="line">    <span class="keyword">if</span> (s_lastNITZTimeData != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        resendLastNITZTimeData(socket_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get version string</span></span><br><span class="line">    <span class="keyword">if</span> (s_callbacks.getVersion != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *version;</span><br><span class="line">        version = s_callbacks.getVersion();</span><br><span class="line">        RLOGI(<span class="string">"RIL Daemon version: %s\n"</span>, version);</span><br><span class="line"></span><br><span class="line">        property_set(PROPERTY_RIL_IMPL, version);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        RLOGI(<span class="string">"RIL Daemon version: unavailable\n"</span>);</span><br><span class="line">        property_set(PROPERTY_RIL_IMPL, <span class="string">"unavailable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><em>参考资料</em></h2><ul>
<li><a href="http://sniffer.site/2016/11/29/Android-RILD详解/">http://sniffer.site/2016/11/29/Android-RILD详解/</a> </li>
<li><a href="http://sniffer.site/2016/11/29/Android-RIL概述/">http://sniffer.site/2016/11/29/Android-RIL概述/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Binder </tag>
            
            <tag> RILD </tag>
            
            <tag> HAL </tag>
            
            <tag> RILJ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入Android HAL binder]]></title>
      <url>http://sniffer.site/2018/06/06/%E6%B7%B1%E5%85%A5Android-HAL-binder/</url>
      <content type="html"><![CDATA[<p>HAL binder是Android O(8.0)专门用于HAL（Hardware Abstract Layer)层（native）进程与其clients之间的通信机制（clients可以是native进程，也可以是Java Framework进程)。 HAL binder替代了早先使用的socket通信，其kernel层实际是基于原有的binder驱动，但为了配合Client与Server之间的数据传输，需要使用特定的中间层HIDL来进行接口与数据的转换。那么，相对之前的HAL通信方式（socket），基于HIDL的HAL通信有什么优势了？从系统架构的角度，HIDL为客户端与服务端提供了清晰的接口；从效率的角度，binder IPC实际在传输数据上只有一次拷贝，而socket实际传输需要两次数据拷贝<a id="more"></a>。</p>
<p>目前Android有两种类型的HAL：</p>
<ul>
<li><p><strong>binder化的HAL</strong>： 利用HIDL(HAL interface Definition Language)来描述HAL接口，Framework层与HAL层通过binder IPC的方式进行通信；如下的HAL模块都是利用binder IPC来进行通信的:</p>
<ul>
<li><a href="mailto:`android.hardware.biometrics.fingerprint@2.1" target="_blank" rel="noopener">`android.hardware.biometrics.fingerprint@2.1</a>`</li>
<li><a href="mailto:`android.hardware.configstore@1.0" target="_blank" rel="noopener">`android.hardware.configstore@1.0</a>`</li>
<li><a href="mailto:`android.hardware.dumpstate@1.0" target="_blank" rel="noopener">`android.hardware.dumpstate@1.0</a>`</li>
<li><a href="mailto:`android.hardware.graphics.allocator@2.0" target="_blank" rel="noopener">`android.hardware.graphics.allocator@2.0</a>`</li>
<li><a href="mailto:`android.hardware.radio@1.0" target="_blank" rel="noopener">`android.hardware.radio@1.0</a>`</li>
<li><a href="mailto:`android.hardware.usb@1.0" target="_blank" rel="noopener">`android.hardware.usb@1.0</a>`</li>
<li><a href="mailto:`android.hardware.wifi@1.0" target="_blank" rel="noopener">`android.hardware.wifi@1.0</a>`</li>
<li><a href="mailto:`android.hardware.wifi.supplicant@1.0" target="_blank" rel="noopener">`android.hardware.wifi.supplicant@1.0</a>`</li>
</ul>
</li>
<li><p><strong>直通式HAL</strong>： 基于HIDL或者传统HAL方式来实现，在这种模式下，Framework层与HAL层的通信可以通过IPC的方式进行，也可以使用共享内存的方式在同一个进程内进行（passthrough,直通）。目前有如下两个HAL模块使用直通式方式进行通信：</p>
<ul>
<li><a href="mailto:`android.hardware.graphics.mapper@1.0" target="_blank" rel="noopener">`android.hardware.graphics.mapper@1.0</a>`</li>
<li><a href="mailto:`android.hardware.renderscript@1.0" target="_blank" rel="noopener">`android.hardware.renderscript@1.0</a>`</li>
</ul>
</li>
</ul>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a><strong>相关代码</strong></h2><ul>
<li><code>/android/system/tools/hidl/</code>： 根据HAL接口 <code>.hal</code>来产生相应的Proxy(client端接口）以及stub(server端接口）。</li>
<li><code>/android/system/libhwbinder/</code>： 初始化binder线程，负责与binder驱动交互，读写数据；</li>
<li><code>/android/system/libhidl</code>： HIDL状态与HAL服务管理接口；</li>
<li><code>/android/os/HwBinder</code>： Java层Hardware binder代码，获取server端接口以及向server发起IPC调用；</li>
<li><code>android_os_HwBinder.cpp (JNI)</code>：Java层HAL binder的JNI代码，负责将Java层的请求传递给相应的server进程；</li>
<li><code>/android/hardware/interfaces/</code>： 各个模块HAL层接口，每个模块都包含了一个<code>Android.bp</code>的脚步来生成对应的代理(Proxy)与存根对象(stub)，如radio接口<code>IRadio.hal</code>,sensors接口<code>ISensors.hal</code>；</li>
<li><code>/android/kernel/drivers/staging/android/</code>： binder驱动；</li>
</ul>
<p>下图是HAL binder的结构简图, 了解Binder的同学应该很快能看出，这个结构跟binder的C/S IPC架构很相似，区别的地方在对于HAL binder来说，server进程是Android的native进程而已。在接下来的两篇文章里，我将以Telephony Framwork(RILJ)与native进程RILD是如何通过hardware binder来进行通信为例，从以下两个方面来说明HAL Binder的实现机制与工作原理：</p>
<ul>
<li>HAL服务管家<code>HwServiceMananger</code>是如何启动以及如何注册、获取系统服务；</li>
<li>RILJ如何通过HAL binder与RILD进行通信？</li>
</ul>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/HwBinder_architecture.png" alt="HwBinder Architecture"> </p>
<blockquote>
<p>关于Android.bp脚本可以参考<a href="https://android.googlesource.com/platform/build/soong/" target="_blank" rel="noopener">https://android.googlesource.com/platform/build/soong/</a></p>
</blockquote>
<p>这篇文章，主要来看下第一个问题，HAL binder是如何启动以及管理所有HAL服务的。跟常规的binder通信（AMS，PMS等使用的binder）一样，HAL binder也需要有一个专门的服务管家，来统一管理系统的服务，同时为客户端提供诸如注册、获取服务等API。</p>
<h2 id="HwServiceMananger的启动"><a href="#HwServiceMananger的启动" class="headerlink" title="HwServiceMananger的启动"></a><strong>HwServiceMananger的启动</strong></h2><p>在<code>/android/system/hwservicemanager/hwservicemanager.rc</code>目录下，有个启动脚本<code>hwservicemanager.rc</code>，init进程在启动之后会对该脚本进行解析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">service hwservicemanager /system/bin/hwservicemanager</span><br><span class="line">    user system</span><br><span class="line">    disabled</span><br><span class="line">    group system readproc</span><br><span class="line">    critical</span><br><span class="line">    onrestart setprop hwservicemanager.ready <span class="literal">false</span></span><br><span class="line">    onrestart class_restart hal</span><br><span class="line">    onrestart class_restart early_hal</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">animation</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>/android/system/core/rootdir/init.rc</code>文件中，有个控制指令，专门来启动<code>hwservicemananger</code>这个系统服务：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">on post-fs</span><br><span class="line">    # Load properties from</span><br><span class="line">    #     /system/build.prop,</span><br><span class="line">    #     /odm/build.prop,</span><br><span class="line">    #     /vendor/build.prop <span class="keyword">and</span></span><br><span class="line">    #     /factory/factory.prop</span><br><span class="line">    load_system_props</span><br><span class="line">    <span class="meta"># start essential services</span></span><br><span class="line">    start logd</span><br><span class="line">    start servicemanager</span><br><span class="line">    start hwservicemanager</span><br><span class="line">    start vndservicemanager</span><br></pre></td></tr></table></figure>
<p>这样，系统加载<code>hwservicemanager</code>，进入main函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinderCallback</span> :</span> <span class="keyword">public</span> LooperCallback &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinderCallback() &#123;&#125;</span><br><span class="line">    ~BinderCallback() override &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">(<span class="keyword">int</span> <span class="comment">/* fd */</span>, <span class="keyword">int</span> <span class="comment">/* events */</span>, <span class="keyword">void</span>* <span class="comment">/* data */</span>)</span> override </span>&#123;</span><br><span class="line">        IPCThreadState::self()-&gt;handlePolledCommands();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// Continue receiving callbacks.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化hwbinder驱动，设置线程池</span></span><br><span class="line">    configureRpcThreadpool(<span class="number">1</span>, <span class="literal">true</span> <span class="comment">/* callerWillJoin */</span>);</span><br><span class="line"></span><br><span class="line">    ServiceManager *manager = <span class="keyword">new</span> ServiceManager();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;add(serviceName, manager)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to register hwservicemanager with itself."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TokenManager有何作用？</span></span><br><span class="line">    TokenManager *tokenManager = <span class="keyword">new</span> TokenManager();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;add(serviceName, tokenManager)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to register ITokenManager with hwservicemanager."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;Looper&gt; looper(Looper::prepare(<span class="number">0</span> <span class="comment">/* opts */</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> binder_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 设置线程进入等待状态，准备处理IPC请求</span></span><br><span class="line">    IPCThreadState::self()-&gt;setupPolling(&amp;binder_fd);</span><br><span class="line">    <span class="keyword">if</span> (binder_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to aquire binder FD. Aborting..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Flush after setupPolling(), to make sure the binder driver</span></span><br><span class="line">    <span class="comment">// knows about this thread handling commands.</span></span><br><span class="line">    IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line">    <span class="comment">// IPC请求回调，有数据时会调用该回调进行处理</span></span><br><span class="line">    sp&lt;BinderCallback&gt; cb(<span class="keyword">new</span> BinderCallback);</span><br><span class="line">    <span class="keyword">if</span> (looper-&gt;addFd(binder_fd, Looper::POLL_CALLBACK, Looper::EVENT_INPUT, cb,</span><br><span class="line">            <span class="literal">nullptr</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to add hwbinder FD to Looper. Aborting..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell IPCThreadState we're the service manager</span></span><br><span class="line">    sp&lt;BnHwServiceManager&gt; service = <span class="keyword">new</span> BnHwServiceManager(manager);</span><br><span class="line">    IPCThreadState::self()-&gt;setTheContextObject(service);</span><br><span class="line">    </span><br><span class="line">    ioctl(binder_fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">    ...    </span><br><span class="line">    rc = property_set(<span class="string">"hwservicemanager.ready"</span>, <span class="string">"true"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        looper-&gt;pollAll(<span class="number">-1</span> <span class="comment">/* timeoutMillis */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ServiceManager</code>启动主要需要做以下几件事情：</p>
<ul>
<li>初始化<code>/dev/hwbinder</code>驱动，为其分配一块虚拟内存用于IPC数据交换；</li>
<li>向<code>hwbinder</code>注册HAL服务管家(IPC上下文管理者）；</li>
<li>监听<code>/dev/hwbinder</code>是否有数据可读，如有则调用回调执行指令；</li>
</ul>
<h2 id="hwbinder驱动初始化"><a href="#hwbinder驱动初始化" class="headerlink" title="hwbinder驱动初始化"></a><strong>hwbinder驱动初始化</strong></h2><p><code>HwServiceManager</code>启动的第一件事情，就是配置binder线程池，告知驱动当前需要启动多少个线程处理IPC指令：对于<code>HwServiceManager</code>而言，只需要一个binder线程，即调用者线程即可（调用者线程何时加入binder线程池下面会讲到），而无需启动新的线程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// HidlBinderSupport.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">configureBinderRpcThreadpool</span><span class="params">(<span class="keyword">size_t</span> maxThreads, <span class="keyword">bool</span> callerWillJoin)</span> </span>&#123;</span><br><span class="line">    ProcessState::self()-&gt;setThreadPoolConfiguration(maxThreads, callerWillJoin <span class="comment">/*callerJoinsPool*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ProcessState</code>只有一个实例（<code>ProcessState</code>可以看成是<code>hwbinder</code>用户空间进程状态管理者），因此在调用<code>ProcessState():self</code>的时候，如果当前<code>ProcessState</code>没有创建全局实例，则会创建一个实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sp&lt;ProcessState&gt; ProcessState::self()</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    gProcess = <span class="keyword">new</span> ProcessState;</span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建<code>ProcessState</code>的时候，主要做两件事：</p>
<ul>
<li>打开<code>/dev/hwbinder</code>驱动，验证binder版本以及协议版本，并配置最大的binder线程数量（对于hwbinder，默认的最大线程数量为0）；</li>
<li>将<code>/dev/hwbinder</code>映射到一块大小约为1M的虚拟内存上用于交换IPC数据；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ProcessState::ProcessState()</span><br><span class="line">    : mDriverFD(open_driver()) <span class="comment">// 配置最大线程数</span></span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(<span class="number">0</span>)</span><br><span class="line">    , mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">NULL</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">NULL</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mSpawnThreadOnStart(<span class="literal">true</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">        mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="comment">// *sigh*</span></span><br><span class="line">            ALOGE(<span class="string">"Using /dev/hwbinder failed: unable to mmap transaction memory.\n"</span>);</span><br><span class="line">            close(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGE(<span class="string">"Binder driver could not be opened.  Terminating."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ProcessState</code>初始化完成后，获取到相应实例，配置线程池(对于每个HAL服务来是，一般线程池只有一个线程，就是服务进行注册时所在的<br>主线程），告知线程当前所需的最大线程数目：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> ProcessState::setThreadPoolMaxThreadCount(<span class="keyword">size_t</span> maxThreads) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(mDriverFD, BINDER_SET_MAX_THREADS, &amp;maxThreads) != <span class="number">-1</span>) &#123;</span><br><span class="line">        mMaxThreads = maxThreads;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = -errno;</span><br><span class="line">        ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(-result));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注册HAL服务管家"><a href="#注册HAL服务管家" class="headerlink" title="注册HAL服务管家"></a><strong>注册HAL服务管家</strong></h2><p>线程池配置完成后，获取当前线程的Looper（对的，就是Framework层常用的Handler消息循环在native的对应），并告知HwBinder驱动由当前线程来处理HAL服务上下文相关的指令， 设置Looper消息回调。接着，就是注册HAL服务的管家<code>ServiceManager</code>了。</p>
<p><code>ServiceManager</code>继承了<code>IServiceManager</code>接口，负责管理系统中所有的HAL服务，为其他进程提供服务注册、查找等功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Manages all the hidl hals on a device.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Terminology:</span></span><br><span class="line"><span class="comment"> *   Package: "android.hidl.manager"</span></span><br><span class="line"><span class="comment"> *   Major version: "1"</span></span><br><span class="line"><span class="comment"> *   Minor version: "0"</span></span><br><span class="line"><span class="comment"> *   Version: "1.0"</span></span><br><span class="line"><span class="comment"> *   Interface name: "IServiceManager"</span></span><br><span class="line"><span class="comment"> *   Fully-qualified interface name: "android.hidl.manager@1.0::IServiceManager"</span></span><br><span class="line"><span class="comment"> *   Instance name: "manager"</span></span><br><span class="line"><span class="comment"> *   Fully-qualified instance name: "android.hidl.manager@1.0::IServiceManager/manager"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">interface IServiceManager &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve an existing service that supports the requested version.</span></span><br><span class="line">    get(<span class="built_in">string</span> fqName, <span class="built_in">string</span> name) generates (interface service);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register a service. The service manager must retrieve the (inherited)</span></span><br><span class="line"><span class="comment">     * interfaces that this service implements, and register them along with</span></span><br><span class="line"><span class="comment">     * the service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    add(<span class="built_in">string</span> name, interface service) generates (<span class="keyword">bool</span> success);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Transport : <span class="keyword">uint8_t</span> &#123;</span><br><span class="line">        EMPTY,</span><br><span class="line">        HWBINDER,</span><br><span class="line">        PASSTHROUGH,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the transport of a service.</span></span><br><span class="line">    getTransport(<span class="built_in">string</span> fqName, <span class="built_in">string</span> name) generates (Transport transport);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// List all registered services. Must be sorted.</span></span><br><span class="line">    <span class="built_in">list</span>() generates (vec&lt;<span class="built_in">string</span>&gt; fqInstanceNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// List all instances of a particular service. Must be sorted.</span></span><br><span class="line">    listByInterface(<span class="built_in">string</span> fqName) generates (vec&lt;<span class="built_in">string</span>&gt; instanceNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register for service notifications for a particular service. Must support</span></span><br><span class="line"><span class="comment">     * multiple registrations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    registerForNotifications(<span class="built_in">string</span> fqName,</span><br><span class="line">                             <span class="built_in">string</span> name,</span><br><span class="line">                             IServiceNotification callback)</span><br><span class="line">        generates (<span class="keyword">bool</span> success);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When the passthrough service manager returns a service via</span></span><br><span class="line"><span class="comment">     * get(string, string), it must dispatch a registerPassthroughClient call</span></span><br><span class="line"><span class="comment">     * to the binderized service manager to indicate the current process has</span></span><br><span class="line"><span class="comment">     * called get(). Binderized service manager must record this PID, which can</span></span><br><span class="line"><span class="comment">     * be retrieved via debugDump.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 注册直通式客户端</span></span><br><span class="line">    registerPassthroughClient(<span class="built_in">string</span> fqName, <span class="built_in">string</span> name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着， 让<code>BnHwServiceManager</code>成为HAL服务的上下文管家，需要做两件事：一是告知<code>IPCThreadState</code>负责上下文管理的对象，用于接收来自其他进程的IPC请求；一是告知kernel上下文管理者的是一个handle为0的<code>IBinder</code>对象，kernel会为其保存一个节点，以便IPC时使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Tell IPCThreadState we're the service manager</span></span><br><span class="line">sp&lt;BnHwServiceManager&gt; service = <span class="keyword">new</span> BnHwServiceManager(manager);</span><br><span class="line">IPCThreadState::self()-&gt;setTheContextObject(service);</span><br><span class="line"><span class="comment">// Then tell binder kernel</span></span><br><span class="line">ioctl(binder_fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p> <code>BnHwServiceManager</code>是<code>ServiceManager</code>服务端的stub对象，与客户端代理Proxy<code>BpHwServiceManager</code>相对应，具体怎么来的，在下一篇文章中再详细讲述</p>
</blockquote>
<p>最后，设置<code>hwservicemanager.ready</code>，表面当前<code>hwservicemanager</code>已经处于可用状态；<code>pollAll</code>则表示<code>hwservicemanager</code>进入消息循环等待的过程，一旦<code>/dev/hwbinder</code>有数据可读，就会调用之前注册的<code>BinderCallback</code>进行处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rc = property_set(<span class="string">"hwservicemanager.ready"</span>, <span class="string">"true"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    looper-&gt;pollAll(<span class="number">-1</span> <span class="comment">/* timeoutMillis */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在接下来的一篇文章，基于<code>Telephony</code>与<code>RILD</code>的通信来讲述HAL服务的具体工作流程。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://source.android.com/devices/architecture/hal" target="_blank" rel="noopener">https://source.android.com/devices/architecture/hal</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Binder </tag>
            
            <tag> HAL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从HTTP到HTTPS]]></title>
      <url>http://sniffer.site/2018/05/05/%E4%BB%8EHTTP%E5%88%B0HTTPS/</url>
      <content type="html"><![CDATA[<p><a href="http://sniffer.site/2017/08/23/HTTP%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/">HTTP</a> 自从上世纪90年代随着WEB的诞生而出现的，是所有WEB应用的基础。随着网络购物、电子商务、网上银行等逐渐普及，HTTP本身存在信息窃听与身份伪装等问题，已很难满足人们对于可信安全的通信环境的需求了。如何确保用户隐私与数据不被非法获取，这是HTTPS（<a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank" rel="noopener">HTTP Secure</a> )需要解决的问题<a id="more"></a>。使用HTTPS协议的网站，一般都以<code>https</code>开头而不是<code>http</code>，如:<a href="https://tools.ietf.org/html/rfc2246" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2246</a> 。</p>
<p>那么，从数据安全的角度来看，HTTP有哪些不足了？</p>
<ul>
<li>HTTP本身不具备加密功能，因此请求与响应都没有经过加密，而使用的是不加密的明文，因此内容可能会被窃听；</li>
<li>通信时不会验证通信方（client/server)的身份，任何人都可以发送请求，而服务器对于所有请求也照单全收，因此客户端与服务端都有可能被伪装；</li>
<li>在传输数据时，报文可能被篡改或者攻击，无法保证报文的完整性(integrity);这种在请求与数据传输过程中，被攻击者拦截并篡改的攻击方式被称为中间人攻击(<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank" rel="noopener">Man-in-the-middle attack</a> );</li>
</ul>
<p>为了解决上述安全问题，HTTPS通过在HTTP之下添加一个安全层SSL/TLS(<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="noopener">Transport Layer Security</a> , <a href="https://tools.ietf.org/html/rfc2246" target="_blank" rel="noopener">RFC2246</a>)来实现数据的加密、身份验证以及数据完整性校验：<br><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/HTTPS.png" alt="HTTPS architecture"></p>
<p>就是说，HTTPS实际是在TCP/IP的基础上加上了TLS协议，而TLS协议是独立于HTTP协议的，因此除了HTTP之外，其他的应用层协议SMTP，TELNET，EMAIL也同样可以使用TLS来实现安全加密的通信。</p>
<h2 id="HTTPS需要解决的问题"><a href="#HTTPS需要解决的问题" class="headerlink" title="HTTPS需要解决的问题"></a>HTTPS需要解决的问题</h2><p>HTTPS需要解决的首要问题是，通信过程请求与响应的加密。我们知道，目前世界上常用的加密方式有两种：一个是对称密钥加密(<a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm" target="_blank" rel="noopener">Symmetric-key algorithm</a> ，加密与解密都使用同一个密钥，因此要确保加密信息的安全，通信双方交换密钥时需要保证密钥不被窃取；另一种是非对称加密（也称为<a href="https://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="noopener">公开密钥加密</a> ), 加密与解密使用两个不同的密钥，一把公钥（对外公开），一把私钥（需要保存），使用非对称加密，发送方只需使用公钥对数据加密，而接收方则利用自己的私钥对密文进行解密，这样通信双方不用交换密钥，不用担心通信过程中密钥被窃取。</p>
<p>HTTPS实际上同时使用了这两种加密方式来实现安全通信。在通信开始交换密钥时使用的是非对称加密的方式来交换对称加密的密钥；等到密钥交换完毕后，发送通信数据时则利用交换后的密钥来对数据进行加密。</p>
<p>但采用这种混合加密的方式通信还存在一个问题：无法确保非对称加密公开密钥的真实性。比如，某个客户端与服务器建立链接时，如何要证明所接收到的公钥就是服务器发送过来的密钥了，有可能在密钥传递的过程中，公钥已经被攻击者替换成完全不同的一个密钥了。</p>
<p>为了解决上述公钥真实性的问题，需要使用第三方数字认证机构（<a href="https://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="noopener">Certificate Authority</a> )颁布的<a href="https://en.wikipedia.org/wiki/Public_key_certificate" target="_blank" rel="noopener">公钥数字证书</a> 。数字证书是一种身份标识，表明持有者是一个可信的实体。但即便有一个颁发数字证书的CA，也不能完全确保数字证书的持有着就是可信的（CA机构的数字证书有可能被攻击者篡改或者攻破），这样就产生了类似“先有蛋，还是先有鸡”的问题了 。这是另一个需要解决的信任问题了（（查看<a href="https://en.wikipedia.org/wiki/Web_of_trust" target="_blank" rel="noopener">信任链</a>））。回到HTTPS那个公钥问题。HTTPS是如何利用公钥证书进行安全通信的？</p>
<ol>
<li>服务器的运营人员向CA提出公开密钥（公钥）的申请；</li>
<li>CA在确认申请人的身份之后，利用非对称加密算法，产生公钥与私钥。私钥做<a href="https://en.wikipedia.org/wiki/Digital_signature" target="_blank" rel="noopener">数字签名</a> ，公钥放入公钥证书一起发送给申请者；</li>
<li>服务器拿到公钥证书后，在通信时，发送给客户端，以利用公钥进行通信；</li>
<li>客户端接受到服务器发过来的公钥证书后，会利用保存在本地的数字证书（CA除了需要将数字证书发给服务器之外，还需要发给客户端，为了确保安全，一般浏览器会内置CA的公钥证书）中的公钥验证服务器的数字签名，一旦验证通过，客户端便认为： 一公钥证书的颁发机构是真实合法的；二是服务的身份是可信的。</li>
</ol>
<p>确保了密钥交换的公钥的真实性后，HTTPS就可以放心的通信了。</p>
<h2 id="HTTPS通信流程"><a href="#HTTPS通信流程" class="headerlink" title="HTTPS通信流程"></a><strong>HTTPS通信流程</strong></h2><p>下图HTTPS的通信流程，相比HTTP通信，其主要多了客户端与服务端的握手流程（握手流程也可以参考TLS标准<a href="https://tools.ietf.org/html/rfc2246" target="_blank" rel="noopener">RFC2246</a> ）：</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/HTTPS_Process.png" alt="HTTPS Process"> </p>
<ol>
<li>客户端发送ClientHello报文开始SSL通信；报文包含了客户端支持的SSL版本号、加密组件(Cipher suite)列表（包括了加密算法以及密钥长度等）；</li>
<li>服务端可进行SSL通信，则发送ServerHello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件（是从接收的客户端中筛选出来的）；</li>
<li>服务端发送包含数字证书的certificate报文;</li>
<li>最后服务器发送ServerHelloDone告知客户端SSL握手协商结束；</li>
<li>SSL第一次握手结束后，客户端以ClientKeyExchange报文作为回应，报文中包含通信加密中使用的Premaster secret的随机密码串。报文本身会利用公开密钥进行加密处理；</li>
<li>客户端继续发送ChangeCipherSpec报文，提示服务器，在此报文后的通信会采用Pre-master secret密钥加密；</li>
<li>客户端发送Finished报文，该报文包含了建立链接至此全部报文的整体校验值。握手协商是否成功，要以服务器是否能正确的机密该报文为判定条件；</li>
<li>服务器同样发送ChangeCipherSpec报文；</li>
<li>服务器发送Finished报文；</li>
<li>服务器和客户端的Finished报文交换完毕后，SSL通信链接就算建立完成了。此后，客户端就会发送HTTP请求；</li>
<li>应用层协议通信开始，发送HTTP响应；</li>
<li>最后由客户端断开链接。断开链接时，发送close notify报文（上图做了简化，实际到这一步还需要发送TCP FIN报文关闭TCP链接）。</li>
</ol>
<p>在上述通信过程中，应用层HTTP发送的数据都会附加一个利用MAC（<a href="https://en.wikipedia.org/wiki/Message_authentication_code" target="_blank" rel="noopener">Message Authentication Code</a> 的报文摘要，MAC用来验证通信数据的完整性。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Certificate_System/8.0/html/Deployment_Guide/Introduction_to_Public_Key_Cryptography-Digital_Signatures.html" target="_blank" rel="noopener">https://access.redhat.com/documentation/en-US/Red_Hat_Certificate_System/8.0/html/Deployment_Guide/Introduction_to_Public_Key_Cryptography-Digital_Signatures.html</a> </p>
</li>
<li><p><a href="https://sites.google.com/site/ddmwsst/digital-certificates#TOC-What-is-a-Digital-Certificate" target="_blank" rel="noopener">https://sites.google.com/site/ddmwsst/digital-certificates#TOC-What-is-a-Digital-Certificate</a> </p>
</li>
<li><p><a href="https://tools.ietf.org/html/rfc2246" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2246</a></p>
</li>
<li>《图解HTTP》</li>
<li><a href="https://tls13.ulfheim.net/" target="_blank" rel="noopener">SSL协议握手详尽的介绍</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 网络协议 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> HTTPS </tag>
            
            <tag> TLS </tag>
            
            <tag> SSL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《人类简史》札记]]></title>
      <url>http://sniffer.site/2018/04/30/%E3%80%8A%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E3%80%8B%E6%9C%AD%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>作为文化的中国，其实已经灭亡了。。。为什么中国人在这一百多年，老是把传统和现代，把西方文化和中国文化对立起来，为什么我们不能像欧洲那样把传统和现代的关系处理的那么好？</p>
<p>粟宪庭</p>
</blockquote>
<p>《人类简史》之前也听说过，但一直没有时间去看。一个朋友极力推荐之下，从他那借了过来，前后断断续续看了一个月，快看完了。作者的视野广阔，从宏观上来描述人类的发展历史，但描述起历史细节也是娓娓道来，总之可读性极好。推荐指数五星。以前，看书都是翻了就算看了，没有留下多少笔记，这次看《人类简史》有些心得感悟，都写了下来，算是一个总结<a id="more"></a>。</p>
<ul>
<li>人类社会的观念都是主体间共同想象出来的产物，比如国家，政府，自由以及权利。因此想改变一个国家或者民族的对待某种事物的态度与看法，首先是要为其构造出新的“想象”，这种“想象”可以称之为思想。一旦这种新思想在主体间传播开来，植入越来越多人的头脑，旧秩序就面临瓦解与崩塌。从这里也可以看到，新思想对于那些独裁者来说是难以接受的毒药。因此，纵观古今，无一例外的，独裁者都要想法设法控制垄断人民的思想，一看到有任何“不合时宜”的言论或行为都会严加禁止，竭力把星星之火扼杀在尚未燎原之前。</li>
<li>人类社会的诸多观念都是基于想象而构建出来的，并没有相应的实体对象，如平等，人权，国家，财富，金钱。一旦人不再相信这些概念，人类的社会秩序就面临崩塌。人类能从自然的演化中占据绝对优势，依靠的也是这样的想象力。这种想象力利用得当，对社会与个人都是极有利的事情，而利用不当，成为统治阶层的工具，则只会压制人性，让社会走向不公，降低社会效率。</li>
<li>书开篇就说，135亿年前，宇宙大爆炸形成了能量、时间与空间；在这以后大约30万年，开始有了复杂的物质结构，有了“原子”、“分子”。这简短的几句，看似平常，可要是追问起来，对人而言，却是终极的谜题：宇宙爆炸之前是怎么样的状态？原子与分子形成之前是什么状态？</li>
<li>人类经过上百万年的进化演变，从前那种残酷的生存环境已经不再，人类也不用像往昔那样为了获取食物而焦虑，为了与各种大型的野兽争夺食物而感到恐惧。这种对生存的焦虑与恐惧随着人类的强大而渐渐转移到其他方面，比如创造，比如政府，比如商品等等。直到今天，人类依然在某种程度上被这些进化的烙印所影响、左右。</li>
<li>做任何事都是有成本的，看的见的是时间成本，而看不见的却是机会成本，更多的时候是难以预料的偶然事件叠加导致机会成本陡增。这就是所谓的学费。怎么减少交学费的次数？这个需要不断的思考总结。</li>
<li>人从神崇拜到个人崇拜，是种倒退。人类漫长的历史过程，就是不断探索世界，理解自然规则，认识自我的过程。人历经过自然灾害，在残酷的战争中挣扎撕裂过，到今天，应该意识到，要解放自己，活的洒脱，让生命不在痛苦与沉闷中度过，关键还是在发挥个体的个性，把个体的潜能挖掘出来，寻找自我的价值。</li>
<li>数万年年前，人类还在荒野奔跑，与野兽做斗争，辛苦劳累一天只是够养活一家人而已。随着人类认知开始跳跃，生产效率不断提升，历经工业革命、信息技术革命，到现在的人工智能，如今人再不用像网昔那样为了吃饱穿暖而愁眉苦脸，担惊受怕了。人们在忙完自己一天的工作后，可以吃喝玩乐，可以逛街散步；可以开着车到处溜达，也可以到公园里漫步。但在某种程度上，人类的生活变得更加无趣了，人与人之间也更加疏离。信息爆炸性的增长看似丰富了人的生活，却在一定程度上让人类自身变得茫然与焦虑。而在另一方面，大部分人虽然远离了历史上残酷的战争以及制度性的压迫，但由于自然资源的过度开发，经济快速发展，环境污染、资源枯竭、生态失衡、人口过多等种种问题开始困扰着人类社会。如果说在过去几万年间人类的进化是与自然的斗争，那么现在却是一场人与自身的斗争。面对这些问题，人类若不懂得克制，不懂得保持对自然与宇宙的敬畏，那么人类面临的终将是痛苦，将付出沉重的代价。</li>
<li>进化心理学认为现在人类社会和心理特征早在农业时代之前就开始形成。即便到了今天，我们的大脑和心灵还是以狩猎和采集的生活方式在思考。。。在现代城市环境下，我们比前人拥有更多物质资源，拥有更长寿命，但又觉得疏离、沮丧而压力重重。</li>
<li>人类从智人时代，就开始了对生态环境的大规模破坏，放火烧林、屠戮动物，所到之处物种开始大范围灭绝。几万前，人类尚处在享受美食、享受占有与掠夺的快感之中，对自然的理解也处于比较单一粗糙的阶段，并不会反思这种行为对自然的摧毁，对人类自身的生存环境带来的影响。直到今天，工业化与城市化的快速发展，人类人口膨胀，人不仅破坏了自然的平衡，也把自身的生存环境弄得乌烟瘴气。青山绿水也只是存在于远古的想象了。</li>
<li>远古时代，人类与自然对斗争，与身边的老虎狮子争夺生存空间；进入农业时代，人类开始大规模改造自然，不再过着担惊受怕的生活。由于人口的大福增加，人与人之间对于资源的竞争加剧，民族之间的摩擦也不断增加，战争、疾病威胁着人类自身的生存；进入工业社会到今天，人类对自然资源的利用已经到了无以复加的地步，煤矿、铁矿、铜矿、金矿；石油、天然气；饮用水、森林等资源都被过度开发，而工厂集中生产带来了环境污染，人类的生存环境日益堪忧：水污染，空气污染，噪声污染，生活空间被极度压缩，四处奔波再也看不得青山绿水。人类贪婪无节制的发展，不仅造成了自然的破坏，也导致了自身生存环境不断恶化。若再这样下去，人类能够得到的只是生态毁灭后的地球。未来，人类面临更大的挑战的是如何协调自身发展与自然环境的保护。</li>
<li>“历史从无正义“，第一次看到这句话以及书中的陈述，心里压抑了好一阵。这是否就意味着个人只能听任命运的摆布，意味着历史就是强者的天下，而弱者只能接受被压制与奴役的残酷？若是这样，努力还有什么意义？从已有的知识来看，历史从来都没有什么必然的规律，而是充满着偶然性。从地球的诞生，到细胞的存在，再到生命的出现、智人的存在，都只是自然中各种偶然因素作用的结果。而人类短暂的历史，为何总上演着一幕又一幕的悲剧： 疾病、饥荒、战争导致大规模的人口死亡；黑人被奴役，当作动物一般贩卖；女性被认为比男性虚弱，因此总是被压制与剥夺的一方？个体无法掌控自己的命运，正义总是缺位，就如古人说的，”兴，百姓苦；亡，百姓苦“。可到了今天，我们有机会来审视人自身命运的时候，比对现实，或许可以看的更为清晰些：正义是一种选择，一种社会制度的安排，正义并不是天然的，而是根植于社会与文化的构建。就像今天，欧美等国家走的是民主与法制，法律保障了每个个体的自由与权利，保证了每个个体依靠自身努力获取到的财富所享有的权益，在这样的社会里，正义蕴涵在国家的制度与法律条文中；而朝鲜、伊朗等国家则选择了专制与独裁，每个人都得服从集体与国家的安排，个人自由的空间被压缩到极致，个体难以控制自身的命运，只有被现实所裹挟，那么，正义又从何谈起？</li>
<li>为什么是欧洲成为了近代历史科学的摇篮，而不是中国或者中东地区了？作者赫拉利认为，帝国主义、资本主义与科学的结合造成了这样的结果。15世纪，葡萄牙、西班牙的航海冒险家，跨越浩瀚的大海，是为了生存，为了财富与土地，为了征服与探索；而彼时，中国明朝的郑和也七次扬帆去到大西洋沿岸，但目的却不是为了财富，而是为了宣扬天朝上国的威严与强盛。西欧国家为了保持自己对占有财富的控制权，会产生诸如绘制地图、征税等需要科学家来解决的实际问题，因此会大力去培育自己的科学队伍，科学因此得以进步。财富的积累与资本的扩展是无疑是科学获得快速发展的动因。但除此之外，科学的持续发展也离不开欧洲国家政治与社会制度的保障。若没有法制来保护科学家的发明创造，没有法律来确保科学家的权益，个体的创造才能怎么会被激发出来？在强大的野心与征服、探索欲望推动下，在法制的保障下，欧洲成为近代世界的中心也就不难理解了。</li>
<li>近百年来，人类拥有的物质财富增加了成千上百倍，每个个体的财富也大幅攀升。住房，汽车，冰箱，洗衣机，电视，电脑，手机等等，这些让人类的生活变得更加方便快捷，舒适安逸了。但与此同时却也让人产生了依赖感。试想，今天的人是否能够离开手里的智能设备了？恐怕一小时都做不到。人类的物质财富翻了好几个数量级，但人类的快乐与幸福是否也跟着在增长了？结论恐怕不容乐观。今天的人们为了工作整天忙碌奔波，生活看似有了更多的选择，但内心却更为孤独而焦虑。选择太多了，欲望刺激太多了，人们的时间精力被四处打散。匆忙盲目之中，人们恐怕都不会问问自己，究竟什么是快乐幸福？什么能够带来快乐与幸福？</li>
</ul>
<p>为什么人能够体验到快乐与幸福了？现代科学已经揭开了谜底：在快乐幸福时，身体里会产生多巴胺、血清素、催产素等“快乐”激素，从而刺激人的大脑，让人感到一阵阵愉悦。这些激素在人运动、做爱或者体验到某种巅峰时刻的时候都会产生。不禁要问，是否可以利用什么手段让大脑细胞感到类似多巴胺刺激的快感了？有，酒精或者毒品。从已有的现实来看，这些外来刺激虽然延长了人的快感（是不是快乐不得而知），但其带来的却是灾难性后果，为了短暂的快感体验而牺牲了一生的快乐幸福恐怕并不值得。快乐与幸福从大的方面来说，有两个部分：一个是外在的，比如财富，家庭，爱情婚姻，以及社会环境；一个是内在的，比如身体，能力，性格。外在的因素往往难以控制，它很难随着个人的意志而发生变化。从这个角度来说，为实现个人福祉，为了避免陷入愤世嫉俗的歇斯底里，人只有努力适应外在的条件，努力调整自己的态度与看法，而不是期待去控制与改变。个人能把握的，实际是这些内在的因素，比如的身体（也可以包括相貌，虽然长相是天生的，但是锻炼身体这件事至少会改善个人的气质），你可以通过不断的体育锻炼来让它更为健壮，让自己变得更有活力；比如能力，只要愿意，你可以通过持续的学习与思考总结来提升自己的技能；比如性格，你可以通过不断的阅读，让自己变得更为渊博，开朗睿智。这些事情，短期来看可能不能让你有所收获，但长期来看确会是巨额的回报。不论是锻炼身体，还是学习新的东西，掌握新的技能，这些都是通往自我认知、发掘自身潜能的必经之路。其目标是认识自己，找到内心所爱，找到生命的价值与意义。不断的发掘自身潜能，也是一个不断拓宽生命边界，探索人生各种可能的一种超凡体验。这个过程会让人感到满足与幸福。对罗素的一句话印象深刻，他说：“参差多态乃人生幸福的源泉“， 我想持续不断的为自己的目标与追寻的价值努力，就是探索参差多态的人生之路吧。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 历史 </tag>
            
            <tag> 人类简史 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中的垃圾回收机制]]></title>
      <url>http://sniffer.site/2018/02/23/Garbage-Collection-in-Java/</url>
      <content type="html"><![CDATA[<p>Java将所有运行时的分配的对象保存到堆(<strong>heap</strong>)中，虚拟机通过诸如<code>new</code>,<code>newarray</code>,<code>anewarray</code>以及<code>multianewarray</code>等指令来分配对象，但并不会在代码中显式的释放这些内存区域，而是由虚拟机中自带的内存回收器(<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science" target="_blank" rel="noopener"><code>Garbage Collection</code></a>)，以下简称<code>GC</code>）来负责内存分配、压缩以及回收。GC的主要任务就是找到堆中那些不再被引用的内存对象，将其回收用于分配新的对象；同时，GC还要负责压缩堆内存分片，减少内存碎片，确保新的对象有足够的连续空间可以使用。GC让开发人员不用再担心内存释放的问题，提升了开发效率；<a id="more"></a> 在另外一个方面，GC使开发人员不用再担心错误的释放了某个对象，确保了程序的完整性。但使用GC的一个潜在弊端是，GC在收集内存时会增加程序负担，减低程序运行效率。</p>
<p>接下来，就来看看Java虚拟机中常用的垃圾回收算法。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a><strong>垃圾收集算法</strong></h2><p>任何垃圾收集算法都需要做如下几件事情：</p>
<ul>
<li>检测需要回收的对象；</li>
<li>回收“垃圾”对象所占用的内存，将这些内存提供给程序使用；</li>
<li>对内存进行去碎片化处理；</li>
</ul>
<p>那么，怎么确定哪些对象是需要回收的了？首先，GC需要确定一个“根对象＂集合，如果某个对象可以通过“根集合”中的元素访问到，则称该对象是可达的（任何根对象都是可达的），因此就可以认为该对象是“存活的”，而对于不可达的对象则被认为是“待回收”的对象，因为他们对程序的执行不会产生影响。那么，一般根集合中的对象要如何选择了？这个跟具体的JVM实现有关系，一般有如下四种：</p>
<ul>
<li>在线程中使用的本地变量；</li>
<li>正在运行的线程；</li>
<li>被类引用的静态变量</li>
<li>通过JNI调用在本地代码引用的对象</li>
</ul>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/Java_GC_objects.png" alt="Java GC objects"></p>
<p>确定了根集合元素之后，JVM是怎么来区分存活对象与需要回收的对象的了？主要有两种方式，一种是引用计数(<a href="https://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="noopener">Reference counting</a>);一种是跟踪(tracing)。引用计数回收器保存了每个对象的引用次数，如果发现该对象的引用次数为零，则认为该对象可被回收；跟踪回收器基于根集合中的节点建立对象引用图，跟踪每个对象的引用关系，跟踪过程完成后，没有标记的对象即是不可达的，因此会被回收。</p>
<h3 id="引用计数回收器"><a href="#引用计数回收器" class="headerlink" title="引用计数回收器"></a><strong>引用计数回收器</strong></h3><p>引用计数是在JVM初期使用的垃圾回收策略。JVM在分配对象时，会保存一个该对象的引用计数，并且该引用计数被初始化为1，当其他变量引用该对象时，对象的引用计数会加一，而该引用不再使用或者被赋予新值时，则将该对象的引用减一。当对象引用计数为零时，就将该对象回收，一旦对象回收，所有该对象引用的对象的引用计数都需要减一。</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/Java-GC-counting-references1.png" alt="Java GC counting references"></p>
<p>引用计数回收器的一个优点在于，回收时间短，不会过多占用程序执行时间，这也使得这种回收方式特别适合程序执行不能中断过久的实时性环境；不足之处时，引用计数不能检测循环引用：多个对象相互引用。即使这些对象对于执行程序的根集合来讲是不可达的，它们的引用计数永远不可能为零。</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/Java-GC-cyclical-dependencies.png" alt="GC counting ref_cyclic references"></p>
<p>正是因为这个原因，引用计数回收已经很少在实际中使用了，如今的JVM大都使用跟踪算法来实现垃圾回收。</p>
<h3 id="跟踪回收器"><a href="#跟踪回收器" class="headerlink" title="跟踪回收器"></a><strong>跟踪回收器</strong></h3><p>跟踪算法从根对象开始，计算出整个对象引用图，将图中被引用的对象进行标记。跟踪回收算法一般分为三个步骤：</p>
<ul>
<li><strong>标记</strong>(mark)： 从根对象开始，遍历所有可达对象，并作相应的标记；</li>
<li><strong>清理</strong>(sweep)：对于未被标记的不可达对象，回收其内存区域，确保可以被下一次内存分配使用；在JVM中，清理阶段必须包含对象的<em>finalization</em>。</li>
<li><strong>压缩</strong>（compact)：在删除“垃圾”对象后，通常需要将存活的对象移动到一起，清除堆内存中的碎片，从而提高新对象分配的效率。</li>
</ul>
<p>虽然跟踪回收器解决了引用计数回收器中存在的循环引用问题，但是在清理之前，通常需要执行”stop the world（STW)”,暂停运行程序，这在一定程度上降低了程序运行的效率。因此，如何减少<em>STW</em>对程序运行的影响，是各个GC算法需要考虑的重点。</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/java_GC_marking_sweep.png" alt="GC-marking &amp; sweeping"></p>
<h2 id="JVM中的垃圾回收器"><a href="#JVM中的垃圾回收器" class="headerlink" title="JVM中的垃圾回收器"></a><strong>JVM中的垃圾回收器</strong></h2><p>当前，JVM主要提供了四种垃圾回收器：the serial collector; the throughput(parallel) collector; the concurrent(CMS) collector以及G1 collector。尽管这四种回收器在细节上有所区别，但所有的GC都将堆内存划分成不同的“代（generations)”：新生代(young generation)以及老一代(old or tenured generation)。新生代又进一步划分为伊甸区(eden space)和两个幸存区(survivor space)。为什么要把堆内存划分成不同的代了？这样做有何益处？这种划分是<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener"><strong>基于经验的分析</strong></a>：应用中大部分对象都具有比较短的生命周期。将堆内存根据生命周期划分成更小的空间，可以减少内存回收的时间。</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/JVM_heap_structure.png" alt="JVM heap structure"></p>
<p>新生代用于新对象的分配、当新生代空间耗尽后，会进行一次垃圾回收。这种在新生代上进行的GC通常被称为<strong>Minor GC</strong>;老一代空间包含了生命周期较长以及在多次Minor GC之后存活的对象，通常老一代空间填满后，会进行一次垃圾回收，被称为<strong>Major GC</strong>（也称为<strong>full GC</strong>),与<strong>Minor GC</strong>相比，<strong>Major GC</strong>通常需要耗费更长的时间。以下是关于新生代空间的几个要点：</p>
<ul>
<li>绝大多数的新创建对象都位于<strong>Eden</strong>空间；</li>
<li>当<strong>eden</strong>被填满后，进行<strong>Minor GC</strong>，所有存活下来的对象都会移动到一个<strong>survivor</strong>空间；</li>
<li><strong>Minor GC</strong>也会检查<strong>survivor</strong>空间，将其中存活的对象移动到另外一个<strong>survivor</strong>空间。因此，在任何时候，总有一个<strong>survivor</strong>空间是空的；</li>
<li>多次<strong>Minor GC</strong>后，依然存活的对象会被移动到老一代空间中去。</li>
</ul>
<p>在JVM内存中，除了堆空间外，还有一个永生代（permanent generation),该内存空间用于存放程序中需要使用的元数据(metadata),同时还保存着Java标准库的类与方法。永生代空间的垃圾回收一般在<strong>full GC</strong>中进行。</p>
<p>接下来看看各个回收器算法的具体差异以及使用方式：</p>
<ul>
<li><strong><em>seriral collector</em></strong>: 串行回收器是最简单的一种，其使用单个线程来处理堆内存，主要用于单核CPU以及堆空间较小的执行环境。在回收垃圾时，串行回收器会暂停所有程序，这使得它并不适用于服务器场景。JVM中可通过<em>-XX:+UseSerialGC</em>来使用串行回收器；</li>
<li><strong><em>parallel/throughput collector</em></strong>: 并行回收器，对于服务器（多个CPU以及64-bit JVM）这是JVM默认使用的回收器。并行回收器使用多个线程并行的对堆内存进行扫描、标记以及去碎片，在最低程度上减少垃圾回收时程序暂停的时间。但并行回收器在执行minor/major(full) GC时，会暂停所有程序线程。因此，并行回收器比较适合于能够容忍一定时间暂停的场景。并行回收器对应的JVM参数为<em>-XX:+UseParallelGC</em>/<em>-XX:+UseParallelOldGC</em>(JDK 7之前的JVM使用）;</li>
<li><strong><em>CMS collector</em></strong>:Concurrent mark sweep旨在减少full GC引起的长时间暂停，其使用多个线程标记、清理未被引用的对象。在Minor GC时，CMS依然会<em>stop the world</em>,但对于full GC，CMS会使用多个线程定时的扫描老一代内存空间，丢弃那些未被使用的对象。相比并行回收器，CMS大幅减少了程序暂停的时间，但在一定程度上增加了CPU负担，而且CMS并不会对堆空间进行压缩，这会导致大量内存碎片。开启CMS对应的参数为<em>-XX:+UseConcMarkSweepGC</em>`。如果系统的堆内存在4G以下，并且为了避免程序暂停允许GC分配更多的系统资源，可以考虑使用CMS回收器；</li>
<li><strong><em>G1 collector</em></strong>:The Garbage first Collector(G1)在JDK7中引入，是为了更好的支持堆空间在4G以上的系统。G1回收器使用多个后台进程扫描堆空间，并把堆空间分割成1MB～32MB大小的区域。G1回收器会优先扫描包含了最多待回收对象的区域。这样能够减少GC后台线程完成扫描未被引用的对象之前将对象删除的几率，从而避免了GC进入”stop the world”,降低程序运行的效率。G1清理老一代空间对象时，将对象从一个区域复制到另一个区域，这样使得G1在正常情况下也可以进行内存的去碎片化处理。因此相比CMS来说，G1具有更少的碎片。G1对于的JVM参数为<em>-XX:+UseG1GC</em>；</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul>
<li>Java Performance: the Definitive Guide</li>
<li><a href="https://plumbr.io/handbook/what-is-garbage-collection" target="_blank" rel="noopener">https://plumbr.io/handbook/what-is-garbage-collection</a></li>
<li><a href="https://www.cs.cmu.edu/~fp/courses/15411-f14/lectures/21-gc.pdf" target="_blank" rel="noopener">https://www.cs.cmu.edu/~fp/courses/15411-f14/lectures/21-gc.pdf</a></li>
<li><a href="https://betsol.com/2017/06/java-memory-management-for-java-virtual-machine-jvm/" target="_blank" rel="noopener">https://betsol.com/2017/06/java-memory-management-for-java-virtual-machine-jvm/</a></li>
<li><a href="https://www.cs.princeton.edu/picasso/mats/HotspotOverview.pdf" target="_blank" rel="noopener">https://www.cs.princeton.edu/picasso/mats/HotspotOverview.pdf</a></li>
<li><a href="https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All" target="_blank" rel="noopener">https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> JVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java Virtual Machine </tag>
            
            <tag> Garbage Collection </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java虚拟机入门]]></title>
      <url>http://sniffer.site/2018/01/07/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>Java诞生于互联网兴盛的上世纪90年代，为了在不同终端设备上运行Java程序，其在设计之初，就考虑到了语言的可移植性，确保编写完后，可以在任何平台上运行。随着互联网时代的来临，Java因其平台无关性（platform independence), 安全性(security)、网络可移动性(network mobility)以及内存自动管理(Garbage Collection)等特征而得到了广泛的应用。那么， Java的这些特性究竟是如何实现的？相比早前的C/C++等编译型语言，Java程序首先被编译成一个个包含了字节码(<code>bytecode</code>)的<code>.class</code>文件，运行时，<code>.class</code>文件被加载Java虚拟机（Java Virtual Machine)上执行。实际上，任何其他语言只要能够编译成JVM能够识别的<code>bytecode</code>， JVM都可以执行<a id="more"></a>。从这个角度来看，JVM封装了平台的硬件细节，使得Java程序在编译完后可以在任何有Java运行环境的（Java Runtime Enviroment, JRE)平台上运行，无需再关心不同平台的差异。接下来，就来看下，JVM的具体结构以及各个组成部分的功能。</p>
<p>下图是JVM的结构图, 其主要由如下三个部分组成：</p>
<ul>
<li><strong>类加载系统</strong>(class loader subsystem）：负责加载class文件；</li>
<li><strong>运行时数据区</strong>: (Runtime data areas）： 运行程序运行时的内存区域，保存如类实例、类名、方法参数、方法代码以及局部变量等，主要分为方法区(<code>method area</code>)、堆（<code>heap</code>)、栈（<code>Java Stacks</code>)等几个区域，对于不同的虚拟机实现运行时数据区可能并不一样。</li>
<li><strong>执行系统</strong>(Execution Engine）：负责执行JVM指令</li>
</ul>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/Internal%20Architecture%20of%20JVM.png" alt="Internal Architecture of JVM"></p>
<h2 id="类文件"><a href="#类文件" class="headerlink" title="类文件"></a><strong>类文件</strong></h2><p>Java类文件<code>.class</code>是由<code>.java</code>文件编译过来的二进制文件，其中每个字符都只有8-bit，因此类文件字节流也叫做<code>bytecode</code>，每个数据项都是依次相邻存储，不会有任何填充位，如果一个数据项有多个字节，则将其分成多个连续的字节存放（采用高位在前的bit-endian编码）。这中连续存放的格式使得类文件更加紧凑，方便在网络中传输。</p>
<p>类文件的定义确保了不管在何种系统下编译产生，JVM都能够正确的加载、解析执行；因此，其他语言通过编译产生同样的<code>.class</code>文件，JVM同样能够解析执行。</p>
<p>那么，类文件具体包含哪些信息了？Java文件中的变量、方法名以及方法中的代码又是如何存储的？JVM虚拟机规范给出了类文件的结构：</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/Class_file_structure.png" alt="class file structure"></p>
<p>这其中，<code>u1</code>,<code>u2</code>,<code>u4</code>分别表示一个字节、两个字节以及四个字节长的无符号整数，可以看出，类文件实际上是一个由不同长度的数据项组成，每个数据项都有一个类型(type)，名称(name)以及数量（count），比如类文件魔数<code>magic</code>是一个类型为<code>u2</code>、数量为1的数据项。类文件就是按照上述顺序存储的，我们来看看各个数据项的具体信息：</p>
<h3 id="魔数-magic"><a href="#魔数-magic" class="headerlink" title="魔数(magic)"></a>魔数(magic)</h3><p>类文件的开头四个字节总是它的魔数(magic number)<code>0xCAFEBABE</code>，魔数用于识别某个文件是否是类文件；如果一个文件的魔术不是<code>0xCAFEBABE</code>，则肯定不是类文件。</p>
<h3 id="minor-version-major-version"><a href="#minor-version-major-version" class="headerlink" title="minor_version/major_version"></a>minor_version/major_version</h3><p>第二个四个字节分别是次版本号与主版本号，用于表示Java对应的版本，如果版本号不再有效的范围内，JVM会直接拒绝加载该类文件。</p>
<h3 id="常量池-constant-pool"><a href="#常量池-constant-pool" class="headerlink" title="常量池(constant pool)"></a>常量池(constant pool)</h3><p>顾名思义，常量池包含了类或者接口中的常量，如字符串、final变量、类名以及方法名等。常量池是由一个个常量项组成的表，该表大小为<code>constant_pool_count</code>，表索引的位置是从1到<code>constant_pool_count-1</code>,索引位置0是预留位置，一般不使用。 每个常量项都是由一个字节的<code>tag</code>与一个字节数组构成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cp_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u1 info[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>info</code>数组的大小是根据不同tag对应的数据项所占空间大小决定的，常量池有如下几种tag类型：</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/java_constant_pool_types.jpg" alt="contant pool tags"></p>
<p>例如，标签<code>CONSTANT_Class</code>，用于表示一个类或者接口名称，其主要有两部分组成：</p>
<ul>
<li>长度为<code>u1</code>的标签值；</li>
<li>长度为<code>u2</code>的名称索引（指向常量表中的某个位置）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 name_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里也可以看到， 对于Java语言来说，类名或者接口名的最大长度为255个字符。</p>
<h3 id="access-flags"><a href="#access-flags" class="headerlink" title="access_flags"></a>access_flags</h3><p>类型标志，占有2个字节，用于表示这个类或者接口的类型：</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/java_Access_flag.png" alt="access flags"></p>
<h3 id="this-class"><a href="#this-class" class="headerlink" title="this_class"></a>this_class</h3><p>在类型标志之后的两个字节，是<code>this_class</code>数据项，用于表示类名，该数据项实际是一个<code>constant pool</code>的索引，其指向一个<code>CONSTANT_Class</code>类。</p>
<h3 id="super-class"><a href="#super-class" class="headerlink" title="super_class"></a>super_class</h3><p><code>super_class</code>占两个字节，跟<code>this_class</code>一样，也是一个常量池的索引，用于表示一个类的父类的全限定名（例如<code>java.lang.object</code>对应的全限定名为<code>java/lang/object</code>)。在Java中，所有类的基类都是<code>java.lang.object</code>，因此对于所有类，该索引都指向一个<code>java.lang.object</code>的<code>CONSTANT_Class_info</code>常量项，但是对于<code>Object</code>类本身来说，该值为0。</p>
<h3 id="interfaces-count-and-interfaces"><a href="#interfaces-count-and-interfaces" class="headerlink" title="interfaces_count and interfaces"></a>interfaces_count and interfaces</h3><p><code>super_class</code>之后是<code>interfaces_count</code>，表示类所实现的接口或者在类中定义的接口数。接着<code>interfaces_count</code>是接口数据索引数组<code>interfaces</code>，该数组包含了所有指向常量池中接口描述信息<code>CONTANT_Class_info</code>的索引。</p>
<p>在接口信息之后还包含了类似的数据项<code>fields_count/fields</code>、<code>methods_count/methods</code>、<code>attributes_count/attributes</code>。</p>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a><strong>运行时数据区</strong></h2><p>类文件加载完成后， JVM需要为程序新建内存区域，保存诸如方法名、类名、类实例、方法参数、返回值以及局部变量等。JVM将这些运行时的内存主要分为几个区域(需要注意的是，不同的虚拟机实现运行时数据区可能并不相同）：</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/JVM_RuntimeDataArea.png" alt="Java Runtime Data Areas"></p>
<ul>
<li><strong>方法区</strong>(method area）：方法区在JVM启动时候创建，用于存储每个类的运行时常量池（constant pool),变量以及方法信息以及相应的代码。方法区为所有线程共享。如果方法区内存不足，不能满足分配请求时，JVM会抛出一个<code>OutOfMemoryError</code>异常；</li>
<li><strong>堆区</strong>(Heap）：JVM启动时创建，所有引用类对象的创建都是在堆区进行的，该区的内存分配与释放都是由GC(Gabage Collector)来负责管理的。与方法区一样，堆区也是为所有线程共享的。当JVM的内存管理系统无法分配所需内存时，则抛出<code>OutOfMemoryError</code>异常；</li>
<li><strong>栈</strong>(Java Stacks）：新的进程创建时，JVM为其创建一个栈区，用于保存线程的本地变量以及运行结果，返回值等。Java栈是由栈帧(Stack frames)组成的，一个栈帧包含了Java方法调用的状态，当一个线程调用某个方法时，JVM将一个新的栈帧压入栈区；当调用方法完成后，则将该栈帧从栈中弹出。如果一个线程所需的栈内存超过了JVM栈最大能够提供的大小，则会抛出<code>StackOverflowError</code>;</li>
<li><strong>程序计数器寄存器</strong>(PC registers）：每个线程都有自己的程序计数器，用于保存当前线程所运行方法的地址，如果该方法不是native的，程序计数器保存的是线程当前正在执行的方法地址；而对于native方法，程序计数器的值是不定的；</li>
<li><strong>本地方法栈</strong>(Native Method Stacks）:一个线程调用其他语言如C/C++的方法时， JVM会为其创建一个本地方法栈，用于保存临时变量以及返回值等；</li>
<li><strong>运行时常量池</strong>(run-time constant pool): 每个类与接口在类文件中都有一个<code>constant_pool</code>的表，用于存放数值或者方法的引用。每个常量池所需内存都是从JVM的方法区中分配的，JVM会在类或者接口创建的时候为其构造一个运行时常量池。当常量池内存分配不足时，JVM会抛出一个<code>OutOfMemoryError</code>的异常。</li>
</ul>
<h2 id="执行系统"><a href="#执行系统" class="headerlink" title="执行系统"></a><strong>执行系统</strong></h2><p>执行系统(Execution Engine)是JVM的核心部分，主要负责执行虚拟机指令。对于每个线程，都有自己的执行系统实例。执行系统可能直接执行字节码指令，或者执行本地代码，也可以通过<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" title="Just In Time compilation" target="_blank" rel="noopener">JIT</a>执行编译后的本地代码。JVM规范对具体如何执行指令并没有做明确的规定，只是提供了指令的定义。</p>
<p>JVM中的指令都有一个助记符，一般都是由一个单字节操作码(opcode)，跟着零个或者多个操作数(operands)，多数的指令都有操作码，没有操作数。大部分指令的操作码都在首个字母标识了该指令对应的动作，例如，<code>iload</code>指令加载局部变量值的操作栈上，这个局部变量的值必须是<code>int</code>,与此类似的指令还有<code>fload</code>, <code>dload</code>等：</p>
<ul>
<li>int型指令对应开头为<code>*i*</code>;</li>
<li>float型指令对应为<code>*f*</code>;</li>
<li>double型指令对应为<code>**d**</code>;</li>
<li>long型指令对应为<code>l</code>;</li>
<li>short型指令对应<code>s</code>;</li>
<li>byte型指令对应<code>b</code>;</li>
<li>char型指令对应<code>c</code>;</li>
<li>引用类型指令对应<code>a</code>;</li>
</ul>
<p>来看一个JVM指令的具体实例，有如下一个类<code>SayHello.java</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.examples.jason.javecore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHello</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"hello, world!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SayHello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对应文件目录输入指令<code>javac SayHello.java</code>，得到一个<code>SayHello.class</code>的文件，接着利用反编译工具<code>javap</code>,输入指令<code>javap -c SayHello.class</code>,得到反汇编后的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Compiled from <span class="string">"SayHello.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">examples</span>.<span class="title">jason</span>.<span class="title">javecore</span>.<span class="title">SayHello</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.examples.jason.javecore.SayHello();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: invokestatic  #5                  // Method sayHello:()V</span><br><span class="line">       <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul>
<li><a href="http://www.onjava.com/pub/a/onjava/2003/11/12/classloader.html" target="_blank" rel="noopener">http://www.onjava.com/pub/a/onjava/2003/11/12/classloader.html</a></li>
<li><a href="https://www.javaworld.com/article/2077260/learn-java/learn-java-the-basics-of-java-class-loaders.html" target="_blank" rel="noopener">https://www.javaworld.com/article/2077260/learn-java/learn-java-the-basics-of-java-class-loaders.html</a></li>
<li><a href="https://www.artima.com/insidejvm/ed2/introarch.html" target="_blank" rel="noopener">https://www.artima.com/insidejvm/ed2/introarch.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java Virtual Machine </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何用JobScheduler进行任务调度]]></title>
      <url>http://sniffer.site/2017/12/23/%E5%A6%82%E4%BD%95%E7%94%A8JobScheduler%E8%BF%9B%E8%A1%8C%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
      <content type="html"><![CDATA[<p>Android从5.0开始添加了一个任何调度服务<code>JobSchedulerService</code>,APP可以通过该服务进行各种任务的调度，如定时任务，与服务器同步资源，下载特定信息等。由于<code>JobScheduler</code>通过收集各个应用的调度任务，采用批处理的方式，允许多个任务同时运行，可以让设备具有更长的睡眠时间， 从而延长了电池使用。这篇文章，主要从应用与原理两个方面讲述分析<code>JobScheduler</code><a id="more"></a>。</p>
<h2 id="如何使用JobScheduler"><a href="#如何使用JobScheduler" class="headerlink" title="如何使用JobScheduler"></a><strong>如何使用JobScheduler</strong></h2><p>这里假定我们有一个定时任务，需要每隔一段时间就同步本地与服务器的数据。通过<code>JobScheduelr</code>发起任务调度，第一步是要创建一个<code>JobService</code>用于处理定时同步服务器的任务请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * data sync job service</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSyncJobService</span> <span class="keyword">extends</span> <span class="title">JobService</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"DataSyncJobService"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartJob</span><span class="params">(JobParameters jobParameters)</span> </span>&#123;</span><br><span class="line">	Log.v(TAG,<span class="string">"onStartJob()"</span>);</span><br><span class="line">	startSyncData();</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStopJob</span><span class="params">(JobParameters jobParameters)</span> </span>&#123;</span><br><span class="line">	Log.v(TAG,<span class="string">"onStopJob()"</span>);</span><br><span class="line">	showMessage(getString(R.string.stop_job_scheduler));</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startSyncData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">	        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	            e.printStackTrace();</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="comment">// data sync done</span></span><br><span class="line">	        showMessage(getString(R.string.data_sync_complete));</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">	Intent intent = <span class="keyword">new</span> Intent(getBaseContext(), MessageActivity.class);</span><br><span class="line">	intent.putExtra(<span class="string">"message"</span> , message);</span><br><span class="line">	intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">	startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时需要在<code>AndroidManifest.xml</code>中声明该<code>servce</code>， 并且该<code>service</code>必须添加一个权限<code>android:permission=&quot;android.permission.BIND_JOB_SERVICE</code>， 这样当定时时间到后，系统会主动绑定该服务，从而发起任务调度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;service android:name=<span class="string">".DataSyncJobService"</span></span><br><span class="line">    android:permission=<span class="string">"android.permission.BIND_JOB_SERVICE"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>建立了任务处理的<code>service</code>之后，就可以通过<code>JobScheduler</code>来发起任务调度的请求了， Android提供了如下几个接口供用户调度任务：</p>
<ul>
<li><code>int schedule(in JobInfo job)</code> ： 发起一个任务<code>job</code>，如成功则返回1,失败则返回0;</li>
<li><code>enqueue(JobInfo job, JobWorkItem worker)</code>： 与<code>schedule</code>类似，但允许将一个新的任务放入<code>job</code>的队列；</li>
<li><code>void cancel(int jobId)</code> ： 取消一个任务；</li>
<li><code>void cancelAll()</code>： 取消所有任务；</li>
<li><code>List&lt;JobInfo&gt; getAllPendingJobs()</code>：获取当前未处理的任务列表；</li>
<li><code>JobInfo getPendingJob(int jobId)</code>： 根据<code>jobId</code>来获取对应未处理任务的信息；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JobScheduler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESULT_FAILURE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESULT_SUCCESS = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">schedule</span><span class="params">(JobInfo var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">enqueue</span><span class="params">(JobInfo job, JobWorkItem worker)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">(<span class="keyword">int</span> jobId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">cancelAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;JobInfo&gt; <span class="title">getAllPendingJobs</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> JobInfo <span class="title">getPendingJob</span><span class="params">(<span class="keyword">int</span> jobId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>JobScheduler</code>无法实例化，只能通过<code>getSystemService</code>接口来获取实例，在下面这个函数中， 首先构建一个任务用于定时同步服务器数据：</p>
<ul>
<li><code>setPeriordic</code>： 设置定时任务的时间间隔，如果没有设置则不是一个定时任务；</li>
<li><code>setPersisted</code>： 持久化任务数据，下次开机时该任务会自动启动，如果设置了该选项，则需要在<code>AndroidManifest.xml</code>中添加一个用户权限声明：<br>  <code>&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;</code>，这样任务在开机启动后，立刻启动任务调度；</li>
<li><code>setRequiredNetworkType</code>： 是否需要设置调度所需要的网络模式，比如可以设置是否在收费或者漫游情况下发起任务调度；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startDataSyncJobScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ComponentName jobService = <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, DataSyncJobService.class);</span><br><span class="line">	JobInfo.Builder builder = <span class="keyword">new</span> JobInfo.Builder(DATA_SYNC_JOB_ID, jobService);</span><br><span class="line">	builder.setPeriodic(DATA_SYNC_INTERVAL)</span><br><span class="line">		.setPersisted(<span class="keyword">true</span>)</span><br><span class="line">		.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY);</span><br><span class="line"></span><br><span class="line">	JobScheduler js = (JobScheduler)getSystemService(JOB_SCHEDULER_SERVICE);</span><br><span class="line">	js.schedule(builder.build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样系统就会定时向<code>DataSyncJobService</code>发起任务请求，这里需要注意的是，当Android系统进入低电量的睡眠模式时，<code>JobScheuduler</code>是不允许执行的，详细可以参考<a href="https://developer.android.com/training/monitoring-device-state/doze-standby.html" target="_blank" rel="noopener">休眠与待机</a> 。</p>
<h2 id="JobScheduler的原理"><a href="#JobScheduler的原理" class="headerlink" title="JobScheduler的原理"></a><strong>JobScheduler的原理</strong></h2><h3 id="JobSchedulerService初始化"><a href="#JobSchedulerService初始化" class="headerlink" title="JobSchedulerService初始化"></a>JobSchedulerService初始化</h3><p><code>JobSchedulerService</code>属于系统服务，因此在手机启动时，<code>SystemServer</code>进程会主动加载该服务。创建时，<code>JobSchedulerService</code>会依次初始化:</p>
<ul>
<li><code>JobHandler</code>： 用于处理请求的<code>Handler</code>;</li>
<li><code>JobSchedulerStub</code>:服务端stub类，用于处理客户端请求；</li>
<li><code>JobStore</code>: 持久化客户端请求数据</li>
<li><code>StateController</code>: 监听系统状态，以此触发任务调度</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JobSchedulerService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">    mHandler = <span class="keyword">new</span> JobHandler(context.getMainLooper());</span><br><span class="line">    mConstants = <span class="keyword">new</span> Constants(mHandler);</span><br><span class="line">    mJobSchedulerStub = <span class="keyword">new</span> JobSchedulerStub();</span><br><span class="line">    mJobs = JobStore.initAndGet(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the controllers.</span></span><br><span class="line">    mControllers = <span class="keyword">new</span> ArrayList&lt;StateController&gt;();</span><br><span class="line">    mControllers.add(ConnectivityController.get(<span class="keyword">this</span>));</span><br><span class="line">    mControllers.add(TimeController.get(<span class="keyword">this</span>));</span><br><span class="line">    mControllers.add(IdleController.get(<span class="keyword">this</span>));</span><br><span class="line">    mControllers.add(BatteryController.get(<span class="keyword">this</span>));</span><br><span class="line">    mControllers.add(AppIdleController.get(<span class="keyword">this</span>));</span><br><span class="line">    mControllers.add(ContentObserverController.get(<span class="keyword">this</span>));</span><br><span class="line">    mControllers.add(DeviceIdleJobsController.get(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统启动阶段，<code>JobSchedulerService</code>需要注册应用程序安装包监听器（监听APP是否被卸载、重启），同时需要将持久化的任务数据从存储中加载，重新启动这些任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBootPhase</span><span class="params">(<span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PHASE_SYSTEM_SERVICES_READY == phase) &#123;</span><br><span class="line">        mConstants.start(getContext().getContentResolver());</span><br><span class="line">        <span class="comment">// Register br for package removals and user removals.</span></span><br><span class="line">        <span class="keyword">final</span> IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">        filter.addAction(Intent.ACTION_PACKAGE_REMOVED);</span><br><span class="line">        filter.addAction(Intent.ACTION_PACKAGE_CHANGED);</span><br><span class="line">        filter.addAction(Intent.ACTION_PACKAGE_RESTARTED);</span><br><span class="line">        filter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);</span><br><span class="line">        filter.addDataScheme(<span class="string">"package"</span>);</span><br><span class="line">        getContext().registerReceiverAsUser(</span><br><span class="line">                mBroadcastReceiver, UserHandle.ALL, filter, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">final</span> IntentFilter userFilter = <span class="keyword">new</span> IntentFilter(Intent.ACTION_USER_REMOVED);</span><br><span class="line">        getContext().registerReceiverAsUser(</span><br><span class="line">                mBroadcastReceiver, UserHandle.ALL, userFilter, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        mPowerManager = (PowerManager)getContext().getSystemService(Context.POWER_SERVICE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManagerNative.getDefault().registerUidObserver(mUidObserver,</span><br><span class="line">                    ActivityManager.UID_OBSERVER_PROCSTATE | ActivityManager.UID_OBSERVER_GONE</span><br><span class="line">                    | ActivityManager.UID_OBSERVER_IDLE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// ignored; both services live in system_server</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (phase == PHASE_THIRD_PARTY_APPS_CAN_START) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="comment">// Let's go!</span></span><br><span class="line">            mReadyToRock = <span class="keyword">true</span>;</span><br><span class="line">            mBatteryStats = IBatteryStats.Stub.asInterface(ServiceManager.getService(</span><br><span class="line">                    BatteryStats.SERVICE_NAME));</span><br><span class="line">            mLocalDeviceIdleController</span><br><span class="line">                    = LocalServices.getService(DeviceIdleController.LocalService.class);</span><br><span class="line">            <span class="comment">// Create the "runners".</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_JOB_CONTEXTS_COUNT; i++) &#123;</span><br><span class="line">                mActiveServices.add(</span><br><span class="line">                        <span class="keyword">new</span> JobServiceContext(<span class="keyword">this</span>, mBatteryStats, mJobPackageTracker,</span><br><span class="line">                                getContext().getMainLooper()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Attach jobs to their controllers.</span></span><br><span class="line">            mJobs.forEachJob(<span class="keyword">new</span> JobStatusFunctor() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(JobStatus job)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> controller = <span class="number">0</span>; controller &lt; mControllers.size(); controller++) &#123;</span><br><span class="line">                        <span class="keyword">final</span> StateController sc = mControllers.get(controller);</span><br><span class="line">                        sc.maybeStartTrackingJobLocked(job, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// GO GO GO!</span></span><br><span class="line">            mHandler.obtainMessage(MSG_CHECK_JOB).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>JobSchedulerService</code>中共启动了16个<code>JobServiceContext</code>服务负责处理任务请求。接下来，就来看下<code>JobSchedulerService</code>是如何进行工作调度的。</p>
<h3 id="工作调度"><a href="#工作调度" class="headerlink" title="工作调度"></a><strong>工作调度</strong></h3><p>目前<code>JobSchedulerService</code>支持的任务调度主要有如下几个属性：</p>
<ul>
<li>周期性：给定时间间隔触发一次任务调度；</li>
<li>设备充电：是否需要设备当前正在充电；</li>
<li>设备空闲：要求任务调度时设备处于空闲状态；</li>
<li>数据库内容更改： 监听数据库内容状态，如有改变则触发任务调度；</li>
<li>网络连接： 指定网络链接时触发任务调度</li>
</ul>
<p>通过指定任务属性，我们可以发起一个定时任务，也可以指定某个网络条件下触发任务调度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobInfo</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/** Builder class for constructing &#123;<span class="doctag">@link</span> JobInfo&#125; objects. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mJobId;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ComponentName mJobService;</span><br><span class="line">        <span class="keyword">private</span> PersistableBundle mExtras = PersistableBundle.EMPTY;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> mPriority = PRIORITY_DEFAULT;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> mFlags;</span><br><span class="line">        <span class="comment">// Requirements.</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mRequiresCharging;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mRequiresDeviceIdle;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> mNetworkType;</span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;TriggerContentUri&gt; mTriggerContentUris;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> mTriggerContentUpdateDelay = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> mTriggerContentMaxDelay = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mIsPersisted;</span><br><span class="line">        <span class="comment">// One-off parameters.</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> mMinLatencyMillis;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> mMaxExecutionDelayMillis;</span><br><span class="line">        <span class="comment">// Periodic parameters.</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mIsPeriodic;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mHasEarlyConstraint;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mHasLateConstraint;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> mIntervalMillis;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> mFlexMillis;</span><br><span class="line">        <span class="comment">// Back-off parameters.</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> mInitialBackoffMillis = DEFAULT_INITIAL_BACKOFF_MILLIS;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> mBackoffPolicy = DEFAULT_BACKOFF_POLICY;</span><br><span class="line">        <span class="comment">/** Easy way to track whether the client has tried to set a back-off policy. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mBackoffPolicySet = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献 "></a><strong>参考文献 </strong></h2><ul>
<li>ASOP源代码路径： <a href="/android/frameworks/base/services/core/java/com/android/server/job/">/android/frameworks/base/services/core/java/com/android/server/job/ </a></li>
<li><a href="https://developer.android.com/training/monitoring-device-state/doze-standby.html" target="_blank" rel="noopener">https://developer.android.com/training/monitoring-device-state/doze-standby.html</a> </li>
<li>示例代码： <a href="https://github.com/runningforlife/AndroidExamples/tree/master/JobScheduler" target="_blank" rel="noopener">https://github.com/runningforlife/AndroidExamples/tree/master/JobScheduler</a> </li>
</ul>
<hr>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JobScheduler </tag>
            
            <tag> AlarmManager </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Circuit Switching & Packet Switching]]></title>
      <url>http://sniffer.site/2017/11/20/Circuit-Switching-Packet-Switching/</url>
      <content type="html"><![CDATA[<p>通信网络中的两个节点需要交换数据,通常有两种数据传输方式: <a href="https://en.wikipedia.org/wiki/Circuit_switching" target="_blank" rel="noopener">Circuit Switching</a> (CS, 链路交换)以及<a href="https://en.wikipedia.org/wiki/Packet_switching" target="_blank" rel="noopener">Packet Switching</a> (PS, 分组交换)。链路交换早在19世纪便在电讯行业中使用了。对于CS网络，呼叫方（caller）首先需要与被被叫方（callee）建立一个专用的链接，通信才可能进行，双方通信期间，需要占用一定的频带或者时间资源，通信结束，资源才会释放，如果网络出现拥塞，无法分配资源，则通信失败 。下图是链路交换网络通信示意图<a id="more"></a>：</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/CS.png" alt="CS" title="Circuit Switching"></p>
<p>分组交换（PS）是由于计算机网络的出现而开始广泛应用的。其目的是解决CS交换时出现的资源分配问题：需要预先分配资源，即使没有数据传输，资源依然被占用。PS网络，把所要传输的数据分割成一个个“数据包”，然后将其发送到网络，由网络来决定数据的传输路径。与CS交换方式不同的是，PS无需预先建立通信链接, 而是动态分配资源，也无需在通信结束后断开链路，但在“数据包”传输过程中，需要通过查找路由表（routing table，路由表）将数据在网络节点之间传递，因此不同的“数据包”使用的并不是同一个物理链接，每个“数据包”的路径是由路由算法来决定的。PS这种基于路由/寻址的想法也成为了后来演变成了如今的互联网(Internet).</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/PS.png" alt="PS" title="Packet Switching"></p>
<p>通常来说，由于CS在通信节点之间建立了专门的通信链路，因此可以保证通信质量，常见的如<a href="https://en.wikipedia.org/wiki/Public_switched_telephone_network" target="_blank" rel="noopener">PSTN</a> ，移动通信GSM中语音通话都采用了CS来传输数据；而PS通常用于对实时性要求不高的服务，如MMS/VoIP等。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="https://www.ietf.org/rfc/rfc3439.txt" target="_blank" rel="noopener">https://www.ietf.org/rfc/rfc3439.txt</a> </li>
<li><a href="https://en.wikipedia.org/wiki/PSTN_network_topology" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/PSTN_network_topology</a> </li>
<li><a href="http://www.cs.virginia.edu/~mngroup/projects/mpls/documents/thesis/node8.html" target="_blank" rel="noopener">http://www.cs.virginia.edu/~mngroup/projects/mpls/documents/thesis/node8.html</a> </li>
<li><a href="https://en.wikipedia.org/wiki/Switching_circuit_theory" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Switching_circuit_theory</a> </li>
<li><a href="http://www.rfwireless-world.com/Terminology/circuit-switching-vs-packet-switching.html" target="_blank" rel="noopener">http://www.rfwireless-world.com/Terminology/circuit-switching-vs-packet-switching.html</a> </li>
<li><a href="https://en.wikipedia.org/wiki/Circuit_switching" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Circuit_switching</a> </li>
<li><a href="http://dspace.mit.edu/handle/1721.1/11173" target="_blank" rel="noopener">A symbolic analysis of relay and switching circuits</a> </li>
<li><a href="http://www.rogerdmoore.ca/PS/" target="_blank" rel="noopener">Packet Switching-history</a></li>
<li><a href="https://www.rand.org/about/history/baran.html" target="_blank" rel="noopener">https://www.rand.org/about/history/baran.html</a></li>
<li><a href="https://livinginternet.com/i/iw_packet.htm" target="_blank" rel="noopener">https://livinginternet.com/i/iw_packet.htm</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Network Architecture </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CS </tag>
            
            <tag> PS </tag>
            
            <tag> computer network </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 动画]]></title>
      <url>http://sniffer.site/2017/11/18/Android-%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<p>Android为开发者提供了强大的动画功能，常见的有属性动画(<a href="https://developer.android.com/guide/topics/graphics/prop-animation.html" target="_blank" rel="noopener">property animation</a>)、视觉动画（<a href="https://developer.android.com/guide/topics/graphics/view-animation.html" target="_blank" rel="noopener">view anmiation</a>)以及可绘制对象动画(<a href="https://developer.android.com/guide/topics/graphics/drawable-animation.html" target="_blank" rel="noopener">Drawable Animation</a>)，属性动画可以用于任何对象（视图对象或者非视图对象）的任何属性，而视觉动画则只能用于可视对象的某些属性，如颜色，大小，以及旋转等;可绘制对象动画利用一系列<code>Drawable</code>资源创建连续的帧动画。</p>
<a id="more"></a>
<h2 id="Property-Animation（属性动画）"><a href="#Property-Animation（属性动画）" class="headerlink" title="Property Animation（属性动画）"></a><strong>Property Animation（属性动画）</strong></h2><h3 id="什么是属性动画"><a href="#什么是属性动画" class="headerlink" title="什么是属性动画"></a><strong>什么是属性动画</strong></h3><p>属性动画更改某个视图对象的属性值，如背景颜色或者alpha值，使其在某个时间段内变化，其主要由几个参数决定：</p>
<ul>
<li>持续时间：动画持续变化的时间；</li>
<li>时间插值器： 决定了对象属性值如何随着时间变化；</li>
<li>重复次数： 动画结束后是否重复</li>
</ul>
<p>下图表示了属性动画是如何构成的。<code>ValueAnimator</code>由一个时间插值器（<code>TimeInterpolator</code>)、类型估值器(<code>TypeEvaluator</code>)以及参数持续时间、起始值和终值决定。调用<code>start</code>开始动画，<code>ValueAnimator</code>通过插值器来计算消逝的时间比率；接着调用估值器来计算动画对象属性对应的值。最后，通过接口<code>AnimatorUpdateListener</code>来获取更新后当前的属性值。</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/how_valueanimator_calculated.png" alt="how animations are calculated"></p>
<p>Android提供了三种类型的属性动画，其都有一个共同的父类<code>android.animation.Animator</code>:</p>
<ul>
<li><code>ValueAnimator</code>: 该类已经计算出对象属性随时间变化的值，实际使用时需要通过监听器<code>AnimatorUpdateListener</code>来获取对应的值，然后将其应用到对象上；</li>
<li><code>ObjectAnimator</code>: 继承自<code>ValueAnimator</code>,允许指定目标对象以及对象属性来创建动画；</li>
<li><code>AnimatorSet</code>: 将多个<code>Animator</code>放在一起构成一个动画集，该动画集的动画可以一起播放也可以指定先后顺序；</li>
</ul>
<p>来看看插值器与估值器源码实现。插值器确定了对象值是怎么跟随时间变化的。以下是一个加速减速插值器示例（以下代码均来自Android7.0)，使用该插值器时，对象属性值先加速变化而后减速变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An interpolator where the rate of change starts and ends slowly but</span></span><br><span class="line"><span class="comment"> * accelerates through the middle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@HasNativeInterpolator</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccelerateDecelerateInterpolator</span> <span class="keyword">extends</span> <span class="title">BaseInterpolator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">NativeInterpolatorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccelerateDecelerateInterpolator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"UnusedDeclaration"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccelerateDecelerateInterpolator</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getInterpolation</span><span class="params">(<span class="keyword">float</span> input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>)(Math.cos((input + <span class="number">1</span>) * Math.PI) / <span class="number">2.0f</span>) + <span class="number">0.5f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">createNativeInterpolator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NativeInterpolatorFactoryHelper.createAccelerateDecelerateInterpolator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Android还提供了诸如<code>AccelerateInterpolator</code>,<code>AnticipateInterpolator</code>,<code>BounceInterpolator</code>,<code>CycleInterpolator</code>,<code>LinearInterpolator</code>等多种插值器。通过实现<code>TimeInterpolator</code>接口，用户可以自定义自己的插值函数。</p>
<p>由于目标对象存在多种类型的属性值，因此需要类型估值器来计算对应的属性值，常见的有<code>IntEvaluator</code>,<code>FloatEvaluator</code>,<code>ArgbEvaluator</code>。如下是一个整型估值器示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This evaluator can be used to perform type interpolation between &lt;code&gt;int&lt;/code&gt; values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntEvaluator</span> <span class="keyword">implements</span> <span class="title">TypeEvaluator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This function returns the result of linearly interpolating the start and end values, with</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;fraction&lt;/code&gt; representing the proportion between the start and end values. The</span></span><br><span class="line"><span class="comment">     * calculation is a simple parametric calculation: &lt;code&gt;result = x0 + t * (v1 - v0)&lt;/code&gt;,</span></span><br><span class="line"><span class="comment">     * where &lt;code&gt;x0&lt;/code&gt; is &lt;code&gt;startValue&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt; is &lt;code&gt;endValue&lt;/code&gt;,</span></span><br><span class="line"><span class="comment">     * and &lt;code&gt;t&lt;/code&gt; is &lt;code&gt;fraction&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, Integer startValue, Integer endValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> startInt = startValue;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(startInt + fraction * (endValue - startInt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，通过实现<code>TypeEvaluator&lt;T&gt;</code>接口，可以定义非<code>int</code>，<code>float</code>，<code>color</code>类型的估值器。</p>
<p>对于视图对象，可以创建动画的属性主要有：</p>
<ul>
<li><code>translationX</code>,<code>translationY</code>: 平移坐标</li>
<li><code>rotation</code>,<code>rotationX</code>,<code>rotationY</code>： 旋转坐标</li>
<li><code>scaleX</code>,<code>scaleY</code>: 缩放坐标</li>
<li><code>pivotX</code>,<code>pivotY</code>: 中心点坐标</li>
<li><code>x</code>,<code>y</code>: 坐标</li>
<li><code>alpha</code>: 透明度</li>
</ul>
<p>利用<code>ObjectAnimator</code>可以创建一个旋转摸个视图的动画:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ObjectAnimator rotate = ObjectAnimator.ofFloat(myView, <span class="string">"rotation"</span>, <span class="number">0.0f</span>, <span class="number">360f</span>);</span><br><span class="line">rotate.start();</span><br></pre></td></tr></table></figure>
<h3 id="使用属性动画"><a href="#使用属性动画" class="headerlink" title="使用属性动画"></a><strong>使用属性动画</strong></h3><p>那么，在实际应用中，如何创建一个属性动画？Android提供了两种方式，一种是通过<code>XML</code>资源，一个是通过代码。首先来看看第一种。</p>
<h4 id="在XML资源中声明动画"><a href="#在XML资源中声明动画" class="headerlink" title="在XML资源中声明动画"></a><strong>在XML资源中声明动画</strong></h4><p>属性动画位于<code>animator</code>的资源文件夹内：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">res/animator/filename.xml</span><br></pre></td></tr></table></figure>
<p>Android Studio中默认是没有该文件夹的，因此需要手动创建一个<code>animator</code>的资源文件夹。接着，在该文件夹新建一个名为<code>my_anim.xml</code>的<code>XML</code>文件： 属性动画资源对应的标签是<code>&lt;set&gt;</code>,表示一个动画资源集，可以包含多个属性动画，</p>
<blockquote>
<p>属性动画中，标签<code>&lt;animator&gt;</code>表示<code>ValueAnimator</code>,<code>&lt;objectAnimator&gt;</code>表示<code>ObjectAnimator</code>,<code>&lt;set&gt;</code>表示<code>AnimatornSet</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;set xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;animator android:duration=<span class="string">"@android:integer/config_mediumAnimTime"</span></span><br><span class="line">        android:valueTo=<span class="string">"1.0"</span></span><br><span class="line">        android:valueFrom=<span class="string">"0.0"</span></span><br><span class="line">        android:valueType=<span class="string">"floatType"</span></span><br><span class="line">        android:interpolator=<span class="string">"@android:interpolator/accelerate_decelerate"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;objectAnimator android:duration=<span class="string">"@android:integer/config_mediumAnimTime"</span></span><br><span class="line">        android:interpolator=<span class="string">"@android:interpolator/anticipate"</span></span><br><span class="line">        android:valueType=<span class="string">"floatType"</span></span><br><span class="line">        android:propertyName=<span class="string">"rotation"</span></span><br><span class="line">        android:valueTo=<span class="string">"360"</span></span><br><span class="line">        android:valueFrom=<span class="string">"0"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure>
<p>接着使用在代码中将动画资源加载到对象上即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AnimatorSet as = (AnimatorSet)AnimatorInflater.loadAnimator(getApplicationContext(), R.animator.fade_in);</span><br><span class="line">as.setTarget(myView);</span><br><span class="line">as.start();</span><br></pre></td></tr></table></figure>
<h4 id="使用代码创建动画"><a href="#使用代码创建动画" class="headerlink" title="使用代码创建动画"></a><strong>使用代码创建动画</strong></h4><p>创建一个改变视图对象透明度的动画:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ValueAnimator animator = ValueAnimator.ofFloat(<span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">animator.setDuration(<span class="number">500</span>);</span><br><span class="line">animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">        myView.setAlpha((<span class="keyword">float</span>) animation.getAnimatedValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在给定对象上创建一个旋转动画:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ObjectAnimator rotate = ObjectAnimator.ofFloat(mTxt, <span class="string">"rotation"</span>, <span class="number">0.0f</span>, <span class="number">360f</span>);</span><br><span class="line">rotate.setDuration(<span class="number">500</span>);</span><br><span class="line">rotate.start();</span><br></pre></td></tr></table></figure>
<h2 id="View-Animation（视觉动画）"><a href="#View-Animation（视觉动画）" class="headerlink" title="View Animation（视觉动画）"></a><strong>View Animation（视觉动画）</strong></h2><p>视图动画通过计算View的起点/终点，尺寸以及旋转等属性，产生一个补间动画(Tween Animation),其主要类型有：</p>
<ul>
<li><code>AlphaAnimation</code>(<code>&lt;alpha&gt;</code>): 透明度动画；</li>
<li><code>ScaleAnimation</code>（<code>&lt;scale&gt;</code>）:缩放动画;</li>
<li><code>TranslateAnimation</code>(<code>&lt;translate&gt;</code>):平移动画；</li>
<li><code>RotateAnimation</code>(<code>&lt;rotate&gt;</code>): 旋转动画；</li>
<li><code>AnimationSet</code>(<code>&lt;set&gt;</code>): 包含了上述几种动画的集合;</li>
</ul>
<p>与属性动画一样，视觉动画也有两种使用方式，一种是通过XML资源（位于<code>res/anim/filename.xml</code>），一种是通过代码加载。这里使用XML资源声明来看下如何使用视觉动画。</p>
<p>首先，声明所需动画资源：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;set xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;scale</span><br><span class="line">        android:interpolator=<span class="string">"@android:anim/accelerate_decelerate_interpolator"</span></span><br><span class="line">        android:fromXScale=<span class="string">"1.0"</span></span><br><span class="line">        android:toXScale=<span class="string">"1.4"</span></span><br><span class="line">        android:fromYScale=<span class="string">"1.0"</span></span><br><span class="line">        android:toYScale=<span class="string">"0.6"</span></span><br><span class="line">        android:pivotX=<span class="string">"50%"</span></span><br><span class="line">        android:pivotY=<span class="string">"50%"</span></span><br><span class="line">        android:fillAfter=<span class="string">"false"</span></span><br><span class="line">        android:duration=<span class="string">"700"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;set android:interpolator=<span class="string">"@android:anim/decelerate_interpolator"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;scale</span><br><span class="line">            android:fromXScale=<span class="string">"1.4"</span></span><br><span class="line">            android:toXScale=<span class="string">"0.0"</span></span><br><span class="line">            android:fromYScale=<span class="string">"0.6"</span></span><br><span class="line">            android:toYScale=<span class="string">"0.0"</span></span><br><span class="line">            android:pivotX=<span class="string">"50%"</span></span><br><span class="line">            android:pivotY=<span class="string">"50%"</span></span><br><span class="line">            android:startOffset=<span class="string">"700"</span></span><br><span class="line">            android:duration=<span class="string">"400"</span></span><br><span class="line">            android:fillBefore=<span class="string">"false"</span> /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;rotate</span><br><span class="line">            android:fromDegrees=<span class="string">"0"</span></span><br><span class="line">            android:toDegrees=<span class="string">"-45"</span></span><br><span class="line">            android:toYScale=<span class="string">"0.0"</span></span><br><span class="line">            android:pivotX=<span class="string">"50%"</span></span><br><span class="line">            android:pivotY=<span class="string">"50%"</span></span><br><span class="line">            android:startOffset=<span class="string">"700"</span></span><br><span class="line">            android:duration=<span class="string">"400"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/set&gt;</span><br><span class="line"></span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure>
<p>通过代码加载到指定对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AnimationSet scaleIn = (AnimationSet) AnimationUtils.loadAnimation(getApplicationContext(), R.anim.scale_in);</span><br><span class="line">myView.startAnimation(scaleIn);</span><br></pre></td></tr></table></figure>
<h2 id="Drawable-Animation"><a href="#Drawable-Animation" class="headerlink" title="Drawable Animation"></a><strong>Drawable Animation</strong></h2><p>可绘制对象动画通过加载一连串可绘制对象资源像电影一样将资源连续的播放出来，因此也称为帧动画(Frame Animation)。可绘制对象动画的使用方式与上述两种动画无异，首先在 <code>res/drawable/filename.xml</code>中添加一个动画资源文件<code>heart_fill_in</code>,对应的标签为<code>&lt;animation-list&gt;</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;animation-list xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:oneshot=<span class="string">"true"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item android:drawable=<span class="string">"@mipmap/ic_heart_0"</span></span><br><span class="line">        android:duration=<span class="string">"@android:integer/config_longAnimTime"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item android:drawable=<span class="string">"@mipmap/ic_heart_25"</span></span><br><span class="line">        android:duration=<span class="string">"@android:integer/config_longAnimTime"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item android:drawable=<span class="string">"@mipmap/ic_heart_75"</span></span><br><span class="line">        android:duration=<span class="string">"@android:integer/config_longAnimTime"</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;item android:drawable=<span class="string">"@mipmap/ic_heart_100"</span></span><br><span class="line">        android:duration=<span class="string">"@android:integer/config_longAnimTime"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/animation-list&gt;</span><br></pre></td></tr></table></figure>
<p>使用时，将其添加到<code>ImageView</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">myImageView.setBackgroundResource(R.drawable.heart_fill_in);</span><br><span class="line">AnimationDrawable ad = (AnimationDrawable)mHeart.getBackground();</span><br><span class="line">ad.start();</span><br></pre></td></tr></table></figure>
<p>这样就可以看到一个心被填充的动画。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="http://easings.net/en" target="_blank" rel="noopener">http://easings.net/en</a></li>
<li><a href="https://developer.android.com/guide/topics/graphics/overview.html" target="_blank" rel="noopener">https://developer.android.com/guide/topics/graphics/overview.html</a></li>
<li><a href="http://gizma.com/easing/" target="_blank" rel="noopener">http://gizma.com/easing/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Animation </tag>
            
            <tag> Property Animation </tag>
            
            <tag> Frame Animation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GSM短信的发送与接收]]></title>
      <url>http://sniffer.site/2017/10/15/GSM%E7%9F%AD%E4%BF%A1%E7%9A%84%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6/</url>
      <content type="html"><![CDATA[<p>在<a href="https://en.wikipedia.org/wiki/GSM" target="_blank" rel="noopener">GSM</a>中，短消息(SMS,Short Message Service)有两种发送模式，一个是文本模式（所有字符都以可读的字符发送），一种是PDU模式。文本模式下，SMS字符都依照GSM 03.38标准中的默认的7-bit字符表进行编码（表格如下):</p>
<a id="more"></a>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/gsm338_chars.png" alt="GSM3.38 charsets"></p>
<p>在PDU(Protocol Data Unit)模式下，SMS通过编码成特定的二进制串发送出去，在该模式下，PDU数据不仅包含了消息字符，还包括很多元数据，比如短信中心地址(SMSC),字符编码格式以及时间戳等。根据<a href="http://www.etsi.org/" target="_blank" rel="noopener">ETSI</a>标准(GSM 03.40 &amp; GSM 03.38), 单条短信采用7-bit编码时最长可达160个字符，若采用8-bit字符编码则最多包含140个字符，而对于中文、韩文以及日文等东亚文字通常需要16-bit编码，则实际上能发送的文本长度只有70个字符，因此发送长短信时，需要将长短信分割成多个单一的短信（每条短信的长度不超过160个字符)。</p>
<p>那么，如何区分长短信与普通的单条短信了？对于长短信，设置<code>TP-UDHI</code>bit位，用于标识信息包含了头信息；头信息<a href="https://en.wikipedia.org/wiki/User_Data_Header" target="_blank" rel="noopener">UDH</a>（User Data Header)中包含了长短信的引用编号（分割后对应的序列号)，这样SMS接收端就可以根据该序列号将分割前的短信恢复过来。</p>
<p>下面来看下PDU模式下，GSM如何接受与发送短信？</p>
<blockquote>
<p>参考文章： <a href="http://www.gsm-modem.de/sms-pdu-mode.html" target="_blank" rel="noopener">http://www.gsm-modem.de/sms-pdu-mode.html</a></p>
</blockquote>
<h2 id="接收短信"><a href="#接收短信" class="headerlink" title="接收短信"></a><strong>接收短信</strong></h2><p>PDU字符串除了文本数据外，还包含了短信中心地址(SMSC)以及时间戳等信息，所有数据均以十六进制/十进制八位字节或者半个八位字节(4-bit)。以下字符串是<code>Nokia 6110</code>中接收到来自<code>http://www.mtn.co.za/</code>的一条内容为<code>hellohello</code>的短信：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">07</span> <span class="number">917238010010F</span> <span class="number">5</span> <span class="number">040</span>BC87238880900F100009930925161958003C160 <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>这条短信包含了三个部分：（1）标识SMSC长度的八位字节(<code>07</code>);(2) SMSC(<code>917283010010F5</code>); (3) SMS_DELIVER部分。</p>
<table>
<thead>
<tr>
<th><strong>Octets</strong></th>
<th><strong>Description</strong></th>
<th><strong>Format</strong></th>
<th><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>07</td>
<td>SMSC长度</td>
<td>hex-octet</td>
<td>7个八位字节</td>
</tr>
<tr>
<td>91</td>
<td>SMSC地址类型</td>
<td>hex-octet</td>
<td>国际号码</td>
</tr>
<tr>
<td>7283010010F5</td>
<td>SMSC号码</td>
<td>semi-octet</td>
<td>+27381000015</td>
</tr>
<tr>
<td>04</td>
<td>SMS_DELIVER首个八位字节</td>
<td>hex-octet</td>
<td>TP-MMS,参考GSM 03.40</td>
</tr>
<tr>
<td>0B</td>
<td>地址长度</td>
<td>hex-octet</td>
<td>发送方地址长度为11</td>
</tr>
<tr>
<td>C8</td>
<td>TOA,发送方地址类型</td>
<td>hex-octet</td>
<td>参考GSM 03.40 TypeofAddress</td>
</tr>
<tr>
<td>7238880900F1</td>
<td>发送方号码</td>
<td>semi-octets</td>
<td>发送方号码</td>
</tr>
<tr>
<td>00</td>
<td>TP-PID, Protocol Identifier</td>
<td>hex-octet</td>
<td>参考GSM 03.40</td>
</tr>
<tr>
<td>00</td>
<td>TP-DCS, Data Coding Scheme</td>
<td>hex-octet</td>
<td>参考GSM 03.38</td>
</tr>
<tr>
<td>99309251619580</td>
<td>TP-SCTS, time-stamp</td>
<td>semi-octets</td>
<td>29/03/99 15:16:59</td>
</tr>
<tr>
<td>0A</td>
<td>TP-UDL, User Data Length</td>
<td>hex-octets</td>
<td>长度为10</td>
</tr>
<tr>
<td>E8329BFD4697D9EC37</td>
<td>TP-UD, User Data</td>
<td>8-bit octets表示7-bit数据</td>
<td>hellohello</td>
</tr>
</tbody>
</table>
<h2 id="发送短信"><a href="#发送短信" class="headerlink" title="发送短信"></a><strong>发送短信</strong></h2><p>以下是用Nokia 6110在PDU模式下发送“hellohello”消息的PDU字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">00</span> <span class="number">11</span> <span class="number">00</span> <span class="number">0B</span> <span class="number">91</span> <span class="number">6407281553F</span>8 <span class="number">00</span> <span class="number">00</span> AA <span class="number">0</span>A E8329BFD4697D9EC37</span><br></pre></td></tr></table></figure>
<p>与接收短信PDU格式相似，发送的短信也由3个部分组成: (1)SMSC的长度， 这里实际长度<code>00</code>表示使用保存在手机里的SMSC地址； (2) SMSC号码， 由于长度为0， 因此该部分不存在； (3) SMS_SUBMIT消息。</p>
<table>
<thead>
<tr>
<th>Octets</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>SMSC长度， 该字段是可选的， SMSC可以从手机读取</td>
</tr>
<tr>
<td>11</td>
<td>首个八位字节, 各个bit位的含义见GSM 03.40</td>
</tr>
<tr>
<td>00</td>
<td>SMS_SUBMIT计数， 基站每收到一个SMS_SUBMIT都相应的加1， 参考GSM 03.40</td>
</tr>
<tr>
<td>0B</td>
<td>地址长度， 11位的号码</td>
</tr>
<tr>
<td>91</td>
<td>地址类型(TOA), 91表示国际号码</td>
</tr>
<tr>
<td>6407281553F8</td>
<td>semi-octet字符串（<code>46708251358</code>）， 由于号码长度为奇数，因此会在尾部添加一个F，实际编码的号码为<code>46708251358</code></td>
</tr>
<tr>
<td>00</td>
<td>TP-PID, protocol identifier</td>
</tr>
<tr>
<td>00</td>
<td>TP-DCS, 短信文本编码方案，这里<code>00</code>表示采用的7-bit GSM默认的字符编码</td>
</tr>
<tr>
<td>AA</td>
<td>TP-Validaty-Period, 该字段可选</td>
</tr>
<tr>
<td>0A</td>
<td>TP-UDL, 短信文本长度，就是说这个短信数据长度为10*7个bit</td>
</tr>
<tr>
<td>E8329BFD4697D9EC37</td>
<td>TP-UD, 短信文本</td>
</tr>
</tbody>
</table>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="http://www.gsm-modem.de/sms-pdu-mode.html" target="_blank" rel="noopener">http://www.gsm-modem.de/sms-pdu-mode.html</a></li>
<li><a href="http://read.pudn.com/downloads122/doc/520173/SMS_PDU-mode.PDF" target="_blank" rel="noopener">http://read.pudn.com/downloads122/doc/520173/SMS_PDU-mode.PDF</a></li>
<li><a href="http://read.pudn.com/downloads150/sourcecode/embed/646395/Short%20Message%20in%20PDU%20Encoding.pdf" target="_blank" rel="noopener">http://read.pudn.com/downloads150/sourcecode/embed/646395/Short%20Message%20in%20PDU%20Encoding.pdf</a></li>
<li><a href="http://www.smartposition.nl/resources/sms_pdu.html" target="_blank" rel="noopener">http://www.smartposition.nl/resources/sms_pdu.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Mobile Communication </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GSM </tag>
            
            <tag> SMS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java Annotation]]></title>
      <url>http://sniffer.site/2017/10/08/Java-Annotation/</url>
      <content type="html"><![CDATA[<p>在Java中，Annotation(注解）是一种可添加到源码中的句法元数据(<a href="https://en.wikipedia.org/wiki/Java_annotation" target="_blank" rel="noopener">Java annotation</a>)，类、方法、变量、参数以及包都可以进行注解。</p>
<p>注解主要有如下几个用途:</p>
<ul>
<li>为编译器提供信息： 编译器使用annotation来检测错误或者消除警告；</li>
<li>编译或者部署时处理： 可以利用注解信息产生代码，XML文件等；</li>
<li>运行时处理： 可在运行时检查注解，产生相应的代码；</li>
</ul>
<a id="more"></a>
<h2 id="Java预定义注解类型"><a href="#Java预定义注解类型" class="headerlink" title="Java预定义注解类型"></a><strong>Java预定义注解类型</strong></h2><p>Java中<code>java.lang</code>内置有<code>@Deprecated</code>, <code>@Override</code>,以及<code>@SuppressWarnings</code>三个常用的注解：</p>
<ul>
<li><p><code>@Deprecated</code>： 用于标识一个元素弃用了，不再使用；</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(value=RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value=&#123;CONSTRUCTOR,FIELD,LOCAL_VARIABLE,METHOD,PACKAGE,PARAMETER,TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Override</code>： 该注解用于标识当前方法重载了父类中的方法,如果一个标识了<code>@Override</code>的方法没有重载父类中的方法，编译器会产生错误；</p>
</li>
</ul>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(value=METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(value=SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override&#123;&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p><code>@SuppressWarnings</code>：告知编译器忽略特定的警告，例如<code>@SuppressWarnings(&quot;unchecked&quot;)</code>让编译器忽略<code>unchecked</code>警告；<code>@SuppressWarnings(&quot;deprecation&quot;)</code>则用于忽略某个元素已经废弃的警告。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>除了上述注解外， Java还提供了应用于其他注解的注解，被称之为元注解(meta-annotations)，如<code>@Rentention</code>, <code>@Documented</code>, <code>@Target</code>,<code>@Inherited</code>:</p>
<table>
<thead>
<tr>
<th><strong>Annotation interface</strong></th>
<th><strong>Applicable to</strong></th>
<th><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Target</td>
<td>annotations</td>
<td>指定注解使用的元素类型(见下)</td>
</tr>
<tr>
<td>Retention</td>
<td>annotations</td>
<td>指定注解使用的方式，需要保留的时间，<code>RetentionPolicy.SOURCE</code>，<code>RetentionPolicy.CLASS</code>，  <code>RetentionPolicy.RUNTIME</code></td>
</tr>
<tr>
<td>Documented</td>
<td>annotations</td>
<td>使用了该注解的注解，都会用Javadoc工具进行处理，然后输出相应的文档</td>
</tr>
<tr>
<td>Inherited</td>
<td>annotations</td>
<td>标识某个注解是否能被子类锁继承</td>
</tr>
<tr>
<td>Resource</td>
<td>class or interface</td>
<td>声明单个资源</td>
</tr>
<tr>
<td>Resources</td>
<td>class or interface</td>
<td>声明多个资源</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>Target</code>中指定了注解的目标类型，<code>java.lang.annotation</code>中定义了枚举类型<code>ElementType</code>用于表示注解所使用的元素类型:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何自定义注解类型"><a href="#如何自定义注解类型" class="headerlink" title="如何自定义注解类型"></a><strong>如何自定义注解类型</strong></h2><p>Java Annotation使用关键字<code>@interface</code>来声明，自定义时需要注意几点：</p>
<ul>
<li>只允许使用<code>public</code>，<code>default</code>修饰符；</li>
<li>对于注解的属性值，只能使用<code>public</code>或者<code>default</code>修饰符；</li>
<li>注解的属性值类型，只能使用基本类型，<code>String</code>，<code>Class</code>,<code>Enum</code>，<code>Annotation</code>以及上述类型的一维数组；</li>
<li>可以为属性值定义默认值；</li>
</ul>
<p>这里，来看下Android中的一个注解示例<code>@RequestPermission</code>,当某个元素需要请求系统权限时，可以使用该注解标识：从定义可以看到，<code>@RequestPermission</code>只是在源码（不是运行时或者class文件中）中使用，可用于方法、构造函数、变量、参数以及注解等几种类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ANNOTATION_TYPE,METHOD,CONSTRUCTOR,FIELD,PARAMETER&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequiresPermission &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The name of the permission that is required, if precisely one permission</span></span><br><span class="line"><span class="comment">     * is required. If more than one permission is required, specify either</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #allOf()&#125; or &#123;<span class="doctag">@link</span> #anyOf()&#125; instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Specifies a list of permission names that are all required.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] allOf() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Specifies a list of permission names where at least one is required</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] anyOf() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If true, the permission may not be required in all cases (e.g. it may only be</span></span><br><span class="line"><span class="comment">     * enforced on certain platforms, or for certain call parameters, etc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">conditional</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Specifies that the given permission is required for read operations.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * When specified on a parameter, the annotation indicates that the method requires</span></span><br><span class="line"><span class="comment">     * a permission which depends on the value of the parameter (and typically</span></span><br><span class="line"><span class="comment">     * the corresponding field passed in will be one of a set of constants which have</span></span><br><span class="line"><span class="comment">     * been annotated with a &lt;code&gt;<span class="doctag">@RequiresPermission</span>&lt;/code&gt; annotation.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Target</span>(&#123;FIELD, METHOD, PARAMETER&#125;)</span><br><span class="line">    <span class="meta">@interface</span> Read &#123;</span><br><span class="line">        <span class="function">RequiresPermission <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> @RequiresPermission</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Specifies that the given permission is required for write operations.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * When specified on a parameter, the annotation indicates that the method requires</span></span><br><span class="line"><span class="comment">     * a permission which depends on the value of the parameter (and typically</span></span><br><span class="line"><span class="comment">     * the corresponding field passed in will be one of a set of constants which have been annotated with a &lt;code&gt;<span class="doctag">@RequiresPermission</span>&lt;/code&gt; annotation.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Target</span>(&#123;FIELD, METHOD, PARAMETER&#125;)</span><br><span class="line">    <span class="meta">@interface</span> Write &#123;</span><br><span class="line">        <span class="function">RequiresPermission <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> @RequiresPermission</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>源码: <code>/android/frameworks/base/core/java/android/annotation/RequiresPermission.java</code></p>
</blockquote>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a><strong>应用示例</strong></h2><p>那么，如何使用annotation？使用过<code>JUnit</code>测试框架的应该了解，<code>JUnit</code>就是使用注解来创建测试用例，并执行这些用例的。现在，我们就来模仿<code>JUnit</code>来写一个自定义的测试注解<code>@Test</code>。假定有一个类<code>MathsOperation</code>, 该类支持<code>add</code>以及<code>divide</code>两个数学操作，对于除法操作，如果除数为零，则抛出一个自定义的<code>InvalidParamterException</code>的异常， 因此如果任何除数为零的操作，都会抛出异常，此时可通过检测该异常来判断测试用例是否通过。</p>
<ul>
<li>定义<code>@Test</code>注解<code>Test.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.examples.jason.javecore.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.METHOD;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target</span> (value=METHOD)</span><br><span class="line"><span class="meta">@Retention</span> (RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This annotation attribute is used whether method throw assigned custom *exception </span></span><br><span class="line"><span class="comment">     * or not. If it throws custom exception, it means test case pass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? extends Exception&gt; expected() <span class="keyword">default</span> java.lang.Exception.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>InvalidParameterException.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.examples.jason.javecore.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class &lt;code&gt;InvalidParameterException&lt;/code&gt; is a subclass of &lt;code&gt;Exception&lt;/code&gt; class;</span></span><br><span class="line"><span class="comment"> * This class is used to throw exception when method arguments are invalid </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jason</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvalidParameterException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvalidParameterException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvalidParameterException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvalidParameterException</span><span class="params">(Throwable t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.message;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>MathsOperation.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.examples.jason.javecore.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * math operation class, which support two math operations</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jason</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathsOperation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> InvalidParameterException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidParameterException();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>)(a/b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>MathUnitTests.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.examples.jason.javecore.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * All test cases are written here with <span class="doctag">@Test</span> annotation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUnitTests</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span>(expected = InvalidParameterException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDivide</span><span class="params">()</span> <span class="keyword">throws</span> InvalidParameterException</span>&#123;</span><br><span class="line">        MathsOperation mp = <span class="keyword">new</span> MathsOperation();</span><br><span class="line">        mp.divide(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MathsOperation mp = <span class="keyword">new</span> MathsOperation();</span><br><span class="line">        <span class="keyword">int</span> s = mp.sum(<span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="number">13</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Sum Test Case Pass, output value is "</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>UnitTestRunner.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.examples.jason.javecore.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class is test suite runner, which will runs all test cases</span></span><br><span class="line"><span class="comment"> * provided in given test class. This class particularly check custom exception thrown by method. </span></span><br><span class="line"><span class="comment"> * If thrown exception match with expected exception mentioned on attributes of <span class="doctag">@Test</span> annotation, that means</span></span><br><span class="line"><span class="comment"> * test case is pass. This same scenario is used in JUnit as well.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitTestRunner</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runUnitTests</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class&lt;?&gt; testClass = Class.forName(className);</span><br><span class="line">            Object obj = testClass.newInstance();</span><br><span class="line">            Method[] methods = testClass.getMethods();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">                <span class="keyword">if</span>(method.isAnnotationPresent(com.examples.jason.javecore.annotation.Test.class))&#123;</span><br><span class="line">                    Test annotation = method.getAnnotation(Test.class);</span><br><span class="line">                    Class&lt;? extends Exception&gt; expectedClass = annotation.expected();</span><br><span class="line">                    <span class="keyword">if</span>(expectedClass != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            method.invoke(obj);</span><br><span class="line">                        &#125; <span class="keyword">catch</span>(InvocationTargetException e)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(e.getTargetException().getClass() == expectedClass)&#123;</span><br><span class="line">                                System.out.println(<span class="string">"Test Case Pass with InvalidParameterException"</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                                System.out.println(<span class="string">"Test Case Fail with an exception: "</span> + e.getMessage());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                            System.out.println(<span class="string">"Test Case Fail with an exception: "</span> + e.getMessage());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException cnfe)&#123;</span><br><span class="line">            cnfe.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UnitTestRunner utRunner = <span class="keyword">new</span> UnitTestRunner();</span><br><span class="line">        utRunner.runUnitTests(<span class="string">"com.examples.jason.javecore.annotation.MathUnitTests"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="https://stablekernel.com/the-10-step-guide-to-annotation-processing-in-android-studio/" target="_blank" rel="noopener">https://stablekernel.com/the-10-step-guide-to-annotation-processing-in-android-studio/</a></li>
<li><a href="https://medium.com/@aitorvs/annotation-processing-in-android-studio-7042ccb83024" target="_blank" rel="noopener">https://medium.com/@aitorvs/annotation-processing-in-android-studio-7042ccb83024</a></li>
<li><a href="https://medium.com/@iammert/annotation-processing-dont-repeat-yourself-generate-your-code-8425e60c6657" target="_blank" rel="noopener">https://medium.com/@iammert/annotation-processing-dont-repeat-yourself-generate-your-code-8425e60c6657</a></li>
<li><a href="https://web.archive.org/web/20140223113106/http://www.somanyword.com/2014/02/how-to-create-and-implement-custom-annotations-in-java/" target="_blank" rel="noopener">https://web.archive.org/web/20140223113106/http://www.somanyword.com/2014/02/how-to-create-and-implement-custom-annotations-in-java/</a></li>
<li><a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101" target="_blank" rel="noopener">http://hannesdorfmann.com/annotation-processing/annotationprocessing101</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Annotation </tag>
            
            <tag> Annotation Processor </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何在Android中查看进程状态]]></title>
      <url>http://sniffer.site/2017/09/22/%E5%A6%82%E4%BD%95%E5%9C%A8Android%E4%B8%AD%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
      <content type="html"><![CDATA[<p>在Android开发调试过程中，常需要使用<code>ps</code>指令用于获取当前系统进程的快照信息（如果想要获取进程动态信息，则需要使用<code>top</code>命令)。通过ADB SHELL连接上手机后，输入<code>adb shell</code>命令进入shell控制台, 输入<code>ps</code>即可查看当前系统所有进程信息：</p>
<a id="more"></a>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ps_all.png" alt="ps all process"></p>
<p>Android的PS指令在Linux的基础上做了很大的简化，使用<code>ps</code>查看一个进程的信息，大概有两种方式，一个是根据进程全名，一个是根据进程ID。比如，这里要获取Phone进程的信息:</p>
<ul>
<li>进程名</li>
</ul>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ps_process_name.png" alt="ps process name"></p>
<ul>
<li>进程ID</li>
</ul>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ps_pid.png" alt="ps PID"></p>
<blockquote>
<p>有关PS指令的具体代码可参考: <code>/android/system/core/toolbox/ps.c</code></p>
</blockquote>
<p>另外，通过<code>ps</code>指令，指定参数<code>-T</code>还可以查看进程内所有线程的状态：</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ps_threads.png" alt="ps threads"></p>
<p>上述<code>ps</code>指令输出各个参数有何含义？</p>
<table>
<thead>
<tr>
<th><strong>FIELD</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>USER</td>
<td>进程持有者名称</td>
</tr>
<tr>
<td>PID</td>
<td>进程ID</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程ID</td>
</tr>
<tr>
<td>VSIZE</td>
<td>进程在虚拟内存所占的空间大小(KB)</td>
</tr>
<tr>
<td>RSS</td>
<td>进程实际所使用的物理内存大小（KB)</td>
</tr>
<tr>
<td>WCHAN</td>
<td>Waiting Channel,  进程等待正在等待的某个事件，如果为空，则表示进程处于运行状态</td>
</tr>
<tr>
<td>PC</td>
<td>Program Counter, 程序计数器所保存的地址</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody>
</table>
<p>除了列表中的参数之外，输出的参数中还有一列用于表示进程状态，这里看到进程状态是<code>S</code>(sleeping)。通常进程可能有以下几个状态:</p>
<table>
<thead>
<tr>
<th><strong>缩写代号</strong></th>
<th><strong>进程状态</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>D</td>
<td>TASK_UNINTERRUPTABLE</td>
<td>uninterruptible sleeping, cannot be woken up</td>
</tr>
<tr>
<td>S</td>
<td>TASK_INTERRUPTABLE</td>
<td>sleeping, can be woken up</td>
</tr>
<tr>
<td>R</td>
<td>TASK_RUNNING</td>
<td>task currently running</td>
</tr>
<tr>
<td>T</td>
<td>TASK_STOPPED</td>
<td>traced or stopped</td>
</tr>
<tr>
<td>Z</td>
<td>TASK_ZOMBIE</td>
<td>zombie process, terminated and parent not waiting</td>
</tr>
</tbody>
</table>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="https://www.cyberciti.biz/faq/show-all-running-processes-in-linux/" target="_blank" rel="noopener">https://www.cyberciti.biz/faq/show-all-running-processes-in-linux/</a></li>
<li><a href="https://ss64.com/bash/ps.html" target="_blank" rel="noopener">https://ss64.com/bash/ps.html</a></li>
<li><a href="http://www.unix.com/man-page/All/1b/ps/" target="_blank" rel="noopener">http://www.unix.com/man-page/All/1b/ps/</a></li>
<li><a href="http://www.petefreitag.com/tools/man-pages/ps.html" target="_blank" rel="noopener">http://www.petefreitag.com/tools/man-pages/ps.html</a></li>
<li><a href="https://events.linuxfoundation.org/images/stories/pdf/lf_abs12_kobayashi.pdf" target="_blank" rel="noopener">https://events.linuxfoundation.org/images/stories/pdf/lf_abs12_kobayashi.pdf</a></li>
<li><a href="https://access.redhat.com/sites/default/files/attachments/processstates_20120831.pdf" target="_blank" rel="noopener">https://access.redhat.com/sites/default/files/attachments/processstates_20120831.pdf</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 进程状态，Shell指令 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTP简介]]></title>
      <url>http://sniffer.site/2017/08/23/HTTP%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>HTTP(Hypertext Transfer Protocol)即超文本传输协议，是一种用于传输文本、音视频等超媒体(hypermedia)的应用层协议。HTTP从1990年开始就应用于WWW(World Wide Web)服务中,其发展变化与WEB服务紧密相连。这篇文章，就来看看HTTP协议的基本概念。</p>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h2><p>HTTP协议允许不同类型的客户端与服务端进行通讯，支持不同的网络配置，并不依赖于特定的系统。在消息交换过程中，不保存任何状态（state-less,状态无关)。HTTP协议请求基于Request/Response，一个客户端向服务端发送request，该请求包含了Request Method, URL，协议版本以及请求的资源类型；服务端得到请求后，返回一个response,包括状态信息（协议版本，状态码)以及请求的资源。这样一次Request/Response的过程我们称为一次HTTP会话(session)，大致有三个阶段：</p>
<ol>
<li>客户端与服务端建立一个TCP链接；</li>
<li>客户端发送数据请求，等待回应；</li>
<li>服务端处理请求，返回结果并提供一个状态码与资源；</li>
</ol>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/http1-request-response.png" alt="HTTP Request-Response"></p>
<p>了解TCP/IP的人应该知道，网络协议是一个分层的结构，由物理层、链路层、网络层、传输层以及应用层组成。物理层与链路层负责处理不同网络底层通信细节，如网络接口，网络速率等；网络层主要负责数据的路由，传输层主要负责数据分包、数据重传、拥塞控制，而应用层协议则通常与某个业务需求紧密相关，在某些特定的场景下使用，如HTTP用于WEB应用，而DNS则用于域名解析，FTP协议用于文件传输，EMAIL协议则用于电子邮件的发送与接收。HTTP协议一般通过TCP协议来进行会话，对应的TCP端口为80(有时也会用8080),而对于加密版HTTP协议HTTPS，则使用443端口。</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/NetworkProtocolLayer.png" alt="Network Protocol Layer"></p>
<p>既然HTTP是用于Web中获取资源（这个资源可以是一个文档，一张图片或者一个视频），那么HTTP是如何知道资源所在的位置了？在HTTP，对每个资源都有一个唯一的识别符URI(<a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier" title="Uniform Resource Identifier" target="_blank" rel="noopener">Uniform Resource Identifier</a>),常见的URI有两种:一种是URL(<a href="https://en.wikipedia.org/wiki/URL" target="_blank" rel="noopener">Uniform Resource Locator</a>),就是我们通常所说的WEB地址；一种是URN(<a href="https://en.wikipedia.org/wiki/Uniform_Resource_Name" target="_blank" rel="noopener">Uniform Resource Name</a>:</p>
<blockquote>
<p>URL示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https:<span class="comment">//developer.mozilla.org</span></span><br><span class="line">https:<span class="comment">//developer.mozilla.org/en-US/docs/Learn/</span></span><br><span class="line">https:<span class="comment">//developer.mozilla.org/en-US/search?q=URL</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>URN示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">urn:isbn:<span class="number">9780141036144</span></span><br><span class="line">urn:ietf:rfc:<span class="number">7230</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们来看下URI是怎么构成的。</p>
<h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a><strong>URI</strong></h2><p>如下图是一个URI的结构示意图：</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/URL%20Structure.png" alt="URI structure"></p>
<h3 id="scheme"><a href="#scheme" class="headerlink" title="scheme"></a><strong>scheme</strong></h3><p><code>https://</code>属于URI的协议部分，用来标识浏览器所使用的协议，对WEB服务来说，通常使用<strong>HTTP</strong>或者<strong>HTTPS</strong>协议。常用的scheme有如下几种：</p>
<table>
<thead>
<tr>
<th><strong>scheme</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>Data URI</td>
</tr>
<tr>
<td>file</td>
<td>host-specific file names</td>
</tr>
<tr>
<td>ftp</td>
<td>File transfer protocol</td>
</tr>
<tr>
<td>http/https</td>
<td>hyper text transfer protocol(secure)</td>
</tr>
<tr>
<td>mailto</td>
<td>electronic mail address</td>
</tr>
<tr>
<td>ssh</td>
<td>secure shell</td>
</tr>
<tr>
<td>tel</td>
<td>telephone</td>
</tr>
<tr>
<td>urn</td>
<td>Uniform Resource Names</td>
</tr>
<tr>
<td>view-source</td>
<td>source code of the resource</td>
</tr>
<tr>
<td>ws/wss</td>
<td>(encrypted) websocket connections</td>
</tr>
</tbody>
</table>
<h3 id="Authority"><a href="#Authority" class="headerlink" title="Authority"></a><strong>Authority</strong></h3><p><code>tools.ietf.org</code>又称为域名，该域名标识了一个WEB服务器的地址。通常，我们也可以直接使用该WEB服务器的IP地址来访问，但是在WEB中比较少用。</p>
<h3 id="Port"><a href="#Port" class="headerlink" title="Port"></a><strong>Port</strong></h3><p><code>:443</code>是HTTP进行数据交换的TCP端口，如果一个WEB服务器使用的是HTTP的标准端口(HTTP:80; HTTPS: 44),则在URI中可以忽略，否则需要特别指出。</p>
<h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a><strong>Path</strong></h3><p><code>/html/rfc7320</code>表示某个资源在WEB服务器中的路径，通过该路径WEB服务器查找到用户请求的资源。</p>
<h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a><strong>Query</strong></h3><p><code>?query</code>部分是提供给WEB服务器的额外参数，其通常是如下形式的<code>&lt;key,value&gt;</code>对：<code>?k1=v1&amp;k2=v2</code>，例如在使用搜索引擎时，关键词就会以这样的形式呈现给WEB服务器。如下是在Google输入Android后浏览器地址栏显示的部分结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https://www.google.co.kr/search?newwindow=1&amp;site=&amp;source=hp&amp;q=Android</span><br></pre></td></tr></table></figure>
<h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a><strong>Fragment</strong></h3><p><code>#section-2.7</code>可以看做是一个资源某个部分的一个索引或者书签，通过该字段，我们可以直接访问到某个WEB页面的某一部分。需要注意的时，HTTP发送资源请求时，<code>#Fragment</code>部分并不会发送到服务器，这个部分是由浏览器来处理的， 浏览器会根据这个标签将页面滑动到相应的位置。</p>
<h2 id="HTTP消息"><a href="#HTTP消息" class="headerlink" title="HTTP消息"></a><strong>HTTP消息</strong></h2><p>HTTP消息定义了客户端与服务端如何进行数据的交换，这里有两种类型的消息：一种是客户端发送的请求(request)，一种是服务端发送的响应(responses)。接下来，就来详细的看下HTTP两类消息的构成。</p>
<p>HTTP请求跟响应总体上结构很相似，主要由四个部分组成(下图所示）：</p>
<ol>
<li>一个单一的起始行(<em>start-line</em>):起始行描述的是请求的类型（获取数据还是写入数据）或者服务端响应的状态是成功或者失败。</li>
<li>HTTP头(headers): 描述请求类型或者消息的主体部分（body);</li>
<li>一个空白行用于表示所有元数据(meta-information)已经发送完毕；</li>
<li>可选的消息主体(body),如请求的内容或者服务端相应的数据。一般，消息主体的存在以及大小需要在起始行和HTTP头中指定。</li>
</ol>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/HTTP%20Message.png" alt="HTTP message structure"></p>
<h3 id="HTTP-Request"><a href="#HTTP-Request" class="headerlink" title="HTTP Request"></a><strong>HTTP Request</strong></h3><p>一个HTTP请求由三个部分组成：</p>
<ul>
<li>start line;</li>
<li>http headers;</li>
<li>body</li>
</ul>
<h4 id="start-line"><a href="#start-line" class="headerlink" title="start line"></a><strong>start line</strong></h4><p>HTTP的<em>start line</em>用于标识客户端想要服务器执行的某个动作，例如是GET某个数据，还是上传某个数据，其有三个要素组成：</p>
<ol>
<li><p>HTTP method:该HTTP请求所要执行的动作，主要有以下几类：</p>
<ul>
<li><strong>GET</strong>(需要大写）： 从服务端获取指定的资源，可以是一个文档，一张图片，一个视频等；</li>
<li><strong>PUT</strong>:创建一个新的资源或者用新的数据取代目标资源；</li>
<li><strong>POST</strong>: 提交某个资源，例如对已存在的资源进行注释；提交一个表单；发布消息到新闻组，邮件列表等；通过附加操作扩展一个数据库；</li>
<li><strong>DELETE</strong>: 删除某个特定的资源；</li>
<li><strong>TRACE</strong>: 用于发起一个远端的回环(loop-back)的消息请求；</li>
<li><strong>CONNECT</strong>: 用于建立一个到服务端的网络隧道(tunnel)；</li>
<li><strong>HEAD</strong>: 请求一个与<strong>GET</strong>命令请求相同的response,但是不包含消息主体(body);</li>
<li><strong>OPTIONS</strong>: 为目标资源描述会话的可选项</li>
</ul>
</li>
<li><p>请求资源的URL, URL在不同的情况下可以是：</p>
<ul>
<li>绝对路径，通常后面会有一个<code>?</code>以及一个查询字符串，一般与<strong>GET</strong>,<strong>POST</strong>，<strong>HEAD</strong>以及<strong>OPTIONS</strong>搭配使用： <code>POST / HTTP/1.1</code>, <code>GET /background.png HTTP/1.1</code>;</li>
<li>完整的URL，通常连接一个代理服务器时与<strong>GET</strong>方法一起使用：<code>GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1</code></li>
<li>一个URL的authority部分，包含了域名跟端口号： <code>CONNECT developer.mozilla.org:80 HTTP/1.1</code></li>
<li>与<strong>OPTIONS</strong>方法一起使用的星号(<code>*</code>):  <code>OPTIONS * HTTP/1.1</code></li>
</ul>
</li>
<li>HTTP版本号，用于告知服务端接收请求响应时所期望的HTTP版本；</li>
</ol>
<h4 id="HTTP-Headers"><a href="#HTTP-Headers" class="headerlink" title="HTTP Headers"></a><strong>HTTP Headers</strong></h4><p>HTTP头用于客户端向服务端发送关于请求或者响应的额外信息，比如字符的编码方式，语言等，这些信息可以分成如下三个部分：</p>
<ul>
<li>一般性头信息(General Header): 对于请求与响应都适用;</li>
<li>请求头信息(Request Header): 关于HTTP请求的附加信息</li>
<li>实体头信息(Entity Header): 适用于请求主体(body)的附加信息</li>
</ul>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/HTTP%20Headers.png" alt="HTTP header"></p>
<blockquote>
<p>有关HTTP头的详细信息可以参考:<a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/List_of_HTTP_header_fields</a></p>
</blockquote>
<h4 id="Request-Body"><a href="#Request-Body" class="headerlink" title="Request Body"></a><strong>Request Body</strong></h4><p>通常情况下，HTTP请求不包主体，除非客户端有数据需要更新到服务器上，此时一般由HTTP头<code>Content-Length</code>,<code>Content-Type</code>来确定消息体的数据类型以及长度。</p>
<h3 id="HTTP-Response"><a href="#HTTP-Response" class="headerlink" title="HTTP Response"></a><strong>HTTP Response</strong></h3><p>与HTTP请求相类似，HTTP响应也有三部分组成：</p>
<ol>
<li><em>status line</em>: 状态行主要包括HTTP协议版本、状态码以及状态码描述字符串组成。例如<code>HTTP/1.1 404 NOT FOUND</code>；</li>
<li><em>Headers</em>: 响应的头跟请求的头信息有相同的结构（可参考上节关于请求头信息的描述），也包含了三个类型的头信息<ul>
<li>General Headers: 适用于整个消息；</li>
<li>Response Headers: 描述有关服务端的信息；</li>
<li>Entity Headers: 适用于消息主体部分；</li>
</ul>
</li>
<li><em>body</em>： 并不是所有的HTTP响应都有主体部分，像<strong>204，201</strong>状态码对应的响应就不需要。</li>
</ol>
<p>最后一部分，我们来看下服务端响应客户端请求后返回的状态码以及具体的含义。</p>
<h3 id="status-code"><a href="#status-code" class="headerlink" title="status code"></a><strong>status code</strong></h3><p>HTTP的状态码是一个3位数表示，其作用是告知客户端如何解析服务端的响应，共有5种类型的状态码：</p>
<h4 id="1xx-informational"><a href="#1xx-informational" class="headerlink" title="1xx: informational"></a><strong>1xx: informational</strong></h4><p>服务端告知客户端继续或者执行某个操作：</p>
<ul>
<li>100： continue, 表示客户端可以继续发送HTTP请求；</li>
<li>101： switching protocols, 切换协议；</li>
</ul>
<h4 id="2xx-Successful"><a href="#2xx-Successful" class="headerlink" title="2xx: Successful"></a><strong>2xx: Successful</strong></h4><p>这类状态码用于告知客户端，服务端已经成功收到并处理了HTTP请求：</p>
<ul>
<li>200： OK, 请求成功；</li>
<li>202： Accepted, 请求已经被接收到，但是尚未完成处理；</li>
</ul>
<h4 id="3xx-Redirection"><a href="#3xx-Redirection" class="headerlink" title="3xx: Redirection"></a><strong>3xx: Redirection</strong></h4><p>重定向：需要用户的做进一步的操作，通常需要跳至一个不同的URL去获取资源</p>
<ul>
<li>301： moved permanently, 资源已经更换到一个新的URL；</li>
<li>303:  see other, 需要通过另外一个URL来获取资源；</li>
</ul>
<h4 id="4xx-Client-error"><a href="#4xx-Client-error" class="headerlink" title="4xx: Client error"></a><strong>4xx: Client error</strong></h4><p>服务端认为客户端出错时发送此状态码，如访问一个无效的资源或者请求有误：</p>
<ul>
<li>400： bad reqeust, 请求有误；</li>
<li>401: unauthorized, 请求需要验证；</li>
<li>403： forbidden, 服务器拒绝访问资源；</li>
<li>404: Not found, 请求的资源不存在</li>
</ul>
<h4 id="5xx-Server-error"><a href="#5xx-Server-error" class="headerlink" title="5xx: Server error"></a><strong>5xx: Server error</strong></h4><p>此类状态码表示服务器处理请求时出现了错误：</p>
<ul>
<li>500： internal server error, 服务器自身出错；</li>
<li>501： not implemented, 服务器尚未实现该请求；</li>
<li>503： service unavailable, 服务不用，如服务故障或者过载</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="https://code.tutsplus.com/tutorials/http-the-protocol-every-web-developer-must-know-part-1--net-31177" target="_blank" rel="noopener">https://code.tutsplus.com/tutorials/http-the-protocol-every-web-developer-must-know-part-1–net-31177</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP</a></li>
<li><a href="https://inst.eecs.berkeley.edu/~ee233/sp06/student_presentations/EE233_TCPIP.pdf" target="_blank" rel="noopener">https://inst.eecs.berkeley.edu/~ee233/sp06/student_presentations/EE233_TCPIP.pdf</a></li>
<li><a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2616</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 网络协议 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用哈希函数C实现]]></title>
      <url>http://sniffer.site/2017/08/06/%E5%B8%B8%E7%94%A8%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0C%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>哈希函数（<a href="https://en.wikipedia.org/wiki/Hash_function" target="_blank" rel="noopener">hash function</a>)是一个将某个集合内的元素映射到一个大小固定的元素集合的函数，其在数据查找、数据去重等方面有着许多的应用。这里，就来看看常用的一些哈希函数是如何来实现的。</p>
<a id="more"></a>
<h2 id="0-RsHash"><a href="#0-RsHash" class="headerlink" title="0. RsHash"></a><strong>0. RsHash</strong></h2><p>最简单的一种Hash函数实现方法，来自于Rober Sedgwicks的C语言算法书:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">RsHash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">378551</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">63689</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        hash = hash * a + (*str++);</span><br><span class="line">        a *= b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-JsHash"><a href="#1-JsHash" class="headerlink" title="1. JsHash"></a><strong>1. JsHash</strong></h2><p>由Justin Sobel提出的Hash函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">JsHash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">1315423911</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        hash ^= ((hash &lt;&lt; <span class="number">5</span>) + (*str++) + (hash &gt;&gt; <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-PjwHash"><a href="#2-PjwHash" class="headerlink" title="2. PjwHash"></a><strong>2. PjwHash</strong></h2><p>PwjHash是由AT&amp;T的Peter J.Wenberger提出的Hash算法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">PjwHash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> bitsOfUnsignedInt = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) * <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> threeQuarters = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((bitsOfUnsignedInt * <span class="number">3</span>)/<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> halfQuarter = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(bitsOfUnsignedInt/<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> highBits = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="number">0xFFFFFFFF</span> &lt;&lt;(bitsOfUnsignedInt - halfQuarter));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> test = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        hash = (hash &lt;&lt; halfQuarter) + (*str++);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((test = hash &amp; highBits) != <span class="number">0</span>)&#123;</span><br><span class="line">            hash = ((hash^(test &gt;&gt; threeQuarters)) &amp; (~highBits));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-ElfHash"><a href="#3-ElfHash" class="headerlink" title="3. ElfHash"></a><strong>3. ElfHash</strong></h2><p>该Hash函数在UNIX系统中有着广泛的应用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ElfHash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">4</span>) + (*str++);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((x = hash &amp; <span class="number">0xF0000000</span>L) != <span class="number">0</span>)&#123;</span><br><span class="line">            hash ^= (x &gt;&gt; <span class="number">24</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hash &amp;= ~x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-BkdrHash"><a href="#4-BkdrHash" class="headerlink" title="4. BkdrHash"></a><strong>4. BkdrHash</strong></h2><p>由Brian Kernighan和Dennis Ritchie在《C Programming Language》中提出的Hash算法:</p>
<blockquote>
<p>Java中的<code>hashCode()</code>函数通常使用该方法实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BkdrHash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seed = <span class="number">131</span>; <span class="comment">/*31 131 1313 13131 131313 etc*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        hash = (hash * seed) + (*str++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-SdbmHash"><a href="#5-SdbmHash" class="headerlink" title="5. SdbmHash"></a><strong>5. SdbmHash</strong></h2><p>在开源项目SDBM中使用的一个Hash算法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">SdbmHash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        hash = (*str++) + (hash &lt;&lt; <span class="number">6</span>) + (hash &lt;&lt; <span class="number">16</span>) - hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-DjbHash"><a href="#6-DjbHash" class="headerlink" title="6. DjbHash"></a><strong>6. DjbHash</strong></h2><p>由Daniel J.Bernstein教授提出的一个Hash算法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">DjbHash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">5381</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span> + hash) + (*str++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-DekHash"><a href="#7-DekHash" class="headerlink" title="7. DekHash"></a><strong>7. DekHash</strong></h2><p>Donald E.Knuth提出的一个hash函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">DekHash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>)^(hash &gt;&gt; <span class="number">27</span>))^(*str++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-ApHash"><a href="#8-ApHash" class="headerlink" title="8. ApHash"></a><strong>8. ApHash</strong></h2><p>由Arash Partow提出的一种Hash算法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ApHash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        hash ^= ((i &amp; <span class="number">1</span> == <span class="number">0</span>) ? (((hash &lt;&lt; <span class="number">7</span>)^(*str)) * (hash &gt;&gt; <span class="number">3</span>)) :</span><br><span class="line">                                (~((hash &lt;&lt; <span class="number">11</span>) + (*str)^(hash &gt;&gt; <span class="number">5</span>))));</span><br><span class="line">        ++str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="http://www.partow.net/programming/hashfunctions/" target="_blank" rel="noopener">http://www.partow.net/programming/hashfunctions/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法/数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hash Function </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cache揭秘]]></title>
      <url>http://sniffer.site/2017/07/16/cache%E6%8F%AD%E7%A7%98/</url>
      <content type="html"><![CDATA[<p>缓存(Memory Cache)在一般意义上是指一种用于存储当前或者历史数据的硬件或者软件结构，其目的是加速数据的存取，提升系统效率。这里，将要讨论的cache是指CPU与主内存之间的一种基于<a href="https://en.wikipedia.org/wiki/Static_random-access_memory" target="_blank" rel="noopener">SRAM</a>(Static Random Access Memory)存储结构。</p>
<p>自计算机诞生以来，CPU的性能大致都按照摩尔定律以每年50%的速度递增，而主内存RAM(Random Access Memory)的性能增速却只有7%，<a id="more"></a>因此在CPU性能与主内存性能之间渐渐形成了一个鸿沟：</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/CPU-and-RAM-gap.jpg" alt="CPU and Memory Gap"></p>
<blockquote>
<p>1980年CPU中尚无cache; 到1995年CPU开始有两级cache</p>
</blockquote>
<p>从主内存中读取数据通常需要花费50~200个CPU周期，利用cache来保存CPU最近使用的数据或者指令，如果cache中存在所需数据（指令），则直接返回给CPU；如果不存在相应的数据，则从主内存中获取，从而提升CPU效率。这样Cache, Main Memory以及Disk（磁盘）之间就形成了通常被称为”<a href="https://en.wikipedia.org/wiki/Memory_hierarchy" target="_blank" rel="noopener">Memory Hierarchy</a>“的存储层次化的结构：</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/MemoryHierarchyOfProcessor.png" alt="memory hierarchy"></p>
<p>那么，为什么cache能够提升CPU的运行效率？这里边依靠的是程序运行时的一个基本原理：引用的局部性(<br><a href="https://en.wikipedia.org/wiki/Locality_of_reference" target="_blank" rel="noopener">Locality of reference</a>):相近的或者最近被访问的内存区域通常就是下一次需要访问的内存区域。最常见的是两种局部性：</p>
<ul>
<li>时间局部性（Temporal locality) : 最近被访问的内存区域，很可能在稍后的时间里被引用；</li>
<li>空间局部性(Spatial locality): 某个内存区域被访问，很可能稍后其临近的区域也会被访问；</li>
</ul>
<p>接下来就来看下cache是怎么构成的。</p>
<h2 id="缓存架构"><a href="#缓存架构" class="headerlink" title="缓存架构"></a><strong>缓存架构</strong></h2><p>下图是一个有256 (2^8) 个缓存行,4KB（2^10)大小的cache架构框图，可以看到，cache由两部分组成：cache controller，以及cache memory； cache memory是由一内存单元阵列组成的专用存储结构，其中每一个存储单元被称为cache lines（缓存行）;而cache controller负责将CPU发送过来的地址映射到cache memory，选取相应的cache memory：</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ARM-cache-architecture.jpg" alt="Cache Architecture"></p>
<blockquote>
<p>图片来自《ARM System Develop’s Guide - Designing and Optimizting System Software》</p>
</blockquote>
<p>一个cache line由三个部分组成：目录项，数据区以及状态。目录项也叫作cache tag,用于标识一个cache line是主内存中的来源（地址）；而从主内存中拷贝过来的数据则保持在数据区,而状态位则用于保持cache line的状态信息，通常有valid(有效）跟dirty（脏数据）两种状态。有效则意味着缓存数据保持的是最新的主内存数据，而脏数据则表示一个缓存行中的数据跟主内存不同。</p>
<p>CPU有数据或者指令请求时，首先被cache controller截取，controller会把内存地址分为三个部分：<code>tag</code>标签域，<code>set index</code>集合索引域，<code>data index</code>数据索引域。利用<code>set index</code>来定位可能包含内存数据的缓存行。刚才我们说道，每个缓存行都有个一个<code>cache tag</code>，controller正是通过这个标签域与状态位来确定数据是否存在。如果一个缓存行的状态为是<code>valid</code>，并且内存地址的<code>tag</code>与缓存行的<code>tag</code>相同，则命中缓存（<code>cache hit</code>)，否则出现缓存缺失(<code>cache miss</code>)。</p>
<ul>
<li>cache miss: 出现缓存缺失，cache controller需要将主内存中的数据拷贝到缓存中，并将其提供给CPU；</li>
<li>cache hit: 缓存命中，直接将命中缓存数据发送给CPU（利用<code>data index</code>确定数据所在位置）；</li>
</ul>
<p>那么，主内存是如何映射到cache当中的了？学过中学数学的都知道，两个集合的映射一般有一对一，多对一、一对多、多对多等几种形式。与此相类似，主内存与cache直接的物理映射（通过硬件设计实现）大致有三种形式：</p>
<ul>
<li>Directed Mapping(直接映射）： 对于主内存中的任一地址仅有一个可能的cache地址。这种映射方式最为简单，其存在的不足之处容易出现“缓存抖动”(<a href="https://en.wikipedia.org/wiki/Thrashing_(computer_science" target="_blank" rel="noopener">cache thrashing</a>)) - 不断出现缓存缺失，从而降低系统性能；</li>
<li>Full-associative cache（全关联）： 对每个主内存中的地址可以映射到任何一个cache位置。全关联虽然为主内存数据的存储带来了更多的灵活性，但是由于其实现方式复杂，成本高，因而通常只在cache空间很小的CPU中使用；</li>
<li>K-way assocative cache(多路关联）:是直接映射与全关联两种方式的折中策略，通过将cache memory划分为更小的单位（<code>ways</code>)，使得主内存中的位置可能有多个cache位置与之相对应。比如下图是一个4-way 4KB大小的cache示意图：</li>
</ul>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ARM%2Bprocessor%2B4way_cache.jpg" alt="4-ways associative cache"></p>
<blockquote>
<p>图片来自《ARM System Develop’s Guide - Designing and Optimizting System Software》</p>
</blockquote>
<p>与前文中的示意图不同的是，这里cache memory共包含了4路，每路都包含了64(2^6)个缓存行，但cache总的大小仍然是4KB（<code>4*4*64*4</code> bytes),但现在对于每个<code>set index</code>都对应了4个cache line,这4个缓存行可以看成是一个<code>set</code>，这也是<code>set index</code>这个名字的由来。</p>
<h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a><strong>缓存策略</strong></h2><p>这里就来看下缓存的两种策略： 写内存以及缓存替换策略。写内存策略用于确定何时将数据写入内存；但出现cache miss时，使用替换策略将某个缓存行换出。</p>
<p>首先来看下写策略。</p>
<h3 id="write-policy"><a href="#write-policy" class="headerlink" title="write policy"></a><strong>write policy</strong></h3><p>当CPU需要将数据写回主内存时，cache controller有两种写策略可选择：一种是同时更新缓存行数据和主内存数据，这种方法被称为<code>writethrough</code>;另一种策略<code>writeback</code>则只更新缓存行数据，而不更新主内存数据。</p>
<ul>
<li>Writethrough: 如果缓存命中，则同时更新主内存与缓存行数据，确保主内存与缓存数据始终保持一致，由于需要将数据写回内存，因此<code>Writethrough</code>会比<code>Writeback</code>慢；</li>
<li>Writeback: 使用该写策略，只更新有效(缓存行标记为valid)的缓存数据，而不更新主内存，这样就可能出现缓存与主内存数据不一致，那么，何时将缓存数据写入内存了？当cache controller写数据到缓存时，将该缓存行中的数据标记为<code>dirty</code>，等到下一次访问时，controller知道这个缓存行数据并不在内存中，因此换出该缓存行时，则自动将其写回主内存；</li>
</ul>
<h3 id="replacement-policy"><a href="#replacement-policy" class="headerlink" title="replacement policy"></a><strong>replacement policy</strong></h3><p>出现cache miss时，cache controller需要从缓存中选择一个缓存行用于保存从主内存中加载的新数据。如果被替换的缓存行包含了有效或者脏数据，则需要将其写回内存。那么，如何从缓存中选择可能被替换的缓存行了？这就是缓存的替换策略。一般有以下几种：</p>
<ul>
<li>Least Recently Used(LRU): 将最少使用的缓存行换出；</li>
<li>Roud-robin(RR): 轮盘随机选择一个缓存行换出；</li>
</ul>
<p>更多关于缓存替换策略可以参考WIKIPEDIA文章：<a href="https://en.wikipedia.org/wiki/Cache_replacement_policies" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cache_replacement_policies</a>。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="http://service.scs.carleton.ca/sivarama/org_book/org_book_web/slides/chap_1_versions/ch17_1.pdf" target="_blank" rel="noopener">http://service.scs.carleton.ca/sivarama/org_book/org_book_web/slides/chap_1_versions/ch17_1.pdf</a></li>
<li><a href="https://www.cs.umd.edu/class/fall2001/cmsc411/proj01/cache/cache.pdf" target="_blank" rel="noopener">https://www.cs.umd.edu/class/fall2001/cmsc411/proj01/cache/cache.pdf</a></li>
<li><a href="http://www.ece.northwestern.edu/~kcoloma/ece361/lectures/Lec14-cache.pdf" target="_blank" rel="noopener">http://www.ece.northwestern.edu/~kcoloma/ece361/lectures/Lec14-cache.pdf</a></li>
<li><a href="https://cseweb.ucsd.edu/classes/fa14/cse240A-a/pdf/08/CSE240A-MBT-L15-Cache.ppt.pdf" target="_blank" rel="noopener">https://cseweb.ucsd.edu/classes/fa14/cse240A-a/pdf/08/CSE240A-MBT-L15-Cache.ppt.pdf</a></li>
<li><a href="http://people.cs.pitt.edu/~cho/cs1541/current/handouts/lect-memh_4up.pdf" target="_blank" rel="noopener">http://people.cs.pitt.edu/~cho/cs1541/current/handouts/lect-memh_4up.pdf</a></li>
<li>《ARM System Develop’s Guide - Designing and Optimizting System Software》</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Computer Architecture </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Memory Cache </tag>
            
            <tag> CPU Architecture </tag>
            
            <tag> Memory Hierarchy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android进程Crash处理流程]]></title>
      <url>http://sniffer.site/2017/07/09/Android%E8%BF%9B%E7%A8%8BCrash%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>之前的一篇文章，讲到了<a href="http://sniffer.site/2017/06/25/Android-ANR%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/">应用程序无响应(ANR)</a>时Android的处理逻辑。这篇文章，就来分析下应用进程发生崩溃(Crash)时，Android是如何处理的？总的说来，Android主要有两大类Crash：</p>
<ul>
<li>Java(JVM)层： 应用程序发生运行时错误（如空指针，浮点运算错误，数据索引超出界限)或者系统进程崩溃(长时间无响应)；</li>
<li>Native层： native进程或者kernel发生运行时错误；</li>
</ul>
<a id="more"></a>
<h2 id="APP层Crash处理"><a href="#APP层Crash处理" class="headerlink" title="APP层Crash处理"></a><strong>APP层Crash处理</strong></h2><p>对Java层，Android需要处理两种情况的Crash：</p>
<ul>
<li>对于APP中未捕获的异常，捕捉到后，进行处理；</li>
<li>监控UI线程（主线程）、前台服务线程、IO线程、显示线程（IMS/WMS,DMS中使用）以及Binder进程通信线程是否挂起（10s内无响应则视为挂起);</li>
</ul>
<blockquote>
<p>主线程(main thread）是指应用启动时创建的进程中的第一个线程，而UI线程则是负责输入、绘制等前台交互，大部分情况下主线程就是UI线程，参考：</p>
<ul>
<li><a href="https://developer.android.com/guide/components/processes-and-threads.html" target="_blank" rel="noopener">https://developer.android.com/guide/components/processes-and-threads.html</a></li>
<li><a href="https://developer.android.com/studio/write/annotations.html#thread-annotations" target="_blank" rel="noopener">https://developer.android.com/studio/write/annotations.html#thread-annotations</a></li>
</ul>
</blockquote>
<p>下面就从这两种情况来分析APP出现的Crash。</p>
<h3 id="未捕获异常Crash"><a href="#未捕获异常Crash" class="headerlink" title="未捕获异常Crash"></a><strong>未捕获异常Crash</strong></h3><p>对于每个进程，在启动过程初始化运行时执行环境时，都会设置一个未捕获异常处理函数，用于捕获APP中未捕获到的异常情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commonInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Entered RuntimeInit!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set default handler; this applies to all threads in the VM */</span></span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> UncaughtHandler());</span><br><span class="line"></span><br><span class="line">    TimezoneGetter.setInstance(<span class="keyword">new</span> TimezoneGetter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SystemProperties.get(<span class="string">"persist.sys.timezone"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeZone.setDefault(<span class="keyword">null</span>);</span><br><span class="line">    ....</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>捕获到应用Crash后，向AMS发送Crash信息，最后将进程杀死：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UncaughtHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Don't re-enter -- avoid infinite loops if crash-reporting crashes.</span></span><br><span class="line">            <span class="keyword">if</span> (mCrashing) <span class="keyword">return</span>;</span><br><span class="line">            mCrashing = <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (mApplicationObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 进程启动时设置了mApplicationObject = ApplicationThread</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                StringBuilder message = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                message.append(<span class="string">"FATAL EXCEPTION: "</span>).append(t.getName()).append(<span class="string">"\n"</span>);</span><br><span class="line">                <span class="keyword">final</span> String processName = ActivityThread.currentProcessName();</span><br><span class="line">                <span class="keyword">if</span> (processName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    message.append(<span class="string">"Process: "</span>).append(processName).append(<span class="string">", "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                message.append(<span class="string">"PID: "</span>).append(Process.myPid());</span><br><span class="line">                Clog_e(TAG, message.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// Bring up crash dialog, wait for it to be dismissed</span></span><br><span class="line">            ActivityManagerNative.getDefault().handleApplicationCrash(</span><br><span class="line">                    mApplicationObject, <span class="keyword">new</span> ApplicationErrorReport.CrashInfo(e));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Try everything to make sure this process goes away.</span></span><br><span class="line">            Process.killProcess(Process.myPid());</span><br><span class="line">            System.exit(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>参考源码</strong>：/android/frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</p>
</blockquote>
<p>AMS接收到Crash后，找到应用的进程记录，做下一步处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleApplicationCrash</span><span class="params">(IBinder app, ApplicationErrorReport.CrashInfo crashInfo)</span> </span>&#123;</span><br><span class="line">       ProcessRecord r = findAppProcess(app, <span class="string">"Crash"</span>);</span><br><span class="line">       <span class="keyword">final</span> String processName = app == <span class="keyword">null</span> ? <span class="string">"system_server"</span></span><br><span class="line">               : (r == <span class="keyword">null</span> ? <span class="string">"unknown"</span> : r.processName);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> userId = r == <span class="keyword">null</span> ? UserHandle.USER_OWNER : r.userId;</span><br><span class="line">       ....</span><br><span class="line">       <span class="comment">// 处理应用Crash</span></span><br><span class="line">       handleApplicationCrashInner(<span class="string">"crash"</span>, r, processName, crashInfo);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>AMS处理APP的Crash主要做了两件事情：</p>
<ul>
<li>保存Crash的当时的现场到Dropbox;</li>
<li>如果发现该APP频繁Crash，记录信息，强制其停止，不提示用户；否则需要弹出APP出错的对话框告知用户，由用户自己选择处理的方式（重启或者强制停止）；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleApplicationCrashInner</span><span class="params">(String eventType, ProcessRecord r, String processName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ApplicationErrorReport.CrashInfo crashInfo)</span> </span>&#123;</span><br><span class="line">    EventLog.writeEvent(EventLogTags.AM_CRASH, Binder.getCallingPid(),</span><br><span class="line">            UserHandle.getUserId(Binder.getCallingUid()), processName,</span><br><span class="line">            r == <span class="keyword">null</span> ? -<span class="number">1</span> : r.info.flags,</span><br><span class="line">            crashInfo.exceptionClassName,</span><br><span class="line">            crashInfo.exceptionMessage,</span><br><span class="line">            crashInfo.throwFileName,</span><br><span class="line">            crashInfo.throwLineNumber);</span><br><span class="line"></span><br><span class="line">    addErrorToDropBox(eventType, r, processName, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, crashInfo);</span><br><span class="line"></span><br><span class="line">    mAppErrors.crashApplication(r, crashInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="系统挂起"><a href="#系统挂起" class="headerlink" title="系统挂起"></a><strong>系统挂起</strong></h3><p>在应用层， Android有一个专门的监控者<code>Watchdog</code>线程来负责监控应用层是否出现系统挂起（在给定时间10s无响应则视为挂起），比如系统服务IMS(AMS,WMS)无响应，UI线程、IO线程无响应，Binder IPC线程无响应等各种异常情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Watchdog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"watchdog"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The shared foreground thread is the main checker.  It is where we</span></span><br><span class="line">    <span class="comment">// will also dispatch monitor checks and do other work.</span></span><br><span class="line">    mMonitorChecker = <span class="keyword">new</span> HandlerChecker(FgThread.getHandler(),</span><br><span class="line">            <span class="string">"foreground thread"</span>, DEFAULT_TIMEOUT);</span><br><span class="line">    mHandlerCheckers.add(mMonitorChecker);</span><br><span class="line">    <span class="comment">// Add checker for main thread.  We only do a quick check since there</span></span><br><span class="line">    <span class="comment">// can be UI running on the thread.</span></span><br><span class="line">    mHandlerCheckers.add(<span class="keyword">new</span> HandlerChecker(<span class="keyword">new</span> Handler(Looper.getMainLooper()),</span><br><span class="line">            <span class="string">"main thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">    <span class="comment">// Add checker for shared UI thread.</span></span><br><span class="line">    mHandlerCheckers.add(<span class="keyword">new</span> HandlerChecker(UiThread.getHandler(),</span><br><span class="line">            <span class="string">"ui thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">    <span class="comment">// And also check IO thread.</span></span><br><span class="line">    mHandlerCheckers.add(<span class="keyword">new</span> HandlerChecker(IoThread.getHandler(),</span><br><span class="line">            <span class="string">"i/o thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">    <span class="comment">// And the display thread.</span></span><br><span class="line">    mHandlerCheckers.add(<span class="keyword">new</span> HandlerChecker(DisplayThread.getHandler(),</span><br><span class="line">            <span class="string">"display thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize monitor for Binder threads.</span></span><br><span class="line">    addMonitor(<span class="keyword">new</span> BinderThreadMonitor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Watchdog</code>线程是在<code>system_server</code>进程启动时启动起来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">final</span> Watchdog watchdog = Watchdog.getInstance();</span><br><span class="line">        watchdog.init(context, mActivityManagerService);</span><br><span class="line">        ....</span><br><span class="line">        Watchdog.getInstance().start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Watchdog</code>线程启动后，开始监测各个线程有无响应（通过在线程消息队列的头部添加一个可执行对象，对于Binder线程则通过<code>BlockUtilThreadAvailable</code>来检测是否有Binder线程可用），一旦发现系统某个线程无响应，则抓取相应APP的堆栈LOG，同时保存kernel的堆栈信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> waitedHalf = <span class="keyword">false</span>;</span><br><span class="line">    File traceFile = <span class="keyword">new</span> File(<span class="string">"/data/anr/traces.txt"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!traceFile.exists()) &#123;</span><br><span class="line">            traceFile.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        traceFile.setReadable(<span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">        traceFile.setWritable(<span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">"Failed to create /data/anr/traces.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;HandlerChecker&gt; blockedCheckers;</span><br><span class="line">        <span class="keyword">final</span> String subject;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> allowRestart;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeout = CHECK_INTERVAL;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mHandlerCheckers.size(); i++) &#123;</span><br><span class="line">                HandlerChecker hc = mHandlerCheckers.get(i);</span><br><span class="line">                hc.scheduleCheckLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> waitState = evaluateCheckerCompletionLocked();</span><br><span class="line">            <span class="keyword">if</span> (waitState == COMPLETED) &#123;</span><br><span class="line">                <span class="comment">// The monitors have returned; reset</span></span><br><span class="line">                waitedHalf = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (waitState == WAITING) &#123;</span><br><span class="line">                <span class="comment">// still waiting but within their configured intervals; back off and recheck</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (waitState == WAITED_HALF) &#123;</span><br><span class="line">                ....</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// something is overdue!</span></span><br><span class="line">            blockedCheckers = getBlockedCheckersLocked();</span><br><span class="line">            subject = describeCheckersLocked(blockedCheckers);</span><br><span class="line">            allowRestart = mAllowRestart;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统处于挂起状态，保存APP堆栈信息</span></span><br><span class="line">   <span class="keyword">final</span> File stack = ActivityManagerService.dumpStackTraces(</span><br><span class="line">                !waitedHalf, pids, <span class="keyword">null</span>, <span class="keyword">null</span>, NATIVE_STACKS_OF_INTEREST);</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 保存kernel堆栈信息</span></span><br><span class="line">    <span class="keyword">if</span> (RECORD_KERNEL_THREADS) &#123;</span><br><span class="line">        dumpKernelStackTraces();</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>参考源码</strong>：/android/frameworks/base/services/core/java/com/android/server/Watchdog.java </p>
</blockquote>
<p>接下来，就来看一看Android是如何处理native进程crash的。</p>
<h2 id="Native层Crash处理"><a href="#Native层Crash处理" class="headerlink" title="Native层Crash处理"></a><strong>Native层Crash处理</strong></h2><p>在native层，Android的Crash处理主要由三个部分组成：</p>
<ul>
<li>kernel捕捉到进程的异常信号(SIGABRT,SIGBUS,SIGFPE)时,调用信号处理函数；信号处理函数负责收集Crash进程的错误信息，并将错误信息通过socket发送给debugger守护进程；</li>
<li>debugger守护进程接收到crash信息后，一方面告知AMS有进程发生Crash，一方面通过tomestone保存完整的现场信息；</li>
<li>AMS收到Crash信息后，弹出对话框告知用户Crash信息，同时保存该crash进程的相关LOG；</li>
</ul>
<p>接下来，我们分步骤来看下native层Crash的处理流程。</p>
<h3 id="Crash信号处理函数"><a href="#Crash信号处理函数" class="headerlink" title="Crash信号处理函数"></a>Crash信号处理函数</h3><p>Native进程发生崩溃（Crash)时，kernel会向其发送一个信号(<a href="https://en.wikipedia.org/wiki/Unix_signal" target="_blank" rel="noopener">signal</a>),此时当前进程被中断，kernel接着调用事先注册在系统中的信号处理函数(Signal Handler)。Android在启动时专门注册了一个signal handler用于处理Native进程由于运行错误而出现的信号。</p>
<p>那么，Android的signal handler是在哪里注册到系统中的了？在Android库bionic中有一个动态链接库<code>linker</code>（文件目录<code>/android/bionic/</code>）,<code>linker</code>启动时会初始化通过系统调用<code>signal</code>向系统注册信号处理函数； Android主要处理<code>SIGABRT</code>、<code>SIGBUS</code>等几种Crash信号（<a href="http://www.comptechdoc.org/os/linux/programming/linux_pgsignals.html" target="_blank" rel="noopener">linux signal</a>)：</p>
<ul>
<li><code>SIGABRT</code>(6): abort, 异常终止；</li>
<li><code>SIGBUS</code>(10): bus error, 总线错误；</li>
<li><code>SIGFPE</code>(8): Floating Point Exception, 浮点运算异常；</li>
<li><code>SIGILL</code>(4): Illegal Instruction, 非法指令；</li>
<li><code>SIGSEGV</code>(11): Invalid memory Segmentation Fault, 无效内存访问；</li>
<li><code>SIGSTKFLT</code>(16): stack fault, 堆栈错误；</li>
<li><code>SIGTRAP</code>(5): Trace Trap, 跟踪陷阱；</li>
</ul>
<h4 id="debugger-cpp"><a href="#debugger-cpp" class="headerlink" title="debugger.cpp"></a><strong>debugger.cpp</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__<span class="function">LIBC_HIDDEN__ <span class="keyword">void</span> <span class="title">debuggerd_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>;</span></span><br><span class="line">      <span class="built_in">memset</span>(&amp;action, <span class="number">0</span>, <span class="keyword">sizeof</span>(action));</span><br><span class="line">      sigemptyset(&amp;action.sa_mask);</span><br><span class="line">      <span class="comment">// 信号处理函数</span></span><br><span class="line">      action.sa_sigaction = debuggerd_signal_handler;</span><br><span class="line">      action.sa_flags = SA_RESTART | SA_SIGINFO;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// Use the alternate signal stack if available so we can catch stack overflows.</span></span><br><span class="line">      action.sa_flags |= SA_ONSTACK;</span><br><span class="line">      <span class="comment">// 需要捕捉的信号</span></span><br><span class="line">      sigaction(SIGABRT, &amp;action, <span class="literal">nullptr</span>);</span><br><span class="line">      sigaction(SIGBUS, &amp;action, <span class="literal">nullptr</span>);</span><br><span class="line">      sigaction(SIGFPE, &amp;action, <span class="literal">nullptr</span>);</span><br><span class="line">      sigaction(SIGILL, &amp;action, <span class="literal">nullptr</span>);</span><br><span class="line">      sigaction(SIGSEGV, &amp;action, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> defined(SIGSTKFLT)</span></span><br><span class="line">      sigaction(SIGSTKFLT, &amp;action, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      sigaction(SIGTRAP, &amp;action, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册完信号处理函数后，一旦kernel检测到有进程出现上述信号，则会调用<code>debuggerd_signal_handler</code>函数进行处理：此时会通过socket接口<code>android:debuggerd32</code>（对于64位系统，socket名为<code>android:debuggerd</code>）发送错误信息，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Catches fatal signals so we can ask debuggerd to ptrace us before</span></span><br><span class="line"><span class="comment"> * we crash.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debuggerd_signal_handler</span><span class="params">(<span class="keyword">int</span> signal_number, <span class="keyword">siginfo_t</span>* info, <span class="keyword">void</span>*)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// It's possible somebody cleared the SA_SIGINFO flag, which would mean</span></span><br><span class="line">  <span class="comment">// our "info" arg holds an undefined value.</span></span><br><span class="line">  <span class="keyword">if</span> (!have_siginfo(signal_number)) &#123;</span><br><span class="line">    info = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  log_signal_summary(signal_number, info);</span><br><span class="line">  <span class="comment">// 向debuggered发送错误信息</span></span><br><span class="line">  send_debuggerd_packet(info);</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>send_debuggerd_packet</code>，首先连接<code>debuggerd</code>的服务端socket；接着不断尝试向该socket写入数据，直至成功：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send_debuggerd_packet</span><span class="params">(<span class="keyword">siginfo_t</span>* info)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Mutex to prevent multiple crashing threads from trying to talk</span></span><br><span class="line">  <span class="comment">// to debuggerd at the same time.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> crash_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">  <span class="keyword">int</span> ret = pthread_mutex_trylock(&amp;crash_mutex);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 连接debuggerd</span></span><br><span class="line">  <span class="keyword">int</span> s = socket_abstract_client(DEBUGGER_SOCKET_NAME, SOCK_STREAM | SOCK_CLOEXEC);</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">    __libc_format_log(ANDROID_LOG_FATAL, <span class="string">"libc"</span>, <span class="string">"Unable to open connection to debuggerd: %s"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// debuggerd knows our pid from the credentials on the</span></span><br><span class="line">  <span class="comment">// local socket but we need to tell it the tid of the crashing thread.</span></span><br><span class="line">  <span class="comment">// debuggerd will be paranoid and verify that we sent a tid</span></span><br><span class="line">  <span class="comment">// that's actually in our process.</span></span><br><span class="line">  <span class="keyword">debugger_msg_t</span> msg;</span><br><span class="line">  <span class="comment">// crash</span></span><br><span class="line">  msg.action = DEBUGGER_ACTION_CRASH;</span><br><span class="line">  msg.tid = gettid();</span><br><span class="line">  msg.abort_msg_address = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(g_abort_message);</span><br><span class="line">  msg.original_si_code = (info != <span class="literal">nullptr</span>) ? info-&gt;si_code : <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 向socket写入数据</span></span><br><span class="line">  ret = TEMP_FAILURE_RETRY(write(s, &amp;msg, <span class="keyword">sizeof</span>(msg)));</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="keyword">sizeof</span>(msg)) &#123;</span><br><span class="line">    <span class="keyword">char</span> debuggerd_ack;</span><br><span class="line">    ret = TEMP_FAILURE_RETRY(read(s, &amp;debuggerd_ack, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> saved_errno = errno;</span><br><span class="line">    notify_gdb_of_libraries();</span><br><span class="line">    errno = saved_errno;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// read or write failed -- broken connection?</span></span><br><span class="line">    __libc_format_log(ANDROID_LOG_FATAL, <span class="string">"libc"</span>, <span class="string">"Failed while talking to debuggerd: %s"</span>, strerror(errno));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 关闭socket</span></span><br><span class="line">  close(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> <strong>参考源码</strong>： /android/bionic/linker/debugger.cpp </p>
</blockquote>
<h4 id="debuggerd-cpp"><a href="#debuggerd-cpp" class="headerlink" title="debuggerd.cpp"></a><strong>debuggerd.cpp</strong></h4><p>在服务端进程<code>debuggerd</code>启动时，会不断监听客户端的连接请求，一旦发现有连接，就会读取其中的数据进行处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// debuggerd crashes can't be reported to debuggerd.</span></span><br><span class="line">  <span class="comment">// Reset all of the crash handlers.</span></span><br><span class="line">  signal(SIGABRT, SIG_DFL);</span><br><span class="line">  signal(SIGBUS, SIG_DFL);</span><br><span class="line">  signal(SIGFPE, SIG_DFL);</span><br><span class="line">  signal(SIGILL, SIG_DFL);</span><br><span class="line">  signal(SIGSEGV, SIG_DFL);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SIGSTKFLT</span></span><br><span class="line">  signal(SIGSTKFLT, SIG_DFL);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  signal(SIGTRAP, SIG_DFL);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ignore failed writes to closed sockets</span></span><br><span class="line">  signal(SIGPIPE, SIG_IGN);</span><br><span class="line">  ....</span><br><span class="line">  <span class="comment">// 创建服务端socket</span></span><br><span class="line">  <span class="keyword">int</span> s = socket_local_server(SOCKET_NAME, ANDROID_SOCKET_NAMESPACE_ABSTRACT,</span><br><span class="line">                              SOCK_STREAM | SOCK_CLOEXEC);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fork a process that stays root, and listens on a pipe to pause and resume the target.（具体什么作用，没看明白）</span></span><br><span class="line">  <span class="keyword">if</span> (!start_signal_sender()) &#123;</span><br><span class="line">    ALOGE(<span class="string">"debuggerd: failed to fork signal sender"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 监听并处理客户端进程请求</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    sockaddr_storage ss;</span><br><span class="line">    sockaddr* addrp = <span class="keyword">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;ss);</span><br><span class="line">    <span class="keyword">socklen_t</span> alen = <span class="keyword">sizeof</span>(ss);</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"waiting for connection\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = accept4(s, addrp, &amp;alen, SOCK_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle_request(fd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在<code>debuggerd</code>与客户端进程已经建立好连接了，读取其中的数据并<code>fork</code>一个新的进程处理之：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_request</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedFd <span class="title">closer</span><span class="params">(fd)</span></span>;</span><br><span class="line">  <span class="keyword">debugger_request_t</span> request;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;request, <span class="number">0</span>, <span class="keyword">sizeof</span>(request));</span><br><span class="line">  <span class="comment">// 读取数据</span></span><br><span class="line">  <span class="keyword">int</span> status = read_request(fd, &amp;request);</span><br><span class="line">  <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">  <span class="comment">// Fork a child to handle the rest of the request.</span></span><br><span class="line">  <span class="keyword">pid_t</span> fork_pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (fork_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">"debuggerd: failed to fork: %s\n"</span>, strerror(errno));</span><br><span class="line">  <span class="comment">// 在子进程中处理请求</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fork_pid == <span class="number">0</span>) &#123;</span><br><span class="line">    worker_process(fd, request);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    monitor_worker_process(fork_pid, request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在子进程中处理Crash：首先尝试连接AMS，接着会保存Crash进程的DUMP LOG，最后通过socket发送消息告知AMS有Crash发生，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">worker_process</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">debugger_request_t</span>&amp; request)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Open the tombstone file if we need it.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> tombstone_path;</span><br><span class="line">  <span class="keyword">int</span> tombstone_fd = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">switch</span> (request.action) &#123;</span><br><span class="line">    <span class="keyword">case</span> DEBUGGER_ACTION_DUMP_TOMBSTONE:</span><br><span class="line">    <span class="keyword">case</span> DEBUGGER_ACTION_CRASH:</span><br><span class="line">      tombstone_fd = open_tombstone(&amp;tombstone_path);</span><br><span class="line">      <span class="keyword">if</span> (tombstone_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"debuggerd: failed to open tombstone file: %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      ....</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don't attach to the sibling threads if we want to attach gdb.</span></span><br><span class="line">  <span class="comment">// Supposedly, it makes the process less reliable.</span></span><br><span class="line">  <span class="keyword">bool</span> attach_gdb = should_attach_gdb(request);</span><br><span class="line">  ....</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">pid_t</span>&gt; siblings;</span><br><span class="line">  <span class="keyword">if</span> (!attach_gdb) &#123;</span><br><span class="line">    ptrace_siblings(request.pid, request.tid, siblings);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> amfd = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; amfd_data;</span><br><span class="line">  <span class="keyword">if</span> (request.action == DEBUGGER_ACTION_CRASH) &#123;</span><br><span class="line">    <span class="comment">// 连接AMS</span></span><br><span class="line">    amfd = activity_manager_connect();</span><br><span class="line">    amfd_data.reset(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> succeeded = <span class="literal">false</span>;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">int</span> crash_signal = SIGKILL;</span><br><span class="line">  <span class="comment">// 保存DUMP LOG</span></span><br><span class="line">  succeeded = perform_dump(request, fd, tombstone_fd, backtrace_map.get(), siblings,</span><br><span class="line">                           &amp;crash_signal, amfd_data.get());</span><br><span class="line">  <span class="keyword">if</span> (succeeded) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.action == DEBUGGER_ACTION_DUMP_TOMBSTONE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!tombstone_path.empty()) &#123;</span><br><span class="line">        android::base::WriteFully(fd, tombstone_path.c_str(), tombstone_path.length());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">if</span> (!attach_gdb) &#123;</span><br><span class="line">    <span class="comment">// Tell the Activity Manager about the crashing process. If we are</span></span><br><span class="line">    <span class="comment">// waiting for gdb to attach, do not send this or Activity Manager</span></span><br><span class="line">    <span class="comment">// might kill the process before anyone can attach.</span></span><br><span class="line">    activity_manager_write(request.pid, crash_signal, amfd, *amfd_data.get());</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  close(amfd);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(!succeeded);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接AMS用来监听native crash的socket， 从这里我们也可以看到，<code>debuggerd</code>进程实际连接的是在<code>NativeCrashListener.java</code>中创建的socket：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">activity_manager_connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  android::base::<span class="function">unique_fd <span class="title">amfd</span><span class="params">(socket(PF_UNIX, SOCK_STREAM, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">address</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;address, <span class="number">0</span>, <span class="keyword">sizeof</span>(address));</span><br><span class="line">  address.sun_family = AF_UNIX;</span><br><span class="line">  <span class="comment">// The path used here must match the value defined in NativeCrashListener.java.</span></span><br><span class="line">  <span class="built_in">strncpy</span>(address.sun_path, <span class="string">"/data/system/ndebugsocket"</span>, <span class="keyword">sizeof</span>(address.sun_path));</span><br><span class="line">  <span class="keyword">if</span> (TEMP_FAILURE_RETRY(connect(amfd.get(), <span class="keyword">reinterpret_cast</span>&lt;struct sockaddr*&gt;(&amp;address), <span class="keyword">sizeof</span>(address))) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;tv, <span class="number">0</span>, <span class="keyword">sizeof</span>(tv));</span><br><span class="line">  tv.tv_sec = <span class="number">1</span>;  <span class="comment">// tight leash</span></span><br><span class="line">  <span class="keyword">if</span> (setsockopt(amfd.get(), SOL_SOCKET, SO_SNDTIMEO, &amp;tv, <span class="keyword">sizeof</span>(tv)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">"debuggerd: Unable to connect to activity manager (setsockopt SO_SNDTIMEO failed: %s)"</span>,</span><br><span class="line">          strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tv.tv_sec = <span class="number">3</span>;  <span class="comment">// 3 seconds on handshake read</span></span><br><span class="line">  <span class="keyword">if</span> (setsockopt(amfd.get(), SOL_SOCKET, SO_RCVTIMEO, &amp;tv, <span class="keyword">sizeof</span>(tv)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">"debuggerd: Unable to connect to activity manager (setsockopt SO_RCVTIMEO failed: %s)"</span>,</span><br><span class="line">          strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> amfd.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>参考源码</strong>： /android/system/core/debuggerd/debuggerd.cpp </p>
</blockquote>
<h4 id="ActivityManagerService-java"><a href="#ActivityManagerService-java" class="headerlink" title="ActivityManagerService.java"></a><strong>ActivityManagerService.java</strong></h4><p>进程<code>debuggerd</code>跟AMS是通过一个叫<code>/data/system/ndebugsocket</code>的socket进行通信的，该socket在<code>NativeCrashListener.java</code>中创建的; <code>NativeCrashListener</code>实际是一个线程，它是在AMS初始化时创建的，其作用是一直在监听来自<code>debuggerd</code>进程的请求，如果有则处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NativeCrashListener(ActivityManagerService am) &#123;</span><br><span class="line">       mAm = am;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">byte</span>[] ackSignal = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">       <span class="comment">// The file system entity for this socket is created with 0700 perms, owned</span></span><br><span class="line">       <span class="comment">// by system:system.  debuggerd runs as root, so is capable of connecting to</span></span><br><span class="line">       <span class="comment">// it, but 3rd party apps cannot.</span></span><br><span class="line">       ....</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           FileDescriptor serverFd = Os.socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">           <span class="keyword">final</span> UnixSocketAddress sockAddr = UnixSocketAddress.createFileSystem(</span><br><span class="line">                   DEBUGGERD_SOCKET_PATH);</span><br><span class="line">           Os.bind(serverFd, sockAddr);</span><br><span class="line">           Os.listen(serverFd, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">               FileDescriptor peerFd = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 等待客户端连接</span></span><br><span class="line">                   peerFd = Os.accept(serverFd, <span class="keyword">null</span> <span class="comment">/* peerAddress */</span>);</span><br><span class="line">                   <span class="keyword">if</span> (MORE_DEBUG) Slog.v(TAG, <span class="string">"Got debuggerd socket "</span> + peerFd);</span><br><span class="line">                   <span class="keyword">if</span> (peerFd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// Only the superuser is allowed to talk to us over this socket</span></span><br><span class="line">                       StructUcred credentials =</span><br><span class="line">                               Os.getsockoptUcred(peerFd, SOL_SOCKET, SO_PEERCRED);</span><br><span class="line">                       <span class="keyword">if</span> (credentials.uid == <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="comment">// 处理Crash数据</span></span><br><span class="line">                           consumeNativeCrashData(peerFd);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   Slog.w(TAG, <span class="string">"Error handling connection"</span>, e);</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   ....</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           Slog.e(TAG, <span class="string">"Unable to init native debug socket!"</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>读取socket中的Crash数据，并将其报告给AMS：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumeNativeCrashData</span><span class="params">(FileDescriptor fd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">final</span> ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            StructTimeval timeout = StructTimeval.fromMillis(SOCKET_TIMEOUT_MILLIS);</span><br><span class="line">            Os.setsockoptTimeval(fd, SOL_SOCKET, SO_RCVTIMEO, timeout);</span><br><span class="line">            Os.setsockoptTimeval(fd, SOL_SOCKET, SO_SNDTIMEO, timeout);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// first, the pid and signal number</span></span><br><span class="line">            <span class="keyword">int</span> headerBytes = readExactly(fd, buf, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">if</span> (headerBytes != <span class="number">8</span>) &#123;</span><br><span class="line">                <span class="comment">// protocol failure; give up</span></span><br><span class="line">                Slog.e(TAG, <span class="string">"Unable to read from debuggerd"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pid = unpackInt(buf, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> signal = unpackInt(buf, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// now the text of the dump</span></span><br><span class="line">            <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ProcessRecord pr;</span><br><span class="line">                <span class="keyword">synchronized</span> (mAm.mPidsSelfLocked) &#123;</span><br><span class="line">                    pr = mAm.mPidsSelfLocked.get(pid);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Don't attempt crash reporting for persistent apps</span></span><br><span class="line">                    <span class="keyword">if</span> (pr.persistent) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> bytes;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// get some data</span></span><br><span class="line">                        bytes = Os.read(fd, buf, <span class="number">0</span>, buf.length);</span><br><span class="line">                        <span class="keyword">if</span> (bytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// did we just get the EOD null byte?</span></span><br><span class="line">                            <span class="keyword">if</span> (buf[bytes-<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                                os.write(buf, <span class="number">0</span>, bytes-<span class="number">1</span>);  <span class="comment">// exclude the EOD token</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// no EOD, so collect it and read more</span></span><br><span class="line">                            os.write(buf, <span class="number">0</span>, bytes);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (bytes &gt; <span class="number">0</span>);</span><br><span class="line">                    ....</span><br><span class="line">                    <span class="comment">// 启动另一个线程NativeCrashReporter通知AMS</span></span><br><span class="line">                    <span class="keyword">final</span> String reportString = <span class="keyword">new</span> String(os.toByteArray(), <span class="string">"UTF-8"</span>);</span><br><span class="line">                    (<span class="keyword">new</span> NativeCrashReporter(pr, signal, reportString)).start();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Couldn't find ProcessRecord for pid "</span> + pid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.e(TAG, <span class="string">"Bogus pid!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Exception dealing with report"</span>, e);</span><br><span class="line">            <span class="comment">// ugh, fail.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>NativeCrashReporter</code>线程告知AMS有native crash发生：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeCrashReporter</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    ProcessRecord mApp;</span><br><span class="line">    <span class="keyword">int</span> mSignal;</span><br><span class="line">    String mCrashReport;</span><br><span class="line"></span><br><span class="line">    NativeCrashReporter(ProcessRecord app, <span class="keyword">int</span> signal, String report) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"NativeCrashReport"</span>);</span><br><span class="line">        mApp = app;</span><br><span class="line">        mSignal = signal;</span><br><span class="line">        mCrashReport = report;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            CrashInfo ci = <span class="keyword">new</span> CrashInfo();</span><br><span class="line">            ci.exceptionClassName = <span class="string">"Native crash"</span>;</span><br><span class="line">            ci.exceptionMessage = Os.strsignal(mSignal);</span><br><span class="line">            ci.throwFileName = <span class="string">"unknown"</span>;</span><br><span class="line">            ci.throwClassName = <span class="string">"unknown"</span>;</span><br><span class="line">            ci.throwMethodName = <span class="string">"unknown"</span>;</span><br><span class="line">            ci.stackTrace = mCrashReport;</span><br><span class="line"></span><br><span class="line">            mAm.handleApplicationCrashInner(<span class="string">"native_crash"</span>, mApp, mApp.processName, ci);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Unable to report native crash"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后的处理流程，跟在第一节关于未捕获异常的时候，就基本一样了。详细可以参考上节内容。</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Crash </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android中的任务管理]]></title>
      <url>http://sniffer.site/2017/07/01/Android%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>Activity是Android负责与用户交互的实体。一个应用一般由多个Activity组成;一个Activity不仅可以打开应用内的Activity，也可以打开其他应用内的Activity，比如通过一个名为<code>android.intent.action.VIEW</code>的Intent事件可以打开浏览器；通过<code>android.intent.action.DIAL</code>可以向CALL发送拨号请求。一系列的Activity组合在一起（完成某个特定的“任务“）构成了一个任务（一个后进先出的队列，被称为back stack），而多个任务又构成了一个任务栈（后台可以有多个任务栈，但系统如需恢复内存，则会杀死部分应用，清空部分任务，以释放内存，因此长时间后应用状态会丢失）。<a id="more"></a>以下图为例，图中的back stack一开始只有一个Activity1；接着在Activity1中启动Activity2，此时Activity2位于队列的顶部，而Activity1位于栈底（Activity1处于Stop状态），而Activity2又启动一个Activity3，同样，Activity3压入栈顶。如果此时通过回退键（<strong>Back</strong>）用户离开Activity3,则Activity3从栈中清除，被系统销毁，而Activity2则恢复到可见状态(resume)。</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/diagram_backstack.png" alt="Back Stack of Activities"></p>
<p>总的说来，Activity与任务栈之间的关系有如下几种情况：</p>
<ul>
<li>当Activity A启动ActivityB时，A处于停止（stop）状态，但是系统会保留其状态（如当前滑动位置以及输入的文本等）；如果在B中用户按下回退键，此时A恢复原来的状态，而B被销毁；</li>
<li>当用户按下HOME键离开一个任务时，当前Activity会被停止，相应的任务进入后台，系统会保留任务中所有Activity的状态。如果用户稍后通过启动界面（Launcher）的图标启动该任务，则任务恢复到前台运行，使任务顶部的Activity处于可见状态(resume);</li>
<li>用户按下回退（back)键时，当前Activity从栈中弹出，销毁（系统不再保留次Activity状态），此时之前的Activity恢复运行；</li>
<li>一个Activity可被实例化多次，该实例可以来自不同的任务（back stack）；</li>
</ul>
<p>那么，Android是如何来管理这些任务的了？这里有这么几个问题：</p>
<ul>
<li>刚讲到，一个Activity可能在一个任务中被实例化多次，那么如何避免这样多次实例化的开销了？</li>
<li>怎么来控制一个Activity所属的任务(back stack)?</li>
<li>怎么启动一个新的任务？</li>
</ul>
<h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a><strong>任务管理</strong></h2><p>Android通过启动模式(Launch Mode)来控制Activity的启动方式，也可以通过控制Activity中的某些属性来控制Activity在任务中的行为。启动模式主要有两种控制方式，一个是在manifest文件的<code>&lt;activity&gt;</code>标签来指定，一种是通过Intent中的标志位。接下来就来看下这两种控制方式。</p>
<h3 id="使用manifest文件"><a href="#使用manifest文件" class="headerlink" title="使用manifest文件"></a><strong>使用manifest文件</strong></h3><p><code>&lt;activity&gt;</code>中有一个<code>launchMode</code>的属性来指定Activity启动的模式：</p>
<ul>
<li><strong>“standard”</strong>: 默认的启动模式，系统创建一个新的Activity实例，并放入启动该Activity的任务中。在这种模式下，一个Activity可能被实例化多次，每个实例可能属于不同的任务，而且有可能一个任务里存在多个实例；</li>
<li><strong>“singleTop”</strong>： 如果当前任务的顶部已存在该Activity实例，则将intent通过<code>onNewIntent</code>方法传给该Activity，不会再创建一个新的Activity实例；</li>
<li><strong>“singleTask”</strong>: 创建一个新的任务，并将该Activity放入任务(back stack)的底部；但是如果其他任务栈中已存在该Activity实例，则不会创建新的任务，而是将该Activity实例所在任务放置到前台运行，intent则通过<code>onNewIntent()</code>方法传给该Activity。该启动模式确保任务栈中始终只有一个Activity实例存在；</li>
<li><strong>“singleInstance”</strong>: 与<code>singleTask</code>相同，唯一的区别在于该模式下系统不会将其他Activity放入到该Activity所在的任务中，并且任何通过该Activity启动的Activity都会在另一个任务当中，就是说，当前Activity始终是其任务中唯一的一个成员；</li>
</ul>
<h3 id="使用Intent标志位"><a href="#使用Intent标志位" class="headerlink" title="使用Intent标志位"></a><strong>使用Intent标志位</strong></h3><p>当通过<code>startActivity()</code>来启动Activity时，可以通过Intent的标志位来控制Activity的启动方式：</p>
<ul>
<li><strong>FLAG_ACTIVITY_NEW_TASK</strong>： 行为与<code>launchMode</code>中的<code>singleTask</code>一样；</li>
<li><strong>FLAG_ACTIVITY_SINGLE_TOP</strong>： 行为与<code>launchMode</code>中的<code>singleTop</code>一样；</li>
<li><strong>FLAG_ACTIVITY_CLEAR_TOP</strong>： 这个标志在<code>launchMode</code>中没有对应的值。如果当前任务中已存在该Activity的实例，则将所有在该Activity之上的其他Activity都销毁，该Activity置于任务的栈顶，并通过<code>onNewIntent()</code>方法将intent传给该实例。</li>
</ul>
<h2 id="处理亲和标志"><a href="#处理亲和标志" class="headerlink" title="处理亲和标志"></a><strong>处理亲和标志</strong></h2><p>affinity(亲和性）表示一个activity属于哪个任务（back stack)。Android默认在同一个进程中，所有的Activity相互之间都有同样的<em>affinity</em>，就是说在同一个任务中。但是，通过<code>taskAffinity</code>属性值我们可以修改一个Activity属于的任务，这样不同应用之前的Activity可以共有一个<em>affinity</em>，而同一个应用之间的Activity也可以有不同的<em>affinity</em>：</p>
<ul>
<li>对于Activity来说，可通过标签<code>&lt;activity&gt;</code>中的属性<code>taskAffinity</code>来指定<em>affinity</em>；</li>
<li>对于一个应用来说，<code>&lt;application&gt;</code>中的<code>taskAffinity</code>属性默认为<code>&lt;manifest&gt;</code>中指定的程序包名；</li>
</ul>
<p>一般有两种情况会影响到Activity的<em>affinity</em>：</p>
<ul>
<li>启动Activity时，设置了标志位<code>FLAG_ACTIVITY_NEW_TASK</code>,此时如果系统没有包含该Activity实例的任务，则启动新的任务；否则该Activity从已有任务中启动；</li>
<li><code>&lt;activity&gt;</code>中的属性值<code>allowTaskReparenting</code>设为true，在这种情况下，如果Activity所属<em>affinity</em>的任务到前台运行，则该Activity可能从启动它的任务(back stack)中移动到它所属<em>affinity</em>的任务当中。</li>
</ul>
<h2 id="清除任务"><a href="#清除任务" class="headerlink" title="清除任务"></a><strong>清除任务</strong></h2><p>如果用户长时间离开一个任务，系统会清理除根Activity以外的所有Activity。当用户返回应用后，仅有根Activity被恢复。但可以通过如下几个<code>&lt;activiyt&gt;</code>的属性值来更改系统的这一行为：</p>
<ul>
<li><code>alwaysRetainTaskState</code>：如果在一个任务中的根Activity中的将其设为true，则不会任务中的任何Activity，即使长时间后，依然保留所有Activity在任务中；</li>
<li><code>clearTaskOnLaunch</code>：其作用恰好与<code>alwaysRetainTaskState</code>相反；如果在根Activity中将该属性值设为true，则只要用户离开任务，则会将除根Activity之外的Activity都清除，就是说，每次用户返回任务时，都是一个最开始初始化的状态；</li>
<li><code>finishOnTaskLaunch</code>：与<code>clearTaskOnLaunch</code>作用类似，但其只局限于单个Activity，而不是整个任务（back stack），它可以使任何一个Activity被清除，包括根Activity。该属性设为true时，应用只是为当前会话而保留在任务中，一旦用户离开，稍后返回任务，则不能再看到该Activity。</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="https://developer.android.com/guide/components/activities/tasks-and-back-stack.html#ManagingTasks" target="_blank" rel="noopener">https://developer.android.com/guide/components/activities/tasks-and-back-stack.html#ManagingTasks</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 任务管理 </tag>
            
            <tag> Activity </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android ANR处理流程]]></title>
      <url>http://sniffer.site/2017/06/25/Android-ANR%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>ANR即Application Not Responding, 应用无响应：当应用在某一个时间内无法及时响应用户请求时，系统会弹出一个对话框，告知用户应用无法响应。此时，用户可以选择关闭应用。对于Android应用来说，有一个UI线程(主线程）专门负责与用户交互，如果在此线程中进行耗时的操作，比如读取磁盘数据、从网络下载资源等IO操作，通常会导致UI线程阻塞，从而无法及时处理用户的输入请求，发生ANR。</p>
<a id="more"></a>
<p>Android是通过AMS跟WMS来监控应用响应状态的，一般有如下两种ANR情况：</p>
<ul>
<li>应用在给定时间内没有对用户输入(按键或者触屏操作）做出响应，通常是5s;</li>
<li>广播接收者(BroadcastReceiver)没有在10s内处理完成；</li>
</ul>
<p>对于输入无响应的情况，native监控到输入无响应时，则告知WMS，最后由WMS发送消息告诉AMS，某个应用发送了ANR，最后AMS会弹出<strong>Application Not Responding</strong>的对话框，请求用户关闭应用；对于广播无响应的情况是由AMS负责处理的，AMS对于每个发送出去给广播接收者的广播都有一个10s的定时，如果广播接收者在10s内尚未处理完，则视为无响应，因此也会弹出<strong>Application Not Responding</strong>。</p>
<p>首先来看下第一种情况。</p>
<h2 id="输入无响应"><a href="#输入无响应" class="headerlink" title="输入无响应"></a><strong>输入无响应</strong></h2><p>输入无响应是指用户长时间（5s内）无法响应用户的输入操作，如触摸，按键等，此时AMS会弹出对话框提示用户应用出现ANR(Application Not Responding)。</p>
<p>Android由<code>InputManagerService</code>（IMS）负责处理用户的输入事件，IMS会将输入转交给对应的应用窗口，最后由应用本身做出相应的操作；在native层，IMS有一个对应的<code>InputManager</code>来管理来自Kernel的输入事件（有关Android输入系统，请参考罗升阳<a href="http://blog.csdn.net/luoshengyang/article/details/6882903" title="Android应用程序键盘消息处理机制分析" target="_blank" rel="noopener">Android应用程序键盘消息处理机制分析</a>），<code>InputReader</code>负责读取输入事件，而<code>InputDispatcher</code>则负责将读取的事件分发出去。这里，就来看下<code>InputDispatcher</code>是如何检测应用输入无响应以及将其分发出去的。</p>
<p>以下是输入ANR处理流程图(图片来自<a href="http://gityuan.com/images/input/input_reader_seq.jpg)：" target="_blank" rel="noopener">http://gityuan.com/images/input/input_reader_seq.jpg)：</a></p>
<img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/input_reader_seq.jpg" class="[full-image]" title="Input ANR Process">
<p>native的<code>InputManager</code>初始化时启动一个<code>InputDispatcherThread</code>用于输入事件的分发:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">InputManager::InputManager(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line">    mDispatcher = <span class="keyword">new</span> InputDispatcher(dispatcherPolicy);</span><br><span class="line">    mReader = <span class="keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line">    mReaderThread = <span class="keyword">new</span> InputReaderThread(mReader);</span><br><span class="line">    mDispatcherThread = <span class="keyword">new</span> InputDispatcherThread(mDispatcher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> InputManager::start() &#123;</span><br><span class="line">    <span class="comment">// 分发线程</span></span><br><span class="line">    <span class="keyword">status_t</span> result = mDispatcherThread-&gt;run(<span class="string">"InputDispatcher"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    <span class="comment">// 读线程</span></span><br><span class="line">    result = mReaderThread-&gt;run(<span class="string">"InputReader"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InputDispatcherThread</code>启动时，进入一个线程循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">InputDispatcherThread::InputDispatcherThread(<span class="keyword">const</span> sp&lt;InputDispatcherInterface&gt;&amp; dispatcher) :</span><br><span class="line">        Thread(<span class="comment">/*canCallJava*/</span> <span class="literal">true</span>), mDispatcher(dispatcher) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动后，进入线程循环</span></span><br><span class="line"><span class="keyword">bool</span> InputDispatcherThread::threadLoop() &#123;</span><br><span class="line">    mDispatcher-&gt;dispatchOnce();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InputDispatcher</code>开始事件处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 指令请求队列为空，则开始分发输入事件</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run all pending commands if there are any.</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    <span class="comment">// 查看线程消息队列是否有新的消息</span></span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据输入事件的类型将事件分发出去，按键输入事件类型是<code>TYPE_KEY</code>，触屏输入事件<code>TYPE_MOTION</code>，这里假定应用处理的是一个按键事件:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(<span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (mPendingEvent-&gt;type) &#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// 按键事件</span></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//分发按键事件</span></span><br><span class="line">            done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 触屏事件</span></span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">            ....</span><br><span class="line">            done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                    &amp;dropReason, nextWakeupTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分发键盘事件之前，首先需要找到当前响应输入的焦点窗口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> InputDispatcher::dispatchKeyLocked(<span class="keyword">nsecs_t</span> currentTime, KeyEntry* entry,</span><br><span class="line">        DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 找到当前输入焦点窗口</span></span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">            entry, inputTargets, nextWakeupTime);</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// Dispatch the key.</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在查找目标焦点窗口之前，会检查是否有应用程序的窗口处于无响应状态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int32_t</span> InputDispatcher::findFocusedWindowTargetsLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        EventEntry* entry, Vector&lt;InputTarget&gt;&amp; inputTargets, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// Check whether the window is ready for more input</span></span><br><span class="line">    reason = checkWindowReadyForMoreInputLocked(currentTime,</span><br><span class="line">            focusedWindowHandle, entry, <span class="string">"focused"</span>);</span><br><span class="line">    <span class="comment">// 输入无响应</span></span><br><span class="line">    <span class="keyword">if</span> (!reason.isEmpty()) &#123;</span><br><span class="line">        injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                <span class="comment">//mFocusedApplicationHandle, mFocusedWindowHandle, nextWakeupTime, reason.string());</span></span><br><span class="line">                mFocusedApplicationHandle, focusedWindowHandle, nextWakeupTime, reason.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">    Failed:</span><br><span class="line">    Unresponsive:</span><br><span class="line">        <span class="keyword">nsecs_t</span> timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);</span><br><span class="line">        updateDispatchStatisticsLocked(currentTime, entry,</span><br><span class="line">                injectionResult, timeSpentWaitingForApplication);</span><br><span class="line">        <span class="keyword">return</span> injectionResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果发现焦点窗口无法对用户事件作出响应，并且超过了给定的时间(Android设定的超时为5s)，则</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int32_t</span> InputDispatcher::handleTargetsNotReadyLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> EventEntry* entry,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputApplicationHandle&gt;&amp; applicationHandle,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle,</span><br><span class="line">        <span class="keyword">nsecs_t</span>* nextWakeupTime, <span class="keyword">const</span> <span class="keyword">char</span>* reason) &#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">//应用无响应超时</span></span><br><span class="line">        <span class="keyword">if</span> (currentTime &gt;= mInputTargetWaitTimeoutTime) &#123;</span><br><span class="line">            onANRLocked(currentTime, applicationHandle, windowHandle,</span><br><span class="line">                    entry-&gt;eventTime, mInputTargetWaitStartTime, reason);</span><br><span class="line">            *nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">            <span class="keyword">return</span> INPUT_EVENT_INJECTION_PENDING;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Force poll loop to wake up when timeout is due.</span></span><br><span class="line">            <span class="keyword">if</span> (mInputTargetWaitTimeoutTime &lt; *nextWakeupTime) &#123;</span><br><span class="line">                *nextWakeupTime = mInputTargetWaitTimeoutTime;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> INPUT_EVENT_INJECTION_PENDING;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将ANR事件以<code>CommandEntry</code>的形式加入到命令队列中，等到下一次输入处理周期时在处理，处理时会调用函数<code>doNotifyANRLockedInterruptible</code>(见<code>dispatchOnce()</code>）:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::onANRLocked(</span><br><span class="line">        <span class="keyword">nsecs_t</span> currentTime, <span class="keyword">const</span> sp&lt;InputApplicationHandle&gt;&amp; applicationHandle,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle,</span><br><span class="line">        <span class="keyword">nsecs_t</span> eventTime, <span class="keyword">nsecs_t</span> waitStartTime, <span class="keyword">const</span> <span class="keyword">char</span>* reason) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将ANR事件添加到命令队列</span></span><br><span class="line">    CommandEntry* commandEntry = postCommandLocked(</span><br><span class="line">            &amp; InputDispatcher::doNotifyANRLockedInterruptible);</span><br><span class="line">    commandEntry-&gt;inputApplicationHandle = applicationHandle;</span><br><span class="line">    commandEntry-&gt;inputWindowHandle = windowHandle;</span><br><span class="line">    commandEntry-&gt;reason = reason;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>InputDispatcherPolicyInterface</code>接口通知<code>NativeInputMananger</code>有ANR事件发生：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::doNotifyANRLockedInterruptible(</span><br><span class="line">        CommandEntry* commandEntry) &#123;</span><br><span class="line">    mLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nsecs_t</span> newTimeout = mPolicy-&gt;notifyANR(</span><br><span class="line">            commandEntry-&gt;inputApplicationHandle, commandEntry-&gt;inputWindowHandle,</span><br><span class="line">            commandEntry-&gt;reason);</span><br><span class="line"></span><br><span class="line">    mLock.lock();</span><br><span class="line"></span><br><span class="line">    resumeAfterTargetsNotReadyTimeoutLocked(newTimeout,</span><br><span class="line">            commandEntry-&gt;inputWindowHandle != <span class="literal">NULL</span></span><br><span class="line">                    ? commandEntry-&gt;inputWindowHandle-&gt;getInputChannel() : <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，准备通知<code>InputManagerService.java</code>（IMS）ANR事件了，<code>mServiceObj</code>实际是一个Java类<code>InputManagerService</code>的一个全局引用，通过<code>CallLongMethod</code>来调用IMS中的<code>notifyANR</code>方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">nsecs_t</span> NativeInputManager::notifyANR(<span class="keyword">const</span> sp&lt;InputApplicationHandle&gt;&amp; inputApplicationHandle,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">const</span> String8&amp; reason) &#123;</span><br><span class="line"></span><br><span class="line">    JNIEnv* env = jniEnv();</span><br><span class="line"></span><br><span class="line">    jobject inputApplicationHandleObj =</span><br><span class="line">            getInputApplicationHandleObjLocalRef(env, inputApplicationHandle);</span><br><span class="line">    jobject inputWindowHandleObj =</span><br><span class="line">            getInputWindowHandleObjLocalRef(env, inputWindowHandle);</span><br><span class="line">    jstring reasonObj = env-&gt;NewStringUTF(reason.<span class="built_in">string</span>());</span><br><span class="line">     <span class="comment">//调用IMS的notifyANR方法</span></span><br><span class="line">    jlong newTimeout = env-&gt;CallLongMethod(mServiceObj,</span><br><span class="line">                gServiceClassInfo.notifyANR, inputApplicationHandleObj, inputWindowHandleObj,</span><br><span class="line">                reasonObj);</span><br><span class="line"></span><br><span class="line">    env-&gt;DeleteLocalRef(reasonObj);</span><br><span class="line">    env-&gt;DeleteLocalRef(inputWindowHandleObj);</span><br><span class="line">    env-&gt;DeleteLocalRef(inputApplicationHandleObj);</span><br><span class="line">    <span class="keyword">return</span> newTimeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>NativeInputManager</code>位于<code>com_android_server_input_InputManagerService.cpp</code>,是<code>InputManagerService.java</code>对应的Native文件中的类，其负责初始化输入系统的native框架</p>
</blockquote>
<p>IMS收到ANR事件后，通过一个回调接口<code>WindowManagerCallbacks</code>通知WMS(WindowManagerService)， <code>WindowManagerCallbacks</code>接口实际是一个<code>InputMonitor.java</code>对象，在SystemServer进程启动时，将WMS中的<code>InputMonitor</code>设置为IMS的回调:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">notifyANR</span><span class="params">(InputApplicationHandle inputApplicationHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputWindowHandle inputWindowHandle, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mWindowMangerCallbacks是InputMonitor实现的回调接口</span></span><br><span class="line">    <span class="keyword">return</span> mWindowManagerCallbacks.notifyANR(</span><br><span class="line">            inputApplicationHandle, inputWindowHandle, reason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向AMS发起<code>inputDispatchingTimedOut</code>的Binder请求，告知其ANR事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">notifyANR</span><span class="params">(InputApplicationHandle inputApplicationHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputWindowHandle inputWindowHandle, String reason)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">if</span> (appWindowToken != <span class="keyword">null</span> &amp;&amp; appWindowToken.appToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 告知AMS有ANR事件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Notify the activity manager about the timeout and let it decide whether</span></span><br><span class="line">            <span class="comment">// to abort dispatching or keep waiting.</span></span><br><span class="line">            <span class="keyword">long</span> timeout = ActivityManagerNative.getDefault().inputDispatchingTimedOut(</span><br><span class="line">                    windowState.mSession.mPid, aboveSystem, reason);</span><br><span class="line">            <span class="keyword">if</span> (timeout &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// The activity manager declined to abort dispatching.</span></span><br><span class="line">                <span class="comment">// Wait a bit longer and timeout again later.</span></span><br><span class="line">                <span class="keyword">return</span> timeout * <span class="number">1000000L</span>; <span class="comment">// nanoseconds</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// abort dispatching</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AMS处理输入响应超时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">inputDispatchingTimedOut</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">final</span> <span class="keyword">boolean</span> aboveSystem, String reason)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ProcessRecord proc;</span><br><span class="line">    <span class="keyword">long</span> timeout;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">            proc = mPidsSelfLocked.get(pid);</span><br><span class="line">        &#125;</span><br><span class="line">        timeout = getInputDispatchingTimeoutLocked(proc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!inputDispatchingTimedOut(proc, <span class="keyword">null</span>, <span class="keyword">null</span>, aboveSystem, reason)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现有应用进程ANR，AMS向主线程发送一个可执行对象，执行ANR操作，最后<code>AppErrors</code>会向当前应用程序的UI线程发送一个ANR的对话框：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inputDispatchingTimedOut</span><span class="params">(<span class="keyword">final</span> ProcessRecord proc,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ActivityRecord activity, <span class="keyword">final</span> ActivityRecord parent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">boolean</span> aboveSystem, String reason)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mAppErrors.appNotResponding(proc, activity, parent, aboveSystem, annotation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，再来看下广播处理超时的情况。</p>
<h2 id="广播处理超时"><a href="#广播处理超时" class="headerlink" title="广播处理超时"></a><strong>广播处理超时</strong></h2><p>广播的运行机制很像“内容发布者-订阅者”这样的信息传递方式：新闻报纸就是典型的例子，订阅者首先得到新闻通讯社注册成为用户才能接收到报纸；而新闻媒体则负责将报纸发送给各个合法的注册者。与此类似，广播的发送者通过<code>Context</code>中的接口<code>sendBroadcast(Intent)</code>向系统发送广播；而接收者则需要通过<code>Context</code>中提供的接口<code>registerReceiver</code>来监听广播，对于有系统权限限制的广播，需要相应的用户权限才允许接收。</p>
<p>Android系统广播由AMS(ActivityManagerService)负责管理，AMS中有两个广播队列，一个是前台广播(Intent中对应的标志位<code>FLAG_RECEIVER_FOREGROUND</code>),具有在前台运行的优先级；一个是后台广播，不指定前台标志位的广播都默认为后台广播。对于前台广播，接收者如果在10s内为完成，则视为超时；后台广播如果接收后60s内为完成，则超时。此时，AMS会向当前UI线程发送一个ANR的对话框。</p>
<p>AMS中接收到广播后，将广播放入一个队列,根据广播接收者注册机制的不同，广播队列分为并行与串行两种处理方式，并行处理广播不用等待其他广播完成，主要用于处理用<code>Context</code>接口注册的广播接收者；串行方式则必须按照严格广播入队列的先后次序来处理.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntentLocked</span><span class="params">(ProcessRecord callerApp,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callerPackage, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        IIntentReceiver resultTo, <span class="keyword">int</span> resultCode, String resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle resultExtras, String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle bOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 从Context中注册的广播接收</span></span><br><span class="line">    <span class="keyword">int</span> NR = registeredReceivers != <span class="keyword">null</span> ? registeredReceivers.size() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ordered &amp;&amp; NR &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If we are not serializing this broadcast, then send the</span></span><br><span class="line">        <span class="comment">// registered receivers separately so they don't wait for the</span></span><br><span class="line">        <span class="comment">// components to be launched.</span></span><br><span class="line">        <span class="keyword">if</span> (isCallerSystem) &#123;</span><br><span class="line">            checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid,</span><br><span class="line">                    isProtectedBroadcast, registeredReceivers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">        BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">                callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,</span><br><span class="line">                appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,</span><br><span class="line">                resultExtras, ordered, sticky, <span class="keyword">false</span>, userId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r);</span><br><span class="line">        <span class="comment">// 放入广播队列，并开始处理广播</span></span><br><span class="line">        <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">            queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">            queue.scheduleBroadcastsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        registeredReceivers = <span class="keyword">null</span>;</span><br><span class="line">        NR = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AndroidManifest.xml文件中声明的广播接收者</span></span><br><span class="line">    <span class="keyword">if</span> ((receivers != <span class="keyword">null</span> &amp;&amp; receivers.size() &gt; <span class="number">0</span>)</span><br><span class="line">            || resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">        BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">                callerPackage, callingPid, callingUid, resolvedType,</span><br><span class="line">                requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line">        <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">            queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">            queue.scheduleBroadcastsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送消息<code>BROADCAST_INTENT_MSG</code>请求处理广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleBroadcastsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前有广播在处理，返回</span></span><br><span class="line">    <span class="keyword">if</span> (mBroadcastsScheduled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, <span class="keyword">this</span>));</span><br><span class="line">    mBroadcastsScheduled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Handler</code>接受到消息，开始处理队列中的广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> </span><br><span class="line">        BroadcastHandler(Looper looper) &#123;</span><br><span class="line">        <span class="keyword">super</span>(looper, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> BROADCAST_INTENT_MSG: &#123;</span><br><span class="line">                <span class="comment">//处理广播</span></span><br><span class="line">                processNextBroadcast(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 广播超时消息</span></span><br><span class="line">            <span class="keyword">case</span> BROADCAST_TIMEOUT_MSG: &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">                    broadcastTimeoutLocked(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理下一个广播，简单起见，这里只分析串行分发广播的方式：首先记录下广播分发的时间<code>dispatchTime</code>,接着设置广播超时时间；最后开始处理广播，将其发送给广播接收者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processNextBroadcast</span><span class="params">(<span class="keyword">boolean</span> fromMsg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mService) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 取消广播超时设置</span></span><br><span class="line">            cancelBroadcastTimeoutLocked();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (r == <span class="keyword">null</span>);</span><br><span class="line">        ...</span><br><span class="line">        r.receiverTime = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (recIdx == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 广播分发时间</span></span><br><span class="line">            r.dispatchTime = r.receiverTime;</span><br><span class="line">            r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (! mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeoutTime = r.receiverTime + mTimeoutPeriod;</span><br><span class="line">            <span class="comment">//设置广播超时消息</span></span><br><span class="line">            setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// Is this receiver's application already running?</span></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.addPackage(info.activityInfo.packageName,</span><br><span class="line">                        info.activityInfo.applicationInfo.versionCode, mService.mProcessStats);</span><br><span class="line">                processCurBroadcastLocked(r, app);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">                finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                        r.resultExtras, r.resultAbort, <span class="keyword">false</span>);</span><br><span class="line">                scheduleBroadcastsLocked();</span><br><span class="line">                <span class="comment">// We need to reset the state if we failed to start the receiver.</span></span><br><span class="line">                r.state = BroadcastRecord.IDLE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">//广播接收者进程不存在，启动之</span></span><br><span class="line">     <span class="keyword">if</span> ((r.curApp=mService.startProcessLocked(targetProcess,</span><br><span class="line">                        info.activityInfo.applicationInfo, <span class="keyword">true</span>,</span><br><span class="line">                        r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,</span><br><span class="line">                        <span class="string">"broadcast"</span>, r.curComponent,</span><br><span class="line">                        (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != <span class="number">0</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>))</span><br><span class="line">                                == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//启动应用失败</span></span><br><span class="line">                    finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                            r.resultExtras, r.resultAbort, <span class="keyword">false</span>);</span><br><span class="line">                    scheduleBroadcastsLocked();</span><br><span class="line">                    r.state = BroadcastRecord.IDLE;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>如果广播处理在10s内未完成，则出发TIME_OUT的消息:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">broadcastTimeoutLocked</span><span class="params">(<span class="keyword">boolean</span> fromMsg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">        mPendingBroadcastTimeoutMessage = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mOrderedBroadcasts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">    BroadcastRecord r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">        <span class="keyword">long</span> timeoutTime = r.receiverTime + mTimeoutPeriod;</span><br><span class="line">        <span class="keyword">if</span> (timeoutTime &gt; now) &#123;</span><br><span class="line">            <span class="comment">// 处理成功，重新设置TIMEOUT时间，返回</span></span><br><span class="line">            setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    r.receiverTime = now;</span><br><span class="line">    r.anrCount++;</span><br><span class="line"></span><br><span class="line">    ProcessRecord app = <span class="keyword">null</span>;</span><br><span class="line">    String anrMessage = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Object curReceiver = r.receivers.get(r.nextReceiver-<span class="number">1</span>);</span><br><span class="line">    r.delivery[r.nextReceiver-<span class="number">1</span>] = BroadcastRecord.DELIVERY_TIMEOUT;</span><br><span class="line">    <span class="keyword">if</span> (curReceiver <span class="keyword">instanceof</span> BroadcastFilter) &#123;</span><br><span class="line">        BroadcastFilter bf = (BroadcastFilter)curReceiver;</span><br><span class="line">        <span class="keyword">if</span> (bf.receiverList.pid != <span class="number">0</span></span><br><span class="line">                &amp;&amp; bf.receiverList.pid != ActivityManagerService.MY_PID) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mService.mPidsSelfLocked) &#123;</span><br><span class="line">                app = mService.mPidsSelfLocked.get(</span><br><span class="line">                        bf.receiverList.pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = r.curApp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move on to the next receiver.</span></span><br><span class="line">    finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">            r.resultExtras, r.resultAbort, <span class="keyword">false</span>);</span><br><span class="line">    scheduleBroadcastsLocked();</span><br><span class="line">    <span class="comment">// 向超时应用发送ANR消息</span></span><br><span class="line">    <span class="keyword">if</span> (anrMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mHandler.post(<span class="keyword">new</span> AppNotResponding(app, anrMessage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> ANR </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程之锁]]></title>
      <url>http://sniffer.site/2017/06/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%94%81/</url>
      <content type="html"><![CDATA[<p>Java语言<code>synchronized</code>关键字自带了一个内置的隐性锁(implicit lock),使用起来方便简单，但是内置锁一旦使用，则会强制将某个代码块加锁或者解锁，而且内置锁并不支持可中断的获取锁。从Java5.0开始，提供了一个并发工具包<code>java.util.concurrent.*</code>，实现了显性锁(explicit lock)<code>ReentrantLock</code>（可重入锁，可多次获取同一个锁）;<code>ReentrantLock</code>实现了与<code>synchronized</code>一样的功能，确保并发过程中数据的互斥访问与可见性。获取<code>ReentrantLock</code>相当于进入一个<code>synchronized</code>代码块，而释放<code>ReentrantLock</code>则相当于从一个<code>synchronized</code>代码块退出。<code>ReentrantLock</code>实现了如下<code>Lock.java</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取锁，可响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试获取锁，如果可用则返回TRUE，否则返回FALSE</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试在给定时间内获取锁，如果超时或者发生中断，则返回FALSE</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建与该锁绑定的Conidition变量</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ReentrantLock</code>支持中断地获取锁，也可以给定超时时间获取锁，从而为并发编程提供了更大的灵活性。如下代码是<code>ReentrantLock</code>使用的一个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可重入锁<code>ReentrantLock</code>有两种获取模式：一种是公平(fair)，就是说锁按照请求的顺序获取的，而非公平(non-fair)模式则并不管等待队列中是否有线程，只要请求锁时可用，则直接获取锁。非公平锁是默认的实现方式。从表面上看，公平模式性能似乎要更好。但实际上，大多数情况非公平模式的性能都要优于公平模式（见 Doug Lea《Java Concurrency in Practice》)。</p>
<p>除了<code>ReentrantLock</code>，还有一种常用的锁<code>ReentrantReadWriteLock</code>(可重入读写锁)。在并发编程的情况下使用<code>ReentrantLock</code>虽然确保了任何时候都只有一个线程操作，保证了数据的一致性，但实际上大部分情况，共享数据往往是只需要读，而不会被修改，这样<code>ReentrantLock</code>对于多个读线程(Reader）的情况就显得有点过于谨慎了。那么，能否让多个读线程同时运行，而任何时刻都只有一个写线程(Writer)了？这就是<code>ReadWriteLock</code>需要做的事情。<code>ReentrantReadWriteLock</code>实现了如下<code>ReadWriteLock</code>接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读锁</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写锁</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读写锁确保可同时有多个Reader而任何时刻都只有一个Writer,从而提升了读写的并发程度。这种特性使得<code>ReentrantReadWriteLock</code>尤其适合读操作执行时间长而很少有写操作的情况。与<code>ReentrantLock</code>类似，读写锁也提供了Fair与Non-fair两种获取模式。在公平模式下，锁总是给那些请求等待时间最长的线程，如果读锁被一个线程持有，此时另一个线程请求写锁，则其他请求读锁的线程一直会阻塞直到获取到写锁的线程完成任务；对于非公平模式，锁获取的顺序是不定的。另外，读写锁还支持锁降级（downgrading)，如果一个线程持有写锁，但需要请求读锁，此时无需释放写锁就可以直接获取读锁（其他写锁请求被阻塞），但不支持锁升级(upgrading，可能导致死锁)：持有读锁的线程请求写锁。</p>
<p>这里我们来看一个具体的实例：利用读写锁来实现一个可支持多个Reader,单个Writer的Map对象，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock rl = rwLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock wl = rwLock.writeLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadWriteMap</span><span class="params">(Map&lt;K,V&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">        wl.lock();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            wl.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do same for putAll(), clear()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">        wl.lock();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            map.remove(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            wl.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">        rl.lock();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">             <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            rl.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>了解了两种基本的锁，接下来这一节就来着重分析下<code>ReentrantLock</code>的具体实现原理。</p>
<h2 id="ReentrantLock的实现原理"><a href="#ReentrantLock的实现原理" class="headerlink" title="ReentrantLock的实现原理"></a><strong>ReentrantLock的实现原理</strong></h2><p>在分析<code>ReentrantLock</code>的具体原理之前，先来看下<code>java.util.concurrent</code>包同步器实现的基础类<code>AbstractQueueSynchronizer</code>(AQS)的实现机制。除了<code>ReentrantLock</code>，<code>ReentrantReadWriteLock</code>之外，AQS是同步类如<code>Semaphore</code>,<code>CountDownLatch</code>,<code>FutureTask</code>的实现基础。与内置同步<code>synchronized</code>不同的是，AQS支持：</p>
<ul>
<li>非阻塞的同步（<code>Lock.tryLock()</code>)以及阻塞同步;</li>
<li>锁获取超时，防止线程饥饿；</li>
<li>可通过中断取消锁的获取；</li>
</ul>
<p>AQS主要提供了两类方法：<code>acquire</code>操作（可能阻塞或者不阻塞当前线程）和<code>release</code>操作。AQS对于每个阻塞线程都维护了一个同步状态，这个状态可以是互斥的（exclusive,只有一个线程可访问）也可以是共享的(shared,多个线程可访问）。互斥模式一般用于实现锁，如<code>ReentrantLock</code>；而信号量<code>Semaphore</code>,计数门栓<code>CountDownLatch</code>则通过共享模式实现。</p>
<h3 id="AQS实现原理"><a href="#AQS实现原理" class="headerlink" title="AQS实现原理"></a><strong>AQS实现原理</strong></h3><p>实现AQS的基本原理比较简单，一个获取操作可以按如下方式处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span>(*synchronization state does not allow acquire*)&#123;</span><br><span class="line">    *enqueue current thread <span class="keyword">if</span> not already queued;*</span><br><span class="line">    *possibly block current thread;*</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*dequeue current thread <span class="keyword">if</span> it was queued;*</span><br></pre></td></tr></table></figure>
<p>而释放操作可以这么处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*update synchronization state*</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(*state may permit a blocked thread to acquire*)</span><br><span class="line">    *unblock one or more queued threads;*</span><br></pre></td></tr></table></figure>
<p>要实现上述操作，需要三个基本组件的通力协作：</p>
<ul>
<li>原子地更新同步状态（通过对一个<code>volatile</code>变量进行CAS操作实现）；</li>
<li>阻塞线程以及解阻线程（通过<code>LockSupport.park/unpark</code>方法实现）；</li>
<li>维护阻塞线程队列；</li>
</ul>
<p>这里，主要来看下AQS是如何实现阻塞线程队列的。AQS中阻塞线程队列是由一个个<code>Node</code>节点组成的双端链表，每个节点包含了阻塞线程，队列的头节点、尾节点、前驱节点，后驱节点以及线程同步状态、线程等待状态等信息。获取时，AQS首先通过<code>tryAcquire</code>（由每个同步类自己实现）尝试获取，如果获取失败，则需要将其添加到等待队列中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">// 尝试获取</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加等待节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入队列</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队后，不断尝试获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 前驱节点为头节点，并且设置状态成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//出队列</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>释放时，调用<code>tryRelease()</code>释放，接着解阻头节点的前驱节点线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看看可重入锁<code>ReentrantLock</code>是如何利用AQS来实现锁的获取与释放的。</p>
<h3 id="ReentrantLock的实现"><a href="#ReentrantLock的实现" class="headerlink" title="ReentrantLock的实现"></a><strong>ReentrantLock的实现</strong></h3><p><code>ReentrantLock</code>提供了两个构造函数：默认构造函数利用非公平模式实现；如果需要公平模式，则可通过指定模式来构造。这里<code>NonfairSync</code>跟<code>FairSync</code>都是<code>ReentrantLock</code>的内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定实现模式：nonfair</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">     sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>获取锁，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非公平方式获取时，首先不管阻塞线程队列是否有线程，直接通过CAS操作来设置状态，直至成功：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// AQS实现</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 非公平方式获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>而对于公平方式，则首先会检查AQS等待队列中是否有线程比当前线程更早的进行获取锁的操作，如果没有才让当前线程成为锁持有者，否则当前线程需要进入等待队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// AQS的实现</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公平方式获取锁，检查是否有更早的等待线程</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关<code>ReentrantLock</code>以及AQS的实现源码可参考<a href="http://grepcode.com/snapshot/repository.grepcode.com/java/root/jdk/openjdk/6-b27/" target="_blank" rel="noopener">OpenJDK</a> 。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/papers/aqs.pdf</a></li>
<li><a href="http://gee.cs.oswego.edu/dl/concurrency-interest/jsr166-slides.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/concurrency-interest/jsr166-slides.pdf</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> 并发编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
            <tag> Lock </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程之原子操作]]></title>
      <url>http://sniffer.site/2017/06/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>在古希腊时代，哲学家Democritus（德谟克利特）提出了关于物质构成的理论：所有物质都由不可分割的元素组成，这种元素被称之为原子（atom）。编程中所说的原子性(atomic)借用了这个概念, 用于表示某个代码指令动作的不可中断性。在之前的一篇文章（Java Memory Model)时，提到多线程并发访问共享数据时，会出现数据竞争，从而导致数据不一致的情况。比如对一个整型变量进行加一的操作： <code>++counter</code>，表面上看，这是一个单一原子操作，但实际上这个操作有三个步骤：首先，需要从内存中（有可能是cache中）加载到寄存器；接着，将该值加一；最后需要将寄存器中的值写入内存。这样，在多个线程访问的情况，上述几个步骤出现交织执行，就可能出现各个线程读写数据不一致的情形。</p>
<a id="more"></a>
<blockquote>
<p>Atomic Theory: <a href="http://www.softschools.com/timelines/atomic_theory_timeline/95/" target="_blank" rel="noopener">http://www.softschools.com/timelines/atomic_theory_timeline/95/</a></p>
</blockquote>
<p>于是，有了原子操作。原子操作确保了执行的不可中断，因而能避免数据冲突。Java从5.0开始有一个<code>atomic</code>的工具包专门支持<code>int</code>，<code>long</code>以及引用变量的原子操作，而在硬件层面，目前大部分处理器都支持诸如<code>CAS</code>(CompareAndSet/CompareAndSwap)，<code>FAA</code>(FetchAndAdd)等原子指令。在介绍Java中的原子操作类之前，先来了解下硬件层面的原子指令。</p>
<blockquote>
<p>一个执行操作的原子性，是说该操作不可中断，除非其他线程在执行原子操作（此时当前线程进行原子操作出现错误)，否则当前线程需要占用CPU，直到执行完该操作为止，从而确保数据的互斥访问与可见性。</p>
</blockquote>
<h2 id="处理器原子指令"><a href="#处理器原子指令" class="headerlink" title="处理器原子指令"></a><strong>处理器原子指令</strong></h2><p>相比锁(lock)，原子操作由于暂时禁止了中断，确保当前线程不会进行上下文切换，不会阻塞当前线程，效率通常要更高。因此，支持原子操作的处理器通常可以用来实现无锁算法(<a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm" target="_blank" rel="noopener">Non-blocking_algorithm</a>)。常见的几个原子指令有:</p>
<ul>
<li>atomic swap: 原子的交换数据，x86对应的指令为<strong>XCHG</strong> (<a href="https://en.wikipedia.org/wiki/X86_instruction_listings" target="_blank" rel="noopener">X86_instruction_listings</a>);</li>
<li>test and set: 向内存写入1，并返回旧值；</li>
<li>fetch and add: 从内存中读取变量，并增加其值；</li>
<li>compare and swap: CAS, 将一个变量的值与某个期望值比较，如果相等，则将新的值写入到内存;否则直接返回原值，不做任何操作（对应X86指令<strong>CMPXCHG</strong>）；</li>
</ul>
<p>这里主要看下CAS的具体原理。CAS操作涉及的参数有内存区域<em>V</em>，期望的旧值<em>A</em>，以及新值<em>B</em>；如果<em>V</em>中的当前值与期望的值相等（表示当前没有其他线程修改过<em>V</em>），则更新<em>V</em>为新值<em>B</em>。当多个线程同时访问<em>V</em>时，一个线程成功修改了变量值，其他线程则直接失败了，但CAS不会阻塞这些线程。</p>
<p>以下是模拟实际CAS操作的一个代码片段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// samples from Ch15 of &lt;&lt;Java Concurrency in Practice&gt;&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimulatedCAS</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectedV, <span class="keyword">int</span> newV)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldV = value;</span><br><span class="line">        <span class="keyword">if</span>(oldV == expectedV)&#123;</span><br><span class="line">            value = newV;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> oldV;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedV, <span class="keyword">int</span> newV)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (expectedV == compareAndSwap(expectedV,newV));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Atomic工具包"><a href="#Atomic工具包" class="headerlink" title="Atomic工具包"></a><strong>Atomic工具包</strong></h2><p>Java5.0开始提供了一个Atomic的工具包，支持对<code>int</code> (<code>AtomicInteger</code>) ,<code>long</code> （<code>AtomicLong</code>）,<code>boolean</code>(<code>AtomicBoolean</code>)以及整型数组(<code>AtomicIntegerArray</code>)、引用类型(<code>AtomicReference</code>)、引用类型成员(<code>AtomicReferenceFieldUpdater</code>）的原子操作。如果使用其他基本类型数据如<code>float</code>,<code>double</code>，可以通过<code>floatToIntBits()</code>和<code>doubleToLongBit()</code>将<code>long</code>跟<code>double</code>转换成一个<code>int</code>，<code>long</code>再使用相应的原子类。</p>
<p>如下是<code>AtomicInteger</code>的一个代码片段，其内部整型成员<code>value</code>是一个<code>volatile</code>变量，这样可以确保多线程访问时数据的可见性；而底层封装类<code>Unsafe</code>提供的CAS操作则保证了<code>AtomicInteger</code>成员变量访问的互斥性。可以这么说，<code>AtomicInteger</code>是<code>volatile</code>的一般化实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确保变量的可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Eventually sets to the given value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putOrderedInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，以<code>AtomicInteger</code>为例来看下<code>Atomic</code>包具体的使用。假定，我们想要统计一个类某个接口的调用次数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExamples</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger sCalledCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AtomicExamples atomic = <span class="keyword">new</span> AtomicExamples();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; ++i)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"currently called "</span> + </span><br><span class="line">                    atomic.callMe() + <span class="string">" times"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;,<span class="string">"thread-"</span> + i);</span><br><span class="line">            </span><br><span class="line">           t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">callMe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sCalledCount.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="http://cs.brown.edu/~mph/Herlihy91/p124-herlihy.pdf" target="_blank" rel="noopener">http://cs.brown.edu/~mph/Herlihy91/p124-herlihy.pdf</a></li>
<li><a href="https://courses.cs.washington.edu/courses/cse378/07au/lectures/L25-Atomic-Operations.pdf" target="_blank" rel="noopener">https://courses.cs.washington.edu/courses/cse378/07au/lectures/L25-Atomic-Operations.pdf</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> 并发编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
            <tag> Atomicity </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Glide详解之图片加载过程分析]]></title>
      <url>http://sniffer.site/2017/05/30/Glide%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>在之前的一篇文章(<a href="http://sniffer.site/2017/05/20/Glide%E8%AF%A6%E8%A7%A3%E4%B9%8B%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/">Glide架构分析</a> )中介绍了Glide的具体原理。这篇文章，用一个下载图片的示例来说明Glide加载图片的整个过程。以下是用Glide从网络上加载一个图片的代码片段：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">Glide</span><br><span class="line">  .with(activity) <span class="comment">// Activity</span></span><br><span class="line">  .load(url)</span><br><span class="line">  .centerCrop()</span><br><span class="line">  .placeholder(R.drawable.loading_spinner)</span><br><span class="line">  .crossFade()</span><br><span class="line">  .into(myImageView);</span><br></pre></td></tr></table></figure>
<p>大致说来，在Glide中图片的加载有如下几个过程：</p>
<ul>
<li>产生一个图片加载的请求<code>GenericRequest&lt;T&gt;</code>;</li>
<li>将图片加载请求发送给资源引擎中心<code>Engine</code>,由其负责资源的加载以及数据解码任务的管理；</li>
<li><code>EngineRunnable</code>首先尝试从DISK加载资源，完成后进行回调，将数据加载到<code>ImageView</code>中；</li>
<li>磁盘中没有请求对应的资源，则尝试从网络端下载，并解码完成后回调，将数据加载到<code>Target</code>对象；</li>
</ul>
<p>现在就来详细的看下Glide加载图片的整个过程。</p>
<h2 id="产生图片加载请求"><a href="#产生图片加载请求" class="headerlink" title="产生图片加载请求"></a><strong>产生图片加载请求</strong></h2><p>调用<code>Glide.with(activity)</code>产生一个<code>RequestManager</code>，用来负责管理和启动数据加载请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">    <span class="keyword">return</span> retriever.get(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>RequestManagerRetriever</code>产生<code>RequestMananger</code>时，会启动一个没有视图对象的<code>Fragment</code>用以自动管理Glide中加载请求的生命周期：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">RequestManager <span class="title">fragmentGet</span><span class="params">(Context context, android.app.FragmentManager fm)</span> </span>&#123;</span><br><span class="line">    RequestManagerFragment current = getRequestManagerFragment(fm);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestManager = <span class="keyword">new</span> RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">        current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TargetApi</span>(Build.VERSION_CODES.JELLY_BEAN_MR1)</span><br><span class="line"><span class="function">RequestManagerFragment <span class="title">getRequestManagerFragment</span><span class="params">(<span class="keyword">final</span> android.app.FragmentManager fm)</span> </span>&#123;</span><br><span class="line">    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">        current = pendingRequestManagerFragments.get(fm);</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            current = <span class="keyword">new</span> RequestManagerFragment();</span><br><span class="line">            pendingRequestManagerFragments.put(fm, current);</span><br><span class="line">            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">            handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续调用<code>RequestManager.load(url)</code>,<code>RequestMananger</code>开始着手创建新的图片加载请求<code>DrawableTypeRequest&lt;String&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DrawableTypeRequest&lt;String&gt; <span class="title">load</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (DrawableTypeRequest&lt;String&gt;) fromString().load(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DrawableTypeRequest&lt;String&gt; <span class="title">fromString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadGeneric(String.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">DrawableTypeRequest&lt;T&gt; <span class="title">loadGeneric</span><span class="params">(Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数据加载器，Glide默认的是HttpUrlGlideUrlLoader</span></span><br><span class="line">    ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);</span><br><span class="line">    ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader =</span><br><span class="line">            Glide.buildFileDescriptorModelLoader(modelClass, context);</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> optionsApplier.apply(</span><br><span class="line">            <span class="keyword">new</span> DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,</span><br><span class="line">                    glide, requestTracker, lifecycle, optionsApplier));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>DrawableTypeRequest</code>，可以配置图片加载时的参数，如图片显示位置(<code>fitCenter</code>;<code>centerCrop</code>),图片加载的优先级<code>priority</code>,设置下载之前的占位符图片<code>placeholder()</code>，以及图片下载失败时的图片<code>error()</code>:</p>
<blockquote>
<p>这些参数配置功能均在<code>DrawableRequestBuilder</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DrawableRequestBuilder&lt;ModelType&gt; <span class="title">priority</span><span class="params">(Priority priority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.priority(priority);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DrawableRequestBuilder&lt;ModelType&gt; <span class="title">centerCrop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transform(glide.getDrawableCenterCrop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DrawableRequestBuilder&lt;ModelType&gt; <span class="title">fitCenter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transform(glide.getDrawableFitCenter());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> DrawableRequestBuilder&lt;ModelType&gt; <span class="title">crossFade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.animate(<span class="keyword">new</span> DrawableCrossFadeFactory&lt;GlideDrawable&gt;());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DrawableRequestBuilder&lt;ModelType&gt; <span class="title">error</span><span class="params">(<span class="keyword">int</span> resourceId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.error(resourceId);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，图片加载请求就完成了。此时调用<code>into(ImageView)</code>，Glide就可以准备加载图片了。在<code>GenericRequestBuilder</code>中，调用<code>into(ImageView)</code>时首先会将<code>ImageView</code>包装成一个<code>Target&lt;R&gt;</code>,这里的资源类型<code>R</code>是<code>GlideDrawable</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Target&lt;TranscodeType&gt; <span class="title">into</span><span class="params">(ImageView view)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must pass in a non null View"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isTransformationSet &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">                applyCenterCrop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">            <span class="keyword">case</span> FIT_START:</span><br><span class="line">            <span class="keyword">case</span> FIT_END:</span><br><span class="line">                applyFitCenter();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//$CASES-OMITTED$</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// Do nothing.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> into(glide.buildImageViewTarget(view, transcodeClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Glide调用<code>ImageViewTargetFactory</code>来生成一个<code>Target</code>对象，这里实际创建的是一个<code>GlideDrawableImageViewTarget</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageViewTargetFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;Z&gt; <span class="function">Target&lt;Z&gt; <span class="title">buildTarget</span><span class="params">(ImageView view, Class&lt;Z&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (GlideDrawable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Target&lt;Z&gt;) <span class="keyword">new</span> GlideDrawableImageViewTarget(view);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Bitmap.class.equals(clazz)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Target&lt;Z&gt;) <span class="keyword">new</span> BitmapImageViewTarget(view);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Drawable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Target&lt;Z&gt;) <span class="keyword">new</span> DrawableImageViewTarget(view);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unhandled class: "</span> + clazz</span><br><span class="line">                    + <span class="string">", try .as*(Class).transcode(ResourceTranscoder)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>into(Target)</code>，在这里生成一个<code>Request</code>,并将其传递给<code>RequestTracker</code>执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(Y target)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    ....</span><br><span class="line">    Request previous = target.getRequest();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        previous.clear();</span><br><span class="line">        requestTracker.removeRequest(previous);</span><br><span class="line">        previous.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 产生图片加载请求</span></span><br><span class="line">    Request request = buildRequest(target);</span><br><span class="line">    target.setRequest(request);</span><br><span class="line">    lifecycle.addListener(target);</span><br><span class="line">    requestTracker.runRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动图片加载"><a href="#启动图片加载" class="headerlink" title="启动图片加载"></a><strong>启动图片加载</strong></h2><p>调用<code>RequestTracker.runRequest</code>，保存该<code>Request</code>到队列中，如果当前状态没有处于<code>paused</code>，则直接调用<code>Request.begin</code>,启动<code>Request</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    requests.add(request);</span><br><span class="line">    <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">        request.begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pendingRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">        onException(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = Status.WAITING_FOR_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">        onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target.getSize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">        target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果图片给定的尺寸大小有效，则从<code>FixedLoadProvider</code>中获取一个数据加载器（在构造<code>DrawableTypeRequest</code>时由Glide创建），并将其作为参数传入<code>Engine</code>进行图片加载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    status = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    width = Math.round(sizeMultiplier * width);</span><br><span class="line">    height = Math.round(sizeMultiplier * height);</span><br><span class="line"></span><br><span class="line">    ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();</span><br><span class="line">    <span class="keyword">final</span> DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);</span><br><span class="line">    ....</span><br><span class="line">    ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();</span><br><span class="line">    ....</span><br><span class="line">    loadedFromMemoryCache = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 调用load进行图片加载</span></span><br><span class="line">    loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,</span><br><span class="line">            priority, isMemoryCacheable, diskCacheStrategy, <span class="keyword">this</span>);</span><br><span class="line">    loadedFromMemoryCache = resource != <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载图片，如果缓存中有，则直接回调返回该资源；或者<code>Engine</code>中有保存的活跃资源（之前提交了<code>Request</code>但尚未被释放的资源）也会直接返回该资源。否则需要从DISK或者网络端进行加载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T, Z, R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(Key signature, <span class="keyword">int</span> width, <span class="keyword">int</span> height, DataFetcher&lt;T&gt; fetcher,</span></span></span><br><span class="line"><span class="function"><span class="params">        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</span></span></span><br><span class="line"><span class="function"><span class="params">        Priority priority, <span class="keyword">boolean</span> isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String id = fetcher.getId();</span><br><span class="line">    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),</span><br><span class="line">            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),</span><br><span class="line">            transcoder, loadProvider.getSourceEncoder());</span><br><span class="line">    <span class="comment">// cache中已经包含</span></span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cb.onResourceReady(cached);</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            logWithTimeAndKey(<span class="string">"Loaded resource from cache"</span>, startTime, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 活跃资源中包含该请求所需资源</span></span><br><span class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">    <span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cb.onResourceReady(active);</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            logWithTimeAndKey(<span class="string">"Loaded resource from active resources"</span>, startTime, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineJob current = jobs.get(key);</span><br><span class="line">    ....</span><br><span class="line">    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</span><br><span class="line">    DecodeJob&lt;T, Z, R&gt; decodeJob = <span class="keyword">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</span><br><span class="line">            transcoder, diskCacheProvider, diskCacheStrategy, priority);</span><br><span class="line">    <span class="comment">// EngineRunnable负责图片下载，解码</span></span><br><span class="line">    EngineRunnable runnable = <span class="keyword">new</span> EngineRunnable(engineJob, decodeJob, priority);</span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line">    engineJob.addCallback(cb);</span><br><span class="line">    <span class="comment">// 开始执行图片加载</span></span><br><span class="line">    engineJob.start(runnable);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将<code>EngineRunnable</code>可执行对象放入一个优先级线程池<code>FifoPriorityThreadPoolExecutor</code>中执行：</p>
<blockquote>
<p>两个线程池均在GlideBuilder创建，然后传给Engine的构造函数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(EngineRunnable engineRunnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.engineRunnable = engineRunnable;</span><br><span class="line">    future = diskCacheService.submit(engineRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>EngineRunnable</code>的初始状态为<code>CACHE</code>,因此首先会尝试从DISK的缓存中加载资源，如果加载成功，则直接回调返回该资源给上层调用者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    Exception exception = <span class="keyword">null</span>;</span><br><span class="line">    Resource&lt;?&gt; resource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从DISK或者NETWORK加载图片</span></span><br><span class="line">        resource = decode();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        exception = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 资源加载结束，回调返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (resource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        onLoadFailed(exception);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onLoadComplete(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Resource&lt;?&gt; decode() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// stage为cache,直接从cache中获取资源</span></span><br><span class="line">    <span class="keyword">if</span> (isDecodingFromCache()) &#123;</span><br><span class="line">        <span class="keyword">return</span> decodeFromCache();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> decodeFromSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>DecodeJob.decodeFromCache()</code>尝试从CACHE中获取资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> Resource&lt;?&gt; decodeFromCache() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Resource&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = decodeJob.decodeResultFromCache();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"Exception decoding result from cache: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = decodeJob.decodeSourceFromCache();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果CACHE中并没有发现可用的资源，<code>EngineRunnable</code>进入<code>SOURCE</code>状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDecodingFromCache()) &#123;</span><br><span class="line">        stage = Stage.SOURCE;</span><br><span class="line">        <span class="comment">// 通过EngineJob将该执行对象再次执行</span></span><br><span class="line">        manager.submitForSource(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        manager.onException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EngineJob: 这一次提交到网络端线程池加载资源</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitForSource</span><span class="params">(EngineRunnable runnable)</span> </span>&#123;</span><br><span class="line">    future = sourceService.submit(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从网络端下载图片，回调返回结果"><a href="#从网络端下载图片，回调返回结果" class="headerlink" title="从网络端下载图片，回调返回结果"></a><strong>从网络端下载图片，回调返回结果</strong></h2><p>调用<code>DecodeJob.decodeFromSource()</code>,从网络端下载图片,并将数据解码成对应格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Z&gt; <span class="title">decodeFromSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Resource&lt;T&gt; decoded = decodeSource();</span><br><span class="line">    <span class="keyword">return</span> transformEncodeAndTranscode(decoded);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>Resource&lt;T&gt;</code>对应的<code>DataFetcher&lt;A&gt;</code>来从网络端加载数据，这里<code>T</code>是一个<code>Bitmap</code>， 而<code>A</code>是一个<code>InputStream</code>数据流；接着讲该输入流转换成相应的<code>Resource&lt;Bitmap&gt;</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;T&gt; <span class="title">decodeSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Resource&lt;T&gt; decoded = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">        <span class="comment">// 这里的DataFetcher实际上是OkHttpStreamFetcher</span></span><br><span class="line">        <span class="keyword">final</span> A data = fetcher.loadData(priority);</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">            logWithTimeAndKey(<span class="string">"Fetched data"</span>, startTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        decoded = decodeFromSourceData(data);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fetcher.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decoded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>OkHttpStreamFetcher.loadData()</code>加载数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">loadData</span><span class="params">(Priority priority)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request.Builder requestBuilder = <span class="keyword">new</span> Request.Builder().url(url.toStringUrl());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; headerEntry : url.getHeaders().entrySet()) &#123;</span><br><span class="line">        String key = headerEntry.getKey();</span><br><span class="line">        requestBuilder.addHeader(key, headerEntry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    Request request = requestBuilder.build();</span><br><span class="line"></span><br><span class="line">    Response response;</span><br><span class="line">    call = client.newCall(request);</span><br><span class="line">    response = call.execute();</span><br><span class="line">    responseBody = response.body();</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Request failed with code: "</span> + response.code());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> contentLength = responseBody.contentLength();</span><br><span class="line">    stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>loadProvider</code>是<code>StreamBitmapDataLoadProvider</code>，而用于资源解码的是<code>StreamBitmapDecoder</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;T&gt; <span class="title">decodeFromSourceData</span><span class="params">(A data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Resource&lt;T&gt; decoded;</span><br><span class="line">    <span class="comment">// 默认的磁盘缓存策略是(source,result) = (false, true)</span></span><br><span class="line">    <span class="keyword">if</span> (diskCacheStrategy.cacheSource()) &#123;</span><br><span class="line">        decoded = cacheAndDecodeSourceData(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用InputStream对应的资源解码器对InputStream进行解密</span></span><br><span class="line">        decoded = loadProvider.getSourceDecoder().decode(data, width, height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decoded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//StreamBitmapDecoder: 输入流数据进行解码，按照给定的图片尺寸对图片进行比例采样</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Bitmap&gt; <span class="title">decode</span><span class="params">(InputStream source, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    Bitmap bitmap = downsampler.decode(source, bitmapPool, width, height, decodeFormat);</span><br><span class="line">    <span class="keyword">return</span> BitmapResource.obtain(bitmap, bitmapPool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此图片解码完成了，接着要讲<code>Resource&lt;Bitmap&gt;</code>转换成另一种包装类格式<code>GlideBitmapDrawable</code>，因而此时实际返回的是一个<code>GlideBitmapDrawableResource</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Z&gt; <span class="title">decodeFromSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Resource&lt;T&gt; decoded = decodeSource();</span><br><span class="line">    <span class="comment">// 大小变换以及转换成另一个类Z</span></span><br><span class="line">    <span class="keyword">return</span> transformEncodeAndTranscode(decoded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;Z&gt; <span class="title">transformEncodeAndTranscode</span><span class="params">(Resource&lt;T&gt; decoded)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;T&gt; transformed = transform(decoded);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Transformed resource from source"</span>, startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将变换后的结果保存到缓存</span></span><br><span class="line">    writeTransformedToCache(transformed);</span><br><span class="line">    <span class="comment">// 转换成GlideBitmapDrawable</span></span><br><span class="line">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回调<code>onLoadComplete()</code>,告知<code>EngineJob</code>资源加载完成了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onLoadComplete</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">    manager.onResourceReady(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回调<code>EngineJob.onResourceReady()</code>,在主线程上处理回调结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EngineJob</span> <span class="keyword">implements</span> <span class="title">EngineRunnable</span>.<span class="title">EngineRunnableManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于向主线程发送消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Handler MAIN_THREAD_HANDLER = <span class="keyword">new</span> Handler(Looper.getMainLooper(), <span class="keyword">new</span> MainThreadCallback());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(<span class="keyword">final</span> Resource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resource = resource;</span><br><span class="line">        MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, <span class="keyword">this</span>).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadCallback</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (MSG_COMPLETE == message.what || MSG_EXCEPTION == message.what) &#123;</span><br><span class="line">                EngineJob job = (EngineJob) message.obj;</span><br><span class="line">                <span class="keyword">if</span> (MSG_COMPLETE == message.what) &#123;</span><br><span class="line">                    <span class="comment">// 资源加载成功</span></span><br><span class="line">                    job.handleResultOnMainThread();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    job.handleExceptionOnMainThread();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主线程上处理结果：首先告知<code>Engine</code>资源加载完毕，接着告知所有<code>ResourceCallback</code>，并返回一个含有资源的包装类<code>EngineResource</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResultOnMainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    engineResource = engineResourceFactory.build(resource, isCacheable);</span><br><span class="line">    hasResource = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hold on to resource for duration of request so we don't recycle it in the middle of notifying if it</span></span><br><span class="line">    <span class="comment">// synchronously released by one of the callbacks.</span></span><br><span class="line">    engineResource.acquire();</span><br><span class="line">    listener.onEngineJobComplete(key, engineResource);</span><br><span class="line">    <span class="comment">// 回调接口在Engine中添加</span></span><br><span class="line">    <span class="keyword">for</span> (ResourceCallback cb : cbs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isInIgnoredCallbacks(cb)) &#123;</span><br><span class="line">            engineResource.acquire();</span><br><span class="line">            cb.onResourceReady(engineResource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Our request is complete, so we can release the resource.</span></span><br><span class="line">    engineResource.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回忆下最开始调用<code>Engine.decode()</code>的地方<code>GenericRequest</code>，可以看到，<code>ResourceCallback</code>的源头在<code>GenericRequest</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        onException(<span class="keyword">new</span> Exception(<span class="string">"Expected to receive a Resource&lt;R&gt; with an object of "</span> + transcodeClass</span><br><span class="line">                + <span class="string">" inside, but instead got null."</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    onResourceReady(resource, (R) received);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;?&gt; resource, R result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We must call isFirstReadyResource before setting status.</span></span><br><span class="line">    <span class="keyword">boolean</span> isFirstResource = isFirstReadyResource();</span><br><span class="line">    status = Status.COMPLETE;</span><br><span class="line">    <span class="keyword">this</span>.resource = resource;</span><br><span class="line">    <span class="comment">// RequestListener是用户自己定义的监听接口</span></span><br><span class="line">    <span class="keyword">if</span> (requestListener == <span class="keyword">null</span> || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,</span><br><span class="line">            isFirstResource)) &#123;</span><br><span class="line">        GlideAnimation&lt;R&gt; animation = animationFactory.build(loadedFromMemoryCache, isFirstResource);</span><br><span class="line">        <span class="comment">// 告知Target资源加载完毕</span></span><br><span class="line">        target.onResourceReady(result, animation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notifyLoadSuccess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>ImageViewTarget.onResourceReady</code>,将资源加载到<code>ImageView</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Z resource, GlideAnimation&lt;? <span class="keyword">super</span> Z&gt; glideAnimation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (glideAnimation == <span class="keyword">null</span> || !glideAnimation.animate(resource, <span class="keyword">this</span>)) &#123;</span><br><span class="line">        setResource(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此这个图片就加载完成了。相比<code>Piccasso</code>,Glide大量使用了泛型，所以看代码可能比较费力，但是只要搞清楚各个泛型之间的关系，代码之间的逻辑就容易理清了。</p>
]]></content>
      
        <categories>
            
            <category> Open Source </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Glide </tag>
            
            <tag> 图片加载 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[近来二三事]]></title>
      <url>http://sniffer.site/2017/05/29/%E8%BF%91%E6%9D%A5%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>如何专注你的聪明才智，比你有多聪明更重要</p>
</blockquote>
<ul>
<li>上周跟妹子去看了阿米尔-汗主演的《摔跤吧，爸爸》。电影剧情比较简单，讲述的是一个全国摔跤冠军一直梦想着在有生之年拿到一块国际金牌，为国争光。他把希望寄托在自己尚未降生的儿子身上，但天不随人愿，老婆连续生了几个小孩，无例外都是女孩。他渐渐放弃了通过儿子来实现自己梦想的想法。自己也一天天衰老。一次意外，他发现两个女儿吉塔与巴比塔是天生的摔跤手，于是萌生了让女儿接受摔跤训练，将其培养成世界冠军的想法。但这个想法遭到了家人的反对，邻里的嘲笑，几乎所有人都不看好他。<a id="more"></a>但是，他的坚持获得了回报：大女儿吉塔先后获得了州冠军，全国摔跤冠军，并进入国家体育学院接受专业训练，而二女儿巴比塔也开始崭露头脚。最后吉塔在英联邦运动会上，夺得了摔跤金牌，终于圆了他的梦想。看到他女儿亲自将金牌递到他手里时，我还是忍不住留下了眼泪…他的那份坚持与勇气让我感动。有时，心怀梦想，做那些别人不敢做的事情的人注定孤单，但有梦想的陪伴，人至少能过得充实，能让生命发挥出不一样的光彩，而不是在沉默之中度过一生。发挥你的光与热，不要跟随大众，不要随大流，而是要勇敢追求自己真正期待的梦想。</li>
</ul>
<ul>
<li>近来学习新东西感觉要比以前快了。想想，可能是之前读书学习都没有掌握一个好的系统性的方法，只是埋头在看，花时间在学习而已，并没有深入的思考背后的概念。现在想来，要想对自己不熟悉的领域有一个深入的学习与认知，光有热情与时间精力远远不够，还需要正确的学习方法。正确的学习方法，是指学习时不再被动接受，而是主动去思考，思考概念背后所要解决的问题，思考概念背后所隐藏的原理；实在迷惑不解时，可能需要利用类比与联想的方式将概念与其他已知或者熟悉的概念联系起来帮助自己理解与把握。对于那些很大的“概念”，则需要将其进行分解，采用<code>divide and conquer</code>，各个击破，然后再综合起来，这样以来，头脑对概念的理解就会渐渐清晰起来。更重要的是要培养一种思维习惯，碰到一个概念，首先就问自己几个问题：(1) 这个概念是用来解决什么问题；（2） 有类似的概念吗？ （3）为什么需要这样一个概念，是否有现有的可以替代了？</li>
</ul>
<ul>
<li>与一同事聊起中国的世俗人情。他说，他家一年到头光各种人情往来就要好几万块，每年回去光给家里每个侄子侄女的红包都要在千元以上。关于这种压岁钱、婚礼礼金以及各种人情消费，也听过见过，但这种攀比虚荣的人情往来竟会到了这种地步，也是让人感概。我们常说，中国是个人情社会，人们之前靠着“你帮我，我帮你”的社会伦理准则进行交往，但为何这种人情竟发展到了虚荣攀比以及炫富式的消费，进而形成一种社会风气，却是值得深思。在这样的人情社会，人们往往有一种用钱来衡量彼此之间的密程度，你给我送礼“重”，你对我的情谊就深。人们期待通过金钱来巩固彼此的感情，来维系人与人之间的信任与忠诚，但这往往会让人大失所望。因为金钱并不可靠，真正可靠的是规则，是制度保障下的规则。这种用钱来维持人情的做法，跟中国历史上法治的缺乏不无关系。当人们做什么事情都想着靠钱来解决时，当人们想到一个问题时总是想到通过挣钱来解决时，何尝不能说这是一个社会缺乏法治与法制的表现了？在另一方面来说，这种在金钱上的攀比也跟国人“好面子”有着不可分割的联系。世界上每个民族都多少会为了装饰门面而维护“脸面”，但像中国这样从普通百姓到政府首脑都爱慕虚荣这一点来看，却是少见的，可以说，“好面子”已经成了中国人内在的一部分。从慈禧“量中华之物力，结与国之欢心”，到政府各种集体式的炫耀，中国在某些方面依然原地踏步。”好面子“式的炫耀说到底是一种自卑，一种不自信，一种期待用表演来获取他人关注的爱慕虚荣。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 社会万象 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 摔跤吧，爸爸 </tag>
            
            <tag> 电影 </tag>
            
            <tag> 学习方法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程之Java Memory Model]]></title>
      <url>http://sniffer.site/2017/05/29/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BJava-Memory-Model/</url>
      <content type="html"><![CDATA[<p>在之前一篇文章里，讲到了利用<code>synchronized</code>关键字来进行同步，从而避免多线程并发执行时可能出现的竞争条件，那么JVM又是如何实现线程之间的通信的？换句话说，线程A写共享数据的结果怎么确保被其他线程可见，使得线程之间共享的数据对每个线程而言都是一致的？Java从5.0开始定义了一个新的Memory Model(Java Specification Request 133, JSR133)，在多线程情况下，为Java程序提供了一个最少程度的保证：正确同步的情况下，一个线程写共享变量对于其他线程是可见的。Java Memory Model(JMM)抽象了不同计算机平台底层内存读写细节（Register; Cache; Main Memory)，为程序员提供了一个访问内存的统一的模型与视角，从而确保在不同平台上程序能有同样的结果，实现Java“编写一次，可以在任何平台上执行”的目标。</p>
<a id="more"></a>
<h2 id="为什么需要JMM"><a href="#为什么需要JMM" class="headerlink" title="为什么需要JMM"></a><strong>为什么需要JMM</strong></h2><p>现代计算机的内存是一个层级的结构(memory hierarchy),最上层是寄存器(register),接下来是缓存(cache),最后才是主内存(main memory),因此一个变量的读总是需要经过cache，如果cache数据无效，才会从main meory中获取;写变量同样如此，先将数据写入对应cache,等到某个时间才将cache中的数据与main memory进行同步(见下图）。这样，在硬件层面就存在一个如何确保各个CPU之间数据可见性的问题。不同的硬件平台可能有不同的memory model来处理CPU之间的数据可见性。最简单的memory model就是一个CPU对内存中某个变量的写操作立即对其他CPU可见，这种强内存模型要求数据之间存在严格的顺序一致性,也被称为sequential consistency。虽然sequential consistency为线程之间的数据同步提供了强有力的保证，但是（1）顺序一致性要求所有的内存操作对所有线程可见；（2）禁止了编译器与CPU对于代码的优化，这无疑会降低系统运行的性能。因此，为在性能与数据可见性之间取得平衡，大部分平台都提供了一个更弱的meomory model,在需要进行数据同步时，通过一个内存屏障(<a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">Memory  Barrier</a> )来同步CPU缓存与主内存之间的数据。</p>
<img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/MemoryHierarchy.png" class="[full-image]" title="Memory Hierarchy">
<blockquote>
<p>每个CPU有自己独立的Register,Cache,但是共享Main Memory,各个不同的CPU之间通过总线（bus)来访问内存</p>
<ul>
<li><a href="https://csapp.cs.cmu.edu/2e/ch6-preview.pdf" target="_blank" rel="noopener">Memory Hierarchy</a> </li>
<li><a href="https://www.cs.auckland.ac.nz/~jmor159/363/html/mem_hierarchy.html" target="_blank" rel="noopener">https://www.cs.auckland.ac.nz/~jmor159/363/html/mem_hierarchy.html</a> </li>
</ul>
</blockquote>
<p>除了上述硬件平台memory model之间的差异，JMM还需要考虑编译器以及CPU执行指令时对代码执行顺序进行重排(reordering)导致的共享数据不一致问题。</p>
<h3 id="Reordering"><a href="#Reordering" class="headerlink" title="Reordering"></a><strong>Reordering</strong></h3><p>在单线程情况下，Java语言本身要求JVM满足<code>as-if-serial</code>语义（只要在单线程情况下程序的执行结果不被改变，任何其他的重排都是允许的)。但对于多线程问题就复杂起来了。考虑如下两个线程,两个线程共享变量<code>a，b</code>，各自有一个局部变量<code>r1</code>，<code>r2</code>,假定初始状态时<code>a = 0, b = 0</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Thread A</span></span><br><span class="line"><span class="number">1</span>: r2 = a;</span><br><span class="line"><span class="number">2</span>: b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread B</span></span><br><span class="line"><span class="number">3</span>: r1 = b;</span><br><span class="line"><span class="number">4</span>: a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>直觉上来看，<code>r1 = 1</code>,<code>r2 = 2</code>似乎不可能。对线程A或者B来说，执行动作1与3都执行在前，如果1在前，则<code>r2 = a</code>不应该看到动作4执行的结果；如果3在前，同样<code>r1 = b</code>不应该看到2执行的结果。但是，分开来看，只要不影响当前线程的执行结果，编译器是可以对两个线程的指令进行重排的，因此，实际上代码可能按照如下顺序执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Thread A</span></span><br><span class="line">b = <span class="number">1</span>;</span><br><span class="line">r2 = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread B</span></span><br><span class="line">r1 = b;</span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>不难看出，这样就有可能出现<code>r1 = 1</code>,<code>r2 = 2</code>难以预料的结果了。为了解决上述问题（编译器或者CPU优化时导致的指令重排)，Java定义了自己的一个memory model，由JVM来负责处理数据同步的底层实现细节（通过在适当的位置插入内存屏障来实现共享内存的可见性；通过CAS操作来实现原子操作)，开发者只要通过正确的调用<code>synchronized</code>,<code>final</code>,<code>volatile</code>等语言本身提供的同步语义即可实现共享数据的一致性与可见性。</p>
<h2 id="什么是JMM"><a href="#什么是JMM" class="headerlink" title="什么是JMM"></a><strong>什么是JMM</strong></h2><p>总的说来，JMM定义了线程与主内存之间的一种抽象关系，其定义的规则在于解决多线程情况下可能出现的三个问题：</p>
<ul>
<li>Atomicity(原子性）: 那些指令必须是不可分割的(原子操作）；</li>
<li>Visibility（可见性）： 在什么情况下，一个线程的写操作结果对另一个线程可见；</li>
<li>Ordering（重排）: 在什么情况下，对任何线程而言，执行操作是可重排的</li>
</ul>
<blockquote>
<p>JMM确保读写内存区域（除了long/double之外）是原子的；volatile long/double读写是原子的;</p>
</blockquote>
<p>一个线程执行的动作可被另一个线程检测到或者被直接影响到，则将该动作称为线程之间的动作(inter-thread action)，主要有以下几种：</p>
<ul>
<li>Read(non-volatile): 读一个变量；</li>
<li>Write(non-volatile): 写一个变量；</li>
<li>同步动作：<ul>
<li>读取一个volatile变量；</li>
<li>写一个volatile变量；</li>
<li>Lock/unlock</li>
<li>线程的启动与终止</li>
</ul>
</li>
</ul>
<p>这样，一个线程间的执行动作可由一个由线程(t),执行的动作(k),变量或者monitor(v)以及任意的动作标识符（u）这样一个<code>&lt;t,k,v,u&gt;</code>四元组来确定了。在多线程情况下，最简单的内存模型就是所有动作总的顺序（由单个执行动作组成）跟程序的执行顺序（Program Order)保持一致，且所有的单个动作都具有原子性，操作的结果能够立刻对所有其他线程可见(Sequential Consistency)。这种强一致性虽然能够保证动作的可见性与执行顺序的可预测性，但是由于其禁止了编译器以及CPU指令优化，因此会降低系统的性能。</p>
<blockquote>
<p>Sequential Consistency: </p>
<ul>
<li><a href="http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf" target="_blank" rel="noopener">http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sequential_consistency" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Sequential_consistency</a></li>
</ul>
</blockquote>
<p>JMM提供了另一种选择，在不同平台上的执行性能与程序可预测性之间取得了平衡：JMM保证，在正确同步的情况下，JVM必须确保写变量对其他各个线程是可见的。通过对Java中的各种执行动作定义一种偏序关系(partial ordering),JMM确保程序执行结果的一致性。这种偏序关系通常被称为<strong>happens-before</strong>。JMM中主要有如下<strong>happens-before</strong>规则：</p>
<ul>
<li>Lock Rule: 在一个monitor上释放锁<strong>happens-before</strong>每一个在该monitor上的锁获取；</li>
<li>Volatile Rule: 写一个volatile变量<strong>happens-before</strong>每一个volatile变量的读操作；</li>
<li>Thread Start Rule: 线程的启动<code>start()</code><strong>happens-before</strong>每一个其他该线程的动作；</li>
<li>Thread Termination Rule: 任何在一个线程上的动作 <strong>happens-before</strong>其他线程得知该线程终止之前的动作 （从<code>Thread.join</code> 成功返回或者  <code>Thread.isAlive</code>返回false);</li>
<li>All actions in a thread <strong>happens-before</strong> any other thread successfully returns from a <code>join</code> on that thread(与上条类似）；</li>
<li>Interruption Rule: 一个线程中断另一个线程<strong>happens-before</strong> 被中断线程检测到该中断(either by having InterruptedException thrown or invoking <code>Thread.isInterrupted</code> or <code>Thread.interrupted</code>);</li>
<li>Initialization Rule: 对象的默认初始化<strong>happens-before</strong>其他任何执行动作（除默认的写动作之外)（the defaul initialization of any object <strong>happens-before</strong> any other actions(other than default-writes) of a program);</li>
</ul>
<blockquote>
<p>什么是Partial Ordering <a href="https://en.wikipedia.org/wiki/Partially_ordered_set" target="_blank" rel="noopener">Partially_ordered_set</a></p>
</blockquote>
<p>下面就来看下，<code>volatile</code>以及<code>final</code>在<strong>happens-before</strong>规则下的语义。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><strong>volatile</strong></h2><p>关键词<code>volatile</code>在不用同步的情况下，通过内存屏障的方式来禁止变量读写操作的重排序，从而确保一个线程的写操作对其他线程是可见的（volatile变量不会缓存到对其他处理器比可见的register或者cache，因此其他线程的读操作得到的总是其他任何线程最新写的结果）。在JSR133之前，只是不允许volatile变量之间的重排序，但不会禁止volatile变量与普通变量之间的重排序，而新的JSR133模型则严格限制了volatile变量读写与普通变量读写之间的重排序：写一个volatile变量在内存效果上等同于释放monitor锁; 读volatile变量则等同于获取monitor锁。</p>
<p>volatile只是保证了变量读写的可见性，但并没有确保互斥性。因此，使用volatile变量需要慎重。以下两点可以作为volatile使用的参考：</p>
<ul>
<li>将一个类的引用声明为volatile并不能保证该类中非volatile的成员的可见性；</li>
<li>在单个写线程、多个读线程一个变量时使用volatile；</li>
</ul>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">		x = <span class="number">30</span>;</span><br><span class="line">		v = <span class="keyword">true</span>; <span class="comment">// JMM确保上述普通变量与volatile变量之间的操作不被重排序</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(v == <span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> y = <span class="number">2</span>*x; <span class="comment">//  x = 30对其他任何读线程都是可见的</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>| 有关更多volatile变量的使用方法，请参考<a href="https://www.ibm.com/developerworks/java/library/j-jtp06197/index.html" target="_blank" rel="noopener">Managing Volatility</a></p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a><strong>final</strong></h2><p>关键词<code>final</code>确保变量是不可变的（尽管该变量所引用的对象可变），一旦一个变量声明为final,并被初始化一次，之后就不会被更改。因此，final变量无需做同步即可在多线程情况下使用：一个在对象构造完成之后，可见该对象的引用的线程保证可以看到该对象的<code>final</code>变量。 </p>
<p>示例：一个线程调用<code>write()</code>,另一个调用<code>read()</code>,根据Happens-before Rule,由于变量f的写动作总是在对象构造完成之后，因此读线程总是可以看到<code>f.x = 3</code>,而由于<code>f.y</code>并非final变量，因此JMM并不保证读线程可以看到<code>f.y = 4</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalFieldExample</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> FinalFiledExample f;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalFieldExample</span><span class="params">()</span></span>&#123;</span><br><span class="line">        x = <span class="number">3</span>;</span><br><span class="line">        y = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        f = <span class="keyword">new</span> FinalFieldExample();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = f.x; <span class="comment">// guaranteed to see 3</span></span><br><span class="line">            <span class="keyword">int</span> j = f.y; <span class="comment">// could see 0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/" target="_blank" rel="noopener">[JMM refers] http://www.cs.umd.edu/~pugh/java/memoryModel/</a></li>
<li><a href="https://mortoray.com/2010/11/18/cpu-reordering-what-is-actually-being-reordered/" target="_blank" rel="noopener">[Reordering] https://mortoray.com/2010/11/18/cpu-reordering-what-is-actually-being-reordered/</a></li>
<li><a href="https://www.ibm.com/developerworks/library/j-jtp02244/index.html" target="_blank" rel="noopener">[Fixing JMM] https://www.ibm.com/developerworks/library/j-jtp02244/index.html</a></li>
<li><a href="http://gee.cs.oswego.edu/dl/cpj/jmm.html?cm_mc_uid=64655373050114725223524&amp;cm_mc_sid_50200000=1494921172" target="_blank" rel="noopener">[Doug Lee] http://gee.cs.oswego.edu/dl/cpj/jmm.html?cm_mc_uid=64655373050114725223524&amp;cm_mc_sid_50200000=1494921172</a></li>
<li><a href="https://www.ibm.com/developerworks/library/j-jtp03304/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/library/j-jtp03304/</a></li>
<li><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener">https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html</a> </li>
<li><a href="http://download.oracle.com/otndocs/jcp/memory_model-1.0-pfd-spec-oth-JSpec/" target="_blank" rel="noopener">http://download.oracle.com/otndocs/jcp/memory_model-1.0-pfd-spec-oth-JSpec/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
            <tag> Java Memory Model </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Zygote进程启动过程详解]]></title>
      <url>http://sniffer.site/2017/05/27/Zygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>与Java程序类似，Android应用程序框架层(Application Framework)以及APP运行在一个Dalvik Virtual Machine之上，那么，Android启动时框架层是如何初始化的，从何处初始化的？为此，Android在启动时会首先初始化一个专门的系统进程<code>zygote</code>来负责启动与初始化Java代码，比如系统服务进程<code>system_server</code>的启动，系统启动时各种Java服务的初始化，APP资源文件的加载，APP进程的创建与启动。这篇文章，主要讲<code>zygote</code>进程的两个问题：</p>
<a id="more"></a>
<ul>
<li><code>zygote</code>进程如何初始化的；</li>
<li>APP进程是如何通过<code>zygote</code>创建的？</li>
</ul>
<blockquote>
<p>本文基于Android NN7.0</p>
</blockquote>
<h2 id="zygote进程的初始化"><a href="#zygote进程的初始化" class="headerlink" title="zygote进程的初始化"></a><strong>zygote进程的初始化</strong></h2><p>kernel初始化完成后，Android启动的第一个进程是init(pid = 0)，此后启动的进程都是init进程的子进程；init进程在启动时，会解析<code>init.rc</code>脚本中的语句，以此来启动某个进程或者执行某个动作。</p>
<p>脚本<code>init.zygotexx.rc</code>(xx是不同平台的字长，有32/64两种）负责启动系统服务<code>zygote</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">zygote</span> <span class="title">stream</span> 660 <span class="title">root</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">write</span> /<span class="title">sys</span>/<span class="title">android_power</span>/<span class="title">request_state</span> <span class="title">wake</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">write</span> /<span class="title">sys</span>/<span class="title">power</span>/<span class="title">state</span> <span class="title">on</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">audioserver</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">cameraserver</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">media</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">netd</span></span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">foreground</span>/<span class="title">tasks</span> /<span class="title">dev</span>/<span class="title">stune</span>/<span class="title">foreground</span>/<span class="title">tasks</span></span></span><br></pre></td></tr></table></figure>
<p>这里：</p>
<ul>
<li><code>service</code>表示该进程是一个系统服务进程；</li>
<li><code>zygote</code>是该进程的名字；</li>
<li><code>/system/bin/app_process</code>是进程代码所在的文件路径；</li>
<li><code>-Xzygote /system/bin --zygote --start-system-server</code>： 是进程启动参数，单杠<code>-</code>是符号参数</li>
<li><code>socket zygote stream 660 root system</code>： 创建一个<code>/dev/socket/zygote</code>的socket，zygote会监听该socket，一旦有APP进程启动请求即fork一个进程;</li>
<li><code>onrestart</code>: 表示只要该service重启，就执行后面的动作。就是说，<code>zygote</code>服务重启的话，会重启<code>audioserver</code>,<code>cameraserver</code>等系统服务；</li>
<li><code>writepid</code>: 属于服务所需要执行的函数，<code>zygote</code>进程fork完成后，将其PID写入该参数对应的文件；</li>
</ul>
<p><code>init</code>进程解析该脚本语句，通过<code>Service.cpp</code>中的函数<code>start</code>来启动<code>zygote</code>进程:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Service::Start() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags_ &amp; SVC_RUNNING) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    NOTICE(<span class="string">"Starting service '%s'...\n"</span>, name_.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="comment">// 进程创建成功</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        umask(<span class="number">077</span>);</span><br><span class="line">        <span class="comment">// 创建socket</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; si : sockets_) &#123;</span><br><span class="line">            <span class="keyword">int</span> socket_type = ((si.type == <span class="string">"stream"</span> ? SOCK_STREAM :</span><br><span class="line">                                (si.type == <span class="string">"dgram"</span> ? SOCK_DGRAM :</span><br><span class="line">                                 SOCK_SEQPACKET)));</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>* socketcon =</span><br><span class="line">                !si.socketcon.empty() ? si.socketcon.c_str() : scon.c_str();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = create_socket(si.name.c_str(), socket_type, si.perm,</span><br><span class="line">                                  si.uid, si.gid, socketcon);</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                PublishSocket(si.name, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存PID到文件</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> pid_str = StringPrintf(<span class="string">"%d"</span>, getpid());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; file : writepid_files_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!WriteStringToFile(pid_str, file)) &#123;</span><br><span class="line">                ERROR(<span class="string">"couldn't write %s to %s: %s\n"</span>,</span><br><span class="line">                      pid_str.c_str(), file.c_str(), strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setpgid(<span class="number">0</span>, getpid());</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// 执行app_process二进制代码中的main函数</span></span><br><span class="line">        <span class="keyword">if</span> (execve(strs[<span class="number">0</span>], (<span class="keyword">char</span>**) &amp;strs[<span class="number">0</span>], (<span class="keyword">char</span>**) ENV) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ERROR(<span class="string">"cannot execve('%s'): %s\n"</span>, strs[<span class="number">0</span>], strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"failed to start '%s'\n"</span>, name_.c_str());</span><br><span class="line">        pid_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time_started_ = gettime();</span><br><span class="line">    pid_ = pid;</span><br><span class="line">    flags_ |= SVC_RUNNING;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    NotifyStateChange(<span class="string">"running"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>app_main.cpp</code>中的main函数，其中的<code>argv[]</code>是一个<code>{-Xzygote,/system/bin,--zygote,--start-system-server}</code>的字符串指针数组； 解析参数后，通过<code>AppRuntime</code>加载<code>ZygoteInit</code>类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 运行时执行环境，加载JAVA代码</span></span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line">    <span class="comment">// Process command line arguments； ignore argv[0]</span></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; argv[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++i; <span class="comment">// Skip --.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存-Xzygote参数</span></span><br><span class="line">        runtime.addOption(strdup(argv[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse runtime arguments.  Stop at first unrecognized option.</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    ++i;  <span class="comment">// Skip unused "parent dir" argument.</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">            ....</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">            ....</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We're in zygote mode.</span></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">"start-system-server"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// In zygote mode, pass all remaining arguments to the zygote</span></span><br><span class="line">        <span class="comment">// main() method.</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置进程名称</span></span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>());</span><br><span class="line">        set_process_name(niceName.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// zygote模式，加载ZygoteInit类，这里的args为"start-system-server"</span></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码： /android/frameworks/base/cmds/app_process/app_main.cpp </p>
</blockquote>
<p>由于<code>AppRuntime</code>继承了<code>AndroidRuntime</code>，调用<code>AndroidRuntime.start()</code>:创建一个VM实例，并注册系统JNI，然后调用<code>ZygoteInit</code>的main方法，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="comment">// 创建一个VM实例</span></span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register android functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">    assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.size() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取main函数ID</span></span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调用main函数</span></span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(slashClassName);</span><br><span class="line"></span><br><span class="line">    ALOGD(<span class="string">"Shutting down VM\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</span><br><span class="line">        ALOGW(<span class="string">"Warning: unable to detach main thread\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</span><br><span class="line">        ALOGW(<span class="string">"Warning: VM did not shut down cleanly\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>ZygoteInit.main</code>, 监听来自客户端的请求；在子进程中，<code>runSelectLoop</code>会抛出一个<code>MethodAndArgsCaller</code>异常，该异常被捕获后，会去调用应用的入口方法<code>ActivityThread.main</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* set default handler; this applies to all threads in the VM */</span></span><br><span class="line">    RuntimeInit.__init__UncaughtHandler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//启动Android调试工具DDMS(Dalvik Debug Monitor Server)</span></span><br><span class="line">        RuntimeInit.enableDdms();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">        String socketName = <span class="string">"zygote"</span>;</span><br><span class="line">        String abiList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">                primaryZygoteThreadRunning=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"!@Zygote : primaryZygoteThreadRunning = "</span> + primaryZygoteThreadRunning + <span class="string">" ZygoteAgentRunning = "</span> + zygoteAgentRunning);</span><br><span class="line">        <span class="comment">// 注册一个/dev/sockete/zyogote的socket，将其与一个FileDescriptor进行绑定</span></span><br><span class="line">        registerZygoteSocket(socketName);</span><br><span class="line">        <span class="comment">// 预加载资源、共享库</span></span><br><span class="line">        preload();</span><br><span class="line">        <span class="comment">// 启动system_server进程</span></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            startSystemServer(abiList, socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不断监听socket接口连接请求，子进程创建完成后，会抛出MethodAndArgsCaller异常</span></span><br><span class="line">        runSelectLoop(abiList);</span><br><span class="line">        <span class="comment">// 如果进程退出，需要关闭zygote的socket</span></span><br><span class="line">        closeServerSocket();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Zygote died with exception"</span>, ex);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>runSelectLoop</code>不断监听来自客户端的请求，如果有，则创建一个<code>ZygoteConnection</code>用于处理来自客户端的请求，负责解析应用启动的参数，调用<code>fork</code>启动一个新的进程，然后加载应用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> <span class="keyword">throws</span> MethodAndArgsCaller </span>&#123;</span><br><span class="line">        ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">        ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">        fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">        peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">                pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">                pollFds[i].fd = fds.get(i);</span><br><span class="line">                pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 监听socket端口,如果有请求则返回</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 初始状态，pollFds只有一个服务端socket对应的fd</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// acceptCommandPeer阻塞调用，直到有来自客户端的请求</span></span><br><span class="line">                    ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                    peers.add(newPeer);</span><br><span class="line">                    fds.add(newPeer.getFileDesciptor());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 第一个元素为空，其他的都是来自客户端的请求</span></span><br><span class="line">                    <span class="keyword">boolean</span> done = peers.get(i).runOnce();</span><br><span class="line">                    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                        peers.remove(i);</span><br><span class="line">                        fds.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// acceptCommandPeer返回一个请求对应的ZygoteConnection用于读取socket中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ZygoteConnection <span class="title">acceptCommandPeer</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZygoteConnection(sServerSocket.accept(), abiList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"IOException during accept()"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    FileDescriptor[] descriptors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        args = readArgumentList();</span><br><span class="line">        descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"IOException on command socket "</span> + ex.getMessage());</span><br><span class="line">        closeSocket();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// EOF reached.</span></span><br><span class="line">        closeSocket();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * In order to avoid leaking descriptors to the Zygote child,</span></span><br><span class="line"><span class="comment">         * the native code must close the two Zygote socket descriptors</span></span><br><span class="line"><span class="comment">         * in the child process before it switches from Zygote-root to</span></span><br><span class="line"><span class="comment">         * the UID and privileges of the application being launched.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * In order to avoid "bad file descriptor" errors when the</span></span><br><span class="line"><span class="comment">         * two LocalSocket objects are closed, the Posix file</span></span><br><span class="line"><span class="comment">         * descriptors are released via a dup2() call which closes</span></span><br><span class="line"><span class="comment">         * the socket and substitutes an open descriptor to /dev/null.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> [] fdsToClose = &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">        FileDescriptor fd = mSocket.getFileDescriptor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fdsToClose[<span class="number">0</span>] = fd.getInt$();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fd = ZygoteInit.getServerSocketFileDescriptor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fdsToClose[<span class="number">1</span>] = fd.getInt$();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 调用本地方法fork一个新的进程</span></span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.category, parsedArgs.accessInfo,</span><br><span class="line">                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">                parsedArgs.appDataDir, parsedArgs.mountKnoxPoint);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr, <span class="string">"Exception creating pipe"</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr, <span class="string">"Invalid zygote arguments"</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteSecurityException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr,</span><br><span class="line">                <span class="string">"Zygote security policy prevents request: "</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// in child</span></span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 在子进程中，会加载应用代码</span></span><br><span class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// should never get here, the child is expected to either</span></span><br><span class="line">            <span class="comment">// throw ZygoteInit.MethodAndArgsCaller or exec().</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// in parent...pid of &lt; 0 means failure</span></span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此<code>Zygote</code>进程就启动完成了。接下来我们就来看一看，有APP启动时，<code>zygote</code>进程如何创建新的应用进程的？</p>
<h2 id="zygote创建新的应用进程"><a href="#zygote创建新的应用进程" class="headerlink" title="zygote创建新的应用进程"></a><strong>zygote创建新的应用进程</strong></h2><p>在Activity启动过程中，如果当前应用尚未启动过，进程不存在，AMS(Activity Manager Service)会为应用启动一个新的进程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(app.uid);</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// Start the process.  It will either succeed and return a result containing</span></span><br><span class="line">        <span class="comment">// the PID of the new process, or else throw a RuntimeException.</span></span><br><span class="line"></span><br><span class="line">        Process.ProcessStartResult startResult = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(userid&gt;<span class="number">0</span> &amp;&amp; (bbcId&gt;<span class="number">0</span> &amp;&amp; userid == bbcId) &amp;&amp; app.info.bbcseinfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            startResult = Process.start(entryPoint,</span><br><span class="line">            app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">            app.info.targetSdkVersion, app.info.bbcseinfo, app.info.bbccategory, app.info.accessInfo,</span><br><span class="line">            requiredAbi, instructionSet,</span><br><span class="line">            app.info.dataDir, mountKnoxPoint, entryPointArgs);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            startResult = Process.start(entryPoint,</span><br><span class="line">            app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">            app.info.targetSdkVersion, aasaSeInfo != <span class="keyword">null</span> ? <span class="keyword">new</span> String(aasaSeInfo) : app.info.seinfo, <span class="comment">//AASA--4 : changed orginal : only "app.info.seinfo"</span></span><br><span class="line">            app.info.category, app.info.accessInfo,</span><br><span class="line">            requiredAbi, instructionSet,</span><br><span class="line">            app.info.dataDir, mountKnoxPoint, entryPointArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(RemoteException re)&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>Process.start()</code>启动一个新的进程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> category,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> accessInfo,  </span></span></span><br><span class="line"><span class="function"><span class="params">                              String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> mountKnoxPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                debugFlags, mountExternal, targetSdkVersion, seInfo, category, accessInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, mountKnoxPoint, zygoteArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">        Log.e(LOG_TAG,</span><br><span class="line">                <span class="string">"Starting VM process through Zygote failed"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Starting VM process through Zygote failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>zygote</code>创建一个新的进程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> category,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> accessInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> mountKnoxPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String[] extraArgs)</span> </span></span><br><span class="line"><span class="function">                                  <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Process.class) &#123;</span><br><span class="line">            ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加启动参数</span></span><br><span class="line">            argsForZygote.add(<span class="string">"--runtime-args"</span>);</span><br><span class="line">            argsForZygote.add(<span class="string">"--setuid="</span> + uid);</span><br><span class="line">            argsForZygote.add(<span class="string">"--setgid="</span> + gid);</span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// 进程名</span></span><br><span class="line">            <span class="keyword">if</span> (niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                argsForZygote.add(<span class="string">"--nice-name="</span> + niceName);</span><br><span class="line">            &#125;</span><br><span class="line">            ....</span><br><span class="line">            argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extraArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String arg : extraArgs) &#123;</span><br><span class="line">                    argsForZygote.add(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// openZygoteSocketIfNeeded 连接socket</span></span><br><span class="line">           <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>将启动进程所需的参数通过<code>/dev/socket/zygote</code>发送给<code>zygote</code>进程,并将创建的PID返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * See com.android.internal.os.ZygoteInit.readArgumentList()</span></span><br><span class="line"><span class="comment">         * Presently the wire format to the zygote process is:</span></span><br><span class="line"><span class="comment">         * a) a count of arguments (argc, in essence)</span></span><br><span class="line"><span class="comment">         * b) a number of newline-separated argument strings equal to count</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> BufferedWriter writer = zygoteState.writer;</span><br><span class="line">        <span class="keyword">final</span> DataInputStream inputStream = zygoteState.inputStream;</span><br><span class="line"></span><br><span class="line">        writer.write(Integer.toString(args.size()));</span><br><span class="line">        writer.newLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            String arg = args.get(i);</span><br><span class="line">            writer.write(arg);</span><br><span class="line">            writer.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写入socket</span></span><br><span class="line">        writer.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Should there be a timeout on this?</span></span><br><span class="line">        ProcessStartResult result = <span class="keyword">new</span> ProcessStartResult();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Always read the entire result from the input stream to avoid leaving</span></span><br><span class="line">        <span class="comment">// bytes in the stream for future process starts to accidentally stumble</span></span><br><span class="line">        <span class="comment">// upon.</span></span><br><span class="line">        result.pid = inputStream.readInt();</span><br><span class="line">        result.usingWrapper = inputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前分析<code>zygote</code>启动时，我们了解到，每当有进程创建请求时，都会通过<code>runSelectLoop</code>函数创建一个<code>ZygoteConnection</code>； <code>ZygoteConnecton</code>中的<code>runOnce()</code>函数负责将进程启动的参数写入到socket，并着手创建新的进程，创建完成后将子进程PID写回到socket：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    FileDescriptor[] descriptors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从Socket中读取数据</span></span><br><span class="line">        args = readArgumentList();</span><br><span class="line">        descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        closeSocket();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">int</span> pid = -<span class="number">1</span>;</span><br><span class="line">    FileDescriptor childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">    FileDescriptor serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsedArgs = <span class="keyword">new</span> Arguments(args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.abiListQuery) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleAbiListQuery();</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * In order to avoid leaking descriptors to the Zygote child,</span></span><br><span class="line"><span class="comment">         * the native code must close the two Zygote socket descriptors</span></span><br><span class="line"><span class="comment">         * in the child process before it switches from Zygote-root to</span></span><br><span class="line"><span class="comment">         * the UID and privileges of the application being launched.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * In order to avoid "bad file descriptor" errors when the</span></span><br><span class="line"><span class="comment">         * two LocalSocket objects are closed, the Posix file</span></span><br><span class="line"><span class="comment">         * descriptors are released via a dup2() call which closes</span></span><br><span class="line"><span class="comment">         * the socket and substitutes an open descriptor to /dev/null.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> [] fdsToClose = &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">        FileDescriptor fd = mSocket.getFileDescriptor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fdsToClose[<span class="number">0</span>] = fd.getInt$();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fd = ZygoteInit.getServerSocketFileDescriptor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fdsToClose[<span class="number">1</span>] = fd.getInt$();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 创建进程，并返回</span></span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.category, parsedArgs.accessInfo,</span><br><span class="line">                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">                parsedArgs.appDataDir, parsedArgs.mountKnoxPoint);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr, <span class="string">"Exception creating pipe"</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr, <span class="string">"Invalid zygote arguments"</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteSecurityException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr,</span><br><span class="line">                <span class="string">"Zygote security policy prevents request: "</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程继承了zygote进程的FD，需要关闭</span></span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 继续子进程启动后的一些准备工作</span></span><br><span class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line">            <span class="comment">// should never get here, the child is expected to either</span></span><br><span class="line">            <span class="comment">// throw ZygoteInit.MethodAndArgsCaller or exec().</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// in parent...pid of &lt; 0 means failure</span></span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 将子进程PID写入socket</span></span><br><span class="line">            <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>zygote.forkAndSpecialize</code>创建进程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkAndSpecialize</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> debugFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span>[][] rlimits, <span class="keyword">int</span> mountExternal, String seInfo, <span class="keyword">int</span> category, <span class="keyword">int</span> accessInfo, String niceName, <span class="keyword">int</span>[] fdsToClose,String instructionSet, String appDataDir, <span class="keyword">int</span> mountKnoxPoint)</span> </span>&#123;</span><br><span class="line">    VM_HOOKS.preFork();</span><br><span class="line">    <span class="comment">// 调用native方法创建进程</span></span><br><span class="line">    <span class="keyword">int</span> pid = nativeForkAndSpecialize(</span><br><span class="line">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, category, accessInfo, niceName, fdsToClose,</span><br><span class="line">              instructionSet, appDataDir, mountKnoxPoint);</span><br><span class="line">    <span class="comment">// Enable tracing as soon as possible for the child process.</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        Trace.setTracingEnabled(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that this event ends at the end of handleChildProc,</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"PostFork"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    VM_HOOKS.postForkCommon();</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找到<code>forkAndSpecialize</code>对应的native方法,实际是创建一个Linux进程，子进程与父进程拥有共同的内存空间，至此一个应用的进程就创建完成了。但此时应用本身的代码还没有加载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ForkAndSpecializeCommon</span><span class="params">(JNIEnv* env, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray javaGids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jint debug_flags, jobjectArray javaRlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jint mount_external,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jstring java_se_info, jint category, jint accessInfo, jstring java_se_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">bool</span> is_system_server, jintArray fdsToClose,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jstring instructionSet, jstring dataDir, jint mountKnoxPoint)</span> </span>&#123;</span><br><span class="line">  SetSigChldHandler();</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">sigset_t</span> sigchld;</span><br><span class="line">  sigemptyset(&amp;sigchld);</span><br><span class="line">  sigaddset(&amp;sigchld, SIGCHLD);</span><br><span class="line">  ....</span><br><span class="line">  <span class="comment">// 创建进程</span></span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// The child process.</span></span><br><span class="line">    gMallocLeakZygoteChild = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up any descriptors which must be closed immediately</span></span><br><span class="line">    DetachDescriptors(env, fdsToClose);</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">if</span> (!is_system_server) &#123;</span><br><span class="line">        <span class="keyword">int</span> rc = createProcessGroup(uid, getpid());</span><br><span class="line">        <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rc == -EROFS) &#123;</span><br><span class="line">                ALOGW(<span class="string">"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGE(<span class="string">"createProcessGroup(%d, %d) failed: %s"</span>, uid, pid, strerror(-rc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// VM post fork for child process</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</span><br><span class="line">                              is_system_server, instructionSet);</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"Error calling post fork hooks."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// the parent process</span></span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Android中的native方法所在文件命名是由Java包名基础上加上Java文件名组成，例如<code>nativeForkAndSpecialize</code>所在类<code>zygote.java</code>对应的包名为<code>com.android.internal.os</code>,那么其该native方法对应的文件为<code>com_android_internal_os_zygote.cpp</code></p>
</blockquote>
<p>最后在新的子进程中，需要对APP进程的执行环境进行初始化，调用<code>RuntimeInit.zygoteInit</code>对APP进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of the postFork event.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                pipeFd, parsedArgs.remainingArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//初始化运行时执行环境, 这里的remainingArgs实际是每个APP的入口`android.app.ActivityThread`</span></span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                parsedArgs.remainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>zygoteInit</code>主要负责如下几件事情：</p>
<ul>
<li>通用初始化<code>commonInit()</code>: 设置未捕获异常的处理函数；设置默认时区;</li>
<li>VM本地初始化<code>nativeZygoteInit()</code>；</li>
<li>应用初始化<code>applicationInit()</code>: 这里正是APP代码加载的地方;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"RuntimeInit"</span>);</span><br><span class="line">    redirectLogStreams();</span><br><span class="line"></span><br><span class="line">    commonInit();</span><br><span class="line">    nativeZygoteInit();</span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法<code>applicationInit</code>在设置完堆内存的使用率（可能引发GC）和应用目标SDK后；通过<code>invokeStaticMain</code>抛出一个<code>MethodAndArgsCaller</code>异常的方式调用<code>ActivityThread.main</code>，这样这个应用就算加载完成了。这篇文章旨在梳理zygote进程的一些逻辑，有关某个具体应用的加载流程请参考:<a href="http://sniffer.site/2017/02/21/Android-Phone%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">Android Phone进程启动过程分析</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="comment">// If the application calls System.exit(), terminate the process</span></span><br><span class="line">    <span class="comment">// immediately without running any shutdown hooks.  It is not possible to</span></span><br><span class="line">    <span class="comment">// shutdown an Android application gracefully.  Among other things, the</span></span><br><span class="line">    <span class="comment">// Android runtime shutdown hooks close the Binder driver, which can cause</span></span><br><span class="line">    <span class="comment">// leftover running threads to crash before the process actually exits.</span></span><br><span class="line">    nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We want to be fairly aggressive about heap utilization, to avoid</span></span><br><span class="line">    <span class="comment">// holding on to a lot of memory that isn't needed.</span></span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75f</span>);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Arguments args;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        Slog.e(TAG, ex.getMessage());</span><br><span class="line">        <span class="comment">// let the process exit</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The end of of the RuntimeInit event (see #zygoteInit).</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remaining arguments are passed to the start class's static main</span></span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Zygote </tag>
            
            <tag> Android应用启动 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程综述]]></title>
      <url>http://sniffer.site/2017/05/24/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%BB%BC%E8%BF%B0/</url>
      <content type="html"><![CDATA[<p>在计算机诞生初期，由于其高昂的计算成本，只能允许一个用户运行一个任务或者一批任务（<a href="https://en.wikipedia.org/wiki/Batch_processing" target="_blank" rel="noopener">Batch processing</a>)。随着技术的发展，人们开始思考一个问题，如何在计算机上实现多个任务“同时”运行？一开始，采用的是分时策略（<a href="https://en.wikipedia.org/wiki/Time-sharing" target="_blank" rel="noopener">Time sharing</a>），就是允许多个用户共享一台计算机，但每个用户占用计算机的一个时间片，在这个时间后，由另一个用户接着运行使用。分时系统在一定程度上提高了计算效率，实现了资源的共享。但其实际上并没有真正实现任务的“同时”（并发,concurrency）运行。</p>
<p>现代并发编程(Concurrent Pragramming)概念的出现一方面是受到操作系统中如进程、中断以及抢占的影响；一方面由于计算机硬件技术的发展而出现的多核处理器。</p>
<ul>
<li>进程，是程序执行的一个实体，是操作系统对CPU，寄存器，堆栈，内存，文件系统等计算资源的一种执行时的抽象；有了进程，计算机就可以通过调度系统来实现多个任务“同时”运行了，这里所谓的“同时”并不是多个程序真的在一个CPU中同时运行，而是说调度程序快速的在多个进程之间切换，交替执行不同程序，从而更有效的利用了计算机资源；</li>
<li>多核CPU的出现，为并发、并行计算提供了另一种可能。以前程序只能在一个CPU上运行，现在单个程序可以同时在多个CPU上同时运行了（<a href="https://en.wikipedia.org/wiki/Parallel_computing" target="_blank" rel="noopener">Parallel Computing</a>）；或者多个进程同时在多个CPU上运行。</li>
</ul>
<p>进程虽然提高了计算机系统的利用效率，实现了多个任务的并发执行，但是由于进程上下文切换<a href="https://en.wikipedia.org/wiki/Context_switch" target="_blank" rel="noopener">Context Switch</a>需要耗费CPU时间，频繁的进程切换势必导致计算机性能的下降。还有一个问题是，单个进程的程序在进行I/O操作时会阻塞，这样一方面会导致程序无响应，一方面也会浪费宝贵的CPU资源。于是，人们提出了线程(Thread)。一个进程中的线程共享进程的内存空间、全局变量、文件等资源，但会有独立的程序计数器(Program Counter),寄存器，栈空间（调用参数，本地变量等）以及线程状态。相比较而言，由于资源共享，线程创建比进程创建要快很多，上下文切换的时间更短，因而常被称为轻量级进程(Light-weight Process,LWP)。</p>
<p>那么，多线程并发到底有哪些好处？</p>
<ul>
<li>充分利用处理器资源： 多线程可以让程序的线程同时在多个CPU上同时执行，这样能充分利用CPU，提高系统的性能，让程序本身运行更快；</li>
<li>更好的程序响应能力:程序在由I/O事件时，无需等待，可以让一个线程等待I/O，另一个线程处理其他事情，从而提供程序运行的效率；</li>
<li>更好的用户体验: 对有UI的程序来说，在多线程执行情况下，可以让一个线程来专门处理与UI的交互，其他线程则处理后台任务，这样既保证了良好的UI响应，也能保证程序的正常运行。</li>
</ul>
<p>多线程并发执行虽然好处多多，但是在线程模型下，由于有资源的共享，多个线程同时操作共享数据/内存时，会出现数据一致性问题，导致程序运行出错。因此引来了一个难以忽视的线程安全问题：数据竞争(data race)与死锁(dead lock)。如果两个线程之间并没有共享数据（或者共享数据是不可变的，immutable)，那么根本就不用考虑同步问题，因为线程之间执行时独立的，互不干涉。一旦有了共享数据，如果其中有一个线程修改，而其他线程需要读取该数据，则两个线程同时操作的情况下，可能出现竞争条件(<a href="https://en.wikipedia.org/wiki/Race_condition" target="_blank" rel="noopener">race condition</a> )或者变质(stale)数据。另一个可能的问题就是死锁。比如一个线程A试图获取某个资源X，而该资源被线程B持有，因此A需要等待B释放资源X；线程B需要获取某个资源Y，但是该资源被A所持有，B需要等待A释放资源Y，这样就可能出现死锁(<a href="https://en.wikipedia.org/wiki/Deadlock" target="_blank" rel="noopener">Dead Lock</a>)。另一方面，线程同步需要额外的计算来实现加锁与释放锁，在一定程度上降低了程序运行的效率,而频繁的上下文切换也会带来性能的损耗。为了减少线程上下文切换，人们又提出了<a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="noopener">协程,coroutine</a>。</p>
<p>存在数据/内存共享的代码区域, 通常被称为<a href="https://en.wikipedia.org/wiki/Critical_section" target="_blank" rel="noopener">临界区(<code>critical section</code>)</a>, 为了避免上述可能存在的数据竞争与死锁问题的出现，需要确保线程的访问是原子(atomic)的, 不可中断的, 这种确保临界区数据的序列化访问方式即我们常说的同步(<code>synchronization</code>).Java在语言层面实现了同步机制。这些同步机制主要考虑两个关键问题：</p>
<ul>
<li>共享数据的互斥访问(mutual exclusion)：对于共享数据，任何时刻都只有一个线程在操作（竞争）;</li>
<li>共享数据的可见性（visibility):一个线程修改数据后对其他线程可见（协作）；</li>
</ul>
<p>在接下来的几篇文章里，我将围绕上述两个为题重点介绍Java并发编程的基本概念以及具体的实现机制,争取在这几篇文章里把Java并发编程的基本概念与核心要点都讲明白：</p>
<ul>
<li><a href="http://sniffer.site/2017/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B/">Java并发编程之线程类的实现</a> </li>
<li><a href="http://sniffer.site/2017/05/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%90%8C%E6%AD%A5/"> Java并发编程之同步</a> ；</li>
<li><a href="http://sniffer.site/2017/05/29/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BJava-Memory-Model/">Java并发编程之Java Memory Model</a> ;</li>
<li><a href="http://sniffer.site/2017/06/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/">Java并发编程之原子操作</a> ；</li>
<li><a href="http://sniffer.site/2017/06/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%94%81/">Java并发编程之锁</a> ；</li>
</ul>
<p>对于并发编程，本人也处于学习总结阶段，有不正确的地方，欢迎指正。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://www.oberon2005.oberoncore.ru/paper/bh2002.pdf" target="_blank" rel="noopener">http://www.oberon2005.oberoncore.ru/paper/bh2002.pdf</a></li>
<li><a href="http://www.enseignement.polytechnique.fr/informatique/INF431/X09-2010-2011/AmphiTHC/SynchronizationPrimitives.pdf" target="_blank" rel="noopener">http://www.enseignement.polytechnique.fr/informatique/INF431/X09-2010-2011/AmphiTHC/SynchronizationPrimitives.pdf</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Glide详解之架构分析]]></title>
      <url>http://sniffer.site/2017/05/20/Glide%E8%AF%A6%E8%A7%A3%E4%B9%8B%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Glide是BumpTech开发的一个同时可支持图片、GIF以及视频加载的Android开源库，同时Glide支持任何用户自定义的网络栈，其主要有以下几个特点：</p>
<ul>
<li>支持GIF格式动画的解码；</li>
<li>支持本地视频加载解码；</li>
<li>加载大图之前，可预先加载一个小图片<a id="more"></a></li>
<li>自动管理资源加载请求的生命周期；</li>
<li>给定图片尺寸，可以对资源进行自由转换</li>
</ul>
<blockquote>
<p>Github：<a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">https://github.com/bumptech/glide</a></p>
</blockquote>
<p>这里就来分析下Glide的具体架构以及介绍其主要特点，分如下几个方面：</p>
<ul>
<li>Glide代码架构及工作原理；</li>
<li>Glide如何自动管理资源加载请求的生命周期的？</li>
<li>Glide是如何进行图片的加载与转换的？</li>
</ul>
<h2 id="架构及工作原理"><a href="#架构及工作原理" class="headerlink" title="架构及工作原理"></a><strong>架构及工作原理</strong></h2><p>先来看一下Glide的代码结构，这里主要看下几个核心的包：</p>
<ul>
<li><code>com.bumptech.glide</code>： 主要负责Glide的初始化，参数配置，<code>Request</code>的创建；</li>
<li><code>com.bumptech.glide.load</code>： 主要负责资源的加载，解码与格式转换；</li>
<li><code>com.bumptech.glide.manager</code>： 负责Glide请求生命周期的自动管理；</li>
<li><code>com.bumptech.glide.module</code>： 用于加载解析用户自定义的网络模块；</li>
<li><code>com.bumptech.glide.provider</code>： 管理Glide中图片、GIF等资源的加载与转换器；</li>
<li><code>com.bumptech.glide.request</code> ： 资源加载请求相关以及动画；</li>
<li><code>com.bumptech.glide.util</code> ： 常用工具类；</li>
</ul>
<p>下图是Glide的原理简图。可以看到，Glide大致可以分为五个部分：</p>
<ul>
<li><code>Glide</code>： 初始化系统，负责管理系统其他模块如数据加载器、网络栈等初始化管理；</li>
<li><code>RequestManager</code>: 创建、初始化以及管理系统所有的Request；</li>
<li><code>Engine</code>: 将资源加载请求放入执行线程池，加载完后返回给主线程；</li>
<li><code>ExecutorService</code>: 线程池执行服务，负责分发调度<code>EngineRunnable</code>可执行对象；</li>
<li><code>DataFetcher</code>: 从磁盘或者网络端加载数据</li>
</ul>
<img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/GlideDiagram.png" class="[full image]" title="Glide Diagram">
<blockquote>
<p>关于Glide资源加载的详细过程请参考我的另一篇文章：<a href="http://sniffer.site/2017/05/30/Glide%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">Glide图片加载过程分析</a> </p>
</blockquote>
<p>接下来就来看一看，Glide的两个特征：请求生命周期的自动化管理以及系统的泛型化。</p>
<h2 id="如何自动进行生命周期管理"><a href="#如何自动进行生命周期管理" class="headerlink" title=" 如何自动进行生命周期管理"></a><strong> 如何自动进行生命周期管理</strong></h2><p>Glide从3.0开始支持Request生命周期的自动管理，即随着Activity或者Fragment的生命周期自动启动、恢复或者停止Request。Glide提供了两种生命周期管理策略：<code>ApplicationLifecycle</code>和<code>ActivityFragmentLifecycle</code>，前者确保Request的生命周期与APP的<code>Application</code>的生命周期保持一致；而后者则使Request的生命周期与<code>Activity</code>或者<code>Fragment</code>保持一致。</p>
<p>那么，<code>ActivityFragmentLifecycle</code>是如何实现的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivityFragmentLifecycle</span> <span class="keyword">implements</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</span><br><span class="line">            lifecycleListeners.add(listener);</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (isDestroyed) &#123;</span><br><span class="line">                listener.onDestroy();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isStarted) &#123;</span><br><span class="line">                listener.onStart();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                listener.onStop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isStarted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">            lifecycleListener.onStart();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">            lifecycleListener.onStop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isDestroyed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123;</span><br><span class="line">            lifecycleListener.onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化<code>RequestManager</code>时，会根据传入的<code>Context</code>来构造<code>RequestManager</code>(这里假定这里是一个<code>FragmentActivity</code>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You cannot start a load on a null Context"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">            <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">            <span class="keyword">return</span> get((Activity) context);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个与`ApplicationLifeCycle`对应的RequestManager</span></span><br><span class="line">    <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成一个无UI的<code>SupportRequestManagerFragment</code>，并将其中的<code>ActivityFragmentLifecycle</code>作为构造函数的参数传递给<code>RequestManager</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        <span class="keyword">return</span> get(activity.getApplicationContext());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assertNotDestroyed(activity);</span><br><span class="line">        FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">        <span class="keyword">return</span> supportFragmentGet(activity, fm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SupportRequestManagerFragment是一个无UI的Fragment,用于控制Request的生命周期</span></span><br><span class="line"><span class="function">RequestManager <span class="title">supportFragmentGet</span><span class="params">(Context context, FragmentManager fm)</span> </span>&#123;</span><br><span class="line">    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm);</span><br><span class="line">    RequestManager requestManager = current.getRequestManager();</span><br><span class="line">    <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestManager = <span class="keyword">new</span> RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">        current.setRequestManager(requestManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>RequestManager</code>构造时，会将<code>RequestManager</code>作为上述Fragment生命周期的监听者，从而使得<code>RequsetManager</code>中的Request生命周期始终与Fragment保持一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RequestManager(Context context, <span class="keyword">final</span> Lifecycle lifecycle, RequestManagerTreeNode treeNode,</span><br><span class="line">        RequestTracker requestTracker, ConnectivityMonitorFactory factory) &#123;</span><br><span class="line">    <span class="keyword">this</span>.context = context.getApplicationContext();</span><br><span class="line">    <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">    <span class="keyword">this</span>.treeNode = treeNode;</span><br><span class="line">    <span class="keyword">this</span>.requestTracker = requestTracker;</span><br><span class="line">    <span class="keyword">this</span>.glide = Glide.get(context);</span><br><span class="line">    <span class="keyword">this</span>.optionsApplier = <span class="keyword">new</span> OptionsApplier();</span><br><span class="line"></span><br><span class="line">    ConnectivityMonitor connectivityMonitor = factory.build(context,</span><br><span class="line">            <span class="keyword">new</span> RequestManagerConnectivityListener(requestTracker));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're the application level request manager, we may be created on a background thread. In that case we</span></span><br><span class="line">    <span class="comment">// cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding</span></span><br><span class="line">    <span class="comment">// ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe.</span></span><br><span class="line">    <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">        <span class="keyword">new</span> Handler(Looper.getMainLooper()).post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                lifecycle.addListener(RequestManager.<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lifecycle.addListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lifecycle.addListener(connectivityMonitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，不难看出这样一个生命周期事件的通知链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SupportRequestManagerFragment --&gt; ActivityFragmentLifecycle --&gt; RequestMananger</span><br></pre></td></tr></table></figure>
<h2 id="系统的泛型化"><a href="#系统的泛型化" class="headerlink" title="系统的泛型化"></a><strong>系统的泛型化</strong></h2><p>Glide在设计上尽可能保持抽象与泛型化，从最大程度上保持了系统的可扩展性与可维护性。这些泛型化主要体现在如下几个方面：</p>
<ul>
<li>用户加载资源的来源可能是一个包含了URI路径的字符串，可能是一个文件，可能是一个URL，因此需要对资源加载的类型泛型化成一个类<code>ModelLoader&lt;T,Y&gt;</code>（称之为ModelType);</li>
<li>资源的数据类型可能是<code>InputStream</code>,也可以是字节流数组<code>byte[]</code>,还可以是一个文件<code>File</code>，因此需要对数据类型进行泛型化成一个类<code>DataFetcher&lt;Y&gt;</code>(称之为DataType);</li>
<li>加载完的资源类型可能是一个<code>drawable</code>，也可能是一个<code>gif</code>文件；可能是一个<code>bitmap</code>,也可能是一个<code>byte[]</code>字节数组，同样将其泛型化成一个类<code>Resource&lt;Z&gt;</code>(称之为ResourceType,实际上是对加载完后的资源的一个包装类型）；</li>
<li>不同资源类型可能需要进行转换，比如讲<code>bitmap</code>转换成字节数组<code>byte[]</code>;将<code>drawable</code>变换成<code>bitmap</code>，因此可以将这种转换的关系泛化成一个类<code>ResourceTranscoder&lt;Z,R&gt;</code>（TranscodeType);</li>
</ul>
<p>接下来就来看下这几个泛型类的实现。</p>
<h3 id="ModelLoader"><a href="#ModelLoader" class="headerlink" title="ModelLoader"></a><strong>ModelLoader</strong></h3><p><code>ModelLoader</code>的功能是将资源加载到一个具体的数据类型，比如<code>InputStream</code>中,实际是利用<code>DataFetcher</code>来实现资源的加载。Glide提供了多种类型的<code>ModelLoader</code>将不同资源的文件加载到一个<code>InputStream</code>中去：</p>
<ul>
<li><code>HttpUrlGlideUrlLoader</code>：将一个GlideUrl加载后到一个Inpustream中；</li>
<li><code>StreamByteArrayLoader</code>： 将一个字节流加载到一个InputStream;</li>
<li><code>StreamFileLoader</code>： 将文件加载到一个InputStream;</li>
<li><code>StreamUrlLoader</code>： 将一个URL资源加载到InputStream;</li>
<li><code>StreamResourceLoader</code>：讲一个Android资源文件加载到InputStream；</li>
</ul>
<h3 id="DataFetcher"><a href="#DataFetcher" class="headerlink" title="DataFetcher"></a><strong>DataFetcher</strong></h3><p><code>DataFetcher</code>用于从文件或者网络上加载资源，将其变成一个特定的数据类型：</p>
<ul>
<li><code>HttpUrlFetcher</code>: 获取一个URL资源的<code>InputStream</code>;</li>
<li><code>ByteArrayFetcher</code>: 将一个字节流数据变成<code>InputStream</code>输入流；</li>
<li><code>StreamLocalUriFetcher</code>： 获取本地URI资源的<code>InputStream</code>;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public final class GenericRequest&lt;A, T, Z, R&gt; implements Request, SizeReadyCallback,</span><br><span class="line">        ResourceCallback &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ResourceTranscoder"><a href="#ResourceTranscoder" class="headerlink" title="ResourceTranscoder"></a><strong>ResourceTranscoder</strong></h3><p>将一种资源类型<code>Resource&lt;Z&gt;</code>转换成另一种类型<code>Resource&lt;R&gt;</code>，比如Bitmap转换成Drawable：</p>
<ul>
<li><code>BitmapBytesTranscoder</code>: 将bitmap转码成一个字节数组；</li>
<li><code>BitmapToGlideDrawableTranscoder</code>： 将一个bitmap转码成一个GlideDrawable;</li>
<li><code>GifDrawableBytesTranscoder</code>: 将GIF文件转码成字节数组；</li>
</ul>
<p>有关Glide加载图片的过程以及泛型参数的擦除请参考另一篇文章<a href="http://sniffer.site/2017/05/30/Glide%E8%AF%A6%E8%A7%A3%E4%B9%8B%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">Glide图片加载过程分析</a> 。</p>
<h2 id="Glide源码地址"><a href="#Glide源码地址" class="headerlink" title="Glide源码地址"></a><strong>Glide源码地址</strong></h2><ul>
<li>Glide源码地址：<a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">https://github.com/bumptech/glide</a> </li>
</ul>
]]></content>
      
        <categories>
            
            <category> Open Source </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Glide </tag>
            
            <tag> Image Loading </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程之同步]]></title>
      <url>http://sniffer.site/2017/05/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%90%8C%E6%AD%A5/</url>
      <content type="html"><![CDATA[<p>在单一线程执行的情况下，并不用考虑任何数据一致性与同步等问题，但到了多个线程执行的情况下，共享数据的同步就显得至关重要了。比如有一个银行账户的操作问题(例子来自<a href="https://en.wikipedia.org/wiki/Concurrent_computing" title="Wikipedia" target="_blank" rel="noopener">Wikipedia</a>),现在有两个线程A与B共享一个账户变量<code>balance</code>,这个提款的操作有两个部分，首先需要判定提款数目是否小于当前账户存款，记为<code>s1</code>;如果该条件满足，则从账户中提取资金，记为<code>s2</code>。假定开始时账户<code>balance=600</code>，现在A调用<code>withdraw(200)</code>,B调用<code>withdraw(500)</code>，如果两个线程A与B调用时，<code>s1</code>都发生在<code>s2</code>之前，则两个线程都可以进入判定条件，提取相应的资金，而实际的存款是小于两个线程需要提取的资金的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">bool <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> withdrawal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (balance &gt;= withdrawal) <span class="comment">// --&gt; s1</span></span><br><span class="line">     &#123;</span><br><span class="line"> </span><br><span class="line">         balance -= withdrawal; <span class="comment">// --&gt; s2</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种线程之间共享资源的一致性同步问题在并发编程中十分常见，通常被称为Data Race。根据官网上的定义(<a href="https://docs.oracle.com/cd/E19205-01/820-0619/geojs/index.html" target="_blank" rel="noopener">what is data race</a>)，Data Race出现是由以下原因导致：</p>
<ul>
<li>多个线程同时访问共享内存；</li>
<li>至少有一个线程写该共享内存区域；</li>
<li>线程访问共享内存并没有利用锁进行同步；</li>
</ul>
<p>除了上述Data Race之外，多个线程之间并发执行的情况下，若不正确进行同步还可能出现：</p>
<ul>
<li>竞争条件(race conditions): 多个线程同时修改一个共享数据，从而导致数据不一致（Data Race就是一种）</li>
<li>死锁(dead lock): 多个线程之间相互等待某个或者多个线程释放某个资源，从而导致死循环（参考： <a href="https://en.wikipedia.org/wiki/Deadlock" target="_blank" rel="noopener">Deadlock</a>）</li>
<li>饿死(Starvation): 某个线程获取某个资源时总是被阻塞（资源被其他线程占有，未被释放），而无法获得CPU</li>
</ul>
<p>那么，Java是如何来解决上述并发编程中出现的问题？Java主要有两种方法来避免上述问题：</p>
<ul>
<li>线程之间的同步（使用synchronized或者lock)</li>
<li>Java内存模型(Java Memory Model)中的执行偏序关系,确保某些特定的代码依照特定的顺序执行，从而确保数据的可见性</li>
</ul>
<p>这篇文章里，主要来看一看线程之间的同步(synchronized)。Java中内置了一个同步关键字<code>synchronized</code>，<code>synchronized</code>实际上是通过<a href="https://en.wikipedia.org/wiki/Monitor_(synchronization" target="_blank" rel="noopener">monitor</a>)(监视器）来实现的。在Java中，每个对象跟一个monitor关联在一起，线程通过获取monitor锁互斥访问某个资源；通过释放monitor上的锁释放占用的资源。因此，Java中任何一个对象都可以成为一个锁来实现同步。在锁住或者解锁monitor时，有如下约定：</p>
<ul>
<li>任何时刻只有一个线程占有一个monitor的一个锁，此时其他尝试获取该monitor锁的其他线程都会被阻塞直到获取锁成功为止；</li>
<li>一个线程可多次获取某个monitor的锁；需要同样次数的解锁，线程才算完全释放monitor锁；</li>
</ul>
<p>总的说来，monitor提供了两种同步功能：</p>
<ul>
<li>Mutual Exclusion: 互斥访问，确保多个线程访问共享资源时不会造成冲突，任何时刻只有一个线程占用资源；</li>
<li>Cooperation: 合作，让多个线程协同工作完成某个特定的任务。资源不可用，线程进入睡眠等待队列；资源可用时，会从等待队列中唤醒队列中的某个线程执行；</li>
</ul>
<h2 id="Mutual-Exclusion"><a href="#Mutual-Exclusion" class="headerlink" title="Mutual Exclusion"></a><strong>Mutual Exclusion</strong></h2><p>互斥访问是通过<code>synchronized</code>来实现的。<code>synchronized</code>在Java中有两种使用方式：一种是在某个代码块前使用，一个是在放在方法名前面使用。例如，上述银行提款的示例,在代码提款的代码块中加上同步（以下简称块同步）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">bool <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> withdrawal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (balance &gt;= withdrawal) <span class="comment">// --&gt; s1</span></span><br><span class="line">         &#123;</span><br><span class="line"></span><br><span class="line">             balance -= withdrawal; <span class="comment">// --&gt; s2</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对整个方法进行同步（以下简称方法同步）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">bool <span class="keyword">synchronized</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> withdrawal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (balance &gt;= withdrawal) <span class="comment">// --&gt; s1</span></span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">         balance -= withdrawal; <span class="comment">// --&gt; s2</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从效果上来说，两种方法都能达到避免<code>balance</code>出现竞争的目的。但块同步锁住的是其表达式内的对象monitor；而方法同步则锁住的是该方法所属类上的monitor，这里有两种情况：</p>
<ul>
<li>非静态方法，锁住当前类实例<code>this</code>对应的monitor;</li>
<li><code>static</code>静态方法，锁住类的<code>Class</code>对象的monitor;</li>
</ul>
<p>当块代码或者方法执行完毕之后，锁会被自动释放。除了语言本身提供的同步之外，Java还提供了<code>volatile</code>用于确保变量读写的可见性；<code>java.util.concurrent</code>中针对不同的应用需求，提供了诸如<code>ReentrantLock</code>,<code>ReadWriteLock</code>,<code>Condition</code>等同步方法，接下来的一篇文章会详细介绍这些类的原理与使用。</p>
<h2 id="Cooperation"><a href="#Cooperation" class="headerlink" title="Cooperation"></a><strong>Cooperation</strong></h2><p>线程在访问共享变量时需要确保互斥访问，而在诸如将计算任务细分成多个子任务的多线程运行的情况下，就需要考虑线程之间的协作（<code>Cooperation</code>），就是说，某个线程执行完某个动作后，怎么让另一个线程知道该完成事件了？</p>
<p>在Java中，每个对象（Object)除了有自己的monitor之外，还有一个关联的<code>wait set</code>(等待集),就是一个线程的集合，表示当前有多少个线程在该对象上等待某个事件的发生。一个对象初次创建时，<code>wait set</code>是空的，当有线程调用<code>Object.wait()</code>时，就将该线程加入到该<code>wait set</code>中，而当其他线程调用<code>Object.notify()</code>或者<code>Object.notifyAll()</code>时，该线程从<code>wait set</code>中释放。</p>
<p><code>Object</code>提供了三种<code>wait</code>方法：</p>
<ul>
<li>不超时：<code>wait()</code></li>
<li>超时等待： <code>wait(long millisecs)</code>；</li>
<li>超时等待：<code>wait(long millisecs, int naos)</code>，更精确的等待时间；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wakes up a single thread that is waiting on this object's</span></span><br><span class="line"><span class="comment">     * monitor. If any threads are waiting on this object, one of them</span></span><br><span class="line"><span class="comment">     * is chosen to be awakened. The choice is arbitrary and occurs at</span></span><br><span class="line"><span class="comment">     * the discretion of the implementation. A thread waits on an object's</span></span><br><span class="line"><span class="comment">     * monitor by calling one of the &#123;<span class="doctag">@code</span> wait&#125; methods.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Causes the current thread to wait until either another thread invokes the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> java.lang.Object#notify()&#125; method or the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> java.lang.Object#notifyAll()&#125; method for this object, or a</span></span><br><span class="line"><span class="comment">     * specified amount of time has elapsed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                                <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; timeout == <span class="number">0</span>)) &#123;</span><br><span class="line">            timeout++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called by the garbage collector on an object when garbage collection</span></span><br><span class="line"><span class="comment">     * determines that there are no more references to the object.</span></span><br><span class="line"><span class="comment">     * /</span></span><br><span class="line"><span class="comment">    protected void finalize() throws Throwable &#123; &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a><strong>wait</strong></h3><p>一个线程调用<code>Object.wait</code>时可能有如下几种情况出现：</p>
<ul>
<li>首先线程需要获取对象<code>Object</code>的锁；如果获取到锁，则会抛出<code>IllegalMonitorStateException</code>异常；</li>
<li>如果是超时等待，且参数<code>nanos</code>的大小不在[0-999999]之间的话或者<code>timeout</code>小于0，则抛出<code>IllegalArgumentException</code>;</li>
<li>线程被中断，抛出中断异常<code>InterruptException</code>,中断状态置为false;</li>
<li>接着，线程加入到对象的<code>wait set</code>,并释放对象锁；</li>
<li><p>此后线程处于等待状态直到从对象的<code>wait set</code>移除之后，以下动作会导致线程从<code>wait set</code>中移除：</p>
<ul>
<li>调用了<code>Object.notfiy()</code>或者<code>Object.notifyAll()</code>;</li>
<li>线程被中断（从<code>wait set</code>移除后，线程中断状态设置为false，并抛出<code>InterruptException</code>异常）；</li>
<li>等待超时；</li>
<li>线程重新获取了对象锁；</li>
</ul>
</li>
</ul>
<h3 id="notification"><a href="#notification" class="headerlink" title="notification"></a><strong>notification</strong></h3><p>通知动作是通过调用<code>Object.notify()</code>和<code>Object.notifyAll()</code>来实现的，调用时可能出现以下几种情况：</p>
<ul>
<li>如果当前线程没有获取到对象锁，则抛出<code>IllegalMonitorStateException</code>异常；</li>
<li>有锁，执行<code>notify</code>，若对象的<code>wait set</code>不为空，则选择一个线程，并移除之（注意，如果当前线程多次获取了对象锁，<code>notify</code>后，其他线程只能等到当前线程完全释放锁后才能成功）；</li>
<li>有锁，执行<code>notifyAll</code>，对象<code>wait set</code>不为空，将所有线程从中移除；</li>
</ul>
<blockquote>
<p>有关wait/notify机制的具体使用，可参考示例代码：<a href="https://github.com/runningforlife/JavaExamples/tree/master/ConcurrencyExamples" target="_blank" rel="noopener">ConcurrencyExamples</a></p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Monitor_(synchronization" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Monitor_(synchronization)</a>)</li>
<li><a href="http://www.artima.com/insidejvm/ed2/threadsynch.html" target="_blank" rel="noopener">http://www.artima.com/insidejvm/ed2/threadsynch.html</a></li>
<li><a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5-110" target="_blank" rel="noopener">http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5-110</a></li>
<li><a href="http://docs.oracle.com/javase/specs/" target="_blank" rel="noopener">Java Language Specification SE8 Edition</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
            <tag> synchronized </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java并发编程之线程]]></title>
      <url>http://sniffer.site/2017/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>线程作为操作系统的最小调度单位。一个进程里可以有多个线程，这些线程有各自的程序计数器、堆栈空间和局部变量，而且可以共享进程的内存空间，因而在上下文切换时时间更短，效率更高，也常被成为轻量级进程(Light Weight Process)。接下来，将从三个方面来介绍Java线程类<code>Thread</code>的具体用法：</p>
<a id="more"></a>
<ul>
<li>线程构造与初始化;</li>
<li>线程状态切换;</li>
<li>线程变量ThreadLocal<t>的使用</t></li>
</ul>
<blockquote>
<p>Thread: <a href="https://en.wikipedia.org/wiki/Thread_(computing)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Thread_(computing)</a></p>
</blockquote>
<h2 id="线程的构造与初始化"><a href="#线程的构造与初始化" class="headerlink" title="线程的构造与初始化"></a>线程的构造与初始化</h2><p><code>Thread</code>类提供了多个构造函数，初始化时有四个主要的参数：</p>
<ul>
<li><code>ThreadGroup</code> 线程所在的线程组;</li>
<li><code>Runnable</code>目标可执行对象;</li>
<li><code>String</code> 线程名称;</li>
<li><code>long</code> stackSize,线程栈空间大小，不指定（为0)时由JVM确定;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">     init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ....</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(ThreadGroup group, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">     init(group, target, name, stackSize);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>线程的构造函数最后通过一个<code>init</code>函数来进行初始化，初始化主要完成完成几个事情:</p>
<ul>
<li>如果用户没有指定<code>ThreadGroup</code>,则首先需要确定该线程的<code>ThreadGroup</code>;</li>
<li>设置守护进程属性以及线程优先级;</li>
<li>创建ThreadLocal变量对应的<code>ThreadLocalMap</code>对象;</li>
<li>产生线程ID</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">     Thread parent = currentThread();</span><br><span class="line">     SecurityManager security = System.getSecurityManager();</span><br><span class="line">     <span class="comment">// 确定ThreadGroup</span></span><br><span class="line">     <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">/* Determine if it's an applet or not */</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">            what to do. */</span></span><br><span class="line">         <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">             g = security.getThreadGroup();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* If the security doesn't have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">            use the parent thread group. */</span></span><br><span class="line">         <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">             g = parent.getThreadGroup();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 增加该线程组中未启动线程的数目</span></span><br><span class="line">     g.addUnstarted();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">this</span>.group = g;</span><br><span class="line">     <span class="comment">// 是否为守护线程/优先级都由父亲线程确定</span></span><br><span class="line">     <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">     <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">     <span class="keyword">this</span>.name = name.toCharArray();</span><br><span class="line">	</span><br><span class="line">     <span class="keyword">this</span>.target = target;</span><br><span class="line">     setPriority(priority);</span><br><span class="line">     <span class="comment">// 创建ThreadLocal变量对应的ThreadLocalMap</span></span><br><span class="line">     <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">             ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">     <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">     <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 设置线程ID */</span></span><br><span class="line">     tid = nextThreadID();</span><br><span class="line">     <span class="comment">// 初始化完成</span></span><br><span class="line">     <span class="keyword">this</span>.me = <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>线程构造完成后，调用<code>start()</code>即可启动了。</p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>看<code>Thread.java</code>源码，线程在JVM中有6种不同的状态：</p>
<ul>
<li><strong>NEW</strong>： 线程刚创建，还未启动;</li>
<li><strong>RUNNABLE</strong>: 线程在JVM中开始执行</li>
<li><strong>BLOCKED</strong>: 线程在等待某个锁时被阻塞</li>
<li><strong>WAITING</strong>： 线程处于无限期等待另一个线程完成某个动作</li>
<li><strong>TIMED_WAITING</strong>: 线程等待另一个线程完成某个动作，超时后返回执行;</li>
<li><strong>TERMINATED</strong>： 线程处于终止状体(执行完成或者推出)</li>
</ul>
<p>下图是一个线程状态之间的切换图：</p>
<img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ThreadState.jpg" class="[full-image]" title="Java Thread State">
<p>线程创建完成后，调用<code>start</code>开始执行。当线程调用<code>wait</code>方法之后，开始进入等待状态，这是需要在其他线程调用<code>notify/notifyAll</code>进行通知才能返回的运行状态，如果使用了超时等待，线程在等待指定时间长度之后，仍未受到通知，则直接返回运行。若线程尝试通过<code>synchronized</code>获取同步锁，则会进入阻塞状态;在执行完<code>run</code>方法中的代码之后，则会进入终止状态。</p>
<h2 id="线程变量ThreadLocal的使用"><a href="#线程变量ThreadLocal的使用" class="headerlink" title="线程变量ThreadLocal的使用"></a>线程变量ThreadLocal<t>的使用</t></h2><p>线程本地变量ThreadLocal允许每个线程都有关于某个变量自己的一份唯一拷贝，线程可通过get/set方法来获取或者设置本地变量的值。通常，一个本地变量是一个static型、跟线程状态相关的变量（如用户ID ,交易ID)。</p>
<p>先来看下如何使用ThreadLocal本地变量。例如，我们想要得到一个线程的执行时间，可以这样利用ThreadLocal：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadProfiler</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;()&#123;</span><br><span class="line">		<span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">		TIME.set(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">		TIME.set(System.currentTimeMillis());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> System.currentTimeMillis() - TIME.get();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样只要在线程开始执行时调用<code>ThreadProfiler.start()</code>，而线程结束时调用<code>ThreadProfiler.getTime()</code>就可以得到线程执行所耗费的时间了。</p>
<p>ThreadLocal通过一个以ThreadLocal为key,其他任何对象为value的<code>ThreadLocalMap</code>（一个HashMap)来保存线程相关的本地变量值，而每个线程都有自己的一个<code>ThreadLocalMap</code>，这样线程就可以通过ThreadLocal来获取该map对象以ThreadLocal为键值的对象值了。</p>
<p>线程调用<code>ThreadLocal</code>的<code>set(T value)</code>时，如果已存在一个map对象，则直接将该值以该<code>ThreadLocal</code>对象为键值保存下来；如果线程没有map对象，则需要创建一个新的<code>ThreadLocalMap</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程调用<code>ThreadLocal.get()</code>,返回线程的本地变量。如果当前线程已经有一个map对象，并且该map对象有<code>ThreadLocal</code>对应的值，则直接返回;否则对线程的<code>ThreadLocalMap</code>对象<code>threadLocals</code>进行初始化操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考源码"><a href="#参考源码" class="headerlink" title="参考源码"></a>参考源码</h2><ul>
<li><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/ThreadLocal.java#ThreadLocal" target="_blank" rel="noopener">http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/ThreadLocal.java#ThreadLocal</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
            <tag> Thread </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[单例模式在Java中的应用]]></title>
      <url>http://sniffer.site/2017/04/29/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%9C%A8Java%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>单例模式（Singleton Pattern)用于确保系统中某个类只有一个实例存在，即该类被创建初始化一次后，之后都不会再被创建。这里就来看下单例模式在Java中常见的几种实现方式： </p>
<a id="more"></a>
<ul>
<li>双重检查锁</li>
<li>类初始化</li>
<li>enum类型实现</li>
</ul>
<h2 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a><strong>双重检查锁</strong></h2><p>先来看下单例模式的简单实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * a very simple singleton</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * this is not thread safe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSingletonUnsafe</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SimpleSingletonUnsafe sInstance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SimpleSingletonUnsafe</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SimpleSingletonUnsafe <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(sInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			sInstance = <span class="keyword">new</span> SimpleSingletonUnsafe();</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">return</span> sInstance;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于没有对代码进行同步保护，上述实现在多个线程并发访问时可能出现<em>sInstance</em>被初始化多次的情况。为避免这种情况，可以直接在声明静态变量时进行类的初始化，从而保证始终只有一次初始化动作（JVM在初始化类时会获取一个锁，确保类初始化是线程安全的）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * a singleton which is thread safe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSingletonSafe</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SimpleSingletonSafe INSTANCE = <span class="keyword">new</span> SimpleSingletonSafe();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SimpleSingletonSafe</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SimpleSingletonSafe <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在有了一个线程安全的单例模式了(Eager Initialization)，但是这里还存在一个问题： 不管是否有线程使用该类，它都会初始化一次。这对于那些占有很多资源的类来说，可能并不合适。能不能只是在需要使用的时候才会类进行初始化了？采用双重检查锁（double checking lock)技术即可避免这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  a lazy singleton to prevent object creation earlier</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  this is not thread safe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonUnsafe</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> LazySingletonUnsafe sInstance = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">LazySingletonUnsafe</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingletonUnsafe <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(sInstance == <span class="keyword">null</span>)&#123;  <span class="comment">//B:  1</span></span><br><span class="line">			<span class="keyword">synchronized</span>(LazySingletonUnsafe.class)&#123;</span><br><span class="line">				<span class="keyword">if</span>(sInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">					sInstance = <span class="keyword">new</span> LazySingletonUnsafe(); <span class="comment">// A: 2</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> sInstance; <span class="comment">// B:  可能返回一个尚未初始化完成的对象</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表面看起来，这个方案似乎已经大功告成了。但在多线程的情况下，可能返回一个未初始化完成的对象。比如，有两个线程A、B，线程A先获取到同步锁，进入初始化代码，此时类<em>LazySingletonUnsafe</em>开始初始化，此时<em>sInstance</em>已经指向类分配的内存空间，不为空，当线程B调用<em>getInstance</em>时，判断条件不成立，因此直接准备返回，而实际上返回的是<em>sInstance</em>的一个引用对象，而可能此时类的初始化并没有完成，B得到的类实例就与A得到的不一致了。通过在限定变量<em>sInstance</em>为<em>volatile</em>(禁止JVM进行指令重排序,确保引用<code>sInstance</code>在多线程情况下是可见的），即可解决该问题：</p>
<p>| 有关<code>volatile</code>在JVM中的实现原理可参考:<a href="http://sniffer.site/2017/05/29/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BJava-Memory-Model/">Java并发编程之Java Memory Model</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * a thread-safe singleton</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonSafe</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingletonSafe sInstance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">LazySingletonSafe</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingletonSafe <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(sInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(LazySingletonUnsafe.class)&#123;</span><br><span class="line">				<span class="keyword">if</span>(sInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">					sInstance = <span class="keyword">new</span> LazySingletonUnsafe();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">return</span> sInstance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java类初始化的详细过程： <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4.2" target="_blank" rel="noopener">http://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4.2</a></p>
</blockquote>
<h2 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a><strong>类初始化</strong></h2><p>与此前双重检查锁中方案2类似，通过一个静态的私有类，类的对象变量作为该私有类的静态成员，该静态成员变量初始化时即创建新的对象，这样即能确保线程安全，也能保证类始终只初始化一次:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  a static nested holder to be singleton</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  JVM will acquire a lock when initializing a class, so it is thread-safe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonHolder INSTANCE = <span class="keyword">new</span> SingletonHolder();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonHolder <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> InstanceHolder.INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="enum类型实现"><a href="#enum类型实现" class="headerlink" title="enum类型实现"></a><strong>enum类型实现</strong></h2><p>在《Effective Java 2nd edition》第二章里推荐一种利用enum来实现单例模式的方法，看起来似乎更为简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"EnumSingleton"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，其中还提到了单例模式下类序列化的问题：为了避免每次序列化时都创建一个新的对象，需要提供一个<code>readResolve</code>函数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述示例代码可参考：<a href="https://github.com/runningforlife/JavaExamples" target="_blank" rel="noopener">https://github.com/runningforlife/JavaExamples</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Design Pattern </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Picasso从使用到原理详解]]></title>
      <url>http://sniffer.site/2017/04/20/Picasso%E4%BB%8E%E4%BD%BF%E7%94%A8%E5%88%B0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>Picasso是SquareUp公司开源的专门为Android平台量身制作的图片加载库。通过Picasso，用户可以方便的将图片加载到特定的ImageView中，而不用关心图片是在一个文件夹里，还是在一个服务器上。那么，Picasso是如何何实现图片的快速加载了？</p>
<a id="more"></a>
<ul>
<li>利用两级缓存机制对图片进行缓存: 加载一个图片时，首先从内存中查看是否存在；如果不存在，则查看外部存储是否有该图片。这时，如果还没有找到，则通过网络端下载图片；</li>
<li>利用OkHttp库进行图片下载，下载后保存到缓存，下次请求时无需从网络端下载；如果出现网络错误，会自动重试下载；</li>
</ul>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a><strong>使用示例</strong></h2><p>Picasso提供了好几个调用接口,可以从文件或资源文件,也可以从网络下载图片.比如,现在要从网络上下载一张图片,并将其加载到一个ImageView上去,可以这么来调用接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(Context context, String url, ImageView target, @DrawableRes <span class="keyword">int</span> placeholder)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Picasso.with(context)</span><br><span class="line">            .load(url)</span><br><span class="line">            .placeholder(placeholder) <span class="comment">// 未下载完之前显示的占位图片</span></span><br><span class="line">            .centerCrop() <span class="comment">// 保持图片尺寸与屏幕长宽比一致</span></span><br><span class="line">            .resize(<span class="number">512</span>,(<span class="keyword">int</span>)(<span class="number">512</span>*DisplayUtil.getScreenRatio(context)))</span><br><span class="line">            .into(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么,如果想要监听图片加载完成这一事件,则需要自己手动实现`Target这个接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageTarget</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ImageView image;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageTarget</span><span class="params">(ImageView view)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.image = view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBitmapLoaded</span><span class="params">(Bitmap bitmap, Picasso.LoadedFrom from)</span> </span>&#123;</span><br><span class="line">        Log.v(TAG,<span class="string">"onBitmapLoaded(): bitmap size "</span> + bitmap.getByteCount() + <span class="string">",loaded from "</span> + from);</span><br><span class="line">        image.setImageBitmap(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBitmapFailed</span><span class="params">(Drawable errorDrawable)</span> </span>&#123;</span><br><span class="line">        Log.v(TAG,<span class="string">"onBitmapFailed()"</span>);</span><br><span class="line">        image.setImageDrawable(errorDrawable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPrepareLoad</span><span class="params">(Drawable placeHolderDrawable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后将其作为参数传入:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(Context context, String url, Target target, @DrawableRes <span class="keyword">int</span> placeholder)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Picasso.with(context)</span><br><span class="line">            .load(url)</span><br><span class="line">            .placeholder(placeholder)</span><br><span class="line">            .centerCrop()</span><br><span class="line">            .resize(<span class="number">512</span>,(<span class="keyword">int</span>)(<span class="number">512</span>*DisplayUtil.getScreenRatio(context)))</span><br><span class="line">            .into(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote><p>具体代码可参考: <a href="https://github.com/runningforlife/AndroidExamples" target="_blank" rel="noopener">https://github.com/runningforlife/AndroidExamples</a>  中ImageLoader部分代码</p>
</blockquote>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a><strong>源码解析</strong></h2><p>下图是Picasso的简单框图,用户调用<code>into(ImageView iv)</code>接口后，Picasso将其该下载图片的请求包装成一个<code>ImageViewAction</code>,接着由<code>Picasso</code>负责发送到<code>Dispatcher</code>中；<code>Dispatcher</code>接着会把该Action继续封装成一个可执行对象<code>BitmapHunter</code>，接着将其提交到线程池<code>PicassoExecutorService</code>中执行；如果此时发现内存中已经有图片，则直接返回，否则<code>BitmapHunter</code>将通过一个<code>Downloader</code>下载图片，下载图片完成后，<code>BitmapHunter</code>会将结果返回给<code>Dispatcher</code>,最后由<code>Dispatcher</code>告知<code>Picasso</code>图片加载完成。</p>
<img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/picasso_structure.png" class="[full image]" title="Piccasso Structure">
<p>这里就来看一看Picasso库的几个核心类:</p>
<h3 id="Picasso-java"><a href="#Picasso-java" class="headerlink" title=" Picasso.java"></a><strong> <code>Picasso.java</code></strong></h3><p>从构造函数来看，<code>Picasso</code>类构造时需要初始化整个库，通过<code>RequestCreator</code>来产生图片加载请求<code>Request</code>，发送到<code>Dispatcher</code>中准备执行； 等图片加载完成后，还需要通过主线程告知用户图片已经加载完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener,</span><br><span class="line">    RequestTransformer requestTransformer, List&lt;RequestHandler&gt; extraRequestHandlers, Stats stats, Bitmap.Config defaultBitmapConfig, <span class="keyword">boolean</span> indicatorsEnabled, <span class="keyword">boolean</span> loggingEnabled) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 请求分发</span></span><br><span class="line">  <span class="keyword">this</span>.dispatcher = dispatcher;</span><br><span class="line">  <span class="comment">// 缓存</span></span><br><span class="line">  <span class="keyword">this</span>.cache = cache;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 构造不同的RequestHandler对象，用以处理不同类型的Request</span></span><br><span class="line">  allRequestHandlers.add(<span class="keyword">new</span> ResourceRequestHandler(context));</span><br><span class="line">  <span class="keyword">if</span> (extraRequestHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">    allRequestHandlers.addAll(extraRequestHandlers);</span><br><span class="line">  &#125;</span><br><span class="line">  allRequestHandlers.add(<span class="keyword">new</span> ContactsPhotoRequestHandler(context));</span><br><span class="line">  allRequestHandlers.add(<span class="keyword">new</span> MediaStoreRequestHandler(context));</span><br><span class="line">  allRequestHandlers.add(<span class="keyword">new</span> ContentStreamRequestHandler(context));</span><br><span class="line">  allRequestHandlers.add(<span class="keyword">new</span> AssetRequestHandler(context));</span><br><span class="line">  allRequestHandlers.add(<span class="keyword">new</span> FileRequestHandler(context));</span><br><span class="line">  allRequestHandlers.add(<span class="keyword">new</span> NetworkRequestHandler(dispatcher.downloader, stats));</span><br><span class="line">  requestHandlers = Collections.unmodifiableList(allRequestHandlers);</span><br><span class="line">  <span class="comment">// 统计图片下载请求</span></span><br><span class="line">  <span class="keyword">this</span>.stats = stats;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>几个重要函数:</p>
<ul>
<li><code>load(...)</code>: 加载图片，资源可是一个URL,也可以是一个文件路径，可以是一个资源文件ID；</li>
<li><code>cancelRequest(ImageView)</code>: 取消某个<code>ImageView</code>的图片加载请求；</li>
<li><code>invalidate(...)</code> : 清除缓存;</li>
<li><code>shutdown</code>: 关闭Picasso,取消所有已存在的<code>Request</code>;</li>
<li><code>enqueueAnsSubmite(Action)</code> : 将图片下载动作<code>ImageViewAction</code>保存到一个Map，并发送给<code>Dispatcher</code>处理；</li>
</ul>
<h3 id="ImageViewAction-java"><a href="#ImageViewAction-java" class="headerlink" title="ImageViewAction.java "></a><strong><code>ImageViewAction.java</code> </strong></h3><p>每一个图片下载请求都封装成一个<code>ImageViewAction</code>,当图片下载完成后，有错误，则调用<code>error(Exception)</code>接口，若用户设置了错误时对应的图片，则直接显示该图片；没有错误，则调用<code>complete(Bitmap, LoadedFrom)</code>，将下载完成的<code>Bitmap</code>显示出来。</p>
<ul>
<li><code>complete(Bitmap,LoadedFrom)</code>: 图片加载完成</li>
</ul>
<h3 id="Dispatcher-java"><a href="#Dispatcher-java" class="headerlink" title="Dispatcher.java "></a><strong><code>Dispatcher.java</code> </strong></h3><p>接收来自<code>Picasso.java</code>的请求动作，产生一个<code>BitmapHunter</code>可执行对象用于下载图片；<code>Dispatcher</code>并不是在一个请求完成之后就发送给<code>Picasso</code>，而是采用批处理的方式，等到完成的动作达到4个时，才一起发送出去。同时，有错误发生网络错误时，需要重新尝试下载；网络状态变化（网络切换）时，<code>Dispatcher</code>会调整线程池中线程的个数，并且重新提交失败的下载请求。</p>
<ul>
<li><code>performSubmit(Action)</code>: 将请求动作提交到线程执行服务<code>PicassoExecutorService</code>；</li>
<li><code>performRetry(BitmapHunter)</code>: 重新执行<code>BitmapHunter</code>对象；</li>
</ul>
<h3 id="BitmapHunter-java"><a href="#BitmapHunter-java" class="headerlink" title="BitmapHunter.java"></a><strong><code>BitmapHunter.java</code></strong></h3><p>用于加载图片的可执行对象，其首先尝试从缓存中读取图片，如果没有则从外部存储或者网络中进行加载。加载完成后，解码生成一个<code>Bitmap</code>返回给<code>Dispatcher</code>。</p>
<ul>
<li><code>hunt()</code> : 加载图片，优先从cache中读取，若没有，则从网络端下载；完成后，返回一个Bitmap对象；</li>
<li><code>getResult()</code>: 返回加载的图片Bitmap;</li>
</ul>
<h3 id="PicassoExecutorService-java"><a href="#PicassoExecutorService-java" class="headerlink" title=" PicassoExecutorService.java"></a><strong> <code>PicassoExecutorService.java</code></strong></h3><p>继承自<code>ThreadPoolExecutor</code>,采用优先级阻塞队列<code>PriorityBlockingQueue</code>对执行请求<code>BitmapHunter</code>进行优先级排序，优先级高的始终位于队列的前端。另外，根据当前网络的状态来调整线程池的线程数目： 如果是WIFI连接，则线程数设置为4；4G网络下的线程数设置为3；而3G的线程数只有2个。</p>
<ul>
<li><code>submit(Runnable)</code> : 将可执行对象加入到线程池中，并返回一个<code>FutureTask&lt;?&gt;</code>对象；</li>
<li><code>adjustThreadCount(NetworkInfo）</code> ： 根据网络状态调整线程池线程数；</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Open Source </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Picasso, </tag>
            
            <tag> ImageLoader </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP/IP网络协议入门]]></title>
      <url>http://sniffer.site/2017/03/07/TCP-IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>互联网是由一个个电脑节点组成的网络，那么两个节点之间是如何进行数据通信的了？先来看一看一个最简单的通信模型：发送者通过一个媒介想一个接收者发送消息，同时接收者也可以向发送者发送消息。</p>
<a id="more"></a>
<img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/CommunicationModel.png" class="[full image]" title="Communication mode">
<p>这种通信模型与平时生活中的日常会话很是相似。A想与B交流，首先A与B要讲同样的方言，如果一个人讲湖南方言，而一个人讲粤语，则沟通无法进行, 除非请一个懂两种方言的翻译或者沟通双发统一使用某一种语言。抽象的来看，通信一般涉及到如下几个要素：</p>
<ul>
<li>两个需要通信的节点（地址）；</li>
<li>通信的数据交换协议（协议）;</li>
<li>节点之间的物理连接（媒介）；</li>
</ul>
<p>缺乏任何其中一个要素通信都不会发生。比如，身在天津的小明A要给远在北京的小芳B发送一封信，这虽然是最常见的通信方式，也要具备通信的三个要素才能顺利进行：小明与小芳就是两个通信节点，小明需要知道小芳的地址才能向她写信，而小芳如果要回信，也需要知道小明的地址；语言文字就是通信得以进行的信息交换协议了，国家的邮政系统与信纸就是通信的媒介。</p>
<p>同样，对于互联网中的任何两个节点，想要进行通信的话，也需要满足这三个要素。互联网的物理媒介可能是普通的网线，可能是电话线，也可能是光纤。在这篇文章里，我们重点关注通信中节点的寻址与数据交换协议TCP/IP协议族。首先，就来看一看，两个节点之间的通信模式有哪些？</p>
<h2 id="通信模式"><a href="#通信模式" class="headerlink" title="通信模式"></a>通信模式</h2><p>这里所谓的通信模式是指节点通信的通道是怎样的。对于网络中节点之间的通信通道，通常有三种模式，分别是单工(simplex),半双工(half duplex)以及全双工(duplex)。这三种通道之间的区别在于节点之间数据传输的方向与时间：</p>
<ul>
<li>单工： 只存在单向通道，始终只能再一个方向上发送数据，常见的比如电视、音频广播电台；</li>
<li>半双工： 同时存在两个通道，每个通道都可以进行数据传输，但不能同时进行通信；</li>
<li>全双工： 同时存在两个通道，并且两个通道可同时交换数据，最常见的就是电话系统。</li>
</ul>
<p>对于互联网中的通信一般都是全双工的，即可在上行与下行通道同时传输数据。接下来就来看一看，互联网之间的节点是如何进行寻址的，即节点A如何知道节点B的地址？</p>
<h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a><strong>寻址</strong></h2><p>网络中的一个节点可以由两个地址来唯一的标识： 一个是网络接口卡（网卡）的物理地址(也叫<a href="https://en.wikipedia.org/wiki/MAC_address" target="_blank" rel="noopener">MAC地址</a>)，一个是IP地址。网卡的物理地址通常是由网卡制造商确定的，而IP地址则是IP(Internet Protocol)协议对应的一个地址，是由一个叫做IANA(Internet Assigned Numbers Authority)的机构管理的。对于IPv4来说，IP地址的长度是32位（4个字节），而IPv6的地址则达到了128位（16个字节）。</p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a><strong>IP地址</strong></h3><p>在互联网协议发展早期，一般将IP地址划分为两个部分：网络号和主机号。同时，为了区分不同用途的IP地址，IP地址的前3位用来区分IP地址的类，共有五类IP地址：</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ipclasses.png" alt="IP地址的分类"></p>
<p>由上，A类地址范围为：128.0.0.0 ~ 191.255.255.255；B类地址范围为: 128.0.0.0 ~ 191.255.255.255;C类地址范围为: 192.0.0.0 ~ 223.255.255.255。以此类推。</p>
<p>如果按照接收端主机来看，可以将IP地址分为三类：单播地址（接收者为单个主机）、广播地址（接收端为给定网络上的所有主机）以及多播地址（接收端为同一组内的所有主机）。如果根据IP地址的用途划分, 有可以分成公有地址与私有地址, 私有地址一般用于局域网的通信, 常见的私有地址范围如下表所示(具体可以参考<a href="https://tools.ietf.org/html/rfc1918" target="_blank" rel="noopener">RFC1918</a>):</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/private-ip-addr.png" alt="私有IP地址"></p>
<p>对于IPv4主机，由于存在网络号与主机号，因而在寻址与路由时需要作出区分，这就需要用到子网掩码了（subnet mask):通过子网掩码，给定一个IP地址，就可以知道该IP地址的子网号以及主机号了。譬如，在配置网络环境时，就常常会用到子网掩码：</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/ip_addr_subnetting.png" alt="Subnet mask"></p>
<p>举个例子，来看一看子网掩码是如何工作的。我们有一个IP地址： <code>192.168.5.130</code>，同时，我们知道子网掩码为<code>255.255.255.0</code>，转换成对应的二进制：</p>
<table>
<thead>
<tr>
<th></th>
<th>二进制</th>
<th>十进制 </th>
</tr>
</thead>
<tbody>
<tr>
<td>IP地址</td>
<td><code>11000000.10101000.00000101.10000010</code></td>
<td><code>192.168.5.130</code> </td>
</tr>
<tr>
<td>子网掩码</td>
<td><code>11111111.11111111.11111111.00000000</code></td>
<td><code>255.255.255.0</code></td>
</tr>
<tr>
<td>子网号</td>
<td><code>11000000.10101000.00000101.00000000</code></td>
<td><code>192.168.5.0</code></td>
</tr>
<tr>
<td>主机号</td>
<td><code>00000000.00000000.00000000.10000010</code></td>
<td><code>0.0.0.130</code></td>
</tr>
</tbody>
</table>
<p>就是说，子网号是IP地址二进制与子网掩码二进制位与的结果，而主机号则是IP地址与子网掩码取反后位与的结果。这样就可以通过子网掩码来对子网内的主机进行寻址了。</p>
<p>在上面讲到了网络节点有物理地址与IP地址，那么，是否可能通过节点的物理地址知道它的IP地址了，或者反过来通过IP地址知道它的物理地址？答案是可以的。在TCP/IP协议族中有一个地址解析协议ARP（Address Resolution Protocol)就是用于将IP地址转化成物理地址的，而逆地址解析协议RARP（Reverse Address Resolution Protocol)则是用于将物理地址转化为IP地址。</p>
<blockquote>
<p>如今，RARP协议已经被更为灵活易用的DHCP(Dynamic Host Configuration Protocol)协议替代。对于内网或者区域性的网络，DHCP通过管理IP地址池来实现动态的分配IP地址，每当有节点接入网络时，DHCP就会为其动态的分配一个IP地址。 </p>
<p>关于DHCP可参考: <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol</a></p>
</blockquote>
<h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a><strong>域名系统</strong></h3><p>如果单纯依靠IP地址来识别网络上的节点的话，对于用户上网来说是很麻烦的事情。访问WEB服务器时，用户需要记忆一大堆IP地址，这无疑是件痛苦的事情。因此，人们想到用域名(Domain Name)来查找网络上的节点，比如，要使用Google搜索，只需要在浏览器中输入<code>www.google.com</code>而不是一串IP地址就可以了。但是实际的网络访问还是需要通过IP地址，这就需要将域名转化成相应的IP地址。这就是域名系统(DNS, Domain Name System)需要做的事情。</p>
<p>可以把域名系统看做是一个层次化的分布式数据库，通过域名服务器可以查看到对应域名的IP地址。域名有根域名、顶级域名以及二级域名之分,根域名下面分了很多顶级域名，而顶级域名下面则又分成很多二级域名，这样就组成了一个层级的结构：</p>
<p><img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/Domain-Name-Structure.png" alt="Domain Name"></p>
<p>比如网络地址<code>www.google.com</code>中</p>
<ul>
<li><code>.com</code>就是一个顶级域名；</li>
<li><code>.google</code>是一个二级域名；</li>
<li><code>www</code>则表示访问的是一个WEB服务器；</li>
</ul>
<p>那么，在通过域名访问网络时，发送节点究竟是如何通过DNS来查找IP地址的了？这里用一个实际的例子来说明域名解析的过程。比如，现在需要访问<code>www.wikipedia.org</code>这个网站，首先会查找根域名服务器，根域名服务器会返回一个顶级域名服务器<code>.org</code>的IP地址；接着，通过该顶级域名服务器IP地址，继续查询,顶级域名服务器则返回一个二级域名<code>.wikipedia</code>的IP地址,这样根据这个IP地址，就可以顺利访问维基百科这个WEB服务了。</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/iterative_DNS_resolver.png" alt="DNS解析过程"></p>
<blockquote>
<p>还有一个问题，需要访问网络的节点是如何知道根域名服务器的IP地址的？事实上，这些根域名服务器的IP地址是内置在电脑系统中的，这样通过事先预定的“根提示文件”(root hints file)就可以发起域名解析了。目前，在全球，共有13个根域名服务器，可以在<a href="http://www.iana.org/domains/root/servers" title="IANA" target="_blank" rel="noopener"> IANA </a> 官网中查看这些根域名服务器的具体信息。</p>
</blockquote>
<h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a><strong>协议分层</strong></h2><p>TCP/IP协议族是一个不同层次上多个协议的组合，每一个层都负责不一样的通信功能。实际使用的是一个五层的协议族：</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/NetworkProtocolLayer.png" alt="TCP IP 协议族"></p>
<ol>
<li>链路层： 也被称为数据链路层或网络接口层，通常包括操作系统中的设备驱动和计算机中对应的网卡。链路层主要处理与物理接口相关的细节，接受来自网络端的数据或者发送数据到上层；</li>
<li>网络层： 有时也称为互联网层，处理分组在网络中的活动以及主机的寻址与识别，例如分组的选路。网络层协议主要包括了IP协议（网际协议）、ICMP（Internet Control Message Protocol，互联网控制报文协议)以及IGMP(Internet Group Management Protocol,Internet组管理协议）。</li>
<li>运输层： 为两台主机上的应用程序提供端到端的通信，有两个不相同的传输协议：TCP(Transmission Control Protocol)和UDP(User Datagram Protocol)。TCP为两台主机提供了高可靠性的数据通信，它所做的工作主要有（1）将应用层传过来的数据分成合适的小块发到网络层，确认接收到分组后，设置发送最后确认分组的超时时钟等；UDP则简单的多，它只是把数据报(Datagram)的分组发给另外一台主机，但不能确保数据报能到达另一端。</li>
<li>应用层处理特定应用程序细节。一般会提供如下几种应用程序:<ul>
<li>Telnet 远程登录；</li>
<li>FTP 文件传输协议；</li>
<li>SMTP 简单邮件传送协议；</li>
<li>SNMP 简单网络管理系统</li>
</ul>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Internet_protocol_suite" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Internet_protocol_suite</a></li>
<li><a href="http://www.ipprimer.com/#/overview" target="_blank" rel="noopener">http://www.ipprimer.com/#/overview</a></li>
<li><a href="http://www.eventhelix.com/RealtimeMantra/Networking/tcp/" target="_blank" rel="noopener">http://www.eventhelix.com/RealtimeMantra/Networking/tcp/</a><br><a href="http://cn.linux.vbird.org/linux_server/0110network_basic.php" target="_blank" rel="noopener">http://cn.linux.vbird.org/linux_server/0110network_basic.php</a> </li>
</ul>
]]></content>
      
        <categories>
            
            <category> 网络协议 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DNS </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于Maven]]></title>
      <url>http://sniffer.site/2017/03/06/Maven%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="什么是Maven"><a href="#什么是Maven" class="headerlink" title="什么是Maven"></a>什么是Maven</h2><p>Maven是一个自动化构建工具，最开始只适用于Java项目，后来逐渐支持C#,Ruby等项目的构建。Maven使用XML格式文件来描述一个项目的依赖，被称为Project Object Model(POM)。一个pom.xml描述了一个项目所有的配置，包括项目信息，项目所依赖的包等等。</p>
<p>Maven可以从一个或者多个代码仓库里（Maven 2 Central Repository)动态下载Java库文件以及插件,并将其保存到本地的仓库里（缓存），从而实现依赖的更新。</p>
<a id="more"></a>
<blockquote>
<p>自动构建：<a href="https://en.wikipedia.org/wiki/Build_automation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Build_automation</a> 　</p>
</blockquote>
<p>通常，一个Maven项目的代码结构如下：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Maven_CoC.svg/220px-Maven_CoC.svg.png" alt="Maven项目代码结构 "></p>
<p>接下里主要介绍下Maven项目构建工具两个关键的概念:编译的生命周期与POM。</p>
<h2 id="编译周期"><a href="#编译周期" class="headerlink" title="编译周期"></a>编译周期</h2><p>Maven提供了３种内置的编译周期：default(默认），clean(清除),site(位置)。默认周期用于项目的部署，clean周期则用于项目的清除工作，site周期主要处理项目相关的文档。</p>
<p>这里简要的列出default周期所包括的各个阶段以及具体作用：</p>
<table>
<thead>
<tr>
<th>阶段　</th>
<th>　任务　</th>
<th>maven命令　</th>
</tr>
</thead>
<tbody>
<tr>
<td>validate</td>
<td>　验证项目配置是否正确以及必要的信息是否可用　</td>
<td>–</td>
</tr>
<tr>
<td>generate-sources</td>
<td>产生用于编译的源代码　</td>
<td>–</td>
</tr>
<tr>
<td>compile</td>
<td>编译项目源代码　</td>
<td>–</td>
</tr>
<tr>
<td>test</td>
<td>用合适的测试框架测试代码,不应该需要代码打包或者部署</td>
<td>–</td>
</tr>
<tr>
<td>package</td>
<td>以可分发的格式打包编译好的代码，比如JAR</td>
<td>–</td>
</tr>
<tr>
<td>verify</td>
<td>确认集合测试结果以确保质量达标　</td>
<td>–</td>
</tr>
<tr>
<td>install</td>
<td>安装包到本地库，用于其他项目的依赖</td>
<td>　mvn install　</td>
</tr>
<tr>
<td>deploy</td>
<td>部署，将软件包拷贝到远程仓库，分享给其他开发者</td>
<td>–</td>
</tr>
</tbody>
</table>
<p>关于项目编译各个生命周期更详细的文档，请参考:</p>
<blockquote>
<p> Maven编译周期: <a href="https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference" target="_blank" rel="noopener">https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference</a></p>
</blockquote>
<h2 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h2><p>什么是POM? POM,英文全称为Project Object Model,即项目对象模型，是Maven中最基本的组成部分（每个Maven项目都必须的一个文件)。POM是一个XML的文档，里边包含了Maven编译所需的项目信息及其配置。创建时，POM里边就包含了对大多数项目适用的默认值，比如编译目录’target’；源码目录’src/main/java’；测试代码目录,’src/test/java’。</p>
<p>POM文件主要包含了以下几个方面的信息:</p>
<ul>
<li>项目依赖；</li>
<li>开发者与贡献者列表；</li>
<li>插件列表；</li>
<li>插件配置;</li>
<li>资源列表</li>
</ul>
<p>一个最小的POM配置需要包括以下几项：</p>
<ul>
<li>项目根目录‘<project>’标签</project></li>
<li>modelVersion，应该被设为4.0.0</li>
<li>groudId,项目所在组的ID</li>
<li>artifactId,项目ID</li>
<li>version, 给定的组下项目的版本号</li>
</ul>
<p>例如下面就是一个最小的POM文件：</p>
<pre><code>&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
  &lt;artifactId&gt;my-app&lt;/artifactId&gt;
  &lt;version&gt;1&lt;/version&gt;
&lt;/project&gt;
</code></pre><p>稍微复杂一点，添加一个项目的依赖，如下这样一个pom.xml文件:</p>
<pre><code>&lt;project&gt;
  &lt;!-- model version is always 4.0.0 for Maven 2.x POMs --&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;!-- project coordinates, i.e. a group of values which
       uniquely identify this project --&gt;

  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
  &lt;artifactId&gt;my-app&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;

  &lt;!-- library dependencies --&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;

      &lt;!-- coordinates of the required library --&gt;

      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;

      &lt;!-- this dependency is only used for running and compiling tests --&gt;

      &lt;scope&gt;test&lt;/scope&gt;

    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre><p>更多关于POM的信息请参考官方文档：<a href="https://maven.apache.org/guides/introduction/introduction-to-the-pom.html" target="_blank" rel="noopener">https://maven.apache.org/guides/introduction/introduction-to-the-pom.html</a> </p>
]]></content>
      
        <categories>
            
            <category> 项目构建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
            <tag> 构建工具 </tag>
            
            <tag> 单元测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[追寻真实的自我]]></title>
      <url>http://sniffer.site/2017/02/27/%E8%BF%BD%E5%AF%BB%E7%9C%9F%E5%AE%9E%E7%9A%84%E8%87%AA%E6%88%91/</url>
      <content type="html"><![CDATA[ <blockquote class="blockquote-center"><p>你对生活的理解程度决定了你有多幸福，有多自由</p>
</blockquote>
<p>最近在看Bob Dylan的自传《编年史》，里边说到六十年代美国变革动荡时期，很多人要他做领袖，当个时代的开路人，希望他为社会的进步呐喊歌唱，但是他做不了。他只想要做真实的自己，做一个真正的民谣歌手，一个纯粹的艺术家。他渴求的只是探求真实的自我。由是，想到自己的经历，不免感慨，也就忍不住写下了这些文字，算是自我反省吧。</p>
<a id="more"></a>
<p>多少年前，你就开始思考自己的人生，想要探索自己的道路</p>
<p>可是，多少年过去了</p>
<p>你却依然摇摇晃晃，并没有坚定的意志与方向</p>
<p>你似乎并不懂得自己真正想要的东西，也未能理解人生真正值得追求的价值在哪里</p>
<p>你并没有找到一个自己真正热爱的东西</p>
<p>你大部分的努力都包含了别人的期待与关注</p>
<p>你内心有太多的负担与包袱，以至于你难以做到轻松愉快的投入到自己的探索之中</p>
<p>有时，你似乎理解了，你感觉到自己的进步</p>
<p>可，内心里你却依然被自卑与自傲所纠缠</p>
<p>过往的经历使你缺乏足够的信心，也让你变得有些自我怀疑</p>
<p>更确切的来说，是身边的人与环境让你总是不断的怀疑自己</p>
<p>总会有人抱着疑虑的心态来看待你，而这也让你染上了自我否定的毛病</p>
<p>你不断的自我怀疑，有时得过且过，浪费了很多时间与精力</p>
<p>在另一方面，你却始终在努力，在不断的改变自己</p>
<p>是的，如果没有那些努力</p>
<p>你或许要比现在还有平庸，比现在还要艰难</p>
<p>也是这些努力带来了一些所谓的成绩，而这点成绩竟然让你有了自傲的心态</p>
<p>现在想来，你只是要用自傲来补偿下内心的自卑</p>
<p>这或许是每个人内心的真实写照</p>
<p>在自卑的一面往往是自傲，而在自傲的一面也能看到自卑</p>
<p>现实生活的残酷与冷漠，不得不让我面对现实</p>
<p>让我放下内心所有可能的虚幻，坦然的面对一个真实的自己</p>
<p>那么，究竟什么才是一个真实的我</p>
<p>到底我该追寻一个怎样真实的自己</p>
<p>不要期待做他人的导师</p>
<p>不要好为人师，不要做任何人的王</p>
<p>不要想着努力赚取功名利禄，不要想攫取权力</p>
<p>努力找到自己喜欢、乐意做的事情吧</p>
<p>找到一件愿意一辈子付出的事情</p>
<p>找到自己的真爱，爱的人、爱的事、爱的物</p>
<p>然后坚持不懈，脚踏实地，一点一滴的去积累，去探寻</p>
<p>放下内心的自傲，也要放下自卑</p>
<p>你就是你，那个真实的存在，那个独一无二的存在</p>
<p>这一生，你要竭力做到把生命的光发的更亮一点，把生命的热散发的更温暖一些</p>
<p>这一生，你要矢志不渝的追寻一个真实的自我</p>
]]></content>
      
        <categories>
            
            <category> 思考 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Bob dylan </tag>
            
            <tag> 追寻自我 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《Effective Java》摘记]]></title>
      <url>http://sniffer.site/2017/02/25/%E3%80%8AEffective-Java%E3%80%8B%E6%91%98%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>第一遍看完感觉没有学到什么，又看了一遍，然后自己找了些实例对比着理解了书上的要点，算是对Java编程有了更多的认识。以下是 《Effective Java 2nd edition》的摘记。</p>
<h2 id="Consider-static-factory-methods-instead-of-constructors"><a href="#Consider-static-factory-methods-instead-of-constructors" class="headerlink" title="Consider static factory methods instead of constructors"></a><strong>Consider <em>static factory methods</em> instead of constructors</strong></h2><p>相比构造函数，静态工厂方法有哪些优点了？首先，静态工厂方法有自己的名字，这可以增强程序的可读性；其次，静态工厂方法每次调用时，不用创建新的对象实例；第三，静态工厂方法可以返回其返回类型的任何子类型对象。</p>
<a id="more"></a>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boolean</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">                                      <span class="title">Comparable</span>&lt;<span class="title">Boolean</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//根据boolean值返回相应的Boolean对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Consider-a-builder-when-faced-with-many-constructor-parameters"><a href="#Consider-a-builder-when-faced-with-many-constructor-parameters" class="headerlink" title="Consider a builder when faced with many constructor parameters"></a><strong>Consider a </strong>builder<strong> when faced with many constructor parameters</strong></h2><p>当存在多个参数时，静态工厂方法和构造函数都会遇到问题。以往的做法是，使用<em>telescoping constructor</em>,对外提供多个构造函数，每个构造函数有不同个数的参数。例如，Android中的<code>View</code>，共有四个构造函数，第一个构造函数有一个参数，一次类推，第四个构造函数则由四个参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context);</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但如果参数太多，<code>telescoping constructor</code>方法也会变得难以卒读。还有一种方式就是采用<em>JavaBeans</em>，但<em>JavaBeans</em>也有自身的不足:由于构造实例是通过多个接口进行的，一个<em>JavaBean</em>可能使实例处于不一致的状态，另一方面也会一个类处于可变状态(<strong>mutable</strong>)。</p>
<blockquote>
<p>关于什么是JavaBeans: <a href="http://stackoverflow.com/questions/3295496/what-is-a-javabean-exactly" target="_blank" rel="noopener">what-is-a-javabean-exactly</a>；<br><a href="https://en.wikipedia.org/wiki/JavaBeans" target="_blank" rel="noopener">wikipedia：JavaBeans</a></p>
</blockquote>
<p>结合上述两种方法的优点，<em>builder</em>模式很好的解决了上述问题：用户获取到一个<code>builder</code>对象，然后将设定的参数传递给该对象，最后通过<code>buidler</code>对象来产生一个不可变的目标对象。通常，<code>builder</code>对象是被构造类的静态成员类。在Android中，构造<code>AlertDialog</code>时，就用到了这种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertDialog</span> <span class="keyword">extends</span> <span class="title">Dialog</span> <span class="keyword">implements</span> <span class="title">DialogInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> AlertController.AlertParams P;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">boolean</span> mIsDeviceDefaultLight;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> mTheme;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>(context, resolveDialogTheme(context, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Context context, <span class="keyword">int</span> themeResId)</span> </span>&#123;</span><br><span class="line">                P = <span class="keyword">new</span> AlertController.AlertParams(<span class="keyword">new</span> ContextThemeWrapper(</span><br><span class="line">                        context, resolveDialogTheme(context, themeResId)));</span><br><span class="line">    </span><br><span class="line">                mTheme = themeResId;</span><br><span class="line">                ....</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            .....</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Builder <span class="title">setTitle</span><span class="params">(CharSequence title)</span> </span>&#123;</span><br><span class="line">                P.mTitle = title;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Builder <span class="title">setCustomTitle</span><span class="params">(View customTitleView)</span> </span>&#123;</span><br><span class="line">                P.mCustomTitleView = customTitleView;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Builder <span class="title">setMessage</span><span class="params">(CharSequence message)</span> </span>&#123;</span><br><span class="line">                P.mMessage = message;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Builder <span class="title">setIcon</span><span class="params">(@DrawableRes <span class="keyword">int</span> iconId)</span> </span>&#123;</span><br><span class="line">                P.mIconId = iconId;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ....</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Builder <span class="title">setPositiveButton</span><span class="params">(CharSequence text, <span class="keyword">final</span> OnClickListener listener)</span> </span>&#123;</span><br><span class="line">                P.mPositiveButtonText = text;</span><br><span class="line">                P.mPositiveButtonListener = listener;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Builder <span class="title">setNegativeButton</span><span class="params">(@StringRes <span class="keyword">int</span> textId, <span class="keyword">final</span> OnClickListener listener)</span> </span>&#123;</span><br><span class="line">                P.mNegativeButtonText = P.mContext.getText(textId);</span><br><span class="line">                P.mNegativeButtonListener = listener;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Builder <span class="title">setNeutralButton</span><span class="params">(@StringRes <span class="keyword">int</span> textId, <span class="keyword">final</span> OnClickListener listener)</span> </span>&#123;</span><br><span class="line">                P.mNeutralButtonText = P.mContext.getText(textId);</span><br><span class="line">                P.mNeutralButtonListener = listener;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Builder <span class="title">setCancelable</span><span class="params">(<span class="keyword">boolean</span> cancelable)</span> </span>&#123;</span><br><span class="line">                P.mCancelable = cancelable;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Builder <span class="title">setOnCancelListener</span><span class="params">(OnCancelListener onCancelListener)</span> </span>&#123;</span><br><span class="line">                P.mOnCancelListener = onCancelListener;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Builder <span class="title">setItems</span><span class="params">(@ArrayRes <span class="keyword">int</span> itemsId, <span class="keyword">final</span> OnClickListener listener)</span> </span>&#123;</span><br><span class="line">                P.mItems = P.mContext.getResources().getTextArray(itemsId);</span><br><span class="line">                P.mOnClickListener = listener;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Builder <span class="title">setAdapter</span><span class="params">(<span class="keyword">final</span> ListAdapter adapter, <span class="keyword">final</span> OnClickListener listener)</span> </span>&#123;</span><br><span class="line">                P.mAdapter = adapter;</span><br><span class="line">                P.mOnClickListener = listener;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Builder <span class="title">setCursor</span><span class="params">(<span class="keyword">final</span> Cursor cursor, <span class="keyword">final</span> OnClickListener listener,</span></span></span><br><span class="line"><span class="function"><span class="params">                    String labelColumn)</span> </span>&#123;</span><br><span class="line">                P.mCursor = cursor;</span><br><span class="line">                P.mLabelColumn = labelColumn;</span><br><span class="line">                P.mOnClickListener = listener;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            .....</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Builder <span class="title">setView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                P.mView = view;</span><br><span class="line">                P.mViewLayoutResId = <span class="number">0</span>;</span><br><span class="line">                P.mViewSpacingSpecified = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> AlertDialog <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                AlertDialog dialog;</span><br><span class="line">                <span class="keyword">if</span>(mIsDeviceDefaultLight) &#123;</span><br><span class="line">                    dialog = <span class="keyword">new</span> AlertDialog(P.mContext, mTheme , <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dialog = <span class="keyword">new</span> AlertDialog(P.mContext, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                P.apply(dialog.mAlert);</span><br><span class="line">                ....</span><br><span class="line">                <span class="keyword">return</span> dialog;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> AlertDialog <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> AlertDialog dialog = create();</span><br><span class="line">                dialog.show();</span><br><span class="line">                <span class="keyword">return</span> dialog;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总的说来，在所构造的对象有很多参数时，特别地，有些参数时可选的，<em>builder</em>模式是一个非常不错的选择。相比而言，使用<em>builder</em>模式，客户端代码更简洁易读(<em>telescoping constructor</em>)，也更安全（可构造一个不可变的对象,<em>JavaBeans</em>）。</p>
<h2 id="Eliminate-obsolete-object-references"><a href="#Eliminate-obsolete-object-references" class="headerlink" title="Eliminate obsolete object references"></a><strong>Eliminate obsolete object references</strong></h2><p>An obsolete reference is simply a reference that will never be dereferenced again. Memory leaks in garbage-collected languages(known as <em>unintentional object retentions</em>) are insidious. If an object reference is unintentionally retained, not only is that object excluded from garbage collection, but so too are any objects referenced by that object, and so on.</p>
<p>The fix for this sort of problem is simple: null out references once they become obsolete. So, when object references should be nulled?</p>
<ol>
<li><strong>Nulling out object references should be the exception rather than the norm</strong>. The best way to eliminate an obsolete reference is to let the variable that contained the reference fall out of scope. This occurs naturally if you define each variable in the narrowest possible scope.</li>
<li>Generally speaking, <strong>whenever a class manages its own memory, the programmer should be alert for memory leaks</strong>. Whenever an element is freed, any object references contained in the element should be nulled out.</li>
<li><strong>Another commmon source of memory leaks is caches</strong>: once you put an object reference into a cache, it’s easy to forget that it’s there and leave it in the cache long after it becomes irrelevant.</li>
<li><strong>A third common source of memory leaks is listeners and callbacks</strong>: if you implement an API where clients register callbacks but don’t deregister them explicitly, they will accumulate unless you take some action.</li>
</ol>
<h2 id="Obey-the-general-contract-when-overriding-equals"><a href="#Obey-the-general-contract-when-overriding-equals" class="headerlink" title="Obey the general contract when overriding equals"></a><strong>Obey the general contract when overriding <em>equals</em></strong></h2><p>什么时候不需要重载<em>object</em>中的<em>equals</em>方法了？</p>
<ol>
<li>类的每个实例都是唯一的：例如像<em>Thread</em>这种活动实体类；</li>
<li>不用关心类是否提供了“逻辑相等”测试：比如<em>java.util.Random</em>类并不需要重载<em>equals</em>方法来检测两个实例是否相同；</li>
<li>父类已经重载了<em>equals</em>，而且该方法同样适用于这个类时，不用再重载；</li>
<li>类时私有的或者包私有的，并且可以确定<em>equals</em>方法不会被调用，则不用重载。</li>
</ol>
<p>那么，在重载<em>equals</em>方法时，需要遵循那些原则了？</p>
<ol>
<li>反射性(reflexive): 对任何非NULL引用 x, <code>x.equals(x)</code>必须为真；</li>
<li>对称性(symmetric): 对任何非NULL引用 x,y: 当且仅当<code>x.equals(y)</code>返回真时，<code>y.equals(x)</code>才为真；</li>
<li>传递性(transitive): 对任何非NULL引用x,y,z,如果<code>x.equals(y)</code>和<code>y.equals(z)</code>均为真，则<code>x.equals(z)</code>也为真；</li>
<li>一致性(consisitency): 如果两个非NULL引用x,y相等，那么应该一直相等除非有一个被改变了；</li>
<li>空值行(Non-nullity): 对于任何非NULL引用 x，<code>x.equals(NULL)</code>为假；</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String) anObject;</span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Always-override-hashCode-when-you-override-equals"><a href="#Always-override-hashCode-when-you-override-equals" class="headerlink" title="Always override hashCode when you override equals"></a><strong>Always override <em>hashCode</em> when you override <em>equals</em></strong></h2><p>如果重载<em>equals</em>时，不重载<em>hashCode</em>的话，在使用基于hash值的集合类，如<code>HashMap</code>,<code>HashSet</code>,<code>Hashtable</code>时，可能出现异常情况。</p>
<p>那么，如何写好一个<em>hashCode</em>函数了？</p>
<ol>
<li>将一个int型变量 result 初始化为一个非零值，比如17；</li>
<li><p>对于类中不同类型的成员变量，其相应的hash值 c 如下：</p>
<ul>
<li>boolean: c = (f ? 0 : 1)</li>
<li>byte, char,short, or int: c = (int) f</li>
<li>long: c = (int) (f ^( f &gt;&gt;&gt; 32))</li>
<li>float: c = Float.floatToIntBits(f)</li>
<li>double: long l = Double.doubleToLongBits(f);c = (int)(1^(l &gt;&gt;&gt; 32))</li>
<li>Object: c = f.hashCode()</li>
<li>Array: 应用上述规则</li>
<li>将所得hash值计算存入result: result = 31 * result + c;</li>
</ul>
</li>
<li><p>返回结果；并确保两个相等(equals)的对象是否有相同的hash值；</p>
</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileKey</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mDev;    <span class="comment">// ID of device</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mIno;    <span class="comment">// Inode number</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FileKey</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(mDev ^ (mDev &gt;&gt;&gt; <span class="number">32</span>)) +</span><br><span class="line">               (<span class="keyword">int</span>)(mIno ^ (mIno &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> FileKey))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        FileKey other = (FileKey)obj;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.mDev != other.mDev) ||</span><br><span class="line">            (<span class="keyword">this</span>.mIno != other.mIno)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Always-override-toString"><a href="#Always-override-toString" class="headerlink" title="Always override toString"></a><strong>Always override <em>toString</em></strong></h2><p>重载<code>toString()</code>函数可以让类使用起来更方便。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Mode</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mModeId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mHeight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> mRefreshRate;    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(<span class="string">"&#123;"</span>)</span><br><span class="line">                .append(<span class="string">"id="</span>).append(mModeId)</span><br><span class="line">                .append(<span class="string">", width="</span>).append(mWidth)</span><br><span class="line">                .append(<span class="string">", height="</span>).append(mHeight)</span><br><span class="line">                .append(<span class="string">", fps="</span>).append(mRefreshRate)</span><br><span class="line">                .append(<span class="string">"&#125;"</span>)</span><br><span class="line">                .toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Mininmize-mutability"><a href="#Mininmize-mutability" class="headerlink" title="Mininmize mutability"></a><strong>Mininmize mutability</strong></h2><p>一个不可变的类是指其对象不可修改。那么，怎么让一个类不可变了？有以下五个原则：</p>
<ol>
<li>不要提供修改对象状态的任何接口(mutators);</li>
<li>确保类不可扩展(extend)：防止类被子类化的简单办法是将其声明为final;或者将其构造函数都声明为<em>private</em>，紧急只提供一个静态的工厂方法来产生类的对象；</li>
<li>将所有成员变量声明为<em>final</em>；</li>
<li>将所有成员声明为<em>private</em>；</li>
<li>有可变的成员变量时，确保其不可被外部修改；</li>
</ol>
<h2 id="Favor-composition-over-inheritance"><a href="#Favor-composition-over-inheritance" class="headerlink" title="Favor composition over inheritance"></a><strong>Favor composition over inheritance</strong></h2><p>跟方法调用不同的是，继承（不是<em>interface implementation</em>)与封装原则是冲突的。在子类确实一个父类的一个子类型时，继承比较合适。换句话说，类B需要扩展类A，仅当两个类之间存在<em>是一个</em>的关系时。因此，在选择使用继承与组合时，应该问一问：类B是否是一个类A？如果不是，则考虑使用组合。</p>
<p>另外，在考虑使用继承时，还应该考虑下：被继承的类的API是否存在缺陷？如果有的话，使用继承方法则会将API的缺陷带入子类，而使用组合，则可以通过包装(<em>wrapper</em>)的方式隐藏这些缺陷。</p>
<h2 id="Prefer-interfaces-to-abstract-classes"><a href="#Prefer-interfaces-to-abstract-classes" class="headerlink" title="Prefer interfaces to abstract classes"></a><strong>Prefer interfaces to abstract classes</strong></h2><p>It is far easier to evolve an abstract class than an interface(once an interface is released and widely implemented, it is almost impossible to change);</p>
<p>In summary, an interface is generally the best way to define a type that permits multiple implementations. <strong>An exception to this rule is the case where ease of evolution is deemed more important than flexibility and power</strong>.</p>
<h2 id="Favor-static-member-classes-over-nonstatic"><a href="#Favor-static-member-classes-over-nonstatic" class="headerlink" title="Favor static member classes over nonstatic"></a><strong>Favor static member classes over nonstatic</strong></h2><p>If you declare a member class that doesnot require access to an enclosing instance, always put the static modifier in its declaration.</p>
<h2 id="Do-not-use-raw-types-in-new-code"><a href="#Do-not-use-raw-types-in-new-code" class="headerlink" title="Do not use raw types in new code"></a><strong>Do not use raw types in new code</strong></h2><p>Using raw types can lead to exceptions at runtime, so don’t use them in new code. </p>
<blockquote>
<p>You must use raw types in class literals: <code>List.class</code>,<code>String[].class</code>,and <code>int.class</code> are all legal,but <code>List&lt;String&gt;.class</code>和<code>List&lt;?&gt;.class</code> are not</p>
</blockquote>
<h2 id="Eliminate-unchecked-warnings"><a href="#Eliminate-unchecked-warnings" class="headerlink" title="Eliminate unchecked warnings"></a><strong>Eliminate unchecked warnings</strong></h2><p>每一个unchecked warnings都很重要，它表示了一个运行时可能出现的<code>ClassCastException</code>，尽可能的移除这些警告。如果无法消除这些警告，并且可以十分确定代码是typesafe的话，在尽可能小的范围内使用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>注解将这些警告移除，并作出相应的comment。</p>
<h2 id="User-bouned-wildcards-to-increase-API-flexibility"><a href="#User-bouned-wildcards-to-increase-API-flexibility" class="headerlink" title="User bouned wildcards to increase API flexibility"></a><strong>User bouned wildcards to increase API flexibility</strong></h2><p>参数化的类型(parameterized types)是不可变的，换句话说，对于任何两个不同的类型Type1,Type2,<code>List&lt;Type1&gt;</code>跟<code>List&lt;Type2&gt;</code>是不同的：<code>List&lt;Type1&gt;</code>既非<code>List&lt;Type2&gt;</code>的子类型，也非其父类型。</p>
<p>为了提升API的弹性，使用通用匹配符类型(wildcard types)作为表示生产者(producers)或者消费者(consumers)的输入参数。如果一个输入参数既是生产者又是消费者，通用匹配符类型并无多大帮助.</p>
<blockquote>
<p>记住: Producer-extends, Consumer-super(PECS); all comparables and comparators are consumers</p>
</blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Producer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; dst)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty())</span><br><span class="line">        dst.add(pop());    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Use-Enums-instead-of-int-constants"><a href="#Use-Enums-instead-of-int-constants" class="headerlink" title="Use Enums instead of int constants "></a><strong>Use Enums instead of int constants </strong></h2><p>什么时候需要使用enum? 在需要固定数目的常量集合时都可以使用。</p>
<p>如果写一个可扩展的enum类型存在困难时，可以声明一个接口然后实现该接口，从而实现可扩展性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BasicOperations</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> BasicOperations implements Operation&#123;</span><br><span class="line">    </span><br><span class="line">    ADD(<span class="string">"+"</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(<span class="string">"-"</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x - y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MULTIPLY(<span class="string">"*"</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x * y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(<span class="string">"/"</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(Double.compare(y, <span class="number">0.0</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> Double.NaN;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> x/y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mOpCode;</span><br><span class="line">    </span><br><span class="line">    BasicOperations(String op)&#123;</span><br><span class="line">        mOpCode = op;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mOpCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ExtendOperations</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExtendOperations implements Operation&#123;</span><br><span class="line"></span><br><span class="line">    POWER(<span class="string">"^"</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.pow(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MOD(<span class="string">"%"</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x % y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mOpCode;</span><br><span class="line">    </span><br><span class="line">    ExtendOperations(String op)&#123;</span><br><span class="line">        mOpCode = op;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mOpCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Prefer-annotations-to-naming-patterns"><a href="#Prefer-annotations-to-naming-patterns" class="headerlink" title="Prefer annotations to naming patterns"></a><strong>Prefer annotations to naming patterns</strong></h2><p>在Java 1.5发布之前，一些工具或者框架采用<em>命名模式</em>对某些程序做特殊的处理，例如JUnit测试框架最开始要求使用者将每个测试方法以<em>test</em>开头。这种方法存在的不足是，万一使用者拼写有误，测试就无法通过；另外一个不足是，对于方法以外的程序部分如类，同样无法进行测试。同时，<em>命名模式</em>无法将参数值与程序元素无法关联，例如假如你想要设计一个测试集合，检查一个方法是否抛出特定的异常，这时本质上来说，异常类型是测试的一个参数。</p>
<p>上述问题都可以使用annotations(注解）来得到解决。这里，我们来定义一个注解类型用于设计用于自动运行并且在抛出异常时失败的测试（使用时只需在方法前面加上:<code>@Test</code>即可）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.METHOD;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Android的源码中，也可以看到很多注解用于对方法或者类做特殊的处理，例如<code>@TargetApi()</code>用于指定某个方法或者构造函数的API级别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Indicates that Lint should treat this type as targeting a given API level, no matter what the</span></span><br><span class="line"><span class="comment">    project target is. */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;TYPE, METHOD, CONSTRUCTOR&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TargetApi &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This sets the target api level for the type..</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考源码: /android/frameworks/base/core/java/android/annotation/</p>
</blockquote>
<h2 id="Design-Method-signatures-carefully"><a href="#Design-Method-signatures-carefully" class="headerlink" title="Design Method signatures carefully"></a><strong>Design Method signatures carefully</strong></h2><p>怎么使得设计的API更容易被理解，更方便的被使用而不易产生错误了？</p>
<ol>
<li>谨慎的命名方法：命名始终遵循标准的命名约定，首要的目标应该是确保命名是可被理解，并且与包内其他命名保持一致；</li>
<li>不要提供太多的方法： 方法太多容易使类变得难以学习，使用，编写文档，测试跟维护，这个对于interface来说尤其如此。因此，当存疑时，应该直接忽略；</li>
<li>避免过长的参数列表：保持四个或者更少的参数。怎么减少参数？有三个办法：一个是将该方法分解为几个不同的方法，每个方法只包含一部分参数；第三个方法是使用<em>Builder模式</em>；</li>
<li>对于参数类型来说，使用interface而不是classes；</li>
<li>尽量使用两个元素的enum类型而非boolean参数，让程序变得更具可读性；</li>
</ol>
<h2 id="Use-overloading-judiciously"><a href="#Use-overloading-judiciously" class="headerlink" title="Use overloading judiciously"></a><strong>Use overloading judiciously</strong></h2><p>overloaded(重载）方法是静态的，其在编译时就确定了如何调用，而overriden(覆盖）方法是动态的，具体如何调用是在运行时确定的。</p>
<h2 id="Return-emtpy-arrays-or-collections-not-nulls"><a href="#Return-emtpy-arrays-or-collections-not-nulls" class="headerlink" title="Return emtpy arrays or collections, not nulls"></a><strong>Return emtpy arrays or collections, not nulls</strong></h2><p>需要返回一个数组或者集合类值时，如果是空，不要返回null，而是返回一个空数组或者空集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// emtpy array</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Cheese&gt; allCheeses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cheese[] EMPTY_ARRAY_CHEESE = <span class="keyword">new</span> Cheese[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Cheese[] getCheeses()&#123;</span><br><span class="line">    <span class="keyword">return</span> allCheeses.toArray(EMPTY_ARRAY_CHEESE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// collections</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Cheese&gt; allCheeses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Cheese&gt; <span class="title">getCheeseList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(allCheeses.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> allCheeses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Write-doc-comments-for-all-exposed-API-elements"><a href="#Write-doc-comments-for-all-exposed-API-elements" class="headerlink" title="Write doc comments for all exposed API elements"></a><strong>Write doc comments for all exposed API elements</strong></h2><p>合适的描述API，需要将每个输出的类、接口、构造函数、方法以及成员变量写评述。同时，为了代码的可维护性，对于不输出的类、接口、构造函数、方法以及成员变量也应做出适当的说明。</p>
<h2 id="Minimize-the-scope-of-local-variables"><a href="#Minimize-the-scope-of-local-variables" class="headerlink" title="Minimize the scope of local variables"></a><strong>Minimize the scope of local variables</strong></h2><p>一个减少局部变量作用域的方法是在它第一次使用时才声明。另外一个办法是尽量让方法的变小，并且每个方法只做一件事。</p>
<h2 id="Refer-to-objects-by-their-interfaces"><a href="#Refer-to-objects-by-their-interfaces" class="headerlink" title="Refer to objects by their interfaces"></a><strong>Refer to objects by their interfaces</strong></h2><p>如果存在合适的接口类型，那么参数，返回值，变量以及成员变量都应该声明为接口类型。</p>
<h2 id="Optimize-judiciously"><a href="#Optimize-judiciously" class="headerlink" title="Optimize judiciously"></a><strong>Optimize judiciously</strong></h2><p>如果过早的进行优化，很可能带来更多的危害而不是好处。不要牺牲合理的架构原则来换取性能：<strong>努力写出好的代码而不是快的代码</strong>。</p>
<blockquote>
<p>M.A.Jackson: we follow two rules in the matter of optimization:</p>
<ul>
<li>Rule 1. Don’t do it;</li>
<li>Rule 2. (for experts only). Don’t do it yet - that is,not until you have a perfectly clear and unoptimized solution.</li>
</ul>
</blockquote>
<h2 id="Use-checked-exceptions-fo-recoverable-conditions-and-runtime-exceptions-for-programming-errors"><a href="#Use-checked-exceptions-fo-recoverable-conditions-and-runtime-exceptions-for-programming-errors" class="headerlink" title="Use checked exceptions fo recoverable conditions and runtime exceptions for programming errors"></a><strong>Use checked exceptions fo recoverable conditions and runtime exceptions for programming errors</strong></h2><p>Java语言提供了三类可抛出对象(throwables):可检查的异常，运行时异常，以及错误。对于客户端需要从异常中恢复的情况，应该使用可检查的异常；而对于编程错误（如客户端调用接口有误）则使用运行时异常。</p>
<h2 id="Synchronize-access-to-shared-mutable-data"><a href="#Synchronize-access-to-shared-mutable-data" class="headerlink" title="Synchronize access to shared mutable data"></a><strong>Synchronize access to shared mutable data</strong></h2><p>适当的实用<em>synchronize</em>,可以确保对象在各个线程中的状态保持一致。在另一方面，同步不仅仅用于互斥访问（任何时候都只有一个线程可以读写），也可用于线程之间的通信。</p>
<p>记住，当有多个线程共享可变数据(mutable data)时，确保每个线程执行读或者写操作时都保持了同步。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Effective Java </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Phone进程启动过程分析]]></title>
      <url>http://sniffer.site/2017/02/21/Android-Phone%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>之前解决一个开机搜网慢的问题时，发现由于Phone进程起来以后才会主动连接RILD,因而在一定程度上Phone进程启动的时间会影响网络状态注册的快慢。适当的将Phone进程提前，可以将网络注册时间提前一点，让状态栏中信号显示的时间提前。那么，Android中作为系统的核心进程之一，Phone进程是如何启动的了？</p>
<a id="more"></a>
<blockquote>
<p>本文参考代码为Android NN7.0, RIL运行机制请参考: <a href="http://sniffer.site/2016/11/19/Android-RIL%E6%A6%82%E8%BF%B0/">Android RIL概述</a></p>
</blockquote>
<p>Telephony最开始创建的是<code>PhoneFactory</code>对象，直接搜索源码，可以看到在<code>PhoneGlobals.java</code>创建时，会调用<code>PhoneFactory</code>对Telephony进行初始化操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Global state for the telephony subsystem when running in the primary</span></span><br><span class="line"><span class="comment"> * phone process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneGlobals</span> <span class="keyword">extends</span> <span class="title">ContextWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.v(LOG_TAG, <span class="string">"!@Boot_SVC : PhoneApp OnCrate"</span>);</span><br><span class="line">        <span class="comment">// CallManager为空</span></span><br><span class="line">        <span class="keyword">if</span> (mCM == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Initialize the telephony framework</span></span><br><span class="line">            PhoneFactory.makeDefaultPhones(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 创建CallManager实例</span></span><br><span class="line">            mCM = CallManager.getInstance();</span><br><span class="line">            <span class="keyword">for</span> (Phone phone : PhoneFactory.getPhones()) &#123;</span><br><span class="line">                mCM.registerPhone(phone);</span><br><span class="line">            &#125;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，<code>PhoneGlobals</code>又是在哪里创建的了？再次搜索代码，可以看到在同一文件目录下，有一个<code>PhoneApp.java</code>文件:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Log.d(<span class="string">"PhoneApp"</span>, <span class="string">"onCreate"</span>);</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span> (UserHandle.myUserId() == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 创建PhoneGlobals实例</span></span><br><span class="line">         mPhoneGlobals = <span class="keyword">new</span> PhoneGlobals(<span class="keyword">this</span>);</span><br><span class="line">         mPhoneGlobals.onCreate();</span><br><span class="line">    </span><br><span class="line">         mTelephonyGlobals = <span class="keyword">new</span> TelephonyGlobals(<span class="keyword">this</span>);</span><br><span class="line">         mTelephonyGlobals.onCreate();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         Log.d(<span class="string">"PhoneApp"</span>, <span class="string">"Phone app is created as userid not 0, there's no PhoneApp() Instance"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     ....</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>那么，<code>PhoneApp</code>这个类又是什么时候创建的？我们知道，每一个Android应用都有一个<code>Application</code>与之对应，它是在应用启动过程中创建的，但是在这里搜索所有的源码，也无法看到<code>PhoneApp</code>创建的地方。联想到应用的启动过程，APP的启动的入口是<code>ActivityThread</code>,那么对于任何<code>PhoneApp</code>这样的系统应用来说，启动的入口也应该是<code>ActivityThread</code>。不妨继续看看代码。</p>
<p>打开Phone进程所在的源码路径: <code>/android/applications/sources/services/Telephony/</code>,查看应用对应的<code>AndroidManefest.xml</code>文件:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:androidprv</span>=<span class="string">"http://schemas.android.com/apk/prv/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">package</span>=<span class="string">"com.android.phone"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:versionCode</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:versionName</span>=<span class="string">"1.0.0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">coreApp</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:sharedUserId</span>=<span class="string">"android.uid.phone"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:sharedUserLabel</span>=<span class="string">"@string/phoneAppLabel"</span> &gt;</span></span><br><span class="line">        .....</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:name</span>=<span class="string">"PhoneApp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:persistent</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hardwareAccelerated</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/phoneAppLabel"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher_phone"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:usesCleartextTraffic</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:defaultToDeviceProtectedStorage</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:directBootAware</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        ....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>application</code>标签下面，可以看到<code>android:persistent=&quot;true&quot;</code>这个属性值，看一看官方的文档怎么解释的：</p>
<blockquote>
<p><strong>android:persistent</strong></p>
</blockquote>
<blockquote>
<p>Whether or not the application should remain running at all times — “true” if it should, and “false” if not. The default value is “false”. Applications should not normally set this flag; persistence mode is intended only for certain system applications.</p>
</blockquote>
<p>由此可见，Phone应用是系统常驻进程，一旦起来后就会一直运行，不会被杀死（除非Phone进程自己发生了的运行时错误而崩溃）。对于这类常驻进程，<code>ActivityManagerService</code>(以下简称AMS)会在初始化完成后，主动启动。在<code>SystemServer</code>初始化完系统的核心服务后，会调用AMS的<code>systemReady(Runnable r)</code>函数。</p>
<h2 id="ActivityManagerService-java"><a href="#ActivityManagerService-java" class="headerlink" title="ActivityManagerService.java"></a><strong>ActivityManagerService.java</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">(<span class="keyword">final</span> Runnable goingCallback)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    </span><br><span class="line">             <span class="comment">// Only start up encryption-aware persistent apps; once user is</span></span><br><span class="line">            <span class="comment">// unlocked we'll come back around and start unaware apps</span></span><br><span class="line">            <span class="comment">// 正是在这里，phone进程被创建</span></span><br><span class="line">            startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Start up initial activity.</span></span><br><span class="line">            mBooting = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// Enable home activity for system user, so that the system can always boot</span></span><br><span class="line">            <span class="keyword">if</span> (UserManager.isSplitSystemUser()) &#123;</span><br><span class="line">                ComponentName cName = <span class="keyword">new</span> ComponentName(mContext, SystemUserHomeActivity.class);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    AppGlobals.getPackageManager().setComponentEnabledSetting(cName,</span><br><span class="line">                            PackageManager.COMPONENT_ENABLED_STATE_ENABLED, <span class="number">0</span>,</span><br><span class="line">                            UserHandle.USER_SYSTEM);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.rethrowAsRuntimeException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            startHomeActivityLocked(currentUserId, <span class="string">"systemReady"</span>);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动所有<code>PackageManager.MATCH_DIRECT_BOOT_AWARE</code>标志为<code>true</code>的应用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startPersistentApps</span><span class="params">(<span class="keyword">int</span> matchFlags)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取系统所有常驻应用程序信息</span></span><br><span class="line">            <span class="keyword">final</span> List&lt;ApplicationInfo&gt; apps = AppGlobals.getPackageManager()</span><br><span class="line">                    .getPersistentApplications(STOCK_PM_FLAGS | matchFlags).getList();</span><br><span class="line">            <span class="keyword">for</span> (ApplicationInfo app : apps) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">"android"</span>.equals(app.packageName)) &#123;</span><br><span class="line">                    <span class="comment">//加载应用</span></span><br><span class="line">                    addAppLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span> <span class="comment">/* ABI override */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加应用程序进程到LRU列表中，并创建进程</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">addAppLocked</span><span class="params">(ApplicationInfo info, <span class="keyword">boolean</span> isolated,</span></span></span><br><span class="line"><span class="function"><span class="params">        String abiOverride)</span> </span>&#123;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        app = getProcessRecordLocked(info.processName, info.uid, <span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有进程记录，因此创建一个进程记录</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">        app = newProcessRecordLocked(info, <span class="keyword">null</span>, isolated, <span class="number">0</span>);</span><br><span class="line">        updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123;</span><br><span class="line">        app.persistent = <span class="keyword">true</span>;</span><br><span class="line">        app.maxAdj = ProcessList.PERSISTENT_PROC_ADJ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Start the process.  It will either succeed and return a result containing</span></span><br><span class="line">    <span class="comment">// the PID of the new process, or else throw a RuntimeException.</span></span><br><span class="line">    <span class="keyword">boolean</span> isActivityProcess = (entryPoint == <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 进程入口为ActivityThread</span></span><br><span class="line">    <span class="keyword">if</span> (entryPoint == <span class="keyword">null</span>) entryPoint = <span class="string">"android.app.ActivityThread"</span>;        </span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动应用进程</span></span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span> &amp;&amp; mPersistentStartingProcesses.indexOf(app) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        mPersistentStartingProcesses.add(app);</span><br><span class="line">        startProcessLocked(app, <span class="string">"added application"</span>, app.processName, abiOverride,</span><br><span class="line">                <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>, <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准备创建应用进程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Process.ProcessStartResult startResult = <span class="keyword">null</span>;</span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">        startResult = Process.start(entryPoint,</span><br><span class="line">        app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">        app.info.targetSdkVersion, aasaSeInfo != <span class="keyword">null</span> ? <span class="keyword">new</span> String(aasaSeInfo) : app.info.seinfo, <span class="comment">//AASA--4 : changed orginal : only "app.info.seinfo"</span></span><br><span class="line">        app.info.category, app.info.accessInfo,</span><br><span class="line">        requiredAbi, instructionSet,</span><br><span class="line">        app.info.dataDir, mountKnoxPoint, entryPointArgs);</span><br><span class="line"></span><br><span class="line">        ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Process-java"><a href="#Process-java" class="headerlink" title="Process.java"></a><strong>Process.java</strong></h2><p>调用<code>Process.start()</code>，创建一个新的进程, Telephony服务以及RIL相关代码都运行在此进程中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> category,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> accessInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> mountKnoxPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                debugFlags, mountExternal, targetSdkVersion, seInfo, category, accessInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, mountKnoxPoint, zygoteArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">        Log.e(LOG_TAG,</span><br><span class="line">                <span class="string">"Starting VM process through Zygote failed"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Starting VM process through Zygote failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送消息到zygote服务进程的socket端口，请求创建新的进程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> category,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> accessInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> mountKnoxPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                                 <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(Process.class) &#123;</span><br><span class="line">           ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// --runtime-args, --setuid=, --setgid=,</span></span><br><span class="line">           <span class="comment">// and --setgroups= must go first</span></span><br><span class="line">           argsForZygote.add(<span class="string">"--runtime-args"</span>);</span><br><span class="line">           argsForZygote.add(<span class="string">"--setuid="</span> + uid);</span><br><span class="line">           argsForZygote.add(<span class="string">"--setgid="</span> + gid);</span><br><span class="line">           ....</span><br><span class="line">           <span class="keyword">if</span> (appDataDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">               argsForZygote.add(<span class="string">"--app-data-dir="</span> + appDataDir);</span><br><span class="line">           &#125;</span><br><span class="line">           ....</span><br><span class="line">           argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (extraArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (String arg : extraArgs) &#123;</span><br><span class="line">                   argsForZygote.add(arg);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//发送消息到zygote的socket端口，请求创建新的进程</span></span><br><span class="line">           <span class="keyword">if</span> (Zygote.isEnhancedZygoteASLREnabled) &#123;</span><br><span class="line">               ....</span><br><span class="line">               <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">               <span class="comment">// End of isEnhancedZygoteASLREnabled case</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Original case</span></span><br><span class="line">               <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="ZygoteConnection-java"><a href="#ZygoteConnection-java" class="headerlink" title="ZygoteConnection.java"></a><strong>ZygoteConnection.java</strong></h2><p>zygote进程接收到AMS的请求后，由<code>ZygoteConnection</code>负责处理请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    FileDescriptor[] descriptors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从socket中读取参数</span></span><br><span class="line">        args = readArgumentList();</span><br><span class="line">        descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"IOException on command socket "</span> + ex.getMessage());</span><br><span class="line">        closeSocket();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// EOF reached.</span></span><br><span class="line">        closeSocket();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid = -<span class="number">1</span>;</span><br><span class="line">    FileDescriptor childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">    FileDescriptor serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsedArgs = <span class="keyword">new</span> Arguments(args);</span><br><span class="line">        <span class="comment">//Zygote调用本地方法创建进程</span></span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.category, parsedArgs.accessInfo,</span><br><span class="line">                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">                parsedArgs.appDataDir, parsedArgs.mountKnoxPoint);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr, <span class="string">"Exception creating pipe"</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr, <span class="string">"Invalid zygote arguments"</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteSecurityException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr,</span><br><span class="line">                <span class="string">"Zygote security policy prevents request: "</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// in child</span></span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// should never get here, the child is expected to either</span></span><br><span class="line">            <span class="comment">// throw ZygoteInit.MethodAndArgsCaller or exec().</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// in parent...pid of &lt; 0 means failure</span></span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ZygoteInit-java"><a href="#ZygoteInit-java" class="headerlink" title="ZygoteInit.java"></a><strong>ZygoteInit.java</strong></h2><p>至此phone进程已经创建完成了，但实际上PhoneApp的代码还没有加载。继续看，在启动的进程里，调用<code>ZygoteInit.zygoteInit</code>来加载phoneApp的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">            FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * By the time we get here, the native code has closed the two actual Zygote</span></span><br><span class="line"><span class="comment">         * socket connections, and substituted /dev/null in their place.  The LocalSocket</span></span><br><span class="line"><span class="comment">         * objects still need to be closed properly.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        closeSocket();</span><br><span class="line">        <span class="keyword">if</span> (descriptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Os.dup2(descriptors[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">                Os.dup2(descriptors[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">                Os.dup2(descriptors[<span class="number">2</span>], STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (FileDescriptor fd: descriptors) &#123;</span><br><span class="line">                    IoUtils.closeQuietly(fd);</span><br><span class="line">                &#125;</span><br><span class="line">                newStderr = System.err;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"Error reopening stdio"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// End of the postFork event.</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        <span class="comment">// 这里没有指定invokewith参数</span></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">            WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                    parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                    VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                    pipeFd, parsedArgs.remainingArgs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里remaingArgs的第一参数是android.app.ActivityThread, 就是之前的entrypoint</span></span><br><span class="line">            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                    parsedArgs.remainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="RuntimeInit-java"><a href="#RuntimeInit-java" class="headerlink" title="RuntimeInit.java"></a><strong>RuntimeInit.java</strong></h2><p>通过<code>RuntimeInit</code>来加载phone APP的代码, <code>zygoteInit</code>函数主要做三件事：</p>
<ul>
<li>做一些通用的初始化，比如设置虚拟机中线程的exception handler;设置默认时区；</li>
<li>完成VM本地的初始化操作；</li>
<li>加载APP代码，也就是调用<code>ActivityThread.main</code>函数来加载整个phone APP；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"RuntimeInit"</span>);</span><br><span class="line">    redirectLogStreams();</span><br><span class="line"></span><br><span class="line">    commonInit();</span><br><span class="line">    nativeZygoteInit();</span><br><span class="line">    <span class="comment">// 初始化应用代码</span></span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>applicationInit</code>通过方法<code>invokeStaticMain</code>反射调用<code>ActivityThread.main</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">        <span class="comment">// If the application calls System.exit(), terminate the process</span></span><br><span class="line">        <span class="comment">// immediately without running any shutdown hooks.  It is not possible to</span></span><br><span class="line">        <span class="comment">// shutdown an Android application gracefully.  Among other things, the</span></span><br><span class="line">        <span class="comment">// Android runtime shutdown hooks close the Binder driver, which can cause</span></span><br><span class="line">        <span class="comment">// leftover running threads to crash before the process actually exits.</span></span><br><span class="line">        nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We want to be fairly aggressive about heap utilization, to avoid</span></span><br><span class="line">        <span class="comment">// holding on to a lot of memory that isn't needed.</span></span><br><span class="line">        VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75f</span>);</span><br><span class="line">        VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Arguments args;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            Slog.e(TAG, ex.getMessage());</span><br><span class="line">            <span class="comment">// let the process exit</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Remaining arguments are passed to the start class's static main</span></span><br><span class="line">        invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>invokeStaticMain</code>通过抛出一个<code>MethodAndArgsCaller</code>的异常，被<code>ZygoteInit.main</code>方法捕获后，调用<code>MethodAndArgsCaller.run</code>，至此就调用了<code>ActivityThread.main</code>方法了，还真是有点绕。</p>
<p>| 有关zygote进程可以参考<a href="http://sniffer.site/2017/05/27/Zygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">http://sniffer.site/2017/05/27/Zygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Missing class when invoking static main "</span> + className,</span><br><span class="line">                    ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method m;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Missing static main on "</span> + className, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Problem getting static main on "</span> + className, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Main method is not public and static on "</span> + className);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">        * by invoking the exception's run() method. This arrangement</span></span><br><span class="line"><span class="comment">        * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">        * up the process.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Zygote.MethodAndArgsCaller(m, argv);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>MethodAndArgsCaller</code>异常的作用是清除父进程中的一些调用堆栈，这样子进程就从<code>ActivityThread.main</code>开始了自己的堆栈调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** method to call */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** argument array */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">            mMethod = method;</span><br><span class="line">            mArgs = args;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">                Throwable cause = ex.getCause();</span><br><span class="line">                <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ActivityThread-java"><a href="#ActivityThread-java" class="headerlink" title="ActivityThread.java"></a><strong>ActivityThread.java</strong></h2><p>到这里，<code>ActivityThread.main</code>会启动一个主线程，接着创建一个<code>ActivityThread</code>用于Phone APP与AMS进行交互。最重要的是，接着在<code>thread.attach(false);</code>这个函数里，<code>ActivityThread</code>会去创建Phone进程入口类<code>PhoneApp</code>。后续就是Phone整个框架代码的加载与初始化了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the reporter for event logging in libcore</span></span><br><span class="line">    EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line">    <span class="comment">// 启动主线程Looper</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样Phone进程就创建启动完成了。整个流程看下来，研究Android系统，源码是王道，但要深入理解系统背后的设计，还是需要从把基本的概念梳理清楚，才能更好的理解系统背后设计的逻辑。</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Telephony </tag>
            
            <tag> Phone进程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Launcher工作原理]]></title>
      <url>http://sniffer.site/2017/02/18/Android-Launcher%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>Android系统启动完成后，第一个启动的Activity就是主界面应用程序Launcher，相当于电脑的桌面。Launcher界面可以看到系统中安装的所有APP,点击APP即可启动该APP应用了。那么，Launcher到底是如何启动的以及如何自定义自己的Launcher了？这篇文章我们就来讲讲这两个问题。</p>
<a id="more"></a>
<h2 id="Launcher的启动"><a href="#Launcher的启动" class="headerlink" title="Launcher的启动"></a><strong>Launcher的启动</strong></h2><p>系统进程<code>SystemServer</code>启动后，开始加载系统核心服务如 <code>ActivityManagerService</code>,<code>WindowManagerService</code>,<code>PowerManagerService</code>，同时加载系统的其他如<code>VibratorService</code>，<code>ConnectivityService</code>以及<code>TelephonyRegistry</code>等系统服务，最后着手启动HOME activity:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备启动SystemUI以及HOME界面</span></span><br><span class="line">    mActivityManagerService.systemReady(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mSystemServiceManager.startBootPhase(</span><br><span class="line">                    SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mActivityManagerService.startObservingNativeCrashes();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                reportWtf(<span class="string">"observing native crashes"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, <span class="string">"StartSystemUI"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                startSystemUi(context);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                reportWtf(<span class="string">"starting System UI"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// 第三方应用可以启动了</span></span><br><span class="line">            mSystemServiceManager.startBootPhase(</span><br><span class="line">                    SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AMS准备工作完毕，着手启动HOME：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">(<span class="keyword">final</span> Runnable goingCallback)</span> </span>&#123;</span><br><span class="line">       ....</span><br><span class="line">       <span class="comment">//获取系统配置</span></span><br><span class="line">       retrieveSettings();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> currentUserId;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           currentUserId = mUserController.getCurrentUserIdLocked();</span><br><span class="line">           readGrantedUriPermissionsLocked();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 执行回调</span></span><br><span class="line">       <span class="keyword">if</span> (goingCallback != <span class="keyword">null</span>) goingCallback.run();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    </span><br><span class="line">           <span class="comment">// Start up initial activity.</span></span><br><span class="line">           mBooting = <span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">// Enable home activity for system user, so that the system can always boot</span></span><br><span class="line">           <span class="keyword">if</span> (UserManager.isSplitSystemUser()) &#123;</span><br><span class="line">               ComponentName cName = <span class="keyword">new</span> ComponentName(mContext, SystemUserHomeActivity.class);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   AppGlobals.getPackageManager().setComponentEnabledSetting(cName,</span><br><span class="line">                           PackageManager.COMPONENT_ENABLED_STATE_ENABLED, <span class="number">0</span>,</span><br><span class="line">                           UserHandle.USER_SYSTEM);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> e.rethrowAsRuntimeException();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 启动HOME应用</span></span><br><span class="line">           startHomeActivityLocked(currentUserId, <span class="string">"systemReady"</span>);</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动HOME界面:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line">String mTopAction = Intent.ACTION_MAIN;</span><br><span class="line">    </span><br><span class="line"><span class="function">Intent <span class="title">getHomeIntent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">       Intent intent = <span class="keyword">new</span> Intent(mTopAction, mTopData != <span class="keyword">null</span> ? Uri.parse(mTopData) : <span class="keyword">null</span>);</span><br><span class="line">       intent.setComponent(mTopComponent);</span><br><span class="line">       intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);</span><br><span class="line">       <span class="keyword">if</span> (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">           <span class="comment">// intent的类别为HOME</span></span><br><span class="line">           intent.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">          &#125;</span><br><span class="line">       <span class="keyword">return</span> intent;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">startHomeActivityLocked</span><span class="params">(<span class="keyword">int</span> userId, String reason)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">       Intent intent = getHomeIntent();</span><br><span class="line">    </span><br><span class="line">       ActivityInfo aInfo =</span><br><span class="line">           resolveActivityInfo(intent, STOCK_PM_FLAGS | (needToCheckBbc ? PackageManager.GET_META_DATA : <span class="number">0</span>), userId);</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">if</span> (aInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">           intent.setComponent(<span class="keyword">new</span> ComponentName(aInfo.applicationInfo.packageName, aInfo.name));</span><br><span class="line">           <span class="comment">// Don't do this if the home app is currently being</span></span><br><span class="line">           <span class="comment">// instrumented.</span></span><br><span class="line">           aInfo = <span class="keyword">new</span> ActivityInfo(aInfo);</span><br><span class="line">           aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);</span><br><span class="line">           ProcessRecord app = getProcessRecordLocked(aInfo.processName,</span><br><span class="line">                   aInfo.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line">           <span class="keyword">if</span> (app == <span class="keyword">null</span> || app.instrumentationClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">               intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    </span><br><span class="line">               <span class="keyword">if</span> (needToCheckBbc) &#123;</span><br><span class="line">                   aInfo = PersonaManagerService.changeInfoIfBBC(mContext, aInfo, intent);</span><br><span class="line">               &#125;</span><br><span class="line">               mActivityStarter.startHomeActivityLocked(intent, aInfo, reason);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Slog.wtf(TAG, <span class="string">"No home screen found for "</span> + intent, <span class="keyword">new</span> Throwable());</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>向AMS发送启动Activity的Binder请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivityStarter</span> </span>&#123;</span><br><span class="line">   ....</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startHomeActivityLocked</span><span class="params">(Intent intent, ActivityInfo aInfo, String reason)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将HOME activity放在任务栈的顶部</span></span><br><span class="line">        mSupervisor.moveHomeStackTaskToTop(HOME_ACTIVITY_TYPE, reason);</span><br><span class="line">        <span class="comment">//向AMS发送binder请求，启动activity</span></span><br><span class="line">        startActivityLocked(<span class="keyword">null</span> <span class="comment">/*caller*/</span>, intent, <span class="keyword">null</span> <span class="comment">/*ephemeralIntent*/</span>,</span><br><span class="line">                <span class="keyword">null</span> <span class="comment">/*resolvedType*/</span>, aInfo, <span class="keyword">null</span> <span class="comment">/*rInfo*/</span>, <span class="keyword">null</span> <span class="comment">/*voiceSession*/</span>,</span><br><span class="line">                <span class="keyword">null</span> <span class="comment">/*voiceInteractor*/</span>, <span class="keyword">null</span> <span class="comment">/*resultTo*/</span>, <span class="keyword">null</span> <span class="comment">/*resultWho*/</span>,</span><br><span class="line">                <span class="number">0</span> <span class="comment">/*requestCode*/</span>, <span class="number">0</span> <span class="comment">/*callingPid*/</span>, <span class="number">0</span> <span class="comment">/*callingUid*/</span>, <span class="keyword">null</span> <span class="comment">/*callingPackage*/</span>,</span><br><span class="line">                <span class="number">0</span> <span class="comment">/*realCallingPid*/</span>, <span class="number">0</span> <span class="comment">/*realCallingUid*/</span>, <span class="number">0</span> <span class="comment">/*startFlags*/</span>, <span class="keyword">null</span> <span class="comment">/*options*/</span>,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/*ignoreTargetSecurity*/</span>, <span class="keyword">false</span> <span class="comment">/*componentSpecified*/</span>, <span class="keyword">null</span> <span class="comment">/*outActivity*/</span>,</span><br><span class="line">                <span class="keyword">null</span> <span class="comment">/*container*/</span>, <span class="keyword">null</span> <span class="comment">/*inTask*/</span>);</span><br><span class="line">        <span class="keyword">if</span> (mSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">            <span class="comment">// If we are in resume section already, home activity will be initialized, but not</span></span><br><span class="line">            <span class="comment">// resumed (to avoid recursive resume) and will stay that way until something pokes it</span></span><br><span class="line">            <span class="comment">// again. We need to schedule another resume.</span></span><br><span class="line">            mSupervisor.scheduleResumeTopActivities();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此HOME启动完成了。</p>
<h2 id="自定义Launcher"><a href="#自定义Launcher" class="headerlink" title="自定义Launcher"></a><strong>自定义Launcher</strong></h2><p>那么，如何来定义自己的Launcher了？这里，我们写一个简单的Launcher界面，上面列出了系统的应用程序，点击上面的图标即可启动应用。</p>
<p>首先，新建一个Activity: CustomHomeActivity：其中主要包含了一个GridView用于显示APP的图标跟名字，APP数据采用Loader进行异步加载，加载完后，数据跟GridView进行绑定。注意，在<code>AndroidManifest.xml</code>中声明activity，必须加上如下<code>intent-filter</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span><br><span class="line">    &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span><br><span class="line">    &lt;category android:name=<span class="string">"android.intent.category.HOME"</span>/&gt;</span><br><span class="line">    &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样，每次用户点击Home按键时，系统就会弹出对话框让你选择启动哪一个Launcher。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomHomeActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">LoaderManager</span>.<span class="title">LoaderCallbacks</span>&lt;<span class="title">List</span>&lt;<span class="title">AppItem</span>&gt;&gt;,</span></span><br><span class="line"><span class="class">	    <span class="title">AppItemAdapter</span>.<span class="title">ItemClickListener</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"CustomHomeActivity"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APP_LOADER = <span class="number">0x01</span>;</span><br><span class="line">	<span class="comment">//<span class="doctag">FIXME:</span> sometimes the gridview is empty; it seems tha data is lost</span></span><br><span class="line">	<span class="keyword">private</span> GridView mGvAppsList;</span><br><span class="line">	<span class="keyword">private</span> AppItemAdapter mAdapter;</span><br><span class="line">	<span class="keyword">private</span> List&lt;AppItem&gt; mAppList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">	    Log.v(TAG, <span class="string">"onCreate()"</span>);</span><br><span class="line"></span><br><span class="line">	    setContentView(R.layout.activity_custom_home);</span><br><span class="line"></span><br><span class="line">	    mGvAppsList = (GridView)findViewById(R.id.gv_app_list);</span><br><span class="line"></span><br><span class="line">	    mAdapter = <span class="keyword">new</span> AppItemAdapter(<span class="keyword">this</span>);</span><br><span class="line">	    mGvAppsList.setAdapter(mAdapter);</span><br><span class="line">	    mAdapter.setListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	    getSupportLoaderManager().initLoader(APP_LOADER,<span class="keyword">null</span>,CustomHomeActivity.<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">super</span>.onResume();</span><br><span class="line"></span><br><span class="line">	    Log.v(TAG,<span class="string">"onResume()"</span>);</span><br><span class="line"></span><br><span class="line">	    Loader loader = getSupportLoaderManager().getLoader(APP_LOADER);</span><br><span class="line">	    <span class="keyword">if</span>(mAppList == <span class="keyword">null</span> || !loader.isStarted())&#123;</span><br><span class="line">	        loader.startLoading();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Loader&lt;List&lt;AppItem&gt;&gt; onCreateLoader(<span class="keyword">int</span> id, Bundle args) &#123;</span><br><span class="line">	    Log.v(TAG,<span class="string">"onCreateLoader()"</span>);</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">new</span> AppLoader(getApplicationContext());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadFinished</span><span class="params">(Loader&lt;List&lt;AppItem&gt;&gt; loader, List&lt;AppItem&gt; data)</span> </span>&#123;</span><br><span class="line">	    Log.v(TAG, <span class="string">"onLoadFinished"</span>);</span><br><span class="line"></span><br><span class="line">	    mAdapter.setData(data);</span><br><span class="line">	    mAdapter.notifyDataSetChanged();</span><br><span class="line">	    <span class="comment">//mGvAppsList.requestLayout();</span></span><br><span class="line">	    mAppList = data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoaderReset</span><span class="params">(Loader&lt;List&lt;AppItem&gt;&gt; loader)</span> </span>&#123;</span><br><span class="line">	    loader.forceLoad();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">	    Log.v(TAG,<span class="string">"onItemClick(): pos = "</span> + position);</span><br><span class="line"></span><br><span class="line">	    PackageManager pm = getPackageManager();</span><br><span class="line">	    String pkgName = mAppList.get(position).getAppInfo().packageName;</span><br><span class="line">	    Intent intent = pm.getLaunchIntentForPackage(pkgName);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span>(intent != <span class="keyword">null</span>)&#123;</span><br><span class="line">	        startActivity(intent);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，就要定义一个Loader用于APP数据的读取与加载，加载完后，把数据传给主线程;这里为了，提高加载的速度，利用DiskLruCache来做数据缓存(只是个示例,具体性能估计提高不大)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppLoader</span> <span class="keyword">extends</span> <span class="title">AsyncTaskLoader</span>&lt;<span class="title">List</span>&lt;<span class="title">AppItem</span>&gt;&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"AppLoader"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISK_CACHE_SIZE = <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">50</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DISK_CACHE_NAME = <span class="string">"MyLauncher"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISK_CACHE_INDEX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> PackageManager mPackageMgr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;AppItem&gt; mAppList;</span><br><span class="line">	<span class="keyword">private</span> HashSet&lt;String&gt; mAppsName;</span><br><span class="line">	<span class="comment">// disk file cache for app icon</span></span><br><span class="line">	<span class="keyword">private</span> DiskLruCache mDiskCache;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AppLoader</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">super</span>(context);</span><br><span class="line"></span><br><span class="line">	    mPackageMgr = context.getPackageManager();</span><br><span class="line"></span><br><span class="line">	    File cachePath = getDiskCachePath(context);</span><br><span class="line">	    <span class="keyword">if</span>(!cachePath.exists())&#123;</span><br><span class="line">	        cachePath.mkdirs();</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">	        <span class="keyword">if</span>(getUsableSpace(cachePath) &gt; DISK_CACHE_SIZE) &#123;</span><br><span class="line">	            mDiskCache = DiskLruCache.open(cachePath, <span class="number">1</span>, <span class="number">1</span>, DISK_CACHE_SIZE);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">	        e.printStackTrace();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;AppItem&gt; <span class="title">loadInBackground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    Log.v(TAG, <span class="string">"loadInBackground()"</span>);</span><br><span class="line"></span><br><span class="line">	    List&lt;ApplicationInfo&gt; appInfoList = mPackageMgr.getInstalledApplications(PackageManager.MATCH_UNINSTALLED_PACKAGES);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span>(appInfoList == <span class="keyword">null</span>)&#123;</span><br><span class="line">	        appInfoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    Log.v(TAG,<span class="string">"loadInBackground(): installed apps size = "</span> + appInfoList.size());</span><br><span class="line"></span><br><span class="line">	    mAppList = <span class="keyword">new</span> ArrayList&lt;&gt;(appInfoList.size());</span><br><span class="line">	    mAppsName = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	    <span class="keyword">for</span>(ApplicationInfo info: appInfoList)&#123;</span><br><span class="line">	        String pkgName = info.packageName;</span><br><span class="line">	        String label = mPackageMgr.getApplicationLabel(info).toString();</span><br><span class="line">	        <span class="comment">// only launchable app is added</span></span><br><span class="line">	        <span class="keyword">if</span>(!mAppsName.contains(label) &amp;&amp;</span><br><span class="line">	                mPackageMgr.getLaunchIntentForPackage(pkgName) != <span class="keyword">null</span>)&#123;</span><br><span class="line">	            String key = getCacheKey(pkgName);</span><br><span class="line">	            Drawable d = loadFromDiskCache(key);</span><br><span class="line"></span><br><span class="line">	            AppItem item;</span><br><span class="line">	            <span class="keyword">if</span>(d != <span class="keyword">null</span>)&#123;</span><br><span class="line">	                item = <span class="keyword">new</span> AppItem(mPackageMgr,d,label);</span><br><span class="line">	                saveIconToDiskCache(key,d);</span><br><span class="line">	            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	                item = <span class="keyword">new</span> AppItem(mPackageMgr, info);</span><br><span class="line">	                saveIconToDiskCache(key,item.getAppIcon());</span><br><span class="line">	            &#125;</span><br><span class="line"></span><br><span class="line">	            mAppList.add(item);</span><br><span class="line">	            mAppsName.add(label);</span><br><span class="line"></span><br><span class="line">	            Log.v(TAG,<span class="string">"application label : label "</span> + label);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    Log.v(TAG, <span class="string">"loadInBackground(): app size = "</span> + mAppList.size());</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">return</span> mAppList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliverResult</span><span class="params">(List&lt;AppItem&gt; appList)</span></span>&#123;</span><br><span class="line">	    Log.v(TAG,<span class="string">"deliverResult()"</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span>(isReset())&#123;</span><br><span class="line">	        <span class="keyword">if</span>(appList != <span class="keyword">null</span>)&#123;</span><br><span class="line">	            onReleaseResources(appList);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    List&lt;AppItem&gt; oldApps = mAppList;</span><br><span class="line">	    mAppList = appList;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span>(isStarted())&#123;</span><br><span class="line">	        <span class="keyword">super</span>.deliverResult(appList);</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span>(oldApps != <span class="keyword">null</span>)&#123;</span><br><span class="line">	        onReleaseResources(oldApps);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStartLoading</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    Log.v(TAG,<span class="string">"onStartLoading()"</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span>(mAppList != <span class="keyword">null</span>)&#123;</span><br><span class="line">	        deliverResult(mAppList);</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span>(takeContentChanged() || mAppList == <span class="keyword">null</span>)&#123;</span><br><span class="line">	        forceLoad();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStopLoading</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    cancelLoad();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCanceled</span><span class="params">(List&lt;AppItem&gt; apps)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">super</span>.onCanceled(apps);</span><br><span class="line"></span><br><span class="line">	    onReleaseResources(apps);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onReset</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">super</span>.onReset();</span><br><span class="line"></span><br><span class="line">	    onStopLoading();</span><br><span class="line">	    <span class="keyword">if</span>(mAppList != <span class="keyword">null</span>)&#123;</span><br><span class="line">	        onReleaseResources(mAppList);</span><br><span class="line">	        mAppList = <span class="keyword">null</span>;</span><br><span class="line">	        mAppsName = <span class="keyword">null</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// take care of releasing resources</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onReleaseResources</span><span class="params">(List&lt;AppItem&gt; apps)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">// for cursor, we may want to close it</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getCacheKey</span><span class="params">(String pkgName)</span></span>&#123;</span><br><span class="line">	    Log.v(TAG,<span class="string">"getCacheKey()"</span>);</span><br><span class="line">	    String key;</span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">	        MessageDigest digest = MessageDigest.getInstance(<span class="string">"SHA"</span>);</span><br><span class="line">	        digest.update(pkgName.getBytes());</span><br><span class="line">	        key = bytesToHexString(digest.digest());</span><br><span class="line">	    &#125;<span class="keyword">catch</span> (NoSuchAlgorithmException e)&#123;</span><br><span class="line">	        key = pkgName;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">return</span> key;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">saveIconToDiskCache</span><span class="params">(String key,Drawable icon)</span></span>&#123;</span><br><span class="line">	    Log.v(TAG,<span class="string">"saveIconToDiskCache()"</span>);</span><br><span class="line">	    <span class="keyword">if</span>(mDiskCache == <span class="keyword">null</span>)&#123;</span><br><span class="line">	        Log.e(TAG,<span class="string">"saveIconToDiskCache(): disk cache is not available"</span>);</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    Bitmap bitmap = BitmapUtil.drawableToBitmap(icon);</span><br><span class="line">	    ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream(bitmap.getByteCount());</span><br><span class="line">	    bitmap.compress(Bitmap.CompressFormat.PNG,<span class="number">100</span>,bos);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">	        DiskLruCache.Editor editor = mDiskCache.edit(key);</span><br><span class="line">	        <span class="keyword">if</span>(editor != <span class="keyword">null</span>)&#123;</span><br><span class="line">	            OutputStream os = editor.newOutputStream(DISK_CACHE_INDEX);</span><br><span class="line">	            os.write(bos.toByteArray());</span><br><span class="line">	            editor.commit();</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="comment">// write to disk</span></span><br><span class="line">	        mDiskCache.flush();</span><br><span class="line">	    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">	        e.printStackTrace();</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Drawable <span class="title">loadFromDiskCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">	    Log.v(TAG,<span class="string">"loadFromDiskCache()"</span>);</span><br><span class="line">	    <span class="keyword">if</span>(mDiskCache == <span class="keyword">null</span> || mDiskCache.size() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">	        DiskLruCache.Snapshot snapshot = mDiskCache.get(key);</span><br><span class="line">	        <span class="keyword">if</span>(snapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">	            FileInputStream fis = (FileInputStream) snapshot.getInputStream(DISK_CACHE_INDEX);</span><br><span class="line">	            Bitmap bitmap = BitmapFactory.decodeStream(fis);</span><br><span class="line">	            <span class="keyword">return</span> <span class="keyword">new</span> BitmapDrawable(getContext().getResources(),bitmap);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">	        e.printStackTrace();</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> File <span class="title">getDiskCachePath</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">boolean</span> isExternalMounted = Environment.getExternalStorageState().</span><br><span class="line">	            equals(Environment.MEDIA_MOUNTED);</span><br><span class="line">	    File diskCacheDir;</span><br><span class="line">	    <span class="keyword">if</span>(!isExternalMounted)&#123;</span><br><span class="line">	        diskCacheDir = <span class="keyword">new</span> File(context.getCacheDir(),DISK_CACHE_NAME);</span><br><span class="line">	    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	        diskCacheDir = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory(),DISK_CACHE_NAME);</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">return</span> diskCacheDir;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getUsableSpace</span><span class="params">(File path)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span> size = path.getUsableSpace();</span><br><span class="line">	    Log.v(TAG,<span class="string">"getUsableSpace(): size = "</span> + size);</span><br><span class="line">	    <span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">bytesToHexString</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">	    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">	        String hex = Integer.toHexString(<span class="number">0xFF</span> &amp; bytes[i]);</span><br><span class="line">	        <span class="keyword">if</span> (hex.length() == <span class="number">1</span>) &#123;</span><br><span class="line">	            sb.append(<span class="string">'0'</span>);</span><br><span class="line">	        &#125;</span><br><span class="line">	        sb.append(hex);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，建立一个ListAdapter，用于将数据与GridView进行绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * an app item adapter to bind data to grid view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppItemAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"AppItemAdapter"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WIDTH = <span class="number">150</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_HEIGHT = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Context mContext;</span><br><span class="line">	<span class="keyword">private</span> List&lt;AppItem&gt; mAppList = Collections.EMPTY_LIST;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SparseArray&lt;View&gt; sViewCache;</span><br><span class="line">	<span class="keyword">private</span> ItemClickListener mListener;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemClickListener</span></span>&#123;</span><br><span class="line">	    <span class="function"><span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(<span class="keyword">int</span> position)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AppItemAdapter</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">	    mContext = context;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setListener</span><span class="params">(ItemClickListener listener)</span></span>&#123;</span><br><span class="line">	    mListener = listener;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(List&lt;AppItem&gt; data)</span></span>&#123;</span><br><span class="line">	    mAppList = data;</span><br><span class="line">	    sViewCache = <span class="keyword">new</span> SparseArray&lt;&gt;(data.size());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> mAppList.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AppItem <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> mAppList.get(position);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">// if use convertView, the binded data list seems to be wrong</span></span><br><span class="line">	    View root = sViewCache.get(position);</span><br><span class="line">	    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">	        LayoutInflater inflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">	         root = inflater.inflate(R.layout.layout_app_item, parent, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">	        ViewHolder vh = <span class="keyword">new</span> ViewHolder(root, position);</span><br><span class="line">	        sViewCache.setValueAt(position,root);</span><br><span class="line">	        <span class="comment">//<span class="doctag">TODO:</span> icon size may be different for different apps</span></span><br><span class="line">	        <span class="comment">// keep the size the same</span></span><br><span class="line">	        Drawable d = mAppList.get(position).getAppIcon();</span><br><span class="line">	        Bitmap bitmap = BitmapUtil.drawableToBitmap(d);</span><br><span class="line">	        Bitmap scaleBitmap = Bitmap.createScaledBitmap(bitmap, DEFAULT_WIDTH, DEFAULT_HEIGHT, <span class="keyword">false</span>);</span><br><span class="line">	        vh.ivIcon.setImageBitmap(scaleBitmap);</span><br><span class="line">	        vh.tvName.setText(mAppList.get(position).getAppName());</span><br><span class="line"></span><br><span class="line">	        Log.v(TAG, <span class="string">"application label = "</span> + vh.tvName.getText());</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span></span>&#123;</span><br><span class="line">	    ImageView ivIcon;</span><br><span class="line">	    TextView tvName;</span><br><span class="line"></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(View root, <span class="keyword">final</span> <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">	        ImageView icon = (ImageView)root.findViewById(R.id.iv_app_icon);</span><br><span class="line">	        TextView name = (TextView)root.findViewById(R.id.tv_app_name);</span><br><span class="line">	        ivIcon = icon;</span><br><span class="line">	        tvName = name;</span><br><span class="line"></span><br><span class="line">	        root.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">	                mListener.onItemClick(pos);</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;);</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(ImageView icon,TextView name)</span></span>&#123;</span><br><span class="line">	        ivIcon = icon;</span><br><span class="line">	        tvName = name;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样一个简单的Launcher就写好了，项目详情请参考: </p>
<blockquote><p><a href="https://github.com/runningforlife/AndroidExamples" title="参考Lanucher目录" target="_blank" rel="noopener">https://github.com/runningforlife/AndroidExamples</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Launcher </tag>
            
            <tag> SystemServer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何在Java中调用C_C++方法]]></title>
      <url>http://sniffer.site/2017/01/07/%E5%A6%82%E4%BD%95%E5%9C%A8Java%E4%B8%AD%E8%B0%83%E7%94%A8C-C-%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>有时，需要在Java中直接调用本地（native)方法，把一些耗时的操作使用效率更高C/C++实现。在Java中调用本地方法通常被称为Java Native Interface(JNI)。那么，什么时候需要用到JNI了？</p>
<a id="more"></a>
<ul>
<li>需要在底层实现耗时更小、更快的程序</li>
<li>在Java中需要调用本地代码库</li>
<li>需要使用平台相关但Java标准库文件不支持的特性</li>
</ul>
<p>接下来，我们就来看一看，如何在Java中通过JNI来调用本地方法？</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h1><p>在开始JNI编程之前，需要确保在系统环境中有配置好了如下程序：</p>
<ul>
<li>Java虚拟机程序， Java编译器(javac),一个本地方法的头文件生成程序(javah)</li>
<li>定义JNI的库文件以及本地头文件: jni.h,jvm.lib,jvm.dll,jvm.so</li>
<li>c/C++编译器，用于创建共享库代码</li>
</ul>
<p>前面两条中的程序只要安装了JDK开发环境，都已包含在系统中了，可以直接使用。另外，需要注意的是，利用System.loadLibrary来加载本地库文件时，不同系统对于生成的库文件命名存在差异，例如在HelloWorld.java使用System.loadLibrary(“HelloWorld”)：</p>
<ul>
<li>Solaris: libHelloWorld.so</li>
<li>Linux: libHelloWorld.so</li>
<li>Win: HelloWorld.dll</li>
<li>Mac: libHelloWorld.jnilib</li>
</ul>
<p>在生成本地库文件时需要留意。接下来，我们就一步步来看下如何在Java中调用本地方法（以下实现均基于Ubuntu 16.04　64bit版本)。</p>
<h1 id="六步实现在Java中调用本地方法"><a href="#六步实现在Java中调用本地方法" class="headerlink" title="六步实现在Java中调用本地方法"></a><strong>六步实现在Java中调用本地方法</strong></h1><h2 id="１．编写Java文件"><a href="#１．编写Java文件" class="headerlink" title="１．编写Java文件"></a><strong>１．编写Java文件</strong></h2><p>指定一个文件夹下，新建一个HelloJni.java文件,并在其中声明需要调用的本地方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJni</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">talkBack</span><span class="params">(String str)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String str)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.loadLibrary(<span class="string">"HelloJni"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		HelloJni jni = <span class="keyword">new</span> HelloJni();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> add = jni.add(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">		jni.sayHello(<span class="string">"hello jni"</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"add: "</span> + add);</span><br><span class="line">		System.out.println(<span class="string">"talkBack: "</span> + jni.talkBack(<span class="string">"hello"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="２-编译Java文件，生成-class文件"><a href="#２-编译Java文件，生成-class文件" class="headerlink" title="２. 编译Java文件，生成.class文件"></a><strong>２. 编译Java文件，生成.class文件</strong></h2><p>在HelloJni.java目录下，打开命令行工具，输入:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">javac HelloJni.java</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看该文件夹，可以看到已经生成了相应的.class文件。</p>
<h2 id="３-生成本地方法对应的头文件"><a href="#３-生成本地方法对应的头文件" class="headerlink" title="３. 生成本地方法对应的头文件"></a><strong>３. 生成本地方法对应的头文件</strong></h2><p>利用JDK中提供的javah程序，我们可以生成Java文件中对应的本地方法头文件,在命令行中输入:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">javah HelloJni</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在对应的目录下，可以看到一个名为HelloJni.h的文件,长成这样子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line"><span class="comment">/* Header for class HelloJni */</span></span><br><span class="line"></span><br><span class="line">#ifndef _Included_HelloJni</span><br><span class="line">#define _Included_HelloJni</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern <span class="string">"C"</span> &#123;</span><br><span class="line">#endif</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     HelloJni</span></span><br><span class="line"><span class="comment"> * Method:    add</span></span><br><span class="line"><span class="comment"> * Signature: (II)I</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jint JNICALL Java_HelloJni_add</span><br><span class="line">  (JNIEnv *, jobject, jint, jint);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     HelloJni</span></span><br><span class="line"><span class="comment"> * Method:    talkBack</span></span><br><span class="line"><span class="comment"> * Signature: (Ljava/lang/String;)Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_HelloJni_talkBack</span><br><span class="line">  (JNIEnv *, jobject, jstring);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     HelloJni</span></span><br><span class="line"><span class="comment"> * Method:    sayHello</span></span><br><span class="line"><span class="comment"> * Signature: (Ljava/lang/String;)V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_HelloJni_sayHello</span><br><span class="line">  (JNIEnv *, jobject, jstring);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="４-编写对应的C-C-方法"><a href="#４-编写对应的C-C-方法" class="headerlink" title="４. 编写对应的C/C++方法"></a><strong>４. 编写对应的C/C++方法</strong></h2><p>按照上述生成的HelloJni.h文件，注意函数的名称与返回值必须与HelloJni.h中完全一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include "HelloJni.h"</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL Java_HelloJni_add</span><br><span class="line">  (JNIEnv *env, jobject obj, jint n1, jint n2)&#123;</span><br><span class="line">  <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JNIEXPORT jstring JNICALL Java_HelloJni_talkBack</span><br><span class="line">  (JNIEnv *env, jobject obj, jstring str)&#123;</span><br><span class="line">  <span class="comment">//注意在C中，应为:const char *s = (*env)-&gt;GetStringUTFChars(str,0)</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *s = env-&gt;GetStringUTFChars(str,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(strcmp(s,<span class="string">"hello"</span>) == <span class="number">0</span>　|| strcmp(s,<span class="string">"hi"</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">  	<span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"jni from c/c++"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"unknow talking"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_HelloJni_sayHello</span><br><span class="line">  (JNIEnv *env, jobject obj, jstring str)&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *s = env-&gt;GetStringUTFChars(str,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">char</span> chs[<span class="number">100</span>];</span><br><span class="line">  strcpy(chs,s);</span><br><span class="line">  printf(chs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="５-生成共享库文件"><a href="#５-生成共享库文件" class="headerlink" title="５. 生成共享库文件"></a><strong>５. 生成共享库文件</strong></h2><p>这里利用Ubuntu系统自带的编译器gcc来产生共享库文件。有关gcc命令的参数可参考 <a href="http://man7.org/linux/man-pages/man1/gcc.1.html;在这里，需要主义两点，一是编译时需要包含两个JNI相关的头文件jni.h以及jni_md.h,否则编译时会出现错误：" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man1/gcc.1.html;在这里，需要主义两点，一是编译时需要包含两个JNI相关的头文件jni.h以及jni_md.h,否则编译时会出现错误：</a></p>
<blockquote><p>对于Ubuntu系统，JDK一般安装在：/usr/lib/jvm</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">:~/Java$ gcc -shared -fPIC libHelloJni.so  HelloJni.cpp</span><br><span class="line">In file included from HelloJni.cpp:<span class="number">1</span>:<span class="number">0</span>:</span><br><span class="line">HelloJni.h:<span class="number">2</span>:<span class="number">17</span>: fatal error: jni.h: No such file <span class="keyword">or</span> directory</span><br><span class="line">compilation terminated.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一个时生成的库文件名前面需要加上lib，如libHelloJni.so,使用System.loadLibrary调用时则去掉lib:System.loadLibrary(“HelloJni”)，否则调用时可能出现无法找到库文件的错误java.lang.UnsatisfiedLinkError，完整的编译命令如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gcc -I/usr/lib/jvm/java<span class="number">-1.8</span><span class="number">.0</span>-openjdk-amd64/include/ -I/usr/lib/jvm/java<span class="number">-1.8</span><span class="number">.0</span>-openjdk-amd64/include/linux -fPIC  -shared -o  libHelloJni.so HelloJni.cpp </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="６-运行java程序"><a href="#６-运行java程序" class="headerlink" title="６. 运行java程序"></a><strong>６. 运行java程序</strong></h2><p>在命令行中输入(需要指定.class文件的搜索路径):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">java -Djava.library.path=/home/jason/Java HelloJni</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>java命令可参考:<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/java.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/7/docs/technotes/tools/windows/java.html</a></p>
<h1 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a><strong>需要注意的地方</strong></h1><ul>
<li>确保.c/.cpp文件中函数名称与生成的.h头文件中的一致</li>
<li>不同操作系统中，生成的共享库文件名称不一样,例如: 在HelloJni.java,System.loadLibrary(“HelloJni”);<br>Solaris: libHelloJni.so<br>Linux: libHelloJni.so<br>Win: HelloJni.dll<br>Mac: libHelloJni.jnilib</li>
<li>执行Java程序时,添加参数 -Djava.library.path=PATH，这里PATH就是JNI库所在位置</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h1><ul>
<li><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/index.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/7/docs/technotes/guides/jni/index.html</a></li>
<li><a href="http://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html</a></li>
<li><a href="http://www.bogotobogo.com/cplusplus/eclipse_CDT_JNI_MinGW_64bit.php" target="_blank" rel="noopener">http://www.bogotobogo.com/cplusplus/eclipse_CDT_JNI_MinGW_64bit.php</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> JNI </tag>
            
            <tag> 共享库文件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[罗素《权威与个人》]]></title>
      <url>http://sniffer.site/2016/12/26/%E7%BD%97%E7%B4%A0%E3%80%8A%E6%9D%83%E5%A8%81%E4%B8%8E%E4%B8%AA%E4%BA%BA%E3%80%8B/</url>
      <content type="html"><![CDATA[<p>《权威与个人》是罗素在1948年里斯讲座所做的几次演讲的文章合集，里边谈到了个人自由与国家权威之间的关系，以及如何平衡这两者以促进人类的进步，确保个人生活的活力。对于缺乏自由与民主熏陶，在集体主义与强权政府成长起来的我而言，这种书无疑是一种解毒剂，让我意识到自由于个人、社会的重要意义。</p>
<a id="more"></a>
<h2 id="社会凝聚力与人性"><a href="#社会凝聚力与人性" class="headerlink" title="社会凝聚力与人性"></a><strong>社会凝聚力与人性</strong></h2><ul>
<li><p>在这些演讲里，我打算考虑这样一个根本问题：我们怎样才能把进步所必需的那种程度的个人首创性和生存所必需的那种程度的社会凝聚力结合起来？…随后，我还将探讨我们时代的一个基本问题，即由现代技术所引发的在组织和人性之间的冲突，或者换一种说法，经济动机和创造以及占有冲动的分离。在论述了这一问题以后，我将考察为了解决这一问题，我们能做什么。</p>
</li>
<li><p>我们早期的、初有人性的祖先，不可能依据一种深思熟虑的策略来做事，而必定一直是被一种本能的机制所驱使，这是一种由部落里的友谊和对所有其他人的敌意组成的二元机制。</p>
</li>
<li><p>社会凝聚力始于对群体的忠诚（这种忠诚由于对敌人的恐惧而加强），并通过部分出于本性、部分深思熟虑的进程而发展，直到它形成我们今天所知的像国家这样巨大的凝聚体。对于这些进程而言，很多力量都起了作用。在很早的阶段，对群体的忠诚一定是通过对领袖的忠诚来强化的。在一个大的部落里，即使平民个体常常互为陌路，酋长或者王却可能为每个人所熟知。这样一来，和对部落的忠诚相对的对个人的忠诚，就使群体的规模在不损害本能的情况下获得增长成为可能。</p>
</li>
<li><p>我们本能地把人类区分成朋友和敌人-对于朋友，我们有合作的道义；对于敌人，我们有抗争的道义。但是这种划分也在不断变化：有时候，一个人会仇恨他生意上的对手，而在另一个时候，当他们受到社会主义或者一个外部敌人威胁时，他会马上开始把对方看作兄弟。一旦超出家庭的界限，始终是由外部的敌人为我们提供凝聚起来的力量。</p>
</li>
<li><p>…过于违反本性冲动的生活是这样一种生活，它可能含有各种紧张的结果，这些结果完全可能像陷入被禁止的冲动一样有害。过着违反本性生活的人，超过一定程度很可能会充满妒忌、怨恨以及所有的冷酷无情。他们可能会形成残忍的性情，或者另一方面，他们可能会完全丧失生活中的所有乐趣，以至于不再有能力做出任何努力。（公务猿这种新物种是否是因为长期在权力的熏陶之下，过着违反本性的生活，扭曲了人性，所以才会变得傲慢而自私，冷漠而残酷。）</p>
</li>
<li><p>我们有各种侵略的冲动，也有各种创造的冲动，社会却禁止我们放纵它们，而它们以足球赛和令人筋疲力尽的角力形式所提供的替代品是远远不够的。任何希望最终可能消除战争的人都应该认真思考这一问题，即如何无害地满足我们从一代代久远的原始祖先那里所承袭的各种本能。（这里所说的满足本能，可以认为是如何释放人类的天性，发挥个人的潜能）</p>
</li>
<li><p>（社会改革者的）问题是要把人类所不可或缺的那种程度的安全和那些与文明生活方式相容的冒险、危险和竞赛形式结合起来…我们必须牢记，尽管我们的生活方式和制度以及知识已经经历了很多深刻的变化，我们的善与恶两方面的本能，很大程度上仍然保持着我们祖先的大脑最初发展成它们现在大小时候的样子。我并不认为各种原始冲动和文明的生活方式是不可调和的，人类历史学家的研究已经表明，人类的本性对各种不同的文化模式具有广泛的适应性。但我并不认为，这种适应性能够通过完全排除一切基本的冲动来实现。一种缺乏冒险的生活可能并不让人满意，但是一种允许采取任何冒险形式的生活却注定是短命的。（即使到了今天，如果缺乏基本的文明法治，缺乏对民主自由的追求与认知，开着奔驰宝马丰田、住着高楼大厦、坐着飞机高铁的我们，跟人类有共同祖先的猿猴有什么根本的区别了？）</p>
</li>
</ul>
<h2 id="社会凝聚力与政府"><a href="#社会凝聚力与政府" class="headerlink" title="社会凝聚力与政府"></a><strong>社会凝聚力与政府</strong></h2><ul>
<li><p>在最早有史可查的社会里，比如古埃及，我们发现，除了来自祭司集团的某些限制以外，国王在其辽阔的土地上的权力是绝对的，我们也可以发现数量庞大的奴隶，国王可以为了像金字塔这样的国家事业而随意奴役他们。在这样的社会里，只有社会等级顶端的少数人–国王、贵族和祭司–需要社会凝聚的心理机制；所有其他人不过是服从罢了。大部分人无疑是不幸的…但是通常来说，只要没有外敌为患，这种普遍状况并不会妨碍国家繁荣，并且也不会损害掌权者的生活享受。</p>
</li>
<li><p>从15世纪至今，国家针对个人的权力一直在持续增长，这首先主要是火药发明的结果。就像在早期无政府状态的日子里，大多数有思想的人崇尚法律那样，在国家权利日益增长的时期，存在着不断增长的崇尚自由的趋势…然而，争取自由的冲动今天在改革者当中似乎已大大减弱了；它已经被对平等的热爱所取代，这主要是由没有任何传统优势的新工业资本家的财富和权力的增长所激发的….在世界上大部分地区，似乎都存在着向古埃及神圣王权体制（它受一个新祭司阶层的控制）的复归。尽管这种趋势在西方不像在东方那么极端…个人主动性被国家或者强大的公司限制了，因此就有了一种巨大的危险，即这种状况会像在古罗马一样，产生一种倦怠感和宿命论。这对充满活力的生活是灾难性的…作为纯粹规模方面的恶意个结果，政府变得越来越远离被统治者，并且倾向于–甚至在一个民主国家中–拥有它自己的独立生命。我并不知道如何彻底消除这一弊端，但我认为，认识到它的存在、并找到各种减轻其危害程度的办法是重要的。（罗素八十年前的担忧即使到了今天也还是普遍存在的。不过现在来看，互联网技术的出现让整个世界变得更“平”了，让普通人有了更多个性与自由的空间。政府的公职人员也不敢再为所欲为，违法乱纪的行为更容易传播而被人们获知了；普通老百姓获取资讯的途径更加多样，政府想控制统治者更加困难了。世界的大趋势正朝着更加透明，民主，自由的方向走的）</p>
</li>
<li><p>政府，从它存在的最早时代起就一直有两种职能，一种是消极的，另一种是积极的。政府的消极职能在于防止私人暴力，保护声明财产，制定刑法并保障其实施。但是除此之外，它还一直具有一种积极目的，即促使对大多数公民而言的共同愿望的实现…在任何一种情况下，都有一个管理机构，这一机构实际上，如果不是有意的话，都远离它所控制的那些人。只有管理机构（无论是国家管理机构还是大型企业的管理机构)的成员才能保持个人的积极主动权，而且对管理机构来说，都不可避免地存在一种趋势，即或多或少都会像看待它们的机器那样来看待为他们工作的人，也就是说，仅仅看成一种必要的手段。顺利合作的愿望不断倾向于扩大单位规模，并由此使仍然具有主动性的人数减少…最糟糕的莫过于一种已经广泛存在于英国各领域的体制，在这种体制下，那些具有名义上的积极性的人永远被文官体制（这种体制有的只是否决之权而非开创之责，并由此养成了一种永远倾向于去禁止的消极心理）控制了。在这样的一种体制下，有能力的人变得绝望，在一个更有希望的环境中本该充满活力的人变得倦怠和轻浮，国家的积极职能也就不可能活跃而高效的实现。（在三星这样的大企业里工作，无时无刻不感到官僚体制的张力。个人的能动性受制于臃肿的管理，即使有能力的人想要做点事情，也常常事与愿违，而公司也似乎并不强调、鼓励员工个人突破已有的限制，寻求职业技能上的进步与创新。长此以往，很多员工都处于一种消极被动的工作状态，除了应付手头上的业务之外再无学习其他技术的热情与追求，对外面的技术变化也显得毫无兴趣，反应迟钝。这种状态同样可以在中国的新物种公务猿身上看到。公务猿对待自己的本职工作热情来自于获取财富，以及这份职业所带来的虚无缥缈的权力虚荣感。至于什么职业道德与责任感，什么服务百姓，改善社区环境这种吃苦不讨好的事情，他们都毫无兴趣。个人能动性全然没有了，有的只是国家意志与控制力的执行。）</p>
</li>
<li><p>（简述了社会凝聚力在各个历史时代所发生的变化，从中我们可以观察到一种双重运动）一方面，存在着一种周期性的发展，即从松散而原始的组织类型到逐渐有序的政府（更广阔的领土，并且对个人生活的更多方面加以规制）的发展…当新的文明已经定型，当政府已经有机会巩固自己的权力，当习俗、传统和法律已经建立起细致得足以窒息进取心的规则之时，社会就进入了一个停滞阶段。人们赞美前辈的功绩，却再也比不上他们；艺术变得因袭守旧，科学也因为对权威的尊崇而被断送…除了这种周期性运动之外，还有一种运动。在每次循环的顶峰，一个国家的统治的区域比以往任何时候都要大，当局对个人实施控制的程度也高于先前任何一个最高点。罗马帝国比巴比伦和埃及帝国大，今天的各个帝国比罗马帝国更大。在过去历史上，从来没有一个大国能像苏联、或者甚至像西欧各国那样，控制它的公民。既然地球的大小是有限的，如果不加制约的话，这种趋势最终必定会产生一个单一世界国家。但是由于那时不会有对外敌的恐惧来增强凝聚力，这种古老的心理机制将不再适用。在世界政府的各种事务里，将不再有爱国主义的空间；没有憎恨和恐惧这些强大的动机，人们不得不在自利和善行中寻找动力。这样的社会能持续下去吗？</p>
</li>
</ul>
<h2 id="个性的作用"><a href="#个性的作用" class="headerlink" title="个性的作用"></a><strong>个性的作用</strong></h2><ul>
<li><p>艺术在我们时代的衰落，并不仅仅是由于艺术家的社会功能已经不像从前那样重要，而且也同样由于自发的喜悦已不再被认为是某种应该让人享受的东西。在比较淳朴的人们当中，民间舞蹈和大众音乐仍然流行，很多人身上也多少有一些诗人气质。但随着人们变得越来越工业化和组织化，孩子当中普遍存在的那种喜悦对成年人来说变得不可能了，因为他们总是想着下一件事情而无法让自己沉侵于此刻。对任何一种审美价值来说，这种想着“下一件事情”的习惯比任何其他能想到的思考习惯都更要命，在所有重要的意义上，如果艺术谣生存下去，它就不能通过建立各种庄严的学院，而是要通过重新获得那种已经差不多被谨小慎微和深谋远虑毁掉的全身心的悲喜能力来实现。（现如今，有了随时可以获取大量资讯的智能移动终端，个人的生活看似更为丰富，但由此带来的是个人时间与精力的碎片化。人们被应接不暇的新闻报道所吸引，沉浸在各种短暂的感官刺激当中；在关注时事之外，人们还要不停的刷刷朋友圈，看看“朋友们”所做的事情。实际上，现在的人已经很难拿出一长段时间来全身心做一件事情了。资讯焦虑让我们陷入一种浮光掠影的浅浮当中。我们已经很少有孩子般纯粹的喜悦以及全身心投入的体验了）</p>
</li>
<li><p>我们知道的太多，却体验得太少。至少我们对一种美好生活所由以产生的那些创造性冲动体验得太少。重要的原因在于我们是被动的；即使我们是主动的，也只是在琐碎的事情上主动。要想把生活从只能由灾难来缓解的无聊状态中解救出来，就必须找到恢复个人主动性的手段，不仅在琐碎的事情上，而且也在真正重要的事情上。并不是说，我们应该毁灭现代组织当中大多数人所赖以生存的那部分，但是我确实想说，组织一直是通过它令人难以忍受的迅速增长和权力集中而发展起来的，我们的思想情感方式已经无法与之齐头并进，因此组织应该具有更大的灵活性，更多地通过地方自治加以调剂，而且更少地通过它那非人的巨大规模来压抑人的精神。（现代管理者应该意识到，公司与组织的真正价值在于其中具有创造天赋以及个性的人。一个公司与组织想要获得真正的成功，要做的便是为这些具有创造能力的人才营造一个发挥自身才能的空间与环境，让这些人的个性得到最大程度的发挥。）</p>
</li>
</ul>
<h2 id="技术与人性的冲突"><a href="#技术与人性的冲突" class="headerlink" title="技术与人性的冲突"></a><strong>技术与人性的冲突</strong></h2><ul>
<li><p>与其他动物不同，人类为了达成某个目标或者目的会乐于从事那些未必令人感到愉快的事情。动物做各种事情（鸟儿筑巢，河狸筑坝）只是出自一种生物的本能，而不是像人类一样认识到这些事情是有用的。人类会通过意志来实现自我控制、谨慎从事、深谋远虑以及抑制各种冲动，但所做的事情超过人性能够容忍的范围时，人类会受到心理上的惩罚…在早期石器时代，艺术创造的快乐和盼望能力增长的快乐本身很可能会被扩散到劳动的各个艰苦阶段…为了下滑瞬间的无上快乐，一个男孩会带着平底雪橇吃力地爬上小山…创造性的冲动可以激发比此更加长久的努力，并且能够保持自发性。一个人如果热切的盼望实现一个目的，并且用于克服困难的华，他就可能历经数年的艰难、险阻以及贫困，试图登上珠穆朗玛峰或者抵达南极极点，又或者做出一项科学发现，而且始终像那个带着雪橇的男孩一样，和他自己的各种冲动协调，因为“那里面有光荣”。</p>
</li>
<li><p>竞争，在它存在的地方，是一个极其强大的动机…尽管人们强烈的反对很多形式的竞争，我认为竞争对促进必要的努力却具有实质性的作用，在一些领域，它还为否则将可能引起战争的那些冲动提供了一个相对无害的发泄出口。没有人会赞成取消比赛中的竞争…球队之间、地方之间或者组织之间的竞争，都可以成为一种有效的刺激。</p>
</li>
<li><p>人们一般能够意识到，他们日常生活受远方世界各地发生事情的影响，但除了少数专家之外，他们并不理解这是怎样发生的。大米为什么没了？经济为什么不行了？物价为何上涨了？房价为何水涨船高？（后三条是我添加的）如果你怪罪印度，或者官僚作风，或者资本主义制度，又或者社会主义国家，你就是在人们的头脑当里召唤一个人们容易去仇恨、虚构的人格化恶魔。在每一个不幸当中，寻找一个可以怪罪的敌人是一种自然的冲动；原始人就把所有病痛归结为敌人的魔法。每当各种问题的起因太难理解时，我们往往会求助这种古老的解释…诉诸对假想敌的仇恨来解释我们生活中所有痛苦的事情往往是破坏性和灾难性的；它会激发原始的本能力量，所用的却是那些具有灾难性后果的办法。</p>
</li>
<li><p>在那些为了民主的平等而被不必要牺牲掉的东西里，最重要的也许是自尊。我所指的自尊是自尊中好的那一半–即所谓“自尊心”（proper pride)。坏的那一半则是一种优越感。自尊将使一个处于敌人控制下的人不至于奴颜婢膝，并使他在世人都反对他时仍然能够感到他自己也许是正确的…自尊到今天为止一直都不可避免地是少数人的美德。无论什么地方，只要存在权力的不平等，在屈从于他人统治的那些人当中，都不可能找到它。暴政最令人反感的特征之一是，它们竟然能够使不公正的受害者去谄媚那些虐待他们的人。</p>
</li>
<li><p>在工业社会里，最重要的问题，而且肯定也是最困难的问题之一，也许是使工作变得有趣–在工作不再仅仅是挣工资的手段的意义上。这一问题的产生尤其和无需技能的工作联系在一起。困难的工作对那些胜任它的人来说可能是有吸引力的…现代的工作性质进一步强调了不依赖于任何一种劳动储备库，它们要求较少的技能，却要求高度的稳定性和可靠性…怎么避免这个问题？罗素接着给出了解决办法: 使工人恢复过去和主人翁相联系的一些情感–即这是“我的”劳动成果，或者无论如何也是“我们的”劳动成果–相联系的自豪感；在所有内部事务上，要做到局部的、小范围的民主。詹姆斯-吉尔斯比在《工业中的自由表达》一书中进行了很好的阐述: 当一个个体或者群体存在严重问题时，而又不能带着问题去找高层管理者时，就会有一种挫败感…在大公司里，有一种比挫败感更甚的东西；对公司的运作，基层成员有一种特殊的无意义感。无论是在政治上还是工业里，只要政府或者管理部门被认为是“他们”，是一个遥远的群体，这个群体趾高气扬，傲慢无礼，并且自然地被人们怀着敌意来看待，民主就不会是一种心理上的事实。（自古以来，个性与创造都只属于少部分人，而大多数人则生活在贫穷、困苦以及残酷的重压之下，在敌意或冷酷的非人权的控制下，他们往往感到自己无助而软所无力。在现代工业化社会中，如何避免这些问题？如何释放出个人的潜能与创造力？这是罗素在接下来的两篇讲稿中着力去解决的难题。）</p>
</li>
</ul>
<h2 id="控制与主动性"><a href="#控制与主动性" class="headerlink" title="控制与主动性"></a><strong>控制与主动性</strong></h2><ul>
<li><p>一个健全而进步的社会既需要集中控制，也需要个人和群体的积极性：没有控制，会出现无政府状态；没有积极性，则会出现停滞…政府的主要目的，罗素认为主要三个：安全、公正和保护。</p>
<ul>
<li>安全：尽管许多国家保护守法公民不受其他公民的侵害，却并不认为是他们免受国家的侵害也是必要的。在那些存在依行政命令进行逮捕，以及不经过法律程序而进行惩罚的地方，无论国家建立多么稳固，个体民众也没有安全可言…安全，尽管无疑是好事情，却也可能因为追求过度而成为一种迷信。安全的生活未必是幸福的生活；它可能会因为无趣和单调而令人感到沉闷。安全本身是由恐惧所激发的消极目的;令人满意的生活必须是一个由希望所激发的积极目的。</li>
<li>公正：作者认为经济上的公正可以按照社会主义的方式来操作，由国家控制主要工业，并且很大程度上控制对外贸易（国家来控制工业导致的直接后果是，政府的权力会因此膨胀；权力的集中与国家资本扭曲了市场，消弱了民营经济，最后变成了控制民众的一种手段）。公正，和安全一样，但却是在一种更大的程度上，是一个受到各种限制的原则。在人人同样贫困以及人人同样富有的地方，公正是存在的，但使富裕的人变得更贫困-似乎并没有什么意义。</li>
<li>保护:政府不仅要保护古迹与风景区，还要维护公共基础设施…我主要考虑的是保护各种自然资源。罗素担心过度的资源开采会导致资源枯竭。这个问题在今天依然严峻。</li>
</ul>
</li>
<li><p>权力只有被委托给一些小团体（在这些小团体中，个人不会被纯粹的巨大数目所吞没），勇于冒险的意识，以及有能力实现人们觉得重要的结果的意识才可能恢复…所有健全体制的一个本质体制是，权力尽可能多地掌握在对所要做的工作感兴趣的人的手里。 </p>
</li>
<li><p>性格的整齐划一和文化的整齐划一是令人遗憾的。生物的进化取决于个体或者部落间先天的差异，文化的进化则取决与后天获得的差异。如果这些差异消失了，就不再会有任何可选择的事物了。在现代世界里，确实有一种现实的危险，即一个地区和另一个地区在文化方面过于相近了。将这一不幸减到最小的最好办法之一，就是增加不同群体的自主性。</p>
</li>
<li><p>和精神利益相比，物质利益更大程度上是一个占有问题。一个人吃了一份食物，其他人无法就无法吃到了，但一个人写作或者欣赏一首诗歌，却不会阻止另外一个人写作或者欣赏同样优美或者更优美的诗歌。这就是为什么，在涉及物质利益时，公正是重要的，而对精神利益来说，所需要的则是机会以及使成功的希望看起来合理的环境。激励有能力从事创造性工作的人的，并不是巨大的物质回报：几乎没有诗人或者科学人士发过财或者想要发财…在一个当权者控制了所有宣传手段的铁板一块的国家里，一个具有突出原创性的人可能会遇到一种更槽糕的命运：无论他是否屈从于法律的惩罚，他都不可能使他的观念为人所知。如果一个社会里发生了这种事情，这个社会就不再能够为人类的共同生活贡献任何有价值的东西了（看到这里，不禁叹息。在这个国家里，这个社会环境，个人就是鱼肉，就是韭菜，任由那些自以为聪明而又傲慢的当权者宰割。他们集中控制物质财富，集中权力，集中资源，每个人都围绕着权力与物质旋转，你几乎没有质疑的时间与精力，大多数时候大部分人都疲于奔命。而那些敢于挑战权威，想要思考发声的，则会被扼杀，失去自由乃至生命。）</p>
</li>
<li><p>文末，罗素说：“但是我们不能仅仅满足于活着而没有死去；我们希望幸福快乐、充满精力并富于创造力的活着”。有时，看着周围的世界，整天都在追逐利益，追逐物质的享乐，而精神却萎靡焦虑。这个国家与社会所作所为正在扼杀人的首创精神，将人丢入新的桎酷，让人成为一个只在乎物质而对精神与灵魂没有任何追求的行尸走肉。但愿自己不要迷失，在追逐幸福的过程中，可以感受到精神的富足与快乐。</p>
</li>
</ul>
<h2 id="个人伦理与社会伦理"><a href="#个人伦理与社会伦理" class="headerlink" title="个人伦理与社会伦理"></a>个人伦理与社会伦理</h2><ul>
<li><p>概而言之，我们已经区分了社会活动的两个主要目的：一方面，安全与公正需要集中的政府控制，这种控制要有效的话，就必须扩展建立起一个世界政府。进步，则相反，需要为与社会秩序相容的个人主动性提供最大的空间。罗素认为，要实现这两个目的，就需要尽可能的保证权力下放：给地方机构更多的权力；让铁路等工业有更多的自治空间；而对于报纸、书籍以及政治宣传，要尽可能的允许竞争，避免被政府控制，以及其他形式的垄断。</p>
</li>
<li><p>一个人如果真的想过他可能过上的最好的生活，他就必须学会批判在他的邻人中被普遍接受的那些部落习俗和信念。</p>
</li>
<li><p>在整个有文字记载的历史上，伦理信念一直有两个非常不同的来源，一个是政治的，另一个是则涉及个人的宗教和道德信念…个人与公民道德的两重性仍然存在着…没有公民道德，社会将灭亡；没有个人道德，他们的存在将毫无价值。对一个美好世界来说，公民与个人道德都是必不可少的。</p>
</li>
<li><p>公共责任的承担并不构成美好生活的全部内容；还存在着对个人价值（excellence)的追求。尽管人类部分是社会性的，但是却并不完全如此…个人价值，尽管很大部分存在于对他人的正当行为中，但也有其他方面…危险的，倒是听任政治和社会责任过于彻底支配了我们关于个人价值的观念…苏格拉底和使徒们（耶稣的十二门徒）告诉我们应该服从神而不是人，《福音书》对于爱上帝和爱邻舍则是一样的强调。所有伟大的宗教领袖，以及所有伟大的艺术家和富于才智的发明家，都显示出一种要实现他们创造性冲动的道德强迫感(a sense of moral compulsion),以及当他们实现这些冲动时的道德提升感（a sense of moral exaltation)。这种情感是《福音书》所宣称的对上帝的职分(duty to God)的基础，并且说可以和神学信仰分离的。</p>
</li>
<li><p>人们并不总是记得，政治、经济和社会组织一般来说应归于手段的范围，而不是目的的范围…但是一个社会的存在不是为了满足，或者至少不应该为了满足一种外在的观感，而是要把一种优良的生活带给组成它的个体。正是在个体身上，而不是在整体里，我们才能找到终极的价值。好的社会是给社会成员带来好生活的手段，而不是由于自身的缘故而具有某种独立的价值的东西。接着罗素说到了善恶。他说，只有个体才是善恶的承受者，才谈得上有善恶之分，人类集体是没有善恶的。认为人类集体也有善恶，最终导向的是极权主义。从这一观点延伸，罗素认为国家只是抽象物：不会感受到痛苦与快乐，也没有任何希望与恐惧。它本身并不具有价值而是实现公民福祉的一个手段而已：我们认为是国家目的的那些东西，实际上是掌控国家的那些个人的目的。当我们具体而非抽象地思考，就会发现，特定的某些人取代了“国家”，他们拥有的权力比大多数人所享有的要多的多。由此，对“国家”的赞颂实际上变成了对少数统治者的赞颂。</p>
</li>
<li><p>在此讲的后一部分，罗素再次阐述了如何在社会集体的凝聚力（国家）与个人主动性取得平衡。在如今高度组织化的社会，缺乏的是自发性，而掌控组织的人则往往试图让人去适应制度而不是让制度来适应人。罗素认为，要破除组织对个人的控制与威胁，必须让个人拥有主动改变的可能与成功的希望，使个体能够在组织之中发挥个人的作用与影响力。人类在科学技术方面并不缺乏聪明才智，但至今我们却没有学会怎样利用已有的知识和技能来最大限度的使我们的生活幸福，甚至光辉灿烂。随着科与学技术的发展，外部自然界对我们的束缚正在逐渐减少，这使我们有更多的精力发挥潜能，使比迄今为止存在过的、更大程度的人类福祉变得可能。要实现这种可能，就必须发挥个人的主动性，鼓励使人类生活变得丰富多彩的各种形式的主动性：通过使人驯服和胆怯，我们不可能建立一个美好的世界，而是要通过鼓励他们勇敢大胆、敢于冒险和无所畏惧来创建一个美好的世界。（人类是否可以建立一个伊甸园？是否能够过上美好幸福的生活？如今看来，好像还离的有点远。战争的威胁与地区争端此起彼伏，人类的生活似乎从未有过真正的安宁。虽然对于公平与正义，善良与美好，大部分的国家与民族都会有共同的认知，但是还有很多的地方依然处于黑暗与压制的环境当中。在这些地方，所谓的美好幸福，只是属于少数权贵阶层，而很大部分人仍然被压迫，被控制，被限制。那么，人类走向罗素说的那种组织与个人得到很好平衡的美好境界的趋势是否会因为这些逆流而发生变化了？大概率应该不会。人类曲曲折折走到现在，对于美好幸福生活的共同期许与愿望变得更为深入人心，这些也正是促使人类作为一个整体走向光明，不断进步的动力。）</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 罗素 </tag>
            
            <tag> 自由，民主 </tag>
            
            <tag> 国家意志与权威 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android RILD详解]]></title>
      <url>http://sniffer.site/2016/11/29/Android-RILD%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>在上一篇文章里（<a href="http://sniffer.site/2016/11/29/Android-RILD%E8%AF%A6%E8%A7%A3/" title="Android RIL概述">http://sniffer.site/2016/11/29/Android-RILD%E8%AF%A6%E8%A7%A3/</a>），简要介绍了Android RIL的架构。这一篇文章，就来看一看RILD（RIL Daemon)相关的内容。Android RIL在HAL(Hardware Abstract Layer)层（C++层）由三个部分组成：</p>
<ul>
<li>RILD是系统的守护进程，主要用于初始化LIBRIL以及启动厂商自定义的Vendor RIL；</li>
<li>LIBRIL库被RILD初始化完成后，用于与Vendor RIL之间进行交互，负责接收、发送指令；</li>
<li>Vendor RIL库是第三方厂商自定义的一个库，用于向Modem发送指令或者接收来自LIBRIL或者Modem的指令, Android有一个基于AT指令的默认参考实现(<code>reference-ril</code>)</li>
</ul>
<a id="more"></a>
<p>三者之间的关系图如下所示：</p>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/android_rild_structure.png" alt="RILD and LIBRIL"></p>
<p>从这里可以看到，RILD在启动时，负责将LibRil以及Vendor RIL进行初始化，将相应的回调函数以及调用接口进行注册，LibRIL向vendor RIL提供了接口<code>RIL_Env</code>，当Vendor有消息时，利用该回调返回；而Vendor RIL 同样提供了接口<code>RIL_RadioFunctions</code>,给LibRIl调用。这里涉及到3个主要问题：</p>
<ol>
<li>RILD是如何启动？</li>
<li>RILD是如何进行初始化操作的？</li>
<li>初始完成后，LIBRIL是如何进行消息的接收与发送的？</li>
</ol>
<h2 id="RILD是如何启动的"><a href="#RILD是如何启动的" class="headerlink" title="RILD是如何启动的"></a><strong>RILD是如何启动的</strong></h2><p>RILD(RIL Daemon)是系统的守护进程，系统已启动，就会一直运行。手机开机时，kernel完成初始化后，Android启动一个初始化进程Init用于加载系统基础服务，如文件系统，zygote进程，服务管家ServiceManager,以及RILD：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">service ril-daemon /system/bin/rild</span><br><span class="line">    class main</span><br><span class="line">    socket rild stream 660 root radio</span><br><span class="line">    socket rild-debug stream 660 radio system</span><br><span class="line">    user root</span><br><span class="line">    group radio cache inet misc audio log</span><br></pre></td></tr></table></figure>
<p>这里，init进程从手机文件系统目录<code>system/bin/rild</code>中读取RILD的可执行文件，加载到内存运行；同时，创建两个socket端口:rild和rild-debug,其中rild用于RILJ与RILD之间的数据通信，而rild-debug则用于RILJ与RILD的调试。</p>
<blockquote>
<ul>
<li>开机流程可参考：<a href="http://blog.csdn.net/jason_wzn/article/details/52278533" title="Android开机流程" target="_blank" rel="noopener">http://blog.csdn.net/jason_wzn/article/details/52278533</a></li>
<li>Android初始化语言init可参考：<a href="http://blog.csdn.net/jason_wzn/article/details/50790810" title="init初始化语言" target="_blank" rel="noopener">http://blog.csdn.net/jason_wzn/article/details/50790810</a></li>
</ul>
</blockquote>
<h2 id="RILD是如何进行初始化的"><a href="#RILD是如何进行初始化的" class="headerlink" title="RILD是如何进行初始化的"></a><strong>RILD是如何进行初始化的</strong></h2><p>RILD启动后，一方面会去初始化Vendor RIL，将LIBRIL的回调接口<code>RIL_Env</code>传递给Vendor RIL；同时将Vendor RIL的接口<code>RIL_RadioFunctions</code>注册到LIBRIL中，这样一旦初始化完成，LIBRIL与Vendor RIL就可以进行数据的交换了。</p>
<p>来看一看RILD的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">   // Vendor RIL接口函数</span><br><span class="line">    const RIL_RadioFunctions *(*rilInit)(const struct RIL_Env *, int, char **);</span><br><span class="line">    const RIL_RadioFunctions *funcs;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">OpenLib:</span><br><span class="line"></span><br><span class="line">	//从指定路径加载RILD可执行文件</span><br><span class="line">    dlHandle = dlopen(rilLibPath, RTLD_NOW);</span><br><span class="line"></span><br><span class="line">    if (dlHandle == NULL) &#123;</span><br><span class="line">        RLOGE(&quot;dlopen failed: %s&quot;, dlerror());</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 启动LIBRIL的事件处理线程</span><br><span class="line">    RIL_startEventLoop();</span><br><span class="line">	// Vendor RIL初始化函数，返回一个RIL_RadioFunctions</span><br><span class="line">    rilInit = (const RIL_RadioFunctions *(*)(const struct RIL_Env *, int, char **))dlsym(dlHandle, &quot;RIL_Init&quot;);</span><br><span class="line">	...</span><br><span class="line">    funcs = rilInit(&amp;s_rilEnv, argc, rilArgv);</span><br><span class="line">    RLOGD(&quot;RIL_Init rilInit completed&quot;);</span><br><span class="line">	// 将 RIL_RadioFunctions注册到LIBRIL中</span><br><span class="line">    RIL_register(funcs);</span><br><span class="line"></span><br><span class="line">    RLOGD(&quot;RIL_Init RIL_register completed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RILD初始化主要完成两件事：（1） 加载Vendor RIL的代码，并对其进行初始化操作，将LIBRIL的接口<code>RIL_Env</code>传递给Vendor RIL，用于回调；(2)开始RIL事件处理线程；（3）将Vendor RIL的接口注册到LIBRIL中，这样LIBRIL就可以将消息发送给Vendor RIL了。</p>
<ul>
<li><code>RIL_startEventLoop()</code>启动RIL事件处理线程：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">extern &quot;C&quot; void RIL_startEventLoop(void) &#123;</span><br><span class="line">    /* spin up eventLoop thread and wait for it to get started */</span><br><span class="line">    s_started = 0;</span><br><span class="line">    pthread_mutex_lock(&amp;s_startupMutex);</span><br><span class="line">	...</span><br><span class="line">	// eventLoop函数才是真正开始启动事件处理线程的地方</span><br><span class="line">    int result = pthread_create(&amp;s_tid_dispatch, &amp;attr, eventLoop, NULL);</span><br><span class="line">    if (result != 0) &#123;</span><br><span class="line">        RLOGE(&quot;Failed to create dispatch thread: %s&quot;, strerror(result));</span><br><span class="line">        goto done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (s_started == 0) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;s_startupCond, &amp;s_startupMutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    pthread_mutex_unlock(&amp;s_startupMutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// evetLoop </span><br><span class="line"></span><br><span class="line">static void *eventLoop(void *param) &#123;</span><br><span class="line">    int ret;</span><br><span class="line">    int filedes[2];</span><br><span class="line">	//初始化事件队列</span><br><span class="line">    ril_event_init();</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;s_startupMutex);</span><br><span class="line"></span><br><span class="line">    s_started = 1;</span><br><span class="line">    pthread_cond_broadcast(&amp;s_startupCond);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;s_startupMutex);</span><br><span class="line"></span><br><span class="line">    ret = pipe(filedes);</span><br><span class="line">	// 用于监听wakeup事件的pipe端口</span><br><span class="line">    s_fdWakeupRead = filedes[0];</span><br><span class="line">    s_fdWakeupWrite = filedes[1];</span><br><span class="line">	//设置线程唤醒事件，唤醒时，回调processWakeupCallback函数</span><br><span class="line">    ril_event_set (&amp;s_wakeupfd_event, s_fdWakeupRead, true,</span><br><span class="line">                processWakeupCallback, NULL);</span><br><span class="line"></span><br><span class="line">    rilEventAddWakeup (&amp;s_wakeupfd_event);</span><br><span class="line"></span><br><span class="line">    // 真正干活的函数</span><br><span class="line">    ril_event_loop();</span><br><span class="line">    // kill self to restart on error</span><br><span class="line">    kill(0, SIGKILL);</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>RILD初始化vendor RIL之后，将返回的<code>RIL_RadioFunctions</code>返回给RILD，RILD接着将其注册到LIBRIL中：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">extern &quot;C&quot; void RIL_register (const RIL_RadioFunctions *callbacks) &#123;</span><br><span class="line">    ...</span><br><span class="line">    /* Initialize socket1 parameters */</span><br><span class="line">    s_ril_param_socket = &#123;</span><br><span class="line">                        RIL_SOCKET_1,             /* socket_id */</span><br><span class="line">                        -1,                       /* fdListen */</span><br><span class="line">                        -1,                       /* fdCommand */</span><br><span class="line">                        PHONE_PROCESS,            /* processName */</span><br><span class="line">                        &amp;s_commands_event,        /* commands_event */</span><br><span class="line">                        &amp;s_listen_event,          /* listen_event */</span><br><span class="line">                        processCommandsCallback,  /* processCommandsCallback */</span><br><span class="line">                        NULL                      /* p_rs */</span><br><span class="line">                        &#125;;</span><br><span class="line">	....</span><br><span class="line">	// back compatibility</span><br><span class="line">    if (s_started == 0) &#123;</span><br><span class="line">        RIL_startEventLoop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // start listen socket1</span><br><span class="line">    startListen(RIL_SOCKET_1, &amp;s_ril_param_socket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// startListen</span><br><span class="line">static void startListen(RIL_SOCKET_ID socket_id, SocketListenParam* socket_listen_p) &#123;</span><br><span class="line">    int fdListen = -1;</span><br><span class="line">    int ret;</span><br><span class="line">    char socket_name[10];</span><br><span class="line"></span><br><span class="line">    memset(socket_name, 0, sizeof(char)*10);</span><br><span class="line"></span><br><span class="line">    switch(socket_id) &#123;</span><br><span class="line">        case RIL_SOCKET_1:</span><br><span class="line">            strncpy(socket_name, RIL_getRilSocketName(), 9);</span><br><span class="line">            break;</span><br><span class="line">	....</span><br><span class="line">	// 获取 Unix domain socket对应的FD</span><br><span class="line">    fdListen = android_get_control_socket(socket_name);</span><br><span class="line">	// 监听端口	</span><br><span class="line">    ret = listen(fdListen, 4);</span><br><span class="line"></span><br><span class="line">    socket_listen_p-&gt;fdListen = fdListen;</span><br><span class="line">	// 设置监听回调事件 listenCallback，RILJ主动连接RILD时，处理该回调</span><br><span class="line">    /* note: non-persistent so we can accept only one connection at a time */</span><br><span class="line">    ril_event_set (socket_listen_p-&gt;listen_event, fdListen, false,</span><br><span class="line">                listenCallback, socket_listen_p);</span><br><span class="line">	//添加到事件队列中，并唤醒事件处理线程</span><br><span class="line">    rilEventAddWakeup (socket_listen_p-&gt;listen_event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>源代码： <code>/hardware/ril/libril/ril.cpp</code></p>
</blockquote>
<p>接下来，我们就来看一看LIBRIL与Vendor RIL各自提供的接口函数。 这两个接口都在<code>/hardware/ril/include/telephony/ril.h</code>中进行了声明。</p>
<p>Vendor RIL主要提供了5个接口，供LIBRIL调用：</p>
<ul>
<li><code>RIL_RequestFunc</code>是最主要的一个，所有从RILJ发送过来的请求均由该接口发送给Vendor RIL；</li>
<li><code>RIL_RadioStateRequest</code>从LIBRIL获取modem的即时状态；</li>
<li><code>RIL_Supports</code>判断Vendor RIL是否支持某个请求命令；</li>
<li><code>RIL_Cancel</code>取消某个请求命令；</li>
<li><code>RIL_GetVersion</code>获取RIL的版本号；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int version;        /* set to RIL_VERSION */</span><br><span class="line">    RIL_RequestFunc onRequest;</span><br><span class="line">    RIL_RadioStateRequest onStateRequest;</span><br><span class="line">    RIL_Supports supports;</span><br><span class="line">    RIL_Cancel onCancel;</span><br><span class="line">    RIL_GetVersion getVersion;</span><br><span class="line">&#125; RIL_RadioFunctions;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 将从RILJ发送过来的请求发送给Vendor RIL</span><br><span class="line">typedef void (*RIL_RequestFunc) (int request, void *data,</span><br><span class="line">                                    size_t datalen, RIL_Token t, RIL_SOCKET_ID socket_id);</span><br><span class="line">// 获取 modem 状态</span><br><span class="line">typedef RIL_RadioState (*RIL_RadioStateRequest)(RIL_SOCKET_ID socket_id);</span><br></pre></td></tr></table></figure>
<p>LIBRIL则向Vendor RIL提供了3个接口：</p>
<ul>
<li><code>OnRequestComplete</code>:RIL请求完成后，通过该接口将数据返回给LIBRIL，由LIBRIL将数据写入socket <code>RILD</code>;</li>
<li><code>OnUnsolicitedResponse</code>:CP主动上报消息给Vendor RIL后，通过该接口将消息传给LIBRIL;</li>
<li><code>RequestTimedCallback</code>:在指定时间内，LIBRIL调用回调函数<code>RequestTimedCallback</code>；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct RIL_Env &#123;</span><br><span class="line">	// 请求完成，返回给LIBRIL</span><br><span class="line">    void (*OnRequestComplete)(RIL_Token t, RIL_Errno e,</span><br><span class="line">                           void *response, size_t responselen);</span><br><span class="line"></span><br><span class="line">// Vendor RIL接收到从CP主动上报的消息后，传给LIBRIL</span><br><span class="line">#if defined(ANDROID_MULTI_SIM)</span><br><span class="line">    void (*OnUnsolicitedResponse)(int unsolResponse, const void *data, size_t datalen, RIL_SOCKET_ID socket_id);</span><br><span class="line">#else</span><br><span class="line">    /**</span><br><span class="line">     * &quot;unsolResponse&quot; is one of RIL_UNSOL_RESPONSE_*</span><br><span class="line">     * &quot;data&quot; is pointer to data defined for that RIL_UNSOL_RESPONSE_*</span><br><span class="line">     */</span><br><span class="line">    void (*OnUnsolicitedResponse)(int unsolResponse, const void *data, size_t datalen);</span><br><span class="line">#endif</span><br><span class="line">    /**</span><br><span class="line">     * Call user-specifed &quot;callback&quot; function on on the same thread that</span><br><span class="line">     * RIL_RequestFunc is called. If &quot;relativeTime&quot; is specified, then it specifies</span><br><span class="line">     * a relative time value at which the callback is invoked. If relativeTime is</span><br><span class="line">     * NULL or points to a 0-filled structure, the callback will be invoked as</span><br><span class="line">     * soon as possible</span><br><span class="line">     */</span><br><span class="line">	// 指定时间内LIBRIL调用回调函数RIL_TimedCallback</span><br><span class="line">    void (*RequestTimedCallback) (RIL_TimedCallback callback,</span><br><span class="line">                                   void *param, const struct timeval *relativeTime);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码路径： <code>/hardware/ril/rild/rild.c</code></p>
</blockquote>
<p>初始化完成了 ，那么RIL事件处理线程是从何时开始处理事件的了？RIL事件处理线程是怎么又是同时处理来自RILJ以及Vendor RIL的消息的？下面就来看一看LIBRIL如何处理RIL事件的。</p>
<h2 id="LIBRIL如何处理RIL事件"><a href="#LIBRIL如何处理RIL事件" class="headerlink" title="LIBRIL如何处理RIL事件"></a><strong>LIBRIL如何处理RIL事件</strong></h2><p>为处理RIL事件，LIBRIL提供了3个事件队列（由双向列表组成）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static struct ril_event * watch_table[MAX_FD_EVENTS];</span><br><span class="line">static struct ril_event timer_list;</span><br><span class="line">static struct ril_event pending_list;</span><br></pre></td></tr></table></figure>
<p>其中，<code>watch_table</code>用于事件的监测，<code>timer_list</code>保存定时事件，而<code>pending_list</code>用于保存即将被处理的事件列表。对LIBRIL来讲，有3种类型的RIL事件需要处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// RILJ请求事件</span><br><span class="line">static struct ril_event s_commands_event;</span><br><span class="line">// 事件处理线程唤醒事件</span><br><span class="line">static struct ril_event s_wakeupfd_event;</span><br><span class="line">// RILD socket端口监听事件</span><br><span class="line">static struct ril_event s_listen_event;</span><br></pre></td></tr></table></figure>
<p>上一节我们了解到，在RIL事件处理线程开始时，LIBRIL会添加一个<code>s_wakeupfd_event</code>的唤醒事件，必要时对线程进行唤醒操作；在注册Vendor RIL的接口时，注册一个监听事件<code>s_listen_event</code>，当RILJ尝试通过socket连接RILD时，处理该事件；当RILJ与RILD连接成功后，处理回调函数<code>listenCallback</code>时，会添加一个 <code>s_commands_event</code>事件，用于处理RILD socket的数据。</p>
<p>那么，LIBRIL是从何时开始处理这些事件的？上一节我们了解到，初始化时，LIBRIL启动了一个专门的线程来处理RIL事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void ril_event_loop()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    fd_set rfds;</span><br><span class="line">    struct timeval tv;</span><br><span class="line">    struct timeval * ptv;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line"></span><br><span class="line">        // make local copy of read fd_set</span><br><span class="line">        memcpy(&amp;rfds, &amp;readFds, sizeof(fd_set));</span><br><span class="line">		....</span><br><span class="line">		// 从FD集合中选择可用的端口</span><br><span class="line">        n = select(nfds, &amp;rfds, NULL, NULL, ptv);</span><br><span class="line">		....</span><br><span class="line">        // 处理timer队列中超时的事件</span><br><span class="line">        processTimeouts();</span><br><span class="line">        // 处理监测队列中的事件: listenCallback,</span><br><span class="line">        processReadReadies(&amp;rfds, n);</span><br><span class="line">        // OK，fire pending list</span><br><span class="line">        firePending();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该线程，一直监听FD(File Descriptor)集合<code>readFds</code>，如果有数据时，就会立即返回，进而开始执行事件的处理：首先处理定时事件队列中的event,如果发现有超时的事件，就将其加入pending队列中；接着，查看监测表（保存了最多8个事件）中是否有<code>readFds</code>对应的RIL事件，如果存在，则也将其放入到pending队列。最后，就要开始处理pending队列了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void firePending()</span><br><span class="line">&#123;</span><br><span class="line">    dlog(&quot;~~~~ +firePending ~~~~&quot;);</span><br><span class="line">    struct ril_event * ev = pending_list.next;</span><br><span class="line">    while (ev != &amp;pending_list) &#123;</span><br><span class="line">        struct ril_event * next = ev-&gt;next;</span><br><span class="line">        removeFromList(ev);</span><br><span class="line">		// 执行回调函数: processWakeupCallback,listenCallback,processCommandsCallback...</span><br><span class="line">        ev-&gt;func(ev-&gt;fd, 0, ev-&gt;param);</span><br><span class="line">        ev = next;</span><br><span class="line">    &#125;</span><br><span class="line">    dlog(&quot;~~~~ -firePending ~~~~&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>源码：<code>/android/hardware/ril/libril/samsung/ril_event.cpp</code></p>
</blockquote>
<p>LIBRIL事件处理线程开始时，只有两个事件：<code>s_wakeupfd_event</code>与<code>s_listen_event</code>，<code>s_wakeupfd_event</code>事件在添加<code>s_listen_event</code>事件，需要唤醒RIL事件处理线程被执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void triggerEvLoop() &#123;</span><br><span class="line">    int ret;</span><br><span class="line">    if (!pthread_equal(pthread_self(), s_tid_dispatch)) &#123;</span><br><span class="line">        /* trigger event loop to wakeup. No reason to do this,</span><br><span class="line">         * if we&apos;re in the event loop thread */</span><br><span class="line">         do &#123;</span><br><span class="line">            ret = write (s_fdWakeupWrite, &quot; &quot;, 1);</span><br><span class="line">         &#125; while (ret &lt; 0 &amp;&amp; errno == EINTR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，开始执行<code>s_listen_event</code>事件，调用回调函数<code>listenCallback</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void listenCallback (int fd, short flags, void *param) &#123;</span><br><span class="line">	....</span><br><span class="line">	// 接受RILJ的链接请求</span><br><span class="line">    fdCommand = accept(fd, (sockaddr *) &amp;peeraddr, &amp;socklen);</span><br><span class="line"></span><br><span class="line">    /* check the credential of the other side and only accept socket from</span><br><span class="line">     * phone process</span><br><span class="line">     */</span><br><span class="line">    is_phone_socket = 0;</span><br><span class="line"></span><br><span class="line">    err = getsockopt(fdCommand, SOL_SOCKET, SO_PEERCRED, &amp;creds, &amp;szCreds);</span><br><span class="line">	</span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line">    ret = fcntl(fdCommand, F_SETFL, O_NONBLOCK);</span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line">    p_info-&gt;fdCommand = fdCommand;</span><br><span class="line">	</span><br><span class="line">    p_rs = record_stream_new(p_info-&gt;fdCommand, MAX_COMMAND_BYTES);</span><br><span class="line"></span><br><span class="line">    p_info-&gt;p_rs = p_rs;</span><br><span class="line">    ril_event_set (p_info-&gt;commands_event, p_info-&gt;fdCommand, 1,</span><br><span class="line">        p_info-&gt;processCommandsCallback, p_info);</span><br><span class="line">	// 添加指令事件`s_commands_event`</span><br><span class="line">    rilEventAddWakeup (p_info-&gt;commands_event);</span><br><span class="line">	// 建立新的连接，告知RILJ链接成功，并上报radio状态</span><br><span class="line">    onNewCommandConnect(p_info-&gt;socket_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下次处理pending事件队列时，处理<code>s_commands_event</code>,调用回调函数<code>processCommandsCallback</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	static void processCommandsCallback(int fd, short flags, void *param) &#123;</span><br><span class="line">		// 循环读 RILD socket接口数据流</span><br><span class="line">	    for (;;) &#123;</span><br><span class="line">	        /* loop until EAGAIN/EINTR, end of stream, or other error */</span><br><span class="line">			// 读取 socket数据流</span><br><span class="line">	        ret = record_stream_get_next(p_rs, &amp;p_record, &amp;recordlen);</span><br><span class="line">	</span><br><span class="line">	        if (ret == 0 &amp;&amp; p_record == NULL) &#123;</span><br><span class="line">	            /* end-of-stream */</span><br><span class="line">	            break;</span><br><span class="line">	        &#125; else if (ret &lt; 0) &#123;</span><br><span class="line">	            break;</span><br><span class="line">	        &#125; else if (ret == 0) &#123; /* &amp;&amp; p_record != NULL */</span><br><span class="line">	            processCommandBuffer(p_record, recordlen, p_info-&gt;socket_id);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">		....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// processCommandBuffer</span><br><span class="line">	static int processCommandBuffer(void *buffer, size_t buflen, RIL_SOCKET_ID socket_id) &#123;</span><br><span class="line">	</span><br><span class="line">	    RequestInfo *pRI;</span><br><span class="line">		...</span><br><span class="line">	    pRI = (RequestInfo *)calloc(1, sizeof(RequestInfo));</span><br><span class="line">	</span><br><span class="line">	    pRI-&gt;token = token;</span><br><span class="line">		// 根据 RILJ的REQUEST类型来获取CommandInfo</span><br><span class="line">	    pRI-&gt;pCI = &amp;(s_commands[request]);</span><br><span class="line">	    pRI-&gt;socket_id = socket_id;</span><br><span class="line">		...</span><br><span class="line">		// 将请求分配给对应的函数处理</span><br><span class="line">	    pRI-&gt;pCI-&gt;dispatchFunction(p, pRI);</span><br><span class="line">	</span><br><span class="line">	    return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>s_commands</code>将所有RILJ的请求命令，对应的请求函数以及响应处理函数组成一个类型为<code>commandInfo</code>的结构体数组，等请求从CP返回时，就可以调用对应的响应函数来处理返回的结果了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static CommandInfo s_commands[] = &#123;</span><br><span class="line">	#include &quot;ril_commands.h&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">   &#123;0, NULL, NULL&#125;,                   //none</span><br><span class="line">   &#123;RIL_REQUEST_GET_SIM_STATUS, dispatchVoid, responseSimStatus&#125;,</span><br><span class="line">   &#123;RIL_REQUEST_ENTER_SIM_PIN, dispatchStrings, responseInts&#125;,</span><br><span class="line">   &#123;RIL_REQUEST_ENTER_SIM_PUK, dispatchStrings, responseInts&#125;,</span><br><span class="line">   &#123;RIL_REQUEST_ENTER_SIM_PIN2, dispatchStrings, responseInts&#125;,</span><br><span class="line">   &#123;RIL_REQUEST_ENTER_SIM_PUK2, dispatchStrings, responseInts&#125;,</span><br><span class="line">   &#123;RIL_REQUEST_CHANGE_SIM_PIN, dispatchStrings, responseInts&#125;,</span><br><span class="line">   &#123;RIL_REQUEST_CHANGE_SIM_PIN2, dispatchStrings, responseInts&#125;,</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<blockquote>
<p>源码： <code>/android/hardware/ril/libril/samsung/ril_commands.h</code></p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li>源码： <a href="http://androidxref.com/5.1.1_r6/" target="_blank" rel="noopener">androidxref - 5.1</a></li>
<li><a href="http://blog.csdn.net/maxleng/article/details/5576637" target="_blank" rel="noopener">http://blog.csdn.net/maxleng/article/details/5576637</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> RIL </tag>
            
            <tag> RILD </tag>
            
            <tag> Telephony </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android RIL概述]]></title>
      <url>http://sniffer.site/2016/11/19/Android-RIL%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>Android作为一个通用的移动平台，其首要的功能就是通话、短信以及上网等通信功能。那么，从系统的角度来看，Android究竟是怎么实现与网络的交互的了？ 这篇文章里，就来看一看Android中负责通信功能的Telephony中间层，通常也被称之为RIL(Radio Interface Layer)的具体实现原理与架构。</p>
<p>Android手机要实现与网络端的通信，需要跨越两个层：</p>
<ul>
<li>RIL Java(RILJ)：负责将上层APP的通信请求发送给HAL层；</li>
<li>RIL C++(RILD)： 系统守护进程，负责将RILJ的请求命令发送给CP(Communication Processor)</li>
</ul>
<h2 id="什么是RIL"><a href="#什么是RIL" class="headerlink" title="什么是RIL"></a><strong>什么是RIL</strong></h2><p>简单的说，RIL(Radio Interface Layer)，就是将应用程序的通信请求发送给CP的中间层，其包括两个部分，一个是Java层RILJ,一个是C++层（不妨看作是CP对应的HAL层）RILD。 </p>
<p>RILJ属于系统Phone进程的一部分，随Phone进程启动而加载；而RILD守护进程是通过Android的Init进程进行加载的。</p>
<h2 id="RIL结构"><a href="#RIL结构" class="headerlink" title="RIL结构"></a><strong>RIL结构</strong></h2><p>下图是一个Android RIL的一个结构图。整个通信过程有四个层：</p>
<ul>
<li>最上层的是应用程序，如通话，短信以及SIM卡管理，它们主要负责将用户的指令发送到RIL Framework(以后统称RILJ）；</li>
<li>RILJ为上层提供了通用的API，如TelephonyManager(包括通话，网络状态； SubscriptionManager(卡状态）以及SmsManager等，同时RILJ还负责维持与RILD的通信，并将上层的请求发送给RILD；</li>
<li>RILD是系统的守护进程，对于支持通话功能的移动平台是必不可少的。RILD的功能主要功能是将RILJ发送过来的请求继续传递给CP，同时会及时将CP的状态变化发送给RILJ；</li>
<li>Linux驱动层：kernel驱动层接受到数据后，将指令传给CP，最后由CP发送给网络端，等网络返回结果后，CP将传回给RILD；</li>
</ul>
<p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/android_ril_architecture.png" alt="RIL Architecture"></p>
<p>RILJ与RILD（RILD与CP的通信）都是通过一个个消息进行数据传递。消息主要分两种：一种是RILJ主动发送的请求（solicited），常见的有<code>RIL_REQUEST_GET_SIM_STATUS</code>(获取SIM卡状态）， <code>RIL_REQUEST_DIAL</code>(拨打电话），<code>RIL_REQUEST_SEND_SMS</code>（发送短信）， <code>RIL_REQUEST_GET_CURRENT_CALLS</code>（获取当前通话状态），<code>RIL_REQUEST_VOICE_REGISTRATION_STATE</code>（获取网络状态）； 另一种则是从CP主动上报给RIL的消息（unsolicited)，如网络状态发生变化时，CP会上报<code>RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED</code>，有新短信时，会上报<code>RIL_UNSOL_RESPONSE_NEW_SMS</code>，有来电时会上报<code>RIL_UNSOL_CALL_RING</code>。</p>
<blockquote>
<p>RIL相关的请求命令与数据结构都定义在<code>/android/hardware/ril/include/telephony/ril.h</code></p>
</blockquote>
<p>在整个过程中，有几个关键问题：</p>
<ol>
<li>上层是如何得知RILJ状态变化的；</li>
<li>RILJ与RILD是怎么进行通信的？</li>
<li>RILJD与CP又是如何进行通信的？</li>
</ol>
<p>围绕这三个问题点，我们来看一下具体的细节。</p>
<h3 id="上层如何得知RILJ状态变化"><a href="#上层如何得知RILJ状态变化" class="headerlink" title="上层如何得知RILJ状态变化"></a><strong>上层如何得知RILJ状态变化</strong></h3><p>为方便上层实时监听网络状态、通话状态以及CP的状态变化，RIL提供了一个专门的监听接口<code>IPhoneStateListener.aidl</code>，上层需要监听上述状态变化时，只需要实现上述接口,并在Android系统服务TelephonyRegistry中对上述接口实现进行注册：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void listen(String pkgForDebug, IPhoneStateListener callback, int events, boolean notifyNow);</span><br></pre></td></tr></table></figure>
<p>另外，也可以在TelephonyManager中对RIL状态进行监听：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void listen(PhoneStateListener listener, int events)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>源代码: <code>/android/frameworks/base/telephony/java/com/android/internal/telephony/IPhoneStateListener.aidl</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">oneway interface IPhoneStateListener &#123;</span><br><span class="line">	void onServiceStateChanged(in ServiceState serviceState);</span><br><span class="line">	void onSignalStrengthChanged(int asu);</span><br><span class="line">	void onMessageWaitingIndicatorChanged(boolean mwi);</span><br><span class="line">	void onCallForwardingIndicatorChanged(boolean cfi);</span><br><span class="line"></span><br><span class="line">	// we use bundle here instead of CellLocation so it can get the right subclass</span><br><span class="line">	void onCellLocationChanged(in Bundle location);</span><br><span class="line">	void onCallStateChanged(int state, String incomingNumber);</span><br><span class="line">	void onDataConnectionStateChanged(int state, int networkType);</span><br><span class="line">	void onDataActivity(int direction);</span><br><span class="line">	void onSignalStrengthsChanged(in SignalStrength signalStrength);</span><br><span class="line">	void onOtaspChanged(in int otaspMode);</span><br><span class="line">	void onCellInfoChanged(in List&lt;CellInfo&gt; cellInfo);</span><br><span class="line">	void onPreciseCallStateChanged(in PreciseCallState callState);</span><br><span class="line">	void onPreciseDataConnectionStateChanged(in PreciseDataConnectionState dataConnectionState);</span><br><span class="line">	void onDataConnectionRealTimeInfoChanged(in DataConnectionRealTimeInfo dcRtInfo);</span><br><span class="line">	void onVoLteServiceStateChanged(in VoLteServiceState lteState);</span><br><span class="line">	void onOemHookRawEvent(in byte[] rawData);</span><br><span class="line">	void onCarrierNetworkChange(in boolean active);</span><br><span class="line">	void onFdnUpdated();</span><br><span class="line"></span><br><span class="line">	void onVoiceRadioBearerHoStateChanged(int state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RILJ与RILD如何通信"><a href="#RILJ与RILD如何通信" class="headerlink" title="RILJ与RILD如何通信"></a><strong>RILJ与RILD如何通信</strong></h3><p>RILJ在创建过程中，会启动两个线程：RILSender和RILReceiver,RILSender负责将指令发送给RILD,而RILReceiver则负责从读取从RILD发送过来的数据。RILJ与RILD的通信通道就是在RILReceiver中建立起来的。</p>
<p>我们来看一看RILReciver的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  class RILReceiver implements Runnable &#123;</span><br><span class="line">      byte[] buffer;</span><br><span class="line"></span><br><span class="line">      RILReceiver() &#123;</span><br><span class="line">...</span><br><span class="line">      @Override</span><br><span class="line">      public void</span><br><span class="line">      run() &#123;</span><br><span class="line">          int retryCount = 0;</span><br><span class="line">          String rilSocket = &quot;rild&quot;;</span><br><span class="line"></span><br><span class="line">	// 尝试与RILD建立连接</span><br><span class="line">          try &#123;for (;;) &#123;</span><br><span class="line">              LocalSocket s = null;</span><br><span class="line">              LocalSocketAddress l;</span><br><span class="line"></span><br><span class="line">              if (mInstanceId == null || mInstanceId == 0 ) &#123;</span><br><span class="line">                  rilSocket = SOCKET_NAME_RIL[0];</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  rilSocket = SOCKET_NAME_RIL[mInstanceId];</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              try &#123;</span><br><span class="line">                  s = new LocalSocket();</span><br><span class="line">                  l = new LocalSocketAddress(rilSocket,</span><br><span class="line">                          LocalSocketAddress.Namespace.RESERVED);</span><br><span class="line">                  s.connect(l);</span><br><span class="line">              &#125; catch (IOException ex)&#123;</span><br><span class="line">			...</span><br><span class="line">                  // don&apos;t print an error message after the the first time</span><br><span class="line">                  // or after the 8th time</span><br><span class="line"></span><br><span class="line">                  if (retryCount == 8) &#123;</span><br><span class="line">                      Rlog.e (RILJ_LOG_TAG,</span><br><span class="line">                          &quot;Couldn&apos;t find &apos;&quot; + rilSocket</span><br><span class="line">                          + &quot;&apos; socket after &quot; + retryCount</span><br><span class="line">                          + &quot; times, continuing to retry silently&quot;);</span><br><span class="line">                  &#125; else if (retryCount &gt;= 0 &amp;&amp; retryCount &lt; 8) &#123;</span><br><span class="line">                      Rlog.i (RILJ_LOG_TAG,</span><br><span class="line">                          &quot;Couldn&apos;t find &apos;&quot; + rilSocket</span><br><span class="line">                          + &quot;&apos; socket; retrying after timeout&quot;);</span><br><span class="line">                  &#125;</span><br><span class="line">			...</span><br><span class="line"></span><br><span class="line">                  retryCount++;</span><br><span class="line">                  continue;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              retryCount = 0;</span><br><span class="line">              mSocket = s;</span><br><span class="line"></span><br><span class="line">		// 从socket读取数据</span><br><span class="line">              int length = 0;</span><br><span class="line">              try &#123;</span><br><span class="line">                  InputStream is = mSocket.getInputStream();</span><br><span class="line"></span><br><span class="line">                  for (;;) &#123;</span><br><span class="line">                      Parcel p;</span><br><span class="line"></span><br><span class="line">                      length = readRilMessage(is, buffer);</span><br><span class="line"></span><br><span class="line">                      if (length &lt; 0) &#123;</span><br><span class="line">                          // End-of-stream reached</span><br><span class="line">                          break;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                      p = Parcel.obtain();</span><br><span class="line">                      p.unmarshall(buffer, 0, length);</span><br><span class="line">                      p.setDataPosition(0);</span><br><span class="line"></span><br><span class="line">                      processResponse(p);</span><br><span class="line">                      p.recycle();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; catch (java.io.IOException ex) &#123;</span><br><span class="line">                  Rlog.i(RILJ_LOG_TAG, &quot;&apos;&quot; + rilSocket + &quot;&apos; socket closed&quot;,</span><br><span class="line">                        ex);</span><br><span class="line">              &#125; catch (Throwable tr) &#123;</span><br><span class="line">                  Rlog.e(RILJ_LOG_TAG, &quot;Uncaught exception read length=&quot; + length +</span><br><span class="line">                      &quot;Exception:&quot; + tr.toString());</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">		//无法读取数据，将CP状态设置为不可用</span><br><span class="line">              setRadioState (RadioState.RADIO_UNAVAILABLE);</span><br><span class="line">		...</span><br><span class="line">              mSocket = null;</span><br><span class="line">              RILRequest.resetSerial();</span><br><span class="line"></span><br><span class="line">              // Clear request list on close</span><br><span class="line">              clearRequestList(RADIO_NOT_AVAILABLE, false);</span><br><span class="line">          &#125;&#125; catch (Throwable tr) &#123;</span><br><span class="line">              Rlog.e(RILJ_LOG_TAG,&quot;Uncaught exception&quot;, tr);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>RILReceiver启动时，会建立一个UNIX Domain socket(LocalSocket，kernel层对应<code>/dev/socket/rild</code>)，与RILD进行通信，然后一直从socket中读取数据,并将数据传给上层。连接成功后，RILD会发送一个消息给RILJ，表示连接成功了，这样RILJ就可以将请求数据发送给RILD，进行通信了。</p>
<h3 id="RILD与CP如何进行通信"><a href="#RILD与CP如何进行通信" class="headerlink" title="RILD与CP如何进行通信"></a><strong>RILD与CP如何进行通信</strong></h3><p>RILD与CP（可以看做是两个运行在不同CPU上的进程通信）交换数据方式一般有两种情况。如果AP与CP集中在一个芯片上，如高通的平台就是将AP与CP集中在一块芯片上，这时通常采用共享内存的方式实现跨进程通信；而如果不是在同一块芯片，而是AP与CP分别采用不同厂商的平台，则一般采用字符设备(character devices) 进行通信。总的说来，共享内存的方式在速度上要优于字符设备。</p>
<p>接下来，主要介绍下RILJ部分的代码结构。</p>
<h2 id="RILJ代码结构"><a href="#RILJ代码结构" class="headerlink" title="RILJ代码结构"></a><strong>RILJ代码结构</strong></h2><p>RIL Framework (RILJ)的代码按照功能来划分的话，主要有以下几个组成部分：</p>
<ul>
<li>管理网络状态（信号强度，网络注册状态等）:<code>ServiceStateTracker</code>等；</li>
<li>通话管理（拨号，接听，呼叫等待等）： <code>CallManager</code>,<code>GsmCallTracker</code>等</li>
<li>SMS短信接收发送： <code>InboundSMSHandler</code>,<code>SmsDispater</code>等</li>
<li>SIM卡管理： <code>UiccController</code>, <code>SubscriptionsController</code>等</li>
<li>数据链接管理： <code>DcTracker</code>,<code>DctController</code>等</li>
<li>Telephony 大管家： <code>PhoneBase</code>,<code>GsmPhone</code>,<code>PhoneProxy</code>等</li>
</ul>
<p>以上代码主要位于两个目录：</p>
<ul>
<li><code>/android/frameworks/opt/telephony/</code> （负责与RILD交互）</li>
<li><code>/android/frameworks/base/telephony/</code> （对上层提供接口）</li>
</ul>
<p>下面，以拨打电话的流程作为示例看一看RIL是如何发挥作用的。</p>
<h2 id="示例：-CALL流程"><a href="#示例：-CALL流程" class="headerlink" title="示例： CALL流程"></a>示例： <strong>CALL流程</strong></h2><p>下述是一个MO(Mobile Originated) 通话流程概要：</p>
<ol>
<li>APP向<code>TelecomManager</code>发送拨号请求（关于<code>TelecomManager</code>可以参考另一篇文章<a href="http://blog.csdn.net/jason_wzn/article/details/58164251" target="_blank" rel="noopener">Android Telecom系统服务</a>）；</li>
<li><code>TelecomManager</code>将通话请求发送给<code>GsmPhone</code>；</li>
<li><code>GsmPhone</code>继续将指令传递给<code>GsmCallTracker</code>；</li>
<li><code>GsmCallTracker</code>调用RILJ，RILJ将通话请求发送给RILD；</li>
<li><code>RILD</code>接收到通话指令时，发送给CP；</li>
<li>CP发送给网络，MT(Mobile Terminal)收到通话后，告知网络，由网络将该信息传递给MO已将通话信息发送给MT了（就是手机发出嘟嘟声音的时候）：通话状态由DIALING –&gt; ALERTING；</li>
<li>RILD收到通话状态变化的消息后，发送一个UNSOL_RESPONSE_CALL_STATE_CHANGED的消息给RILJ；</li>
<li>RILJ通知<code>GsmCallTracker</code>通话状态变化了；</li>
<li><code>GsmCallTracker</code>主动查询CALL状态：<code>pollCallWhenSafe()</code>，确保得到的信息是对的，没有发生变化；</li>
<li>RILJ给RILD发送<code>getCurrentCalls()</code>的请求；</li>
<li>RILD获取到CALL状态后，上报给RILJ，再由RILJ返回结果给<code>GsmCallTracker</code></li>
<li><code>GsmCallTracker</code>得到确定的CALL状态后，通知<code>GsmPhone</code>：<code>notifyPreciseCallStateChanged()</code>;</li>
<li><code>GsmPhone</code>将CALL状态变化的消息告知<code>Telecom</code>系统服务；</li>
<li>最后，<code>Telecom</code>系统服务发送CALL状态变化的广播给上层APP</li>
</ol>
<p>到这一步后，通话并没有开始，如果MT接听了电话，则MO会收到CALL状态变化的信息，然后，才真正开始建立通话链接。</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> RIL </tag>
            
            <tag> RILD </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《通往奴役之路》读书摘记]]></title>
      <url>http://sniffer.site/2016/11/04/%E3%80%8A%E9%80%9A%E5%BE%80%E5%A5%B4%E5%BD%B9%E4%B9%8B%E8%B7%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>连生活都要成为艺术</p>
<pre><code>木心
</code></pre></blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>出于对社会主义制度演变的兴趣，一直想读哈耶克(维基百科：<a href="https://en.wikipedia.org/wiki/Friedrich_Hayek" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Friedrich_Hayek</a> ）的书。最近利用闲暇时间看完了这本久负盛名的《通往奴役之路》，做了点摘记。里边讲了社会主义理论的本质特征，讲了集体主义与个人自由的冲突，讲了垄断与竞争，看看这样的书，算是对自己以往认知的一个纠正与弥补。以后还要继续读一读哈耶克其他的著作，如《致命的自负》，《自由秩序原理》，也好看一看社会主义究竟是怎样的一幅美景。</p>
<a id="more"></a>
<h2 id="摘记"><a href="#摘记" class="headerlink" title="摘记"></a>摘记</h2><ul>
<li><p>如果从长远考虑，我们是自己命运的创造者，那么，从短期着眼，我们就是我们所创造的观念的俘虏。只有我们及时认识到这种危险，才能指望去避免它。</p>
</li>
<li></li>
<li><p>我们这一代人的共同信念讲把我们引向何处，并不是某一党派的问题，而是我们每一个人的问题，是一个有着最重大意义的问题。在我们竭尽全力自觉地根据一些崇高的理想缔造我们的未来时，我们却在实际上不知不觉的创造出与我们一直为之奋斗的东西截然相反的结果，人们还想象的出比这更大的悲剧吗？</p>
</li>
<li><p>由基督教与古典哲学提供基本原则的个人主义，在文艺复兴时代第一次得到充分发展，此后逐渐成长和发展为我们所了解的西方文明。这种个人主义的基本特征，就是把个人当做人来尊重；就是在他自己的范围内承认他的看法和趣味是至高无上的。纵然这个范围可能被限制的很狭隘；也就是相信人应该发展摘记的天赋和爱好。  “Freedom”和”liberty”这些字眼儿常常被滥用，以致我们在使用它们表明它们当时所代表的理想时，也颇费踌躇。宽容或许时唯一还能保留这个原则完整意义的字眼儿，这个原则在那个时期整个过程中处于上升状态，只是在近来才又趋于低落，且将随极权主义国家的兴起而彻底消亡。</p>
</li>
<li><p>如常有的情况那样，对我们文明的性质，敌人往往比多数朋友看的更清楚:19世纪的极权主义者奥古斯特-孔德所描述的那样：“西方的长年痼疾，是个体对种属的反抗”，实际上时构建我们文明的力量，１９世纪对前一世纪的个人主义增益，仅仅使所有阶级都意识到自由，把偶然地和拼凑地成长起来的东西加以系统和连续的发展，并将其从英国和荷兰传播到欧洲大陆的大部分地区。</p>
</li>
<li><p>这一成就在未来可能会出现的最有意义和最深远的影响，是一种控制他们自己命运力量的新感觉，是那种对于改善自己命运的无限可能性的信心，这些都是已经取得成就在人们中间创造的。随着成功也就发展出雄心－而人们具有一切权利怀有勃勃雄心。曾经激励人心的承诺似乎不再足够了，进步的速度太迟缓了；过去曾使这一发展成为可能的那些原则，现在则被视为阻止更快进展的障碍，迫切需要消除，而不把它视为保持和发展已经取得成就的条件了。</p>
</li>
<li><p>总是使一个国家变成人间地狱的东西，恰恰时人们试图将其变成天堂。(F-荷尔德林)</p>
</li>
<li><p>没有人比德-托克维尔更清楚的意识到，民主在本质上是一种个人主义的制度，与社会主义有这不可调和的冲突，（他在1848年说:）民主扩展个人自由的范围，而社会主义却对其加以限制。民主尽可能地赋予每一个人价值，而社会主义却仅仅使每一个人成为一个工具、一个数字。民主和社会主义除了“平等”一词之外毫无共同之处。但请注意这个区别：民主在自由之中寻求平等，而社会主义则在约束和奴役之中寻求平等。</p>
</li>
<li><p>“马克思主义已经导致了法西斯主义和民族社会主义，因为就其全部本质而言，它就是法西斯主义和民族社会主义“，而沃尔特-李普曼博士也获得了这种信念：</p>
</li>
</ul>
<blockquote class="blockquote-center"><p>我们所属的这一代人现在正从经验中懂得，当人们放弃自由，转而强制性地将其事务加以组织的时候，情况会怎么样。尽管他们期望一种更富裕的生活，但他们在实践中肯定放弃了这种期望；随着有组织管理的增加，目标的多样化必定会让位于一体化。这是对有计划的社会和人类事务中独裁主义原则的报应。</p>
</blockquote>
<ul>
<li><p>竞争和集中管理二者如果是不完全的，都将成为拙劣和无效率的工具，它们是用来解决同一问题时只能任择其一的原则，把两者混合起来就意味着哪一个也不能真正地起作用，其结果反而比始终只凭二者之一的情况还要槽糕些。或者换一种说法：计划与竞争只有在为竞争而计划而不是运用计划反对竞争的时候，才能够结合起来。</p>
</li>
<li><p>倾向垄断和计划的趋势，并不是我们不能控制的”客观事实“的结果，而是种种看法的产物，这些看法酝酿和传播到半个世纪之久，最后它们到达了支配我们一切政策的因素。</p>
</li>
<li><p>但我们必须首先考虑一下，现代技术的这种发展在多大程度上使广泛领域中垄断的发展不可避免。</p>
</li>
<li><p>应当注意，垄断的形成常常是规模大成本低以外种种因素的结果。它通过相互串通的协定而形成并为公开的政策所促进。当这些协定失效和当这些政策扭转过来时，竞争的条件能够恢复的。</p>
</li>
<li><p>在社会演进中，没有什么东西不可避免的，使其成为不可避免的是思想。</p>
</li>
<li><p>虽然在短时期内我们为多样化和选择的自由所必须付出的代价有时可能是很高的，但在长期内即使是物质福利的进展也将有赖于这种多样性，因为我们不能预见从那些可以提供商品或劳务的许多形态中，究竟哪一种可能发展出更好的东西来。</p>
</li>
<li><p>在一个经济生活受到彻底管制的国家中，甚至形式上承认个人权利或少数人的平等权利都会失去任何意义，对于这一点中欧各个国家的经验给予了充分的说明。那里的经验还表明，完全可能通过运用公认的经济政策方面的工具赖推行一种无情的歧视少数民族的政策，同时又保护少数民族权利法规中文字没有任何侵犯。这种以经济政策为手段的压迫由于以下事实而得到极大的促进：某些产业或活动基本上是由少数民族来从事的，因此，许多表面上针对一个产业或一个职业阶层的措施实际上是指向一个少数民族的。</p>
</li>
<li><p>人们常说，没有经济自由的政治自由是没有意义的。这当然对，但在某种意义上，它是和我们的计划着使用这句话的意思几乎相反。作为任何其他自由前提的经济自由，不能是那种社会主义着允诺给我们的、免于经济劳心的自由，也不可能是只能通过解决个人选择的必要性和权力才能获得的自由；经济自由必须是我们经济活动的自由，这种自由，因其具有选择的权利，不可避免地带来那种权利的风险与责任。</p>
</li>
<li><p>我们这一代已经忘了的是:私有制是自由的最重要的保障。</p>
</li>
<li><p>私有财产制度是给人以有限的自由与平等的主要因素之一，而马克思则希望通过消除这个制度来给与人们以无限的自由与平等。奇怪得很，马克思是第一个看到这一点的。是他告诉我们：回顾以往，私人资本主义连同其自由市场的发展成了我们一切民主自由的发展的先决条件。他从未想到，向前瞻望，如果是他所说的那样，那些其他的自由，恐怕就会随着自由市场的取消而消逝。</p>
</li>
<li><p>证明某种计划是正当的这一工作所需要的不是合理的说服，而是接受信条。其实，各地的社会主义者都最先承认：他们承担的任务要求普遍承认一个共同的世界观，一套明确的价值标准。社会主义者正是在发动一个受到这样一个单一世界观支持的群众运动的努力中，首先创造出了这些灌输工具中的最大部分，这些灌输工具也是纳粹和法西斯主义者有效的加以利用过。</p>
</li>
<li><p>有意识控制的可能性只限于存在真正一致的领域中，而在一些领域中必须听任事情的自由发展，这就是民主的代价。但在一个依赖中央计划行使其职能的社会中，就不可能让这种控制依赖于能达成多数一致；将一个微弱少数的意志强加给人民，这往往是必要的，因为这个少数将是人民中间对有争议的问题能达成一致的最大集体。只要政府的职能能根据一种广为接受的信念，能限定在多数人中通过自由讨论能达成一致的领域时，民主政府便能有效地运行。</p>
</li>
<li><p>撇开所有的技术细节不论，法制的意思就是指政府在一切行动中都受到事前规定并宣布的规则的约束－这种规则使得一个人有可能十分肯定地预见到当局在某一种情况会怎样使用它的强制权力，和根据对此的了解计划它自己的个人事务。虽然因为立法者及那些受委托执行法律的大都是不可能不犯错误的凡人，从而这个理想也永远不可能达到尽善尽美的地步，但是法治的基本点是很清楚的：即留给执掌强制权力的执行机构的行动自由，应当减少到最低限度。虽则每一条法律，通过变动人们可能用以追求其目的的手段而在一定程度上限制了个人自由，但是在法治之下，却防止了政府采取特别的行动破坏个人的行动。</p>
</li>
<li><p>只要政府政策对某种人的精确的影响是已知的，只要政府的直接目的是要达到那些特定的影响，它就不能不了解这些影响，因而也就不能做到不偏不倚。它必定有所偏袒，把它的评价强加于人民，并且，不是帮助他们实现自己的目标，而是为他们选择目标。只要当制定法律的时候就已预见到这些特定的影响，那么，法律就不再仅仅是一个供人民使用的工具，反而成为立法者为了他的目的而影响人民的工具。政府不再是一个旨在帮助个人充分发展其个性的实用的机构，而成为一个“道德的”机构－这里的“道德的”一词不是作为“不道德”的反义词来使用的，而是指这样一种机构，它把它对一切道德问题的观点都强加于其成员，而不管这种观点是道德的或者非常不道德的。在这种意义上，纳粹或者其他任何集体主义的国家都是“道德的”，而自由主义国家则不是。</p>
</li>
<li><p>只有在自由主义时代，法制才被有意识地加以发展，并且是自由主义时代最伟大的成就之一，它不仅是自由的保障，而且也是自由在法律上的体现。正像康德所说的那样（并且在他以前，伏尔泰也用非常相似的措辞说过），“如果一个人不需要服从任何人，只服从法律，那么，他就是自由的。”</p>
</li>
<li><p>因此，如果说，在一个有计划的社会，法治不能保持，这并不是说，政府的行动将不是合法的，或者说，这样一种社会就一定是没有法律的。它只是说，政府强制权力的使用不再受事先规定的规则的限制和决定。法律能够（并且为了集中管理经济活动也必须）使那种实质上是专断的行动合法化。如果法律规定某一部门或当局可以为所欲为，那么，那个部门和当局所做的任何事都是合法的－但它的行动肯定地不不是在受法制原则的支配。通过赋予政府以无限制的权力，可以把最专断的统治合法化；并且一个民主制度就可以以这样的一种方式建立起一种可以想象得到的最完全的专制政治来。</p>
</li>
<li><p>只要社会主义运动在一个国家里同一个特定的集团－通常是技术较高的工人－的利益密切的结合起来，对社会各阶层人民的应用地位形成一种共同观点的问题，就比较简单。这种运动直接关涉到某个特定集团的地位，并且，它的目的就是要提高那个集团与其他集团之间的相对地位。但在向社会主义继续前进的过程中，这个问题的性质就会发生变化，每个人越来越明显地看到，他的收入和一般地位要由国家的强制性机器来决定，为了保持或改善其地位，唯有成为一个有组织集团的成员，那个集团能够根据其利益影响或者支配国家机器。</p>
</li>
<li><p>这个问题当然是更加重要的，因为事实上除非与他们自己的利益直接相关，不然的话，世界上的人们是不太可能作出最大努力的。对大多数人来说，要竭尽全力做某事，就需要施加某种外来的压力。在这个意义上，刺激的问题是一个现实的问题，无论在一般的劳动中或管理活动方面都一样，把工程技术应用于整个国家（这就是计划的意义）“会引起一些难于解决的纪律问题”，这是一位对政府计划有很多经验，并且把这一问题看的清楚的美国工程师所讲的话。</p>
</li>
<li><p>如果需要一个人数众多的、有足够力量能把他们自己对生活的标准价值的看法强加在其余所有的人身上的集团，那么，它的构成者绝不会是具有高度不同的和高度发展的趣味的人，而是那些构成“群众”（就这一名词的贬义而言的），很少有创造性和独立性，是那些能够把人数方面的分量作为他们的理想后盾的人。</p>
</li>
<li><p>只有在存在着、或者有可能建立各个人的统一目标的地方，集体主义的社会才能得到发展，这是一个基本事实，除此之外还有一些因素助长了集体主义的门户之见和唯我独尊的倾向。其中一个最重要的因素是个人认同于一个集团的愿望，这常常是一种自卑感引起的，因而，只有那个集团的成员资格能够使他比这个集团之外的大有优越性，他的需要才会得到满足。</p>
</li>
<li><p>每个集体主义制度都有两个主要特征，首先，需要有一个为整个集团共同接受的目标体系，另外，还需要为了达到这些目标而给予该集团以最大限度的权力的压倒一切的愿望，从这种特征产生了一个特定的道德体系，这个道德体系有些方面是同我们的体系相符的，而有些地方则与我们的体系形成了强烈的对比－但其中有一点同我们的体系不同，这使我们怀疑是否能够称之为道德，即它不让个人的良心自由地运用它自己的规则，甚至也没有个人在任何环境中都必须或可以遵守一般性的规则。这便是集体主义道德和我们所知道的那些道德有那么大的区别，以致我们很难在他们仍然保持的那些道德中发现任何原则。</p>
</li>
<li><p>所有权力都易腐化，绝对的权力则绝对地会腐化。</p>
</li>
<li><p>迷信科学，认为科学可以适应于包括道德领域在内的一切领域，我重申，这是19世纪的一种认识。至于那些鼓吹这个学说的人是否真的信仰它，或者他们是否只是想为他们内心的情感披上一种科学威望的外衣，而他们完全知道它只是一种热情而已，这还有待于通过考察去发现。应当注意的是，历史服从于科学的规律这一教条特别被主张专制权力的人所宣传，这是很自然的。因为这个教条可以消除他们最恨的两种现实，即人类自由和个人的历史活动。</p>
</li>
<li><p>他们（集体主义者）似乎还缺少大多数很细小的、但很重要的品质，就是在一个自由社会里会促进人与人之间相互交往的那些品质：和蔼和幽默感，个人谦逊，尊重别人的隐私和对邻人的善意怀有信任。</p>
</li>
<li><p>集体主义者为了达到他们的目的，必须建立起前所未有的巨大权力－人支配人的那种权力－并且他们的成功也取决于他们获得这种权力的程度。</p>
</li>
<li><p>社会主义只有停留在理论层面时，它才是国际主义的，无论是德国还是在俄国，它就马上变成强烈的民族主义。这就从一个方面说明了西方世界大多数人所想象的那种“自由社会主义”何以是纯理论的，而各处实行的社会主义为什么却是极权主义的。集体主义不能容纳自由主义那博大的人道主义，它只能容纳极权主义的狭隘的门户之见。</p>
</li>
<li><p>我们应当重新学习坦白地面对这一事实：即只有花代价才能得到自由，并且，就我们个人来说，我们必须准备作出重大的物质牺牲，以维护我们的自由。如果我们希望保存自由，我们就必须回复作为盎格鲁－撒克逊国家的自由制度之基础的那种信息；这种信心曾经被本杰明-富兰克林表现在一个适用于我们个人的生活，同时也适用于一切国家的生活的句子里：“那些愿意放弃基本自由来换得少许暂时保障的人，即不配得到自由，也不配得到保障”。</p>
</li>
<li><p>有些人争辩说，我们已经以令人惊骇的程度学会了驾驭自然力量，但可惜的是，我们在如何成功地利用社会合作的可能性这一方面是落后了。如果此话就此打住，那么它是相当对头的。但是，如果他们继续作出对比并且争辩说，我们必须像学会如何驾驭自然力量那样学会驾驭社会力量，那他们就错了。这不仅是一条通往极权主义的道路，而且是一条通往我们文明的毁灭的道路，一条必然阻碍未来进步的道路。那些提出这些要求的人，恰恰是通过他们的要求来表明他们尚未了解光是维护我们的即得成果，我们得在何等程度上依赖非人为力量对个人的努力所起的协调作用。</p>
</li>
<li><p>在过去，使文明能够成长壮大的正是人们对市场的非人为力量的服从，没有这种服从，文明就不可能得到发展；正是通过这种服从，我们才能够每天协力筑造某种比我们当中任何人所能充分了解的还有伟大的东西。过去人们的服从是出于现在有些人认为是迷信的那些信仰，出于宗教的谦卑精神，还是出于对早期的经济学者的浅薄说教的尊重，这都没关系；要紧的是，从理性上去了解服从那些我们不能详细地领会其运作机制的力量的必要性，就要比宗教甚或对各种经济学说的敬意所激发的卑下的敬畏感驱使我们去服从它们时还要困难的多。</p>
</li>
<li><p>即使在垄断无法避免的条件下，控制它的最好办法是不是让政府来掌握它，这也是很值得怀疑的。如果我们所讨论的只是单独一种产业，那或许可以这么做。但当我们必须讨论许多不同的垄断产业时，那就有理由主张，宁可让它们存留在不同的个人手中，而不要把它它们合为一体而由政府单独管理。</p>
</li>
<li><p>集体主义思想的悲剧在于：它起初把理性推到至高无上的地位，却以毁灭理性而告终，因为它误解了理性成长所依据的那个过程。我们的确可以这样说，正是一切集体主义学说的谬论和它对“自觉的”控制或“自觉的”计划的要气，才必然会导致这样的一种要求，即某个人的思想应支配一切－虽然只有对社会现象作个人主义式的探讨才会使我们认识到那些指导理性成长的超个人力量。因此，个人主义在社会过程面前的态度是谦逊的，而对其他意见的态度则是容忍的，并且，它恰好是思想上的傲慢自大的对立面，而想全面指导社会过程的那种要求的根源，正是这种思想上的傲慢自大。</p>
</li>
<li><p>我们这一代人很可能忘记的是，道德不仅必定是个人行为的现象，而且只能存在于一定范围之内。在该范围内，个人有为自己作出决定的自由，而且被要求自愿牺牲个人利益来遵守道德的规则。在个人负责的范围以外，就既没有善，也没有恶，既没有机会获得道德评价，也没有机会通过为自己认为是正确的事务牺牲个人欲望来表明个人的道德信念。只有当我们对我们自己的厉害关系负责并且有牺牲它们的自由时，我们的决定才有道德价值。我们没有权利以他人的利益为代价来博取自己无私的美名，而我们要是在没有选择自由的情况下做到了无私，在道德上也不足以称道。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 通往奴役之路 </tag>
            
            <tag> 哈耶克 </tag>
            
            <tag> 读书 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android系统时间自动更新机制]]></title>
      <url>http://sniffer.site/2016/10/24/Android%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>Android系统是如何更新时间的了？Android提供了两种时间更新方式，NITZ和NTP,其中NITZ是基于移动基站通信更新的，与语音通话时相同的一个通道，而NTP则是通过数据通道（此时手机必须能上网）来更新的。这里，就来了解下这两种时间更新方式具体是如何工作的吧？</p>
<a id="more"></a>
<h2 id="两种时间更新机制"><a href="#两种时间更新机制" class="headerlink" title="两种时间更新机制"></a><strong>两种时间更新机制</strong></h2><h3 id="NITZ"><a href="#NITZ" class="headerlink" title="NITZ"></a><strong>NITZ</strong></h3><p>NITZ(Network Identity and Time Zone，网络标识和时区），是一种用于自动配置本地的时间和日期的机制，同时也通过无线网向移动设备提供运营商信息。NITZ是自从PHASE 2+ RELEASE 96 的GSM中的可选功能，经常被用来自动更新移动电话的系统时钟。NITZ需要运营商网络支持（通过CS网络），目前国内电信、移动都支持NITZ方式更新时间日期，而联通目前不支持。</p>
<blockquote>
<p>参考： <a href="https://en.wikipedia.org/wiki/NITZ" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/NITZ</a></p>
</blockquote>
<h3 id="NTP"><a href="#NTP" class="headerlink" title="NTP"></a><strong>NTP</strong></h3><p>NTP：NTP(Network Time Protocol)提供准确时间，首先要有准确的时间来源，这一时间应该是国际标准时间UTC。 NTP获得UTC的时间来源可以是原子钟、天文台、卫星，也可以从Internet上获取。这样就有了准确而可靠的时间源。时间按NTP服务器的等级传播。与NITZ不同的是，NTP需要从专门的NTP服务器来获取时间，只要手机连接上网络，都可以实现时间的更新。</p>
<blockquote>
<p>参考： <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Network_Time_Protocol</a></p>
</blockquote>
<h2 id="Android如何更新系统时间"><a href="#Android如何更新系统时间" class="headerlink" title="Android如何更新系统时间"></a><strong>Android如何更新系统时间</strong></h2><p>Android有一个专门的系统服务 <code>NetworkTimeUpdateServcie</code>来负责更新系统时间，该服务在系统启动时在<code>SystemServer.java</code>中被创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!disableNetwork &amp;&amp; !disableNetworkTime) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"NetworkTimeUpdateService"</span>);</span><br><span class="line">        networkTimeUpdater = <span class="keyword">new</span> NetworkTimeUpdateService(context);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        reportWtf(<span class="string">"starting NetworkTimeUpdate service"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (networkTimeUpdaterF != <span class="keyword">null</span>) networkTimeUpdaterF.systemRunning();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    reportWtf(<span class="string">"Notifying NetworkTimeService running"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>源码： <code>/frameworks/base/services/core/java/com/android/server/NetworkTimeUpdateService.java</code></p>
</blockquote>
<h3 id="服务初始化"><a href="#服务初始化" class="headerlink" title="服务初始化"></a><strong>服务初始化</strong></h3><p><code>NetworkTimeUpdateService</code>初始时会：</p>
<ul>
<li>注册RIL的ACTION_NETWORK_SET_TIME以及ACTION_NETWORK_SET_TIMEZONE事件，以接受来自Telephony FW的NITZ时间更新；</li>
<li>监听 ACTION_POLL事件(定时更新时间)以及手机网络连接状态；</li>
<li>发送消息同步NTP时间</li>
<li>监听 Settings中“自动更新时间”选项的变化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Initialize the receivers and initiate the first NTP request */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    registerForTelephonyIntents();</span><br><span class="line">    registerForAlarms();</span><br><span class="line">    registerForConnectivityIntents();</span><br><span class="line"></span><br><span class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(TAG);</span><br><span class="line">    thread.start();</span><br><span class="line">    mHandler = <span class="keyword">new</span> MyHandler(thread.getLooper());</span><br><span class="line">    <span class="comment">// Check the network time on the new thread</span></span><br><span class="line">    mHandler.obtainMessage(EVENT_POLL_NETWORK_TIME).sendToTarget();</span><br><span class="line"></span><br><span class="line">    mSettingsObserver = <span class="keyword">new</span> SettingsObserver(mHandler, EVENT_AUTO_TIME_CHANGED);</span><br><span class="line">    mSettingsObserver.observe(mContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步NTP时间"><a href="#同步NTP时间" class="headerlink" title="同步NTP时间"></a><strong>同步NTP时间</strong></h3><p>如果没有收到NITZ时间的更新并且NTP超过一定间隔没有更新时间，服务会主动去同步NTP时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// force refresh NTP cache when outdated</span></span><br><span class="line"><span class="keyword">if</span> (mTime.getCacheAge() &gt;= mPollingIntervalMs) &#123;</span><br><span class="line">    mTime.forceRefresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NTP从服务器获取时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">forceRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// We can't do this at initialization time: ConnectivityService might not be running yet.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCM == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCM = (ConnectivityManager) sContext.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (LOGD) Log.d(TAG, <span class="string">"forceRefresh() from cache miss"</span>);</span><br><span class="line">    <span class="keyword">final</span> SntpClient client = <span class="keyword">new</span> SntpClient();</span><br><span class="line">    <span class="keyword">if</span> (client.requestTime(mServer, (<span class="keyword">int</span>) mTimeout)) &#123;</span><br><span class="line">        mHasCache = <span class="keyword">true</span>;</span><br><span class="line">        mCachedNtpTime = client.getNtpTime();</span><br><span class="line">        mCachedNtpElapsedRealtime = client.getNtpTimeReference();</span><br><span class="line">        mCachedNtpCertainty = client.getRoundTripTime() / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>源码: /frameworks/base/core/java/android/util/NtpTrustedTime.java</p>
</blockquote>
<h3 id="接收NITZ时间"><a href="#接收NITZ时间" class="headerlink" title="接收NITZ时间"></a><strong>接收NITZ时间</strong></h3><p>Telephony Framework层在接收到最新的NITZ时间后，会主动发送广播请求更新系统时间，NetworkTimeUpateService接收到广播后，保存相应的NITZ时间,下一次poll请求时，就会将该事件更新为系统时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BroadcastReceiver mNitzReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        String action = intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (TelephonyIntents.ACTION_NETWORK_SET_TIME.equals(action)) &#123;</span><br><span class="line">            mNitzTimeSetTime = SystemClock.elapsedRealtime();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TelephonyIntents.ACTION_NETWORK_SET_TIMEZONE.equals(action)) &#123;</span><br><span class="line">            mNitzZoneSetTime = SystemClock.elapsedRealtime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="监听Settings中-“自动确定时间和日期”的变化"><a href="#监听Settings中-“自动确定时间和日期”的变化" class="headerlink" title="监听Settings中 “自动确定时间和日期”的变化"></a><strong>监听Settings中 “自动确定时间和日期”的变化</strong></h3><p>在setting中勾选“自动确定时间和日期”、“自动确定时区”后对key值为AUTO_TIME和AUTO_TIME_ZONE的Preference进行了赋值.</p>
<blockquote>
<p>源码路径：packages/apps/Settings/src/com/android/settings/DateTimeSettings.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">observe</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        ContentResolver resolver = context.getContentResolver();</span><br><span class="line">        resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.AUTO_TIME),</span><br><span class="line">                <span class="keyword">false</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange)</span> </span>&#123;</span><br><span class="line">        mHandler.obtainMessage(mMsg).sendToTarget();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>NetworkTimeUpdateService</code>在检测到key值改变的时，就会发送一个消息<code>EVENT_AUTO_TIME_CHANGED</code>;handler接到消息后进行消息处理调用<code>onPollNetworkTime(msg.what)</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> EVENT_AUTO_TIME_CHANGED:</span><br><span class="line">        <span class="keyword">case</span> EVENT_POLL_NETWORK_TIME:</span><br><span class="line">        <span class="keyword">case</span> EVENT_NETWORK_CONNECTED:</span><br><span class="line">            onPollNetworkTime(msg.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onPollNetworkTime方法中先判断是否勾选“自动更新时间”，如果没勾选直接退出，如果勾选了再看。如果NITZ已经更新了（不为NOT_SET(-1))，且更新间隔小于mPollingIntervalMs(mPollingIntervalMs=24<em>60</em>60*1000)，则直接用NITZ更新系统时间，否则用NTP同步时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// If NITZ time was received less than mPollingIntervalMs time ago,</span></span><br><span class="line"><span class="comment">// no need to sync to NTP.</span></span><br><span class="line"><span class="keyword">if</span> (mNitzTimeSetTime != NOT_SET &amp;&amp; refTime - mNitzTimeSetTime &lt; mPollingIntervalMs) &#123;</span><br><span class="line">    resetAlarm(mPollingIntervalMs);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">long</span> ntp = mTime.currentTimeMillis();</span><br><span class="line"> mTryAgainCounter = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">// If the clock is more than N seconds off or this is the first time it's been</span></span><br><span class="line"> <span class="comment">// fetched since boot, set the current time.</span></span><br><span class="line"> <span class="keyword">if</span> (Math.abs(ntp - currentTime) &gt; mTimeErrorThresholdMs</span><br><span class="line">            || mLastNtpFetchTime == NOT_SET) &#123;</span><br><span class="line">    <span class="comment">// Set the system time</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (ntp / <span class="number">1000</span> &lt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                 　　　SystemClock.setCurrentTimeMillis(ntp);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>当从NTP服务器上获取的时间和当前时间之差的绝对值大于一个阀值，则认为当前时间错误，需要更新时间。</p>
<p>总结：</p>
<ul>
<li>时间自动同步选项未勾选，不主动更新时间，直接返回；</li>
<li>NITZ已同步且上次NITZ同步未超过24小时，则设置定时器24小时后再触发同步，即广播NetworkTimeUpdateService.ACTION_POLL；</li>
<li>NTP上次成功同步超过24小时或用户勾选自动同步选项，则进行下面的NTP同步，否则同上设置定时器24小时后再触发同步</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul>
<li><a href="http://www.2cto.com/kf/201409/334153.html" target="_blank" rel="noopener">http://www.2cto.com/kf/201409/334153.html</a></li>
<li><a href="http://blog.csdn.net/lindir/article/details/7973700" target="_blank" rel="noopener">http://blog.csdn.net/lindir/article/details/7973700</a></li>
<li><a href="https://en.wikipedia.org/wiki/NITZ" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/NITZ</a></li>
<li><a href="https://en.wikipedia.org/wiki/Network_Time_Protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Network_Time_Protocol</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 系统时间更新 </tag>
            
            <tag> NITZ </tag>
            
            <tag> NTP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java程序编译过程]]></title>
      <url>http://sniffer.site/2016/10/24/Java%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="Java编译过程"><a href="#Java编译过程" class="headerlink" title="Java编译过程"></a>Java编译过程</h2><p>一般，C/C++程序的编译过程可以分为５个步骤（见下图）：Preprocessing(预处理),Parsing(解析), Translation(翻译),Assembling(汇编）,Linking(链接)。</p>
<a id="more"></a>
<img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/Compilation.png" class="[full-image]" title="Compilation Process">
<p>Java程序具有平台无关性，其在Java Virtual Machine(JVM)上执行，因此编译过程与C/C++大不相同：Java程序首先由编译器翻译成包含了Bytecode(字节码）的<code>.class</code>文件，程序执行时，由类加载器(class loader)将该类的字节码加载到JVM中，JVM会解释执行相应的Bytecode。</p>
<img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/java-compilation.png" class="[full-image]" title="Java Program Compiling and Executing">
<p>那么，一个Java程序是如何变成Bytecode的了?主要由3个过程：</p>
<img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/javac-flow.png" class="[full-image]" title="Java Compiling process">
<p>(1) 解析：Java源代码文件被解析成一个个标记(Token)，解析器根据Token生成语法树(syntax trees);<br>(2) 注释处理:注释处理器(annotation processors)处理所有注释；如果注释处理器产生了新的源文件或者class文件，会重启编译过程，直到没有新的文件产生为止；<br>(3) 语义分析与字节码生成：在这一步，将语法树转化成类文件,生成字节码。</p>
<ul>
<li>变量/引用等变量或符号标注；</li>
<li>数据与控制流分析：局部变量赋值、方法返回值以及异常处理等逻辑验证;</li>
<li>解析语法糖：如泛型与类型擦除，遍历循环、自动拆箱（装箱）以及条件编译等</li>
<li>产生字节码，输出到磁盘</li>
</ul>
<h2 id="Java字节码"><a href="#Java字节码" class="headerlink" title="Java字节码"></a>Java字节码</h2><p>最后，我们来看一看Java字节码究竟长什么样子。</p>
<p>新建一个.java文件，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String helloWorld = <span class="string">"hello world"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(helloWorld);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用javac编译生成对应的.class文件,输入下列命令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c xxx.class　</span><br></pre></td></tr></table></figure>
<p>可以反汇编对应class文件的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Compiled from "HelloWorld.java"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #4                  // String hello world</span><br><span class="line">       5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，bytecode实际上就成了JVM的机器语言，里边是一条条JVM可执行的指令。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://www.borjournals.com/a/index.php/jecas/article/viewFile/289/866" target="_blank" rel="noopener">http://www.borjournals.com/a/index.php/jecas/article/viewFile/289/866</a></li>
<li><a href="http://openjdk.java.net/groups/compiler/doc/compilation-overview/" target="_blank" rel="noopener">http://openjdk.java.net/groups/compiler/doc/compilation-overview/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Compiling process </tag>
            
            <tag> 字节码 </tag>
            
            <tag> class　file </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[由人定胜天说起]]></title>
      <url>http://sniffer.site/2016/10/16/%E7%94%B1%E4%BA%BA%E5%AE%9A%E8%83%9C%E5%A4%A9%E8%AF%B4%E8%B5%B7/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>我同意叔本华说的，引导人们通向艺术和科学的最强烈动机之一是摆脱日常生活及其中令人痛苦的粗糙状态和无望的枯燥乏味，摆脱一个人自身总是在变化着的欲望的羁绊。。。就像画家、诗人或者哲学家一样，科学家努力要创造一个属于他自己的世界。他们中的每个个人都是这个宇宙及它的结构成为它的感情生活的支点，这是为了以这种方法寻找到他在狭窄的个人经历的漩涡中无法找到的宁静与安全</p>
<pre><code>爱因斯坦
</code></pre></blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>中国社会经济的快速发展，给人一种无限的权能感：只要敢于做，大胆做，我们就可以做到想做的任何事情。权力阶层无不如此。因而才有了轰轰烈烈的城市改造，把老祖宗留下的一点建筑文化遗迹都拆除干净；把过去的东西都拆掉，重新修高楼大厦。才有了四万亿的经济刺激计划，才有了最近闹得红红火火的“大众创新，万众创业”。这些冒进的措施与口号，即使出发点是好的，但由于脱离实际，没有考虑到事物的自然发展规律，因而注定是要失败的，长远来看，只会损害社会的发展与民族的进步。</p>
<a id="more"></a>
<p>这些表面上的繁华与个人的好大喜功，常常使我想起“人定胜天”这个词语的含义在中国社会的演变。这里，就来谈一谈我由人定胜天这个观念想到的一些事情。</p>
<h2 id="词义演变"><a href="#词义演变" class="headerlink" title="词义演变"></a>词义演变</h2><p>讲到“人定胜天”，现在一般人的理解是：反映人的主观能动性可以克服客观的任何困难。《现代汉语词典-第五版》（商务印书馆）里解释为：人力能够战胜自然。可是，这个词原本就是这个意思？古语里究竟是怎么来的？这个词语有着怎么样的演变历史，又是如何跟中国近几十年社会的变化相联系的？</p>
<p>《吕氏春秋》（亦称《吕览》）中有，“天定则胜人，人定则胜天；故狼众则食人，人众则食狼 ”，而南宋词人刘过的《襄阳歌》:“人定兮胜天,半壁久无胡日月”。“人定”是“人谋”的意思,是指在一定条件下,人谋的因素比天命还重要,“胜”是“比什么更为重要”而不是要战胜的意思。冯梦龙的《喻世明言》讲相与命的关系,说:“却又犯着恶相的,却因心地端正,肯积阴功,反祸为福。此是人定胜天,非相法之不灵也。”意思是一个人相貌虽犯恶,但心地端正、肯积阴功,人的因素更为重要。其实“人定胜天”只是鼓励人不要因命运崎岖而放弃努力的意思。</p>
<p>自古以来,中国文化都强调天人合一,强调顺应自然,不要拂逆天意,皇帝也只敢自称“天子”,根本就没有要战胜老天爷的文化。 “人定胜天”变成了现在这个意思，是出自毛泽东的手笔。毛泽东曾说过，<br><blockquote class="blockquote-center"><p>“四川的老百姓，一怕老天爷，二怕瞎指挥。我毛泽东管不了老天爷，马克思也管不着。但是我提倡‘人定胜天’。一方面，要‘听天由命’；另一方面，要‘人定胜天’，要充分发挥人的主观能动性。上井冈山时，我们只有几个人，可是后来我们建立了新中国。”</p>
</blockquote></p>
<p>毛早年的文章《愚公移山》,还没有战天斗地的涵意,到1957年他发出“愚公移山,改造中国”的口号,却把原来古老故事中的“(天)帝感其诚”的涵义阉割掉,掀起了“人有多大胆,地有多大产”的大跃进。从此，“人定胜天”演变成了现在这个意思。</p>
<h2 id="由历史想到的"><a href="#由历史想到的" class="headerlink" title="由历史想到的"></a>由历史想到的</h2><p>从50年代后期开始的“大跃进”运动，以及后来发生的文化大革命，彻彻底底的“改造”了中国社会。精英与知识分子几乎被清洗殆尽，官运亨通的是那些会溜须拍马屁，会投机取巧与钻营狠毒的人。这是一个民族的悲剧，也是民族的悲哀，同样是毛本人的悲哀。看一看，那个时代各种标语与口号，就能看出不受限制的权能与权力感，会造成怎样的荒唐：<br><blockquote class="blockquote-center"><p>人有多大胆，地有多大产</p>
<p>一个萝卜千斤重，两头毛驴拉不动</p>
<p>土地潜力无穷尽，亩产多少在人为</p>
<p>倾家荡产大炼钢铁</p>
</blockquote></p>
<p>今天来看，毛本人的”人定胜天“思想，是完完全全失败的，这种观念对中国社会产生的危害一时也无法估量。不难发现，如今大权在握的领导无不是毛时代成长起来的，这些人依然沿袭了那个时代的好大喜功，喊口号的模式，而完全忽略了人性的需求与自然的规律。</p>
<p>毛及其所领导的党企图利用马克思主义理论就要再造一个所谓的新社会，要创造一个社会主义中国。这种狂妄自大与盲目自信让他们忘记了自然规律的存在，忘记了尊重自然与顺应人性的必要性。这是一种人自身权能感无限膨胀后的结果，这是对人性与生命，对自然与宇宙缺乏基本敬畏之心的必然。</p>
<p>当下社会，到处都是灯火辉煌，歌舞升平，人类再不比以往。科学技术的发展已经让人衣食无忧，不用再受到来自其他生物的生存威胁，不用再在草原里奔跑以获取必要的食物，不要再辛苦的劳作，因为机器已经代替了很多繁重的工作。人类已经可以上天下地了，可以修筑高达几百米的建筑，人类在地球上已经完全是“王者”的地位了，人类在某些方面的确进步了不少，但今天的人是否比几万年钱的祖辈更快乐幸福了？不，不！相反，如今的人在纸醉金迷与虚浮享乐的路上越走越远，忘了人自身的本性需求，忘了自然馈赠的可贵，而成为了自造工具的奴隶，变得越来不像人了，变得越来越像一个原始的动物，变得越来越麻木而茫然。权能感的上升让人走路轻都飘飘了。</p>
<p>我们破坏了山丘，破坏了田野，污染了河流，污染了大地，到处是人自己建设的单调而沉闷的建筑。这何时是个尽头？这是否会有尽头？这里的人，何时才能找回对自然与宇宙，对人性与自然秩序的尊敬与敬畏？</p>
]]></content>
      
        <categories>
            
            <category> 社会万象 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 历史 </tag>
            
            <tag> 哲学 </tag>
            
            <tag> 社会 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[停机问题]]></title>
      <url>http://sniffer.site/2016/10/15/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>停机问题(The halting problem) 是可计算理论（Computability theory）中至关重要的一个问题。简单的来说，它要解决:给定一个输入，需要确定一个计算机程序是否能停机（产生问题的解）或者陷入死循环。究竟是否存在一个机器，能够检查给定任何输入的任何程序，确定程序是否在有限时间里停机了？</p>
<a id="more"></a>
<p>通常，使用<a href="https://brilliant.org/wiki/turing-machines/" target="_blank" rel="noopener">Turning Machines</a>(图灵机）来证明该理论：停机意味着图灵机接受或者拒绝一个输入，而如果一个程序在图灵机上陷入了死循环，则说明该图灵机不能在给定的输入上产生解。早在1936年，Alan Turing就证明了，停机问题是不可判定的，因而不可解。如果停机问题存在解，则其他许多计算机科学的难题也会得到解答，如 <a href="https://brilliant.org/wiki/kolmogorov-complexity/" target="_blank" rel="noopener">Kolmogorov compexity</a>, <a href="https://brilliant.org/wiki/busy-beaver-problem/" target="_blank" rel="noopener">the Busy Beaver function</a>等。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Halting_problem" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Halting_problem</a></li>
<li><a href="https://brilliant.org/wiki/halting-problem/" target="_blank" rel="noopener">https://brilliant.org/wiki/halting-problem/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Computer theory </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Halting Problem </tag>
            
            <tag> Computability theory </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux Shell快速入门]]></title>
      <url>http://sniffer.site/2016/10/14/Linux-Shell%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>开始使用Ubuntu操作系统，感觉使用起来也没有太多的障碍，但是对于Shell脚本一直了解不多，于是打算学习下。以下是一个简单的小结（学习Linux 命令对于Android的开发也大有帮助，很多Linux Shell命令在Android中都有对应的版本）。</p>
<a id="more"></a>
<p>脚本语言，既然冠之以“语言”，就说明它跟其他C/C++等编译语言在形式上是完全一样的，有变量，有函数，有if,else,while等条件分支，只是脚本语言是解释性的执行：碰到一句，解释一句，执行。</p>
<h2 id="写一个脚本看一看"><a href="#写一个脚本看一看" class="headerlink" title="写一个脚本看一看"></a><strong>写一个脚本看一看</strong></h2><p>运行脚本之前，需要做三件事情：</p>
<ul>
<li>写一个脚本</li>
<li>使Shell有权限执行该脚本</li>
<li>把脚本放在Shell可以找到的地方</li>
</ul>
<p>打开文本编辑器，输入下列文本,保存为my_scripts.sh：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># this is my first shell script</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hello shell scripts"</span></span><br></pre></td></tr></table></figure>
<p>第一脚本就写成了。运行脚本之前，你可能需要修改脚本的权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 my_scripts</span><br></pre></td></tr></table></figure>
<p>输入下面命令执行脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./my_scripts.sh</span><br></pre></td></tr></table></figure>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a><strong>基础</strong></h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h3><p>shell脚本提供了不少环境变量来获取系统信息，如用户名，主机名，时间等：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HOSTNAME</span>,<span class="variable">$USER</span>,<span class="variable">$DATE</span></span><br></pre></td></tr></table></figure>
<p>这些变量是全局的，在任何时候都可以使用。但，要在脚本中使用的变量（变量无需声明，直接使用即可），却并不具备这样的全局性，例如，有如下脚本 myvar.sh：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"MY_VAR is: <span class="variable">$MY_VAR</span>"</span></span><br><span class="line">MY_VAR= <span class="string">"hi, there"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"MY_VAR is : <span class="variable">$MY_VAR</span>"</span></span><br></pre></td></tr></table></figure>
<p>执行如下脚本命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ MY_VAR=hello</span><br><span class="line">$ ./myvar.sh</span><br><span class="line">MY_VAR is:</span><br><span class="line">MY_VAR is: hi, there</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MY_VAR is:</span><br><span class="line">MY_VAR is: hi, there</span><br></pre></td></tr></table></figure>
<p>因而，变量MY_VAR并不具有全局的作用域，如果要像环境变量一样使用该变量，必须将其export：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ MY_VAR=hello</span><br><span class="line">$ <span class="built_in">export</span> MY_VAR</span><br><span class="line">$ ./myvar.sh</span><br><span class="line">MY_VAR is:</span><br><span class="line">MY_VAR is: hi, there</span><br></pre></td></tr></table></figure>
<p>这样输出就变了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MY_VAR is: hello</span><br><span class="line">MY_VAR is: hi, there</span><br></pre></td></tr></table></figure>
<p>附几个比较特殊的变量：</p>
<ul>
<li><code>$$</code> 该脚本对应的PID(进程ID）</li>
<li><code>$？</code> 上一个脚本命令的退出条件值</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fcn_name</span></span>()&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>那么，怎么知道函数的参数了？很简单，<code>$1</code>对应第一个参数，<code>$2</code>对应第二个参数，以此类推，<code>$0</code>则表示执行脚本本身的名字，另外有几个个比较特殊的变量：</p>
<ul>
<li><code>$#</code> 函数的参数个数(执行脚本的参数）</li>
<li><code>$@</code> 除了脚本名外所有的参数，<code>$1 $2 ....</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"><span class="keyword">while</span> [  <span class="string">"<span class="variable">$#</span>"</span> -gt <span class="string">"0"</span>  ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"\$1 is <span class="variable">$1</span>"</span></span><br><span class="line">	<span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>不是还有递归吗？Shell脚本同样可以实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"></span><br><span class="line">factor()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> -gt  <span class="string">"1"</span> ]; <span class="keyword">then</span></span><br><span class="line">		i= <span class="string">'expr $1 - 1'</span></span><br><span class="line">		j=<span class="string">'factor $i'</span></span><br><span class="line">		k=<span class="string">'expr $1 \* $j'</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="variable">$k</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">echo</span> 1</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>:</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"enter a number"</span></span><br><span class="line">	<span class="built_in">read</span>  x</span><br><span class="line">	factor <span class="variable">$x</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure> 
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a><strong>语句</strong></h3><p>多举几个栗子就看懂了。</p>
<h4 id="if-else-条件判断"><a href="#if-else-条件判断" class="headerlink" title="if/else 条件判断"></a><strong>if/else 条件判断</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># first form</span></span><br><span class="line"><span class="keyword">if</span> condition ; <span class="keyword">then</span></span><br><span class="line">       commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Second form</span></span><br><span class="line"><span class="keyword">if</span> condition ; <span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Third form</span></span><br><span class="line"><span class="keyword">if</span> condition ; <span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">elif</span> condition ; <span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure> 
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a><strong>循环</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 1 2 3 5 9</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"number <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line">INPUT_STR=hello</span><br><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$INPUT_STR</span>"</span> != <span class="string">"bye"</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"Please type something (bye to quit)"</span></span><br><span class="line">	<span class="built_in">read</span> INPUT_STR</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"you just typed: <span class="variable">$INPUT_STR</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure> 
<p>上述f<code>for</code>循环可以写成C风格的形式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (( i = 1; i &lt; 9; i++ ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"number <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure> 
<h4 id="Case"><a href="#Case" class="headerlink" title="Case"></a><strong>Case</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"please say something to me..."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>:</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">	<span class="built_in">read</span> INPUT_STR</span><br><span class="line">	<span class="keyword">case</span> <span class="variable">$INPUT_STR</span> <span class="keyword">in</span></span><br><span class="line">		hello)</span><br><span class="line">			<span class="built_in">echo</span> <span class="string">"hello you too!"</span></span><br><span class="line">			;;</span><br><span class="line">		<span class="built_in">bye</span>)</span><br><span class="line">			<span class="built_in">echo</span> <span class="string">"See you again!"</span></span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">			;;</span><br><span class="line">		*)</span><br><span class="line">			<span class="built_in">echo</span> <span class="string">"fail to understand"</span></span><br><span class="line">			;;</span><br><span class="line">	<span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"that's the all my folks!"</span></span><br></pre></td></tr></table></figure>
<h3 id="退出条件"><a href="#退出条件" class="headerlink" title="退出条件"></a><strong>退出条件</strong></h3><p>应用执行是否成功的标志，是一个0～255之间的整数，0表示应用没有发生错误，执行成功；其他任何值都表示发生了错误。</p>
<p>用 <code>$?</code> 即可查看一个命令是否执行成功。</p>
<p>例如判断某个文件是否存在：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ -f .bash_profile ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"You have a .bash_profile. Things are fine."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Yikes! You have no .bash_profile!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="命令索引"><a href="#命令索引" class="headerlink" title="命令索引"></a><strong>命令索引</strong></h2><table>
<thead>
<tr>
<th>Expression</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>run the previous command in the background</td>
<td><code>ls &amp;</code></td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>logical AND</td>
<td><code>if [ &quot;$foo&quot; -ge &quot;0&quot; ] &amp;&amp; [ &quot;$foo&quot; -le &quot;9&quot; ]</code></td>
</tr>
<tr>
<td>or</td>
<td>logical OR</td>
<td><code>if [ &quot;$foo&quot; -ge &quot;0&quot; ] or [ &quot;$foo&quot; -le &quot;9&quot; ]</code></td>
</tr>
<tr>
<td>^</td>
<td>start of line</td>
<td><code>grep &quot;^foo</code></td>
</tr>
<tr>
<td>$</td>
<td>end of line</td>
<td><code>grep &quot;foo$</code></td>
</tr>
<tr>
<td>=</td>
<td>string equlity</td>
<td><code>if [ &quot;$foo&quot; = &quot;bar&quot; ]</code> </td>
</tr>
<tr>
<td>!</td>
<td>logical NOT</td>
<td><code>if [ &quot;$foo&quot; != &quot;bar&quot; ]</code></td>
</tr>
<tr>
<td>$$</td>
<td>pid of current shell</td>
<td><code>echo &quot;PID=$$</code></td>
</tr>
<tr>
<td>$!</td>
<td>pid of last background command</td>
<td><code>ls &amp; echo &quot;PID of ls = $!</code></td>
</tr>
<tr>
<td>&amp;?</td>
<td>exit status of last command</td>
<td><code>ls; echo &quot;ls returned code $?</code></td>
</tr>
<tr>
<td>$0</td>
<td>name of current command</td>
<td><code>echo &quot;I am $0&quot;</code></td>
</tr>
<tr>
<td>$1</td>
<td>name of 1st parameter</td>
<td><code>echo &quot;first argument is $1</code></td>
</tr>
<tr>
<td>$9</td>
<td>name of 9th parameter</td>
<td><code>echo &quot;nith argument is $9</code></td>
</tr>
<tr>
<td>$@</td>
<td>all of current commands’ parameters(preserving whitespace/quoting)</td>
<td><code>echo &quot;my arguments are $@</code></td>
</tr>
<tr>
<td>$*</td>
<td>all of current commands’ parameters(not preserving whitespace/quoting)</td>
<td><code>echo &quot;my arguments are $*</code></td>
</tr>
<tr>
<td>-d file</td>
<td>True if file is a directory</td>
<td><code>if [ -d /bin ]</code></td>
</tr>
<tr>
<td>-e file</td>
<td>True if file exists</td>
<td><code>if [ -e /home/bin/my.text ]</code></td>
</tr>
<tr>
<td>-f file</td>
<td>True if file exists and is a regular file</td>
<td><code>if [ -f  /bin/fs]</code></td>
</tr>
<tr>
<td>-L file</td>
<td>True if file is symbolic link</td>
<td><code>if [ -L /bin/fs ]</code></td>
</tr>
<tr>
<td>-r file</td>
<td>True if file is readable</td>
<td><code>if [ -r /bin/fs ]</code> </td>
</tr>
<tr>
<td>-w file</td>
<td>True if file is writable</td>
<td><code>if [ -w /bin/fs ]</code> </td>
</tr>
<tr>
<td>-x file</td>
<td>True if file is executable</td>
<td><code>if [ -x /bin/fs ]</code> </td>
</tr>
<tr>
<td>f1 -nt f2</td>
<td>True if f1 is newer than f2(modification time)</td>
<td><code>if [ &quot;@f1&quot; -nt &quot;$f2&quot; ]</code></td>
</tr>
<tr>
<td>f1 -ot f2</td>
<td>True if f1 is older than f2</td>
<td><code>if [ &quot;@f1&quot; -ot &quot;$f2&quot; ]</code></td>
</tr>
<tr>
<td>-z string</td>
<td>True if string is empty</td>
<td><code>if [ -z &quot;$f00&quot; ]</code></td>
</tr>
<tr>
<td>-n string</td>
<td>True if string is not empty</td>
<td><code>if [ -n &quot;$f00&quot; ]</code></td>
</tr>
<tr>
<td>str1=str2</td>
<td>True if str1 equal str2</td>
<td><code>if [ &quot;$foo&quot; = &quot;bar&quot; ]</code></td>
</tr>
<tr>
<td>str1!=str2</td>
<td>True if str1 not equal to str2</td>
<td><code>if [ &quot;$foo&quot; != &quot;bar&quot; ]</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Markdown显示原因： <code>or</code>实际为 <code>||</code></p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://google.github.io/styleguide/shell.xml" target="_blank" rel="noopener">https://google.github.io/styleguide/shell.xml</a></li>
<li><a href="http://www.shellscript.sh/" target="_blank" rel="noopener">http://www.shellscript.sh/</a></li>
<li><a href="https://coolshell.cn/articles/8883.html" target="_blank" rel="noopener">https://coolshell.cn/articles/8883.html</a></li>
<li><a href="https://coolshell.cn/articles/8619.html" target="_blank" rel="noopener">https://coolshell.cn/articles/8619.html</a></li>
<li><a href="https://github.com/alebcay/awesome-shell" target="_blank" rel="noopener">https://github.com/alebcay/awesome-shell</a></li>
<li><a href="https://github.com/awesome-lists/awesome-bash" target="_blank" rel="noopener">https://github.com/awesome-lists/awesome-bash</a></li>
<li><a href="https://github.com/epety/100-shell-script-examples" target="_blank" rel="noopener">https://github.com/epety/100-shell-script-examples</a></li>
<li><a href="http://tldp.org/LDP/abs/html/" target="_blank" rel="noopener">http://tldp.org/LDP/abs/html/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux Shell </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Shell Scripting </tag>
            
            <tag> Linux </tag>
            
            <tag> Bash </tag>
            
            <tag> Unbuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dependency Inversion Principle]]></title>
      <url>http://sniffer.site/2016/10/13/Dependency-Inversion-Principle/</url>
      <content type="html"><![CDATA[<h1 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h1><blockquote>
<p><a href="https://www.labri.fr/perso/clement/enseignements/ao/DIP.pdf" target="_blank" rel="noopener">原文链接</a><br> by Robert C. Martin(Uncle Bob)</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章写于1996年，里边清晰而简明的介绍了“依赖反转原则”，对了解Dependency Injection很有帮助。今天看来，仍然具有很好的释疑作用。</p>
<a id="more"></a>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>我上一篇96年的文章谈到了 Liskov Substitution Principle(<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener">LSP</a>)。 这个原则应用到了C++时，为使用公开(public)继承（inheritance)提供了指导。 该原则说，每一个操作一个基类的引用或者指针的函数，都应能够同样操作该基类的派生类，即使其对该派生类一无所知。这就意味着，派生类的虚成员函数必须与基类的虚成员函数保持一致，并且不应该做更多的事情。也就是说，基类中的虚成员函数必须要在派生类中，并且保证只做有用的工作。如果违背LSP原则，操作基类的引用或指针的函数将不得不检查具体对象的类型，以确保操作正确。而检查对象类型则违反了上周讲到的Open-Closed Principle(<a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" target="_blank" rel="noopener">OCP</a>)。</p>
<p> 在此次专栏里，我们将讨论OCP与LSP结构化带来的启示。 严格使用这些原则所产生的结构，可以被一般化成一个更为基本的原则，我称之为“Dependency Inversion Principle”(DIP)。</p>
<h2 id="软件出现了什么问题？"><a href="#软件出现了什么问题？" class="headerlink" title="软件出现了什么问题？"></a>软件出现了什么问题？</h2><p>大部分人都与有着”糟糕设计“的软件打过交道。有些人则往往发现，自己就是那些具有“糟糕设计”的软件的作者。那么，究竟是什么让一个设计变得如此糟糕了？</p>
<p> 大多数软件工程师并不准备创造”糟糕的设计”。然后大多数软件最终都沦为到某个一个点：有人宣称这个设计很不靠谱。为什么发生这种事了？是否设计一开始就很糟糕，抑或设计实际上像一块腐肉一样变得越来越烂？该问题的关键在于，我们缺乏一个”糟糕设计”的好的定义。</p>
<h2 id="什么是糟糕的设计"><a href="#什么是糟糕的设计" class="headerlink" title="什么是糟糕的设计"></a>什么是糟糕的设计</h2><p>你是否曾提交过一个令自己感到自豪的软件设计，被同行所评审？而那个评审人员却发牢骚似的讥讽道，“你为什么要这么设计”。当然，这时在我身上发生过，我也见过它发生在其他很多工程师身上。很明显，有不同意见的评审工程师并没有使用相同的标准去定义糟糕的设计是什么。我见过最常使用的原则是，“这不会是我实现它的方式”。</p>
<p>但是，我以为应该有一套标准为所有的工程师所认同。一个软件如果满足其设计需求，但是仍然表现出如下三个特征中的任何一个的话，就是一个糟糕的设计：</p>
<ul>
<li>难以修改： 每个修改都会影响到系统的很多部分(<strong>Regidity</strong>)</li>
<li>修改时，系统某些部分难以预料出现崩溃（<strong>Fragility</strong>)</li>
<li>因为无法从当前应用中分离出来，很难在其他应用中复用(<strong>Immobility</strong>)</li>
</ul>
<p>而且，很难说，一个软件并没表现出上述三个特征中的任何一个的话，它做到了可扩展性（flexible)，健壮性（robust)以及可复用性（reusable),并且满足了设计需求，会有糟糕的设计。因此，我们可以用上述三个特征来清晰的区分什么是好的设计，什么是坏的设计。</p>
<h2 id="糟糕设计的源头"><a href="#糟糕设计的源头" class="headerlink" title="糟糕设计的源头"></a>糟糕设计的源头</h2><p>什么导致一个设计缺乏可扩展性、健壮性以及可复用性了？设计里相互依赖的模块。一个设计不容易被修改，则不可扩展。如此僵化源自于一个事实，修改一个模块之间严重依赖的软件会导致一系列其他的相关模块的改动。当此种修改的范围超出设计者或者维护人员的预期时，修改的影响是无法估计的。这使得修改的代价难以预料。项目管理人员，面临如此不可预料的改动，常常不愿意授权修改。如此，这样的修改就被正式确定下来。</p>
<p>不具备健壮性，意味着一个小的修改都会引起程序其他部分发送崩溃。往往，新问题的发生点与修改点并没有概念上的关联。这种设计上的脆弱很大程度上降低了设计与维护公司的信用度。用户与管理人员无法预料他们产品的质量。在应用一个部分的小改动导致了其他毫不相关部分的崩溃。修复这些问题导致更多的问题，致使维护过程变成了一个狗追咬自己尾巴的恶性循环。</p>
<p>一个设计不可复用，是由于期望设计的部分严重依赖于其他部分的实现细节。如果设计考量下该设计是否可能在其他应用中复用，可能他会对该设计在新的应用中的表现有更深的印象。倘若该设计模块之间高度依赖，设计者们同样会被将需要的部分与不需要的部分分离所苦恼。大部分情况下，这样的设计不可复用，是因为分离的代价要远高于重新开发设计的代价。</p>
<h2 id="示例：-“Copy”程序"><a href="#示例：-“Copy”程序" class="headerlink" title="示例： “Copy”程序"></a>示例： “Copy”程序</h2><p>为了更好的阐述上述观点，先看个简单的例子。考虑实现一个将键盘输入的字符拷贝到一个打印机上的程序。假定，实现平台并没有一个支持设备独立的操作系统。这个程序的结构看起来如下图1所示：</p>
<img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/dip_fig1_cpy_program.png" class="[full image]" title="图 1 “复制”程序结构">
<p>图 1 是一个框架图：程序由3个部分组成，”Copy”模块调用其他两个模块。其对应的代码实现如下所示：主体循环不断地调用“读取键盘”模块，以获取键盘输入字符，然后将字符发送到“写打印机”模块以打印字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">while</span>((c == ReadKeyboard()) != EOF)</span><br><span class="line">	WritePrinter(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个低层模块具有很好的可复用性。他们可以用在其他程序中操作键盘与打印机。这与从库中调用子程序很类似。</p>
<p>但是，如果没有键盘或者打印机的时候，这个“Copy”模块就不具备可复用性了。这个系统所蕴含的智慧仅仅用在了这个模块，这真是让人惭愧。正是”Copy”模块蕴藏了一个我们可以复用而很有趣的策略。</p>
<p>例如，考虑一个将键盘字符拷贝到磁盘文件的新程序。当然，我们希望使用已有的“Copy”程序，其包含了一个我们需要的高层策略；它知道如何将字符从一个源拷贝到另一个源。不幸的是，“Copy”模块依赖于“Write Printer”模块，因此在此种情况下，不能使用。</p>
<p>为此，我们可以赋予”Copy”模块一个新的功能（代码如下）。通过对输出设备进行判定，来决定是写入“Printer”还是“Disk”。但是，这却增加了系统彼此依赖的程度。随着时间的推移，越来越多的设备希望使用复制功能，而“Copy”模块则会被一长串的 if/else弄凌乱，也因此它需要依赖于更底层的模块。最后，代码的可复用性与健壮性都会受到影响。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">enum</span> OutputDevice &#123; printer, disk&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(outDevice dev)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="keyword">while</span>(( c == ReadKeyboard()  != EOF)&#123;</span><br><span class="line">		<span class="keyword">if</span>( dev == printer)</span><br><span class="line">			WritePrinter(c);</span><br><span class="line">		esle</span><br><span class="line">			WriteDisk(c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="依赖反转-Dependency-Inversion"><a href="#依赖反转-Dependency-Inversion" class="headerlink" title="依赖反转(Dependency Inversion)"></a>依赖反转(Dependency Inversion)</h2><p>一个描述上述问题的方法是，注意到包含了上层策略的“Copy”模块，依赖于底层它控制模块的实现细节。如果，我们能找到一个办法，使”Copy()”模块独立于它控制的细节的话，代码的可复用性就大大提高了。我们可以使用该模块从任何设备拷贝字符，然后复制字符到任意的输出设备。面向对象设计（OOD）给了我们一个实现依赖反转的机制。</p>
<p>考虑下图2的类结构图：有一个Copy类，包含了一个抽象的Reader类、Writer类。不难以此写出一个从Reader获取字符然后发送到Writer的”Copy“类（见下列代码）。这个“Copy”类不依赖于“KeyBoard Reader”，也不依赖于”Printer Writer”。因而依赖被反转了；”Copy”类依赖于抽象，并且reader与writer的具体实现依赖于同一个抽象。</p>
<img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/dip_fig2_oo_cpy_program.png" class="[The OO Copy Program]" title="图2 面向对象版Copy">
<p>现在，只要派生出“AbstractReader”以及”AbstractWriter“,我们可以复用“copy”类。并且，不管有多少新的”Reader”,”Writer”，“Copy“都不会依赖于它们。这里并没有什么相互依赖使得程序变得不可复用或者健壮性差。而且，Copy类可以再不同的输入输出环境里使用。同样满足了可复用性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">virutal <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function">virutal <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(Reader&amp; r, Writer&amp; w)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="keyword">while</span>((c = r.Read()) != EOF)&#123;</span><br><span class="line">		w.Write(c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设备无关"><a href="#设备无关" class="headerlink" title="设备无关"></a>设备无关</h2><p>到现在为止，很多人可能会想，利用<code>stdio.h</code>中的设备无关性，完全可以用C来实现同样的 Copy功能：<code>getChar()</code>,<code>putChar()</code>（具体代码如下所示）。如果你仔细考虑下上一节中OO版本的代码与C版本的代码，你会认识都两者在逻辑上完全是等价的。图3 中的抽象类被另一种形式的抽象替代了。尽管，C版本代码没有使用类和纯虚函数，但它仍然使用了抽象与多态来实现相同的目的。而且，也同样使用了依赖反转：Copy 并不依赖于任何实现的细节，而是依赖于<code>stdio.h</code>提供的抽象；调用的IO驱动也依赖于<code>stdio.h</code>中的抽象。因此，<code>stdio.h</code>中的设备无关性是另一个依赖反转的栗子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="keyword">while</span>(( c == getchar()) ！= EOF)&#123;</span><br><span class="line">		<span class="built_in">putchar</span>(c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看过了几个例子之后，我们来叙述下DIP的更一般形式。</p>
<h1 id="The-Dependency-Inversion-Principle"><a href="#The-Dependency-Inversion-Principle" class="headerlink" title="The Dependency Inversion Principle"></a>The Dependency Inversion Principle</h1><ul>
<li>High Level modules should not depend upon low level modules. Both should depend upon abstractions.(上层模块不应该依赖于底层模块；两者都应该依赖于抽象)</li>
<li>Abstractions should not depend upon details. Details should depend upon abstractions（抽象不应该依赖于细节；细节应该依赖于抽象）.</li>
</ul>
<p>有人可能疑惑，我为什么要用“inversion”（反转)。坦白说，是因为传统的软件开发技术，如结构化分析与设计，通常创造出一种上层依赖于底层的软件结构，而且抽象依赖于细节。此种方法的目标之一是定义描述上层模块如何调用下层模块的子程序层级结构。下图3是一个很好的示例。因此，相对于传统的面向过程的方法，一个设计良好的OOP程序结构被“反转(inverted)”了。这是中间层设计的核心原则。</p>
<img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/dip_fig2_oo_cpy_program.png" class="[simple layers]" title="图3 简单的层级结构">
<h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>根据Grady Booch的说法，“所有结构良好的OO架构都有很清晰的分层结构，每一层通过清晰定义的接口提供了一套一致性的服务”，简单的利用该原则，我们可以将图3中的结构改变成类似的结构。在这个结构图中，上层Policy类使用底层的机制，而该机制反过来使用了一个细节化的Utility类。尽管这种方法看起来不错，但它有一个隐藏的要害：Policy层容易受到Mechanism层一直到Utility层的影响。<em>依赖具有传递性</em>。Policy层依赖于Utility层的某些接口，因此Policy层传递性的依赖于Utility层。这很不幸。</p>
<img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/dip_fig4_abstract_layers.png" class="[Abstract layers]" title="图4 抽象分层">
<p>图4展示了一个更为合适的模型。底层都是由抽象接口来表示。实际的实现都是直接继承了该接口，而上层则通过接口与底层进行交互。因此，各个层之间是相互独立的。相反，层是依赖于抽象接口。这样，Policy层与Utility层之间的依赖传递被阻断了，并且Policy层与Mechanism层的直接依赖关系也被打破了。</p>
<p>使用这个模型，Policy层不会受到Mechanism层或者Utility层变化的影响。更重要的是，只要提供了一个与Mechanism接口一致的底层模块，Policy层可以被复用。因此，通过反转依赖，我们创造出来一种同时具备可扩展性、可持续性以及可复用性的结构。</p>
<h2 id="在C-中将接口与实现分离"><a href="#在C-中将接口与实现分离" class="headerlink" title="在C++中将接口与实现分离"></a>在C++中将接口与实现分离</h2><p>有人可能抱怨说，图3的结构并没有表现我所说的依赖关系以及依赖传递。毕竟，Policy层仅仅依赖于Mechanism层的接口。为什么Mechanism层的修改会影响到Policy层了？</p>
<p>对某些OO编程语言来说，确实如此。在这些语言中，接口（interface）与实现（implementation）是自动分离的。然而，在C++中，并没有将接口与实现分离，相反，这种分离存在于类的定义以及类的成员函数定义之间。</p>
<p>在C++中，我们通常将一个类分成两个模块：<code>.h</code>和<code>.cc</code>。<code>.h</code>模块包含了类的定义，<code>.cc</code>文件包含了类成员函数的定义。在<code>.h</code>类的定义中，包含了所有成员函数与变量的声明。这种声明超过了简单的接口。所有通用的函数以及私有变量都在<code>.h</code>模块中声明了。这些通用函数以及私用变量是类实现的一部分，然后他们出现在用户需要依赖的模块中了。因此，在C++中，实现并没有与接口分离。</p>
<p>接口与实现分离的情况可以通过纯虚类来处理。一个纯虚类是一个只有纯虚函数的类。由于<code>.h</code>文件中并没有该类的实现，因此纯虚类是一个单纯的接口。图4就是这样的结构：抽象类是纯抽象的，以至每一层都仅仅依赖于下一层的接口(interface)。</p>
<h2 id="一个简单的示例"><a href="#一个简单的示例" class="headerlink" title="一个简单的示例"></a>一个简单的示例</h2><p>只要一个类需要发送消息给另一个类，依赖反转就适用。接下来，以一个Button对象和Lamp对象为例说明这种情况。</p>
<p>Button对象感知外界环境，确定是否有用户按下。具体的原理怎么样，并无关系，它可以是一个GUI界面上的按钮图标，一个被手指按压的物理按钮，甚至可以是一个家庭安全系统中的运动检测器。Button对象检测是否有用户按下。Lamp对象在接收到TurnOn的信息之后，点亮一个类似于灯的东西；如果接收到TurnOff的消息，则熄灭灯。</p>
<p>怎么才能设计一个Button对象控制Lamp对象的系统了？下图5是该系统的一个简图。Button对象只是将TurnOn/TurnOff发送给Lamp对象。为实现一目的，Button类包含了一个Lamp类作为类成员。</p>
<img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/dip_fig5_button_lamp.png" class="[Button and Lamp]" title="图5 Button/Lamp模型">
<p>下列代码实现了图5中的模型。注意到，Button类直接依赖于Lamp类。这意味着，如果Lamp类改变了，Button至少需要重新编译。而且，用来控制一个Motor对象，Button类就不可复用了。因而，该实现违背了DIP原则：上层并没有与底层分离开；抽象也没有与细节分离。没有这样的分离，上层会自动依赖于底层，而抽象也会自动依赖于细节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lamp.h </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lamp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">TurnOn</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">TurnOff</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// button.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lamp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Button(Lamp&amp; l) : mLamp(&amp;l) &#123; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Detect</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">			Lamp* mLamp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// button.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"button.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"lamp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Button:Detect()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">bool</span> buttonOn = GetPhysicalState();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(buttonOn)&#123;</span><br><span class="line">		mLamp-&gt;TurnOn();</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		mLamp-&gt;TurnOff();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="寻找潜在的抽象"><a href="#寻找潜在的抽象" class="headerlink" title="寻找潜在的抽象"></a>寻找潜在的抽象</h2><p>什么才是上层需要的策略？是构成应用的某种抽象，细节的变化并不会引起上层变化的事实。在Button/Lamp示例中，潜在的抽象是，从用户那里检测on/off的动作，并将其传递给目标对象。究竟是什么机制来检测该动作？这毫不相关。什么是目标对象？毫不相关！这些实现的细节不应该影响抽象。</p>
<p>为了实现DIP原则，必须要讲问题的抽象与实现细节分离。因此，需要将设计的依赖换一个方向，使得细节依赖于抽象。下图6展示了这样一个设计。</p>
<img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/dip_fig6_inverted_button_model.png" class="[inverted Button model]" title="图6 反转后的Button模型">
<p>在图6中，我们将Button类的抽象与其实现的细节隔离开来。下面是其实现的代码。现在上层的策略全部在抽象的Button类中了。Button类不知道任何检测用户物理状态的机制。这些细节全部被隔离在具体的派生类：ButtonImpl以及Lamp类。</p>
<p>下列代码中的上层策略可以针对任何按钮与设备复用，而且它并不会受到底层机制变化的影响。因此，它具有很好的健壮性，可扩展性以及可复用性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buttonClient.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButtonClient</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TurnOn</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TurnOff</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// button.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButtonClient</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Button(ButtonClient&amp;);</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Detect</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">GetState</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		ButtonClient* mClient;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//button.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"button.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"buttonClient.h"</span></span></span><br><span class="line"></span><br><span class="line">Button::Button(ButtonClient&amp; bc) : mClient(&amp;bc) &#123; &#125;</span><br><span class="line"></span><br><span class="line">Button::Detect() &#123;</span><br><span class="line">	<span class="keyword">bool</span> buttonOn = GetState();</span><br><span class="line">	<span class="keyword">if</span>(buttonOn) &#123;</span><br><span class="line">		mClient-&gt;TurnOn();</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		mClient-&gt;TurnOff();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lamp.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lamp</span>:</span> <span class="keyword">public</span> ButtonClient &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TurnOff</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TurnOn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buttonImp.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButtonImpl</span>:</span> <span class="keyword">public</span> Button &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		ButtonImpl(ButtonClient&amp;);</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">GetState</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进一步扩展抽象"><a href="#进一步扩展抽象" class="headerlink" title="进一步扩展抽象"></a>进一步扩展抽象</h2><p>有人也许会对图6中的设计抱怨说，被Button控制的设备必须从ButtonClient中派生出来，假如Lamp类来自第三方库的话，我们无法修改源代码了。下图7展示了如何用Adapter模式将第三方库的Lamp对象加入到该模型中来：LampAdapter将继承自ButtonClient的TurnOn/TurnOff消息转换成任何Lamp类可以理解的消息。</p>
<img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/dip_fig7_lamp_adapter.png" class="[The lamp adapter]" title="图7 Lamp适配器">
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>依赖反转的原则深植于许多面向对象技术的优点之中。它可以很好的应用于需要创建可复用中间件的情况。同时对于构建不易受变化影响的代码也是至关重要的。并且，由于抽象与细节隔离开来，代码的往往更容易维护。</p>
<p>这篇文章是我即将被Printice Hall出版的新书<em>Patterns and Advanced Principles of OOD</em>一章的压缩版。在接下来的系列文章中，我们将探讨许多面向对象设计的原则，研究不同设计模式在C++实现中的优点与缺点。我们会对“cohesion”（内聚）与“coupling”（耦合）进行定义，也会发展一种衡量面向对象设计质量的标准。最后，我们还会讨论其他许多有趣的主题。</p>
]]></content>
      
        <categories>
            
            <category> Software Architecture </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dependency Inversion </tag>
            
            <tag> DIP </tag>
            
            <tag> Dependency Injection </tag>
            
            <tag> Uncle Bob </tag>
            
            <tag> 依赖反转 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Binder入门]]></title>
      <url>http://sniffer.site/2016/10/01/Binder%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h1><p>如今的操作系统都支持多进程并发执行， 系统一般都存在多种不同的服务运行在多个进程当中。那么，进程与进程之间如何通信，即跨进程通信（IPC， Inter-Process Communication）是如何进行的呢？ Linux已有好几种IPC机制：</p>
<a id="more"></a>
<ul>
<li>Signals: 最早的IPC方式，一个进程通过发送信号给另一个有相同UID/GID的进程或者在同一进程组的进程</li>
<li>Pipes（包括 named pipes): Pipes是一个单向的用于连接一个进程的标准输出与另一个进程的标准输入的字节流通道</li>
<li>Sockets: 双向的通道，两个进程通过打开同一个socket进行通信</li>
<li>Message queues: 一个进程将消息写入消息队列，另一个进程从改队列中读取消息</li>
<li>Semaphores: 信号量是一个可以被多个进程读写的共有变量</li>
<li>Shared Memeory: 一个系统的内存区域，通过将其映射到两个不同进程的虚拟地址空间，因此每个进程都可以访问该地址空间</li>
<li>D-Bus(<a href="https://en.wikipedia.org/wiki/D-Bus" target="_blank" rel="noopener">Desktop Bus</a>): 用于桌面组件与服务通讯的协议</li>
</ul>
<p>对于Android而言，除了上述几种IPC方式之外，其最重要的IPC方式是binder。在了解Binder 的具体机制之前，先来看看Android系统组件。我们都知道，Android有Activity&lt;直接与用户交互的UI&gt;, Service&lt;负责执行特定的任务，不与用户交互&gt;, Content Provider&lt;负责提供数据访问服务&gt;， BroadCast Receiver&lt;广播接收&gt;四大组件。使用这四种组件都需要在应用的manifest文件<code>AndroidManifest.xml</code>中进行配置声明。</p>
<p><code>Activity</code>是一个应用的UI界面，它主要负责前台与用户进行交互；<code>Service</code>一般用于执行后台长时间的任务； <code>Content Provider</code> 用于保存用户需要长久保存的数据，它为本地或者远端的数据提供了一个统一的操作接口； <code>Broadcaset Receiver</code>用于接收系统级别的消息，告知应用系统的状态与事件，如短息、来电以及低电量。</p>
<img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/android_component_system.png" class="[full-image]" title="Android Component System">
<p>那么，如何让不同进程中的组件进行数据与消息的交换了？Android提供了<code>Intents</code>用于组件的通信。一个 Intent由<code>URI</code>和一个action组成，URI用于定位目标组件，而action则用于标识执行的操作。事实上，Intent本质是基于Binder这一基础设施来进行消息传递的。</p>
<h1 id="Binder-术语"><a href="#Binder-术语" class="headerlink" title="Binder 术语"></a><strong>Binder 术语</strong></h1><p>与很多RPC(Remote Procedure Call)l类似, Android Binder IPC也是基于C/S(Client/Server)的架构方式, 其主要有如下几个组成部分:</p>
<ul>
<li>客户端(Binder Client): 需要使用某个服务的应用或者进程通过AIDL接口发起远程调用, 调用服务端的接口</li>
<li>服务端(Binder Service): 为所有客户端提供API的service</li>
<li>服务管理(Service Manager): 用于注册管理系统的Binder服务, 为客户端提供服务的查找</li>
<li>驱动(Binder Driver): 所有Binder通信的基础, 指令数据的接收与发送都是通过驱动来实现的</li>
</ul>
<img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/Android_Binder_terminology.png" class="[full-image]" title="Binder术语图">
<p>这里罗列了与Binder相关的一些术语:</p>
<ul>
<li><strong>Binder Driver</strong>：用于跨进程通信的Kernel 层驱动，对用户空间提供一个<code>/dev/binder</code>的设备节点</li>
<li><strong>Binder protocol</strong>： 用于与Binder 驱动交互的数据交换协议(ioctl-based)</li>
<li><strong>IBinder interface</strong>： 每个Binder对象都需要实现的接口</li>
<li><strong>Binder Token</strong> : 用于标识Binder对象的32bit的整数</li>
<li><strong>AIDL</strong> : Android Interface Definition Language, 用于描述在IBinder接口上的操作</li>
<li><strong>Proxy</strong>: Android为每一个AIDL接口创建的代理对象，用于客户端调用服务对应的接口（An implementation of the AIDL interface that un/marshals and maps methods calls to transactions submitted via a wrapped IBinder reference to the Binder object）</li>
<li><strong>Stub</strong>: 每个AIDL接口对应的存根对象，用于服务端接受来自客户端的请求，将其转化为对应的函数调用（A partial implementation of the AIDL interface that maps transactions to Binder service method calls while un/marshals data</li>
<li><strong>Context Manager</strong>: 即ServiceManager, 特殊的Binder对象，注册时的句柄值为0，用于其他Binder服务对象的注册与查找</li>
</ul>
<h1 id="什么是Binder"><a href="#什么是Binder" class="headerlink" title="什么是Binder"></a><strong>什么是Binder</strong></h1><p>Binder起源于由Dianne Hackborn 主导的<a href="https://en.wikipedia.org/wiki/OpenBinder" target="_blank" rel="noopener">OpenBinder</a> ，OpenBinder“是一个系统层的组件架构，在OS系统服务之上提供一个高层次、丰富的抽象接口”，Android Binder在OpenBinder的基础上做了修改，但其基本的思想仍然保持一致。</p>
<p>相比上述如信号、socket等传统IPC方式，Binder有哪些不一样的特点？</p>
<ul>
<li>Binder是一个实现了IPC机制的内核驱动</li>
<li>Binder提供了轻量级的 RPC（Remote Procedure Communication) 机制</li>
<li>每一个进程都有一个线程池来处理Binder请求</li>
<li>通过在服务端与设备文件<code>/dev/binder</code>进行内存共享的方式减少数据拷贝&lt;只需要一次数据拷贝&gt;</li>
</ul>
<h1 id="为什么需要Binder"><a href="#为什么需要Binder" class="headerlink" title="为什么需要Binder"></a>为什么需要Binder</h1><p>考虑到安全(security)、稳定性（stability）以及内存管理等因素，Android 应用程序和系统服务运行在不同的进程中，因而需要通信与交换数据，即通常IPC方法需要解决的问题。</p>
<ul>
<li>安全: 每个进程都有自己唯一的系统ID（UID,GID,PID),并且在沙箱（sandbox)中运行</li>
<li>稳定： 如果一个进程崩溃，不会影响到其他进程</li>
<li>内存管理：每个进程管理自己的内存资源，不需要时会释放出来给需要的进程使用</li>
</ul>
<p>而在另一方面Android的 libc（bionic) 并不支持 SystemV IPC,</p>
<ul>
<li>没有SystemV IPC 方法，如 semaphores, shared memory, message queues</li>
<li>当进程退出时忘记释放共享的IPC资源时，SystemV IPC 方法容易泄露kernel资源</li>
</ul>
<p>Binder 通过内建的引用计数机制以及death-notification，确保IPC过程没有资源泄露：当一个binder service 不在被任何 clients引用时，binder的管理者会被通知销毁该binder service，因此 Binder 可以很好的适应低内存、低功耗等移动设备。</p>
<p>那么, 具体来说,Binder主要有如下一些特点：</p>
<ul>
<li><p>支持 线程迁移(thread migration):</p>
<ul>
<li>线程池自动化管理</li>
<li>支持远程调用</li>
<li>支持同步和异步(oneway) 调用</li>
</ul>
</li>
<li><p>通过UID/PID 来识别调用者（clients）</p>
</li>
<li>可以跨进程发送文件描述符</li>
<li>支持常用数据类型的marshalling/unmarshalling</li>
<li>简单的AIDL接口</li>
<li>如果 client/service 在同一进程，同样可以使用</li>
</ul>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h1><h2 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a><strong>通信模型</strong></h2><p>Binder 架构通信基于Client/Server模型：client（进程A）向Binder发起通信请求，并等待server的响应。在Client端，Binder为其提供了一个Proxy的接口；server（进程B）收到请求后，由线程池启动的线程对请求进行处理：</p>
<img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/Binder_Achitecture.png" class="[full-image]" title="Binder通信模型">
<p>这里可以看到， Binder通信进程需要跨越三个层次(具体可以参考老罗的系列文章 <a href="https://blog.csdn.net/luoshengyang/article/details/6618363)：" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/6618363)：</a></p>
<ul>
<li>Binder 内核驱动的通信( C )</li>
<li>中间件(middleware)的通信( C++ )</li>
<li>应用层的通信 ( Java )</li>
</ul>
<h2 id="应用层Binder通信"><a href="#应用层Binder通信" class="headerlink" title="应用层Binder通信"></a><strong>应用层Binder通信</strong></h2><p>Java应用层主要通过AIDL接口来描述Client与Service之间的通信接口。 AIDL定义了远程service的调用接口，其在Client端产生一个Proxy类，在Server端产生一个Stub类。 AIDL的详细说明请参考：</p>
<blockquote><p><a href="http://blog.csdn.net/jason_wzn/article/details/51916983" title="通过AIDL添加Service" target="_blank" rel="noopener">http://blog.csdn.net/jason_wzn/article/details/51916983</a></p>
</blockquote>
<p>有了接口之后，那么client要如何向server发送数据了？在Android中，一个进程向另一个进程发送数据，该过程称为Transaction(交易)，交易所传递的数据，则称为transaction data， 在Java 应用层，交易数据就是一个Parcel对象。 Parcel可以用来传递flatted data，可以用于传递Parcelable对象，也可以用于传递IBinder对象的引用。</p>
<p>Parcel提供了诸如 <code>writeByte/readByte</code>,<code>writeDouble/readDouble</code>,<code>writeInt/readInt</code>等一系列接口用于写入、读取Java中的基本数据类型。通常， 从一个对象创建一个parcel的过程被称为编组一个对象(marshalling),而将从Parcel重建一个对象的过程称为解组一个对象(unmarshalling)。</p>
<p>我们知道，Android的四个组件之间的通信都是依赖于Intent的，正是Intent将数据从一个组件传递到了另一个组件。从Intent的定义可以看出，其本质上是一个可以被编组与解组的Parcel对象，因而可以实现跨组件、跨进程的数据通信。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Intent</span> <span class="keyword">implements</span> <span class="title">Parcelable</span>, <span class="title">Cloneable</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h2 id="中间件层Binder通信"><a href="#中间件层Binder通信" class="headerlink" title="中间件层Binder通信"></a><strong>中间件层Binder通信</strong></h2><p>中间件层的编程语言主要是C++，其作用是：</p>
<ul>
<li>管理用于处理Binder请求的线程池</li>
<li>对相关数据进行序列化与反序列化(marshalling/unmarshalling)</li>
<li>与Binder内核驱动进行交互</li>
</ul>
<p>通过 <code>/android/frameworks/native/include/binder/IServiceManager.h</code> 中定义的接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; defaultServiceManager()</span><br></pre></td></tr></table></figure>
<p>可以获取到全局的变量 <code>sp&lt;IServiceManager&gt;</code>,可以添加与获取相应的系统服务。</p>
<blockquote><p>有关中间件更详细的介绍请参考： <a href="http://blog.csdn.net/luoshengyang/article/details/6627260" target="_blank" rel="noopener">http://blog.csdn.net/luoshengyang/article/details/6627260</a></p>
</blockquote>
<h2 id="内核驱动层的Binder通信"><a href="#内核驱动层的Binder通信" class="headerlink" title="内核驱动层的Binder通信"></a><strong>内核驱动层的Binder通信</strong></h2><p>Binder驱动定义了对外的操作接口： open, mmap, release, poll, 以及系统调用ioctl。 ioctl接口的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(<span class="keyword">int</span> binderFD, BINDER_WRITE_READ, &amp;bwd)</span><br></pre></td></tr></table></figure>
<p>这里， <code>&amp;bwd</code> 为写入Binder驱动的一个数据结构，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> &#123;</span></span><br><span class="line">	  <span class="keyword">binder_size_t</span> write_size;</span><br><span class="line">	  <span class="keyword">binder_size_t</span> write_consumed;</span><br><span class="line">	  <span class="keyword">binder_uintptr_t</span> write_buffer;</span><br><span class="line">	  <span class="keyword">binder_size_t</span> read_size;</span><br><span class="line">	  <span class="keyword">binder_size_t</span> read_consumed;</span><br><span class="line">	  <span class="keyword">binder_uintptr_t</span> read_buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>ioctl</code> 主要有以下几个命令，其中 ：</p>
<ul>
<li><code>BINDER_WRITE_READ</code>用于写入或者读取内存中的交易数据的（最常用的一个命令）</li>
<li><code>BINDER_SET_MAX_THREADS</code> 用于设置线程池支持的最大线程数目（一般的service都设置为15）</li>
<li><code>BINDER_SET_CONEXT_MGR</code> 设置 Context(Service) manager</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_WRITE_READ _IOWR(<span class="meta-string">'b'</span>, 1, struct binder_write_read)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_TIMEOUT _IOW(<span class="meta-string">'b'</span>, 3, __s64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_MAX_THREADS _IOW(<span class="meta-string">'b'</span>, 5, __u32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_PRIORITY _IOW(<span class="meta-string">'b'</span>, 6, __s32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR _IOW(<span class="meta-string">'b'</span>, 7, __s32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT _IOW(<span class="meta-string">'b'</span>, 8, __s32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VERSION _IOWR(<span class="meta-string">'b'</span>, 9, struct binder_version)</span></span><br></pre></td></tr></table></figure>
<h1 id="Binder-Client与Server-通信流程"><a href="#Binder-Client与Server-通信流程" class="headerlink" title="Binder Client与Server 通信流程"></a>Binder Client与Server 通信流程</h1><p>这里，再来回顾下，Android中基于Binder架构，Client与Server之间的通信流程。<br>(图片来自 《deep dive into Android Binder Framework》</p>
<img src="http://sniffer-site.oss-cn-shenzhen.aliyuncs.com/Binder%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png" class="[full-image]" title="Binder communication process">
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android Binder 设计与实现</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6621566" target="_blank" rel="noopener">老罗 Android Binder 系列</a></li>
<li><a href="http://elinux.org/Android_Binder" target="_blank" rel="noopener">Android Binder - 里边很多Binder介绍资料</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Binder </tag>
            
            <tag> IPC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Fota升级]]></title>
      <url>http://sniffer.site/2016/08/18/Android-Fota%E5%8D%87%E7%BA%A7/</url>
      <content type="html"><![CDATA[<p>Android设备的系统升级有两种方式：（1）下载更新包到手机后，手动安装，即所谓“卡刷包”的形式更新；（2） 通过 Over-the-air（<strong>OTA</strong>）的方式更新系统，简称为FOTA（<strong>Firmware Over The Air</strong>)，FOTA升级有两种方式，一种是Full update，即将整个IMG置于升级包中，然后将升级包直接拷贝到系统；一种是Increamental update,即通过增量式的差分包,只是将系统更新的部分打包，然后以打补丁的形式应用到系统。</p>
<a id="more"></a>
<p>在介绍FOTA升级流程之前，先来看看Android系统的分区。一般，Android系统有如下几个分区（不同厂商、设备可能有差异）：</p>
<ul>
<li><strong>/boot</strong>: 用于系统启动的分区，主要包括Kernel和ramdisk。主要用于挂载system和其他分区，并加载system分区的代码。没有该分区，手机是无法正常启动的；</li>
</ul>
<blockquote>
<p><strong>ramdisk.img</strong> is a small partition image that is mounted read-only by the kernel at boot time. It only contains /init and a few config files. It is used to start init which will mount the rest of the system images properly and run the init procedure. A Ramdisk is a standard Linux feature.</p>
</blockquote>
<ul>
<li><strong>/system</strong>：该分区包含了出了 kernel/ramdisk之外的系统应用程序和库文件；正常操作情况下，该分区是只读状态；</li>
<li><strong>/recovery</strong>:用于系统升级打补丁，包含了一个完整的Linux操作系统和一个特殊的recovery包。FOTA升级时，下载完更新包后，进入recovery模式，recovery程序会读更新包，然后将各个patch应用到各个分区；</li>
<li><strong>/misc</strong>：升级时，recovery用于存储相关信息的小分区</li>
<li><strong>/data</strong>：主要包含了用户的数据，如联系人、短信、设置以及安装的应用。清除该分区等同于将手机重置，OTA不会影响该分区；</li>
<li><strong>/cache</strong>：用于存放需要经常访问使用的数据和应用组件，访问该分区需要特殊的应用程序权限；OTA升级时下载的升级包就位于该分区；</li>
</ul>
<h2 id="FOTA升级流程"><a href="#FOTA升级流程" class="headerlink" title="FOTA升级流程"></a>FOTA升级流程</h2><ol>
<li>设备定时检查FOTA服务器是否有更新；如有更新，服务其发送消息（包括更新包URL，以及关于该更新包的描述）通知设备</li>
<li>更新程序下载升级包到 cache 或者 data 分区，并验证升级包的签名证书（证书位于<code>/system/etc/security/otacerts.zip</code>），验证通过后，通知用户准备安装</li>
<li>设备重启至 recovery模式，此时启动的是recovery分区的kernel/system</li>
<li>init进程通过<code>init.rc</code>脚本: <code>service recovery /sbin/recovery</code> 启动 recovery程序</li>
<li>执行 <code>/cache/recovery/command</code>中的脚本命令，将其指向于升级包： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/sbin/recovery&quot; &quot;--update_package=/cache/fota/update.zip&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="6">
<li>recovery首先校验升级包的签名是否与 <code>/res/keys</code> （ramdisk）中的公钥相匹配</li>
<li>recovery通过FOTA中的脚本解析更新包，然后将修改分别更新到对应的boot/system等分区；在系统分区包含的新文件包含了用于更新recovery分区的内容</li>
<li><p>系统正常重启：</p>
<ul>
<li>启动更新后的boot/system 分区</li>
<li>启动时，系统检查当前recovery分区和需要更新的recovery分区（事先保存在<code>/system</code>分区），如果有差异，则更新recovery分区</li>
</ul>
</li>
<li><p>设备通知FOTA服务器升级完成</p>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://source.android.com/devices/tech/ota/index.html" target="_blank" rel="noopener">https://source.android.com/devices/tech/ota/index.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> FOTA </tag>
            
            <tag> Firm Over The Air </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git常用命令]]></title>
      <url>http://sniffer.site/2016/03/07/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>Git是目前使用最普遍的开源分布式版本控制系统，代码托管网站Github就是基于Git作版本管理; Android Studio也支持使用Git来进行版本控制。</p>
<p>这里就来看一看基本的Git命令操作。</p>
<a id="more"></a>
<h2 id="更新Git版本"><a href="#更新Git版本" class="headerlink" title="更新Git版本"></a><strong>更新Git版本</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git <span class="built_in">clone</span> git://git.kernel.org/pub/scm/git/git.git</span><br></pre></td></tr></table></figure>
<h2 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a><strong>配置Git</strong></h2><h3 id="添加用户名与邮箱"><a href="#添加用户名与邮箱" class="headerlink" title="添加用户名与邮箱"></a><strong>添加用户名与邮箱</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git config --global user.name <span class="string">"John Doe"</span></span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure>
<h3 id="配置编辑器"><a href="#配置编辑器" class="headerlink" title="配置编辑器"></a><strong>配置编辑器</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git config --global core.editor emacs</span><br></pre></td></tr></table></figure>
<p>在Windows下，如果想使用Notepad++,则可以这么设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git config --global core.editor <span class="string">"'C:/Program Files/Notepad++/notepad++.exe' -multiInst -nosession"</span></span><br></pre></td></tr></table></figure>
<p>对于64bit 系统，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git config --global core.editor <span class="string">"'C:/Program Files (x86)/Notepad++/notepad++.exe' -multiInst -nosession"</span></span><br></pre></td></tr></table></figure>
<h3 id="确认当前配置"><a href="#确认当前配置" class="headerlink" title="确认当前配置"></a><strong>确认当前配置</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git config --list</span><br></pre></td></tr></table></figure>
<h3 id="保存当前用户验证信息"><a href="#保存当前用户验证信息" class="headerlink" title="保存当前用户验证信息"></a><strong>保存当前用户验证信息</strong></h3><p>在使用Git提交代码时，每次提交git都会要求输入 用户名和密码，很浪费时间。执行如下git命令，将用户名和密码保存到远端服务器，即可跳过该环节：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git config credential.helper store</span><br><span class="line">$ git push http://example.com/repo.git</span><br></pre></td></tr></table></figure>
<p>接着输入用户名跟密码后，执行修改提交都不用再验证了。</p>
<h2 id="获取Git代码仓库"><a href="#获取Git代码仓库" class="headerlink" title="获取Git代码仓库"></a><strong>获取Git代码仓库</strong></h2><h3 id="初始化代码仓库"><a href="#初始化代码仓库" class="headerlink" title="初始化代码仓库"></a><strong>初始化代码仓库</strong></h3><p>在当前项目文件夹下，执行如下命令，会在该目录下创建一个子文件夹.git ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<p>如果想要将当前的代码进行版本控制，则需要跟踪这些文件并做一个初始化的执行操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git add *.c</span><br><span class="line">$ git add LICENSE</span><br><span class="line">$ git commit -m <span class="string">'initial project version'</span></span><br></pre></td></tr></table></figure>
<p>这里把所有.c 文件以及LICENSE文件标记为跟踪(tracking)状态，然后进行commit操作，将其添加到Git的本地工作目录下。</p>
<p>获取已有的Git仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/libgit2/libgit2</span><br></pre></td></tr></table></figure>
<p>将仓库映射到mylibgit文件夹下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit</span><br></pre></td></tr></table></figure>
<h2 id="在仓库中记录文件修改"><a href="#在仓库中记录文件修改" class="headerlink" title="在仓库中记录文件修改"></a><strong>在仓库中记录文件修改</strong></h2><p>在介绍具体的操作命令之前，先来看一看Git文件各个状态的生命周期。对于一个工作目录下的文件而言，主要有两种状态：untracked//tracked;tracked 文件在最近的一个Snapshot当中，它们可以是unmodified, modified,staged；而untracked 文件则是那些不在最近Snapshot和不在Staged area中的文件。当你第一次从克隆一个代码仓库时，所有文件都处于Tracked并且unmodified(未被修改）。</p>
<h3 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a><strong>查看文件状态</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git status</span><br></pre></td></tr></table></figure>
<h3 id="跟踪新创建的文件"><a href="#跟踪新创建的文件" class="headerlink" title="跟踪新创建的文件"></a><strong>跟踪新创建的文件</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure>
<h3 id="staging-已修改文件"><a href="#staging-已修改文件" class="headerlink" title="staging 已修改文件"></a><strong>staging 已修改文件</strong></h3><p>若某个文件已经处于Tracked，则执行add命令将其添加到Staging area</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git add CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<h3 id="查看文件的详细修改"><a href="#查看文件的详细修改" class="headerlink" title="查看文件的详细修改"></a><strong>查看文件的详细修改</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git diff</span><br></pre></td></tr></table></figure>
<h4 id="执行修改"><a href="#执行修改" class="headerlink" title="执行修改"></a><strong>执行修改</strong></h4><p>最简单的命令是 git commit, 但是接着会弹出一个编辑器，需要输入该修改的简短描述，因此更为常用的是如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"Story 182: Fix benchmarks for speed"</span></span><br></pre></td></tr></table></figure>
<p>上述执行命令只是添加了处于Staging 状态的文件修改，那么要如何跳过staging，直接执行Tracked文件的修改？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git commit -a -m <span class="string">'added new benchmarks'</span></span><br></pre></td></tr></table></figure>
<h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a><strong>移除文件</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git rm PROJECTS.md</span><br></pre></td></tr></table></figure>
<h3 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a><strong>重命名文件</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git mv file_from file_to</span><br></pre></td></tr></table></figure>
<h3 id="查看修改记录"><a href="#查看修改记录" class="headerlink" title="查看修改记录"></a><strong>查看修改记录</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>如果有时<code>git status</code>提示<code>detached HEAD</code>， 通过<code>git branch -a</code>会发现当前的分支处在<code>detached HEAD</code>状态，此时要如何处理？这种状态说明你本地的修改没有合入到主分支上，可以通过<code>git reflog</code>/<code>git log -p</code>找到本地修改的commit ID，然后切换到住分支后通过<code>git cherry-pick &lt;commit-id&gt;</code>将修改合入。</p>
<h3 id="取消修改"><a href="#取消修改" class="headerlink" title="取消修改"></a><strong>取消修改</strong></h3><p>Unstage 一个staged文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git reset HEAD CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>取消上一个修改:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git reset --soft HEAD^ // or</span><br><span class="line">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure>
<p>如果需要取消某个commit的文件修改可以执行如下操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git show commit_sha1 -- some_file.c | git apply -R</span><br></pre></td></tr></table></figure>
<h3 id="revert修改"><a href="#revert修改" class="headerlink" title="revert修改"></a><strong>revert修改</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git checkout -- CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>如要将某文件revert到指定的commit,可以执行如下操作:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git checkout &lt;commit_id&gt;  -- &lt;file&gt;</span><br></pre></td></tr></table></figure>
<h3 id="取消所有合入修改"><a href="#取消所有合入修改" class="headerlink" title="取消所有合入修改"></a><strong>取消所有合入修改</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git reset --merge</span><br></pre></td></tr></table></figure>
<h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a><strong>远程操作</strong></h2><h3 id="查看远程Git服务器"><a href="#查看远程Git服务器" class="headerlink" title="查看远程Git服务器"></a><strong>查看远程Git服务器</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git remote</span><br></pre></td></tr></table></figure>
<p>指定参数-v,可以查看Git服务的URL</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure>
<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a><strong>添加远程仓库</strong></h3><p>指定一个短名字（以后使用该名字来操作远程仓库），可以获取相应的仓库： git remote add <shortname> <url>:</url></shortname></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git remote add pb https://github.com/paulboone/ticgit</span><br></pre></td></tr></table></figure>
<p>这样通过 fetch pb，便可以获得远程仓库的数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git fetch pb</span><br></pre></td></tr></table></figure>
<h3 id="fetch-pull-操作"><a href="#fetch-pull-操作" class="headerlink" title="fetch/pull 操作"></a><strong>fetch/pull 操作</strong></h3><p>通过指定远程仓库的名字，fetch操作用于获取远程仓库的数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git fetch origin</span><br></pre></td></tr></table></figure>
<p>如果本地Git仓库已经设置成Track远程仓库，通过pull命令可以将远程的仓库的修改合入本地仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>
<h3 id="将本地修改push到远程仓库"><a href="#将本地修改push到远程仓库" class="headerlink" title="将本地修改push到远程仓库"></a><strong>将本地修改push到远程仓库</strong></h3><p>push用于将本地的数据修改合入到远程的仓库；在某一时刻，只允许一个用户执行该操作，若另一个用户也在执行该操作，则你的push会被<br>拒绝。这样，在进行一下此push操作时，你首先需要获取该用户的修改（fetch），然后执行push操作</p>
<p><em>git push [remote-name] [branch-name]</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<h3 id="获取远程仓库的状态"><a href="#获取远程仓库的状态" class="headerlink" title="获取远程仓库的状态"></a><strong>获取远程仓库的状态</strong></h3><p>如果想要获取某个远程仓库的具体信息，可以使用 git remote show [remote-name] ，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git remote show origin</span><br></pre></td></tr></table></figure>
<h3 id="重命名-移除远程代码仓库"><a href="#重命名-移除远程代码仓库" class="headerlink" title="重命名/移除远程代码仓库"></a><strong>重命名/移除远程代码仓库</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git remote rename pb paul</span><br></pre></td></tr></table></figure>
<p>这样远端的分支从 pb/master 更改为 paul/master. 如果想要移除某个仓库，使用 rm命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git remote rm paul</span><br></pre></td></tr></table></figure>
<h2 id="同步fork-分支"><a href="#同步fork-分支" class="headerlink" title="同步fork 分支"></a><strong>同步fork 分支</strong></h2><h3 id="0-跟踪fork分之代码"><a href="#0-跟踪fork分之代码" class="headerlink" title="(0)  跟踪fork分之代码"></a><strong>(0)  跟踪fork分之代码</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git remote add upstream &lt;remote-url&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-从fork-的master-分支获取最新的修改"><a href="#1-从fork-的master-分支获取最新的修改" class="headerlink" title="(1)  从fork 的master 分支获取最新的修改"></a><strong>(1)  从fork 的master 分支获取最新的修改</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git fetch upstream</span><br></pre></td></tr></table></figure>
<h3 id="2-切换到本地-master-分支"><a href="#2-切换到本地-master-分支" class="headerlink" title="(2) 切换到本地 master 分支"></a><strong>(2) 切换到本地 master 分支</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure>
<h3 id="3-将upstream-master-分支的修改合入-本地-master-分支"><a href="#3-将upstream-master-分支的修改合入-本地-master-分支" class="headerlink" title="(3) 将upstream/master 分支的修改合入 本地 master 分支"></a><strong>(3) 将upstream/master 分支的修改合入 本地 master 分支</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git merge upstream/master</span><br></pre></td></tr></table></figure>
<h3 id="查看所有远程分支状态"><a href="#查看所有远程分支状态" class="headerlink" title="查看所有远程分支状态"></a><strong>查看所有远程分支状态</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git branch -a</span><br></pre></td></tr></table></figure>
<p>切换本地的工作分支-&gt;（提交代码对应的远程分支）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git checkout -b mybranch origin/remote-branch</span><br></pre></td></tr></table></figure>
<h2 id="如何新建一个Github项目？"><a href="#如何新建一个Github项目？" class="headerlink" title="如何新建一个Github项目？"></a><strong>如何新建一个Github项目？</strong></h2><p>﻿﻿ 在Git 新建一个 repository, 无需添加 README.md<br> 在本地你的项目文件夹下，打开 git bash</p>
<h3 id="初始化-本地-repository"><a href="#初始化-本地-repository" class="headerlink" title="初始化 本地 repository"></a><strong>初始化 本地 repository</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<h3 id="跟踪（Track）本地文件到本地-repository"><a href="#跟踪（Track）本地文件到本地-repository" class="headerlink" title="跟踪（Track）本地文件到本地 repository"></a><strong>跟踪（Track）本地文件到本地 repository</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git add .</span><br></pre></td></tr></table></figure>
<h3 id="提交修改到本地-repository"><a href="#提交修改到本地-repository" class="headerlink" title="提交修改到本地 repository"></a><strong>提交修改到本地 repository</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"initial commit"</span></span><br></pre></td></tr></table></figure>
<h3 id="添加远程repository"><a href="#添加远程repository" class="headerlink" title="添加远程repository"></a><strong>添加远程repository</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git remote add origin https://github.com/your-name/your-repo.git</span><br></pre></td></tr></table></figure>
<h3 id="将本地修改push到远程repository"><a href="#将本地修改push到远程repository" class="headerlink" title="将本地修改push到远程repository"></a><strong>将本地修改push到远程repository</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<h2 id="如何使用git生成-合入patch"><a href="#如何使用git生成-合入patch" class="headerlink" title="如何使用git生成/合入patch"></a><strong>如何使用git生成/合入patch</strong></h2><p>在向外部代码仓库提交修改时可能需要手动生成patch，或者将他人的patch合入到自己的代码分支。这里来看下如何通过git来实现代码patch的修改与合入。</p>
<h3 id="生成patch"><a href="#生成patch" class="headerlink" title="生成patch"></a><strong><em>生成patch</em></strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git format-patch master --stdout &gt; fix_empty_poster.patch</span><br></pre></td></tr></table></figure>
<h3 id="合入patch"><a href="#合入patch" class="headerlink" title="*合入patch"></a><strong>*合入patch</strong></h3><p>在合入一个patch之前，可以通过<code>git apply -v --check fix_empty_poster.patch</code> 来检查某个patch是否可以正常合入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git apply --stat fix_empty_poster.patch</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://www.devroom.io/2009/10/26/how-to-create-and-apply-a-patch-with-git/" target="_blank" rel="noopener">https://www.devroom.io/2009/10/26/how-to-create-and-apply-a-patch-with-git/</a></li>
<li><a href="https://git-scm.com/docs" target="_blank" rel="noopener">https://git-scm.com/docs</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
